<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>树形dp总结 - My Docs</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">My Docs</a>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#dp" class="nav-link">树形dp总结</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">统计答案类</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">节点选择类(染色类)</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_3" class="nav-link">树形背包类</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#dp_1" class="nav-link">换根dp</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="dp">树形dp总结</h1>
<h2 id="_1">统计答案类</h2>
<blockquote>
<p>P3047</p>
</blockquote>
<p>dp[u][k]表示距离u不超过k的点权值之和</p>
<p>dfs1:$ dp[u][k]+=\sum dp[v][k-1]$ 下行，不需要容斥，直接由儿子累加即可</p>
<p>求出u的子树所有不超过k的点权值之和</p>
<p>dfs2:$dp[v][k]+=dp[u][k-1]-(k&gt;=2)dp[v][k-2]$上行，需要简单容斥，并且注意要逆序，因为若dp[v][k-2]先更改，则dp[v][k]会出错</p>
<p>求出最终答案</p>
<blockquote>
<p>P2986</p>
</blockquote>
<p>dp[u]表示每个点的答案</p>
<p>f[u]表示该节点所有子节点到它的距离之和</p>
<p>f[u]=f[v]+w * sz[v]</p>
<p>则有dp[1]=f[1]</p>
<p>那么 dp[v]=dp[u]-sz[v] * w+(sz[1] * w-sz[v] * w)</p>
<p>=dp[u]-2 * sz[v] * w+sz[1] * w</p>
<p>转移时只更改的是与该边有关联的答案。</p>
<p>注意初始状态为dp[1]</p>
<blockquote>
<p>CF9D</p>
</blockquote>
<p>f[i][j]表示i个节点，深度不超过j的二叉树总数量,则</p>
<p>$f[i][j]=\sum_{k=1}^{i-1}f[k][j-1]* f[i-k-1][j-1] $</p>
<blockquote>
<p>P1623</p>
</blockquote>
<p>dp+高精度</p>
<p>设f[i][0/1]为最大匹配个数，0表示与儿子不匹配，1表示与其中一个儿子匹配；g[i][0/1]为对应的方案数</p>
<p>转移方程：(有'亿'点复杂)</p>
<pre><code class="language-cpp">//无高精度
void dp1(int u,int p){
    int sum=0;
    for(int i=head[u];~i;i=e[i].nxt){
        int v=e[i].v;
        if(v==p)continue;
        dp1(v,u);
        sum+=max(f[v][0],f[v][1]);
    }
    f[u][0]=sum;
    for(int i=head[u];~i;i=e[i].nxt){
        int v=e[i].v;
        if(v==p)continue;
        f[u][1]=max(f[u][1],sum-max(f[v][0],f[v][1])+f[v][0]+1);
    }
    return;
}
void dp2(int u,int p){
    int sum=1;
    for(int i=head[u];~i;i=e[i].nxt){
        int v=e[i].v;
        if(v==p)continue;
        dp2(v,u);
        if(f[v][0]&lt;f[v][1]){
            sum*=g[v][1];
        }else if(f[v][0]&gt;f[v][1]){
            sum*=g[v][0];
        }else{
            sum*=(g[v][0]+g[v][1]);         
        }
    }
    g[u][0]=sum;
    for(int i=head[u];~i;i=e[i].nxt){
        int v=e[i].v;
        int tmp=1;
        if(v==p)continue;
        if(f[v][0]&lt;f[v][1]){
            tmp=g[v][1];
        }else if(f[v][0]&gt;f[v][1]){
            tmp=g[v][0];
        }else{
            tmp=(g[v][0]+g[v][1]);          
        }
        if(f[u][1]==f[u][0]-max(f[v][0],f[v][1])+f[v][0]+1){
            g[u][1]+=(g[u][0]/tmp)*g[v][0];
        }
    }
    return;
}
</code></pre>
<p>注意最后的g也要根据f判断，这个坑了我一次
~~(我甚至连高精度都没写，只拿了60pts)~~</p>
<h2 id="_2">节点选择类(染色类)</h2>
<blockquote>
<p>P4084</p>
</blockquote>
<p>树形dp入门题:)</p>
<p>dp[i][j]表示当前节点为j颜色是的方案数</p>
<p>注意当该节点已经有颜色时，则dp[u][c[u]]=1,其他为0
；否则dp[u][1,2,3]=1;</p>
<p>转移：</p>
<pre><code class="language-cpp">//1.c[u]!=0
for(i;1-3)
if(i!=c[u])sum+=dp[v][i];
dp[u][c[u]]=(dp[u][c[u]]*sum)%P;
//2.c[u]==0
for(i;1-3)
for(j;1-3)
if(j!=i)sum+=dp[v][j];
dp[u][i]=(dp[u][i]*sum)%P;
</code></pre>
<blockquote>
<p>P2279
非常好。非常恶心</p>
</blockquote>
<p>dp[u][0,1,2,3,4]一共0，1，2，3，4五种状态，分别为爷爷，父亲，自己，儿子，孙子</p>
<p>同样要注意上行的状态dp[u][3] 和dp[u][4]</p>
<blockquote>
<p>P2899</p>
</blockquote>
<p>dp[u][0/1/2]表示三种状态，被自己覆盖，被儿子覆盖，被父亲覆盖</p>
<p>注意顺序时从下往上回溯时搜，所以搜到父亲时儿子已经被更新完，可以直接用</p>
<p>1.dp[u][0]=$\sum$min(dp[v][0],dp[v][1],dp[v][2]),因为自己已经被自己覆盖，所以可以取儿子的所有值；</p>
<p>2.dp[u][2]=$\sum$min(dp[v][0],dp[v][1]),如果u被fa[u]覆盖，则u不会被u自己，也就是dp[v][2]覆盖，就不取了</p>
<blockquote>
<p>update:2021.11.12
应该是dp[u][2]=$\sum$dp[v][1]，因为u只被父亲覆盖，如果取dp[v][0]则表明u还被儿子覆盖，则会出错.</p>
</blockquote>
<p>3.&lt; 重点 &gt;dp[u][1]=min(f[v][0]+$\sum_{i=son[u]}^{i!=v} $min(f[i][0],f[i][1])),因为u要被至少一个子节点覆盖，所以可以暴力枚举每一个节点，则剩余的节点的状态与2相同。</p>
<p>也可以进行数学方法的优化，详见题解</p>
<blockquote>
<p>P3174</p>
</blockquote>
<p>有意思的一道题</p>
<p>定义:</p>
<p>f[n]表示当前节点的子树里最长的链中包含的点(主干与分叉)</p>
<p>ans[n]表示当前节点的答案</p>
<p>因为存在拐弯的情况，所以最优解不一定存在于根节点，因此转移方程：</p>
<pre><code class="language-cpp">    f[u]=max1+num;
    if(p==0) {//p是u的父亲，根节点无父亲
        ans[u]=max1+max2+num-1;
    } else ans[u]=max1+max2+num;
</code></pre>
<p>最终答案为max(ans[i])</p>
<blockquote>
<p>P1352</p>
</blockquote>
<p>模板题。
* 要用儿子更新父亲而不用父亲更新儿子的原因：会产生后效性：儿子的答案不仅与父亲有关，还与爷爷有关，爷爷不选，儿子也不能选。</p>
<h2 id="_3">树形背包类</h2>
<blockquote>
<p>P2015</p>
</blockquote>
<p>树形背包模板题，注意因为是二叉树，所以转移方程有两种：</p>
<p>1.dp[u][t]=max(dp[u][t],dp[ln][t-k]+dp[rn][k]),ln rn 表示左儿子右儿子</p>
<p>2.dp[u][t]=max(dp[u][t],dp[v][k]+dp[u][t-k])</p>
<p>2的好处为可以应对多叉树。</p>
<p>原因是：</p>
<p>因为要先枚举t，所以就像背包一样，当前儿子的贡献能够加在之前的状态里，而之前的状态已经包含在深搜它之前的兄弟，以此类推。这样就可以进行累加。</p>
<p>v相当于石头种类；t相当于背包容量</p>
<p>注意要逆序枚举t，不然会对之前已经得到的状态进行二次累加</p>
<blockquote>
<p>P1270</p>
</blockquote>
<p>树形背包。</p>
<p>1.同样是dp[u][t]=max(dp[u][t],dp[v][k]+dp[u][t-k])；</p>
<p>2.dp[u][t]=max(dp[u][t],dp[u][t-j*5]+j) 在深搜完所有儿子后做这个</p>
<p>同样注意逆序枚举t</p>
<ul>
<li>结论：不一定要按照时间线性流逝设置状态，也可以将时间累加表示，即累加贡献。</li>
</ul>
<blockquote>
<p>P3360</p>
</blockquote>
<p>同上，加入了价值。</p>
<blockquote>
<p>P4362</p>
</blockquote>
<p>每个树枝只有两种情况会产生难受值：</p>
<p>1) 两端点都被大头吃掉
2) 两端点都不被大头吃掉并且小头只有一个(m==2)</p>
<p>因为如果小头多余一个，那么任意一条满足情况2的树枝，它的两端都可以被不同的小头吃，就不会有贡献。</p>
<p>因此转移方程：
$$f[u][i][0]=min(f[u][i][0],min(tmp[i-j][0]+f[v][j][0]+(m==2)* w,tmp[i-j][0]+f[v][j][1]));\
f[u][i][1]=min(f[u][i][1],min(tmp[i-j][1]+f[v][j][1]+w,tmp[i-j][1]+f[v][j][0]));$$</p>
<p>注意m==2，就算没有难受值也要把子树的贡献加到背包里。</p>
<p>并且每次dp之前要将f[u]数组备份下来，这样就可以防止f[u]不断变小.</p>
<p>例如：</p>
<p><img alt="hydra" src="data:image/png;base64,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" /></p>
<p>无tmp：</p>
<p>v1后：f[u][1][0]=0;</p>
<p>v2后：因为f[u][1][0]=0,所以f[u][1][0]=min(0,0+0+5)=0;</p>
<p>有tmp：</p>
<p>v1后：f[u][1][0]=0;</p>
<p>v2前：</p>
<p>f[u][1][0]=INF;
tmp[1][0]=0;</p>
<p>v2后：f[u][1][0]=min(INF,0+0+5)=5;</p>
<p>因为f[u][1][0]在不同时刻表示的是不同状态，如果不备份，就会导致f[u]越来越小，即f[u][1][0]只能与当前时刻的新贡献比较，不能与tmp中之前的状态做min.tmp只能用来更新出当前j不同的状态.</p>
<p>换种说法，f[v2][1][0]表示当前状态，f[v1][1][0]表示之前的状态，则v2以及它之后的状态都会因为f[v1][1][0]=0而越变越小，产生了后效性。</p>
<p>为了不产生后效性，就不能让v2访问到f[v1][1][0],所以需要备份tmp。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;

using namespace std;
const int N=530;
int f[N][N][2],head[N],sz[N],tmp[N][2];
int n,m,k,cnt;
struct node {
    int v,w,nxt;
} e[N&lt;&lt;1];
void add(int u,int v,int w) {
    e[++cnt].v=v;
    e[cnt].w=w;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}
void dp(int u,int p) {
    f[u][0][0]=0;
    f[u][1][1]=0;
    sz[u]=1;
    for(int o=head[u]; ~o; o=e[o].nxt) {
        int v=e[o].v,w=e[o].w;
        if(v==p)continue;
        dp(v,u);
        sz[u]+=sz[v];
    }
    for(int o=head[u]; ~o; o=e[o].nxt) {
        int v=e[o].v,w=e[o].w;
        if(v==p)continue;
        memcpy(tmp,f[u],sizeof tmp);
        memset(f[u],63,sizeof f[u]);
        for(int i=min(k,sz[u]); i&gt;=0; --i) {//注意这里取min(k,sz[u])可以快不少
            for(int j=min(i,sz[v]); j&gt;=0; --j) {
                f[u][i][0]=min(f[u][i][0],min(tmp[i-j][0]+f[v][j][0]+(m==2)*w,tmp[i-j][0]+f[v][j][1]));

                f[u][i][1]=min(f[u][i][1],min(tmp[i-j][1]+f[v][j][1]+w,tmp[i-j][1]+f[v][j][0]));
            }
        }
    }
}
int main() {
    memset(head,-1,sizeof head);
    cnt=-1;
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
    if(n-k&lt;m-1) {
        printf(&quot;-1&quot;);
        return 0;
    }
    for(int i=1,u,v,w; i&lt;n; ++i) {
        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
        add(u,v,w);
        add(v,u,w);
    }
    //init();
    memset(f,63,sizeof f);
    dp(1,1);
    printf(&quot;%d&quot;,f[1][k][1]);
    return 0;
}

</code></pre>
<ul>
<li>树形背包的复杂度分析：</li>
</ul>
<p>$$
对于每个点，枚举的次数为sz[u]<em> sz[v_1]+sz[u]</em> sz[v_2]+...+sz[u]* sz[v_m]=O(sz[u]^2)\</p>
<p>(对于枚举到0，其实相差个常数，可以忽略。)\</p>
<p>所以整体的复杂度就是\sum_{u=1}^n sz[u]^2=O(n^3* k),k&lt;1.\</p>
<p>事实上，最极限的情况就是一条链，此时k=\frac12</p>
<p>所以k&lt;\frac12\</p>
<p>所以可以说树形背包的复杂度严格小于O(0.5n^3)
$$</p>
<blockquote>
<p>P3177</p>
</blockquote>
<p>好题。</p>
<p>设f[u][i]表示每个节点的子树内所有的边产生的贡献。</p>
<p>注意状态的含义时贡献，不是每个子树内所有点的答案，因为子树内的点会和子树外的点产生额外的贡献，并且无法计算。</p>
<p>考虑每条边的贡献，实际上就是两边的同色点的乘积。</p>
<p>则转移方程：</p>
<pre><code class="language-cpp">    int tot=j*(k-j)+(sz[v]-j)*(n-sz[v]-k+j);
    f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]+tot*w);
</code></pre>
<ul>
<li>注意：
1) 这个树形背包要清空非法状态(-1)，不然会出错。</li>
</ul>
<p>2) 第二层的枚举如果是倒序，就一定要先转移f[v][0],即j==0得情况，不然也会出错。原因就是，每次都会用f[u][j]更新一次:f[u][j]+f[v][0]，这就不满足不用得出的状态更新其他状态了。</p>
<ul>
<li>结论:  当设计成子树内答案行不通，换句话说子树内答案受子树外节点影响时，可以设计成子树内边的贡献。</li>
</ul>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define int long long 
using namespace std;
const int N=2200;
int n,k,cnt;
int head[N],sz[N];
int f[N][N];
struct node{
    int v,nxt,w;
}e[N&lt;&lt;1];
void add(int u,int v,int w){
    e[++cnt].v=v;
    e[cnt].w=w;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}
void dfs(int u,int p){
    sz[u]=1;
    for(int o=head[u];~o;o=e[o].nxt){
        int v=e[o].v;
        if(v==p)continue;
        dfs(v,u);
        sz[u]+=sz[v];
    }
}
void dp(int u,int p){
    f[u][1]=f[u][0]=0;
    for(int o=head[u];~o;o=e[o].nxt){
        int v=e[o].v,w=e[o].w;
        if(v==p)continue;
        dp(v,u);
        for(int i=min(sz[u],k);i&gt;=0;--i){
            for(int j=0;j&lt;=min(sz[v],i);++j){
                if(f[u][i-j]==-1)continue;
                int tot=j*(k-j)+(sz[v]-j)*(n-sz[v]-k+j);
                f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]+tot*w);
            }
        } 
    }
}
int read1(){
    int x=0;
    char ch=getchar();
    while(ch&gt;'9' || ch&lt;'0'){
        ch=getchar();
    }
    while(ch&lt;='9' &amp;&amp; ch&gt;='0'){
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-'0';
        ch=getchar();
    }
    return x;
}
void write1(int x){
    if(x&gt;9)write1(x/10);
    putchar(x%10+'0');
}
signed main(){
    memset(head,-1,sizeof head);
    cnt=-1;
    n=read1(),k=read1();
    if(n-k&lt;k)k=n-k;
    for(int i=1,u,v,w;i&lt;n;++i){
        u=read1(),v=read1(),w=read1();
        add(u,v,w);
        add(v,u,w);
    }
    memset(f,-1,sizeof f);
    dfs(1,0);
    dp(1,0);
    write1(f[1][k]);
    return 0;
}
</code></pre>
<h2 id="dp_1">换根dp</h2>
<blockquote>
<p>P6419</p>
</blockquote>
<p>设$f[u]$表示子树内贡献，$g[u]$表示子树外贡献，$dis[u][0/1]$表示子树内最/次长链，$up[u]$表示子树外最长链。</p>
<p>注意更新$up[u]$和$g[u]$时，如果所有关键点都包含在$v$子树内，说明$u$上面没有最长链，那么$up[v]$和$g[v]$都不应该转移。（都为0）</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define int long long 
using namespace std;
const int N=5e5+10;
int dis[N][2],up[N],head[N],f[N],g[N],sz[N],vis[N],ans[N];
int n,k,cnt,tot;
struct node {
    int v,w,nxt;
} e[N&lt;&lt;1];
void add(int u,int v,int w) {
    e[++cnt].v=v;
    e[cnt].w=w;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}
void dfs(int u,int p) {
    sz[u]=vis[u];
    for(int i=head[u]; ~i; i=e[i].nxt) {
        int v=e[i].v,w=e[i].w;
        if(v==p)continue;

        dfs(v,u);
        sz[u]+=sz[v];

        if(!sz[v])continue;
        f[u]+=f[v]+w+w;

        if(dis[v][0]+w&gt;dis[u][0]) {
            dis[u][1]=dis[u][0];
            dis[u][0]=dis[v][0]+w;
        } else if(dis[v][0]+w&gt;dis[u][1]) {
            dis[u][1]=dis[v][0]+w;
        }

    }
}
void dp(int u,int p) {
    for(int i=head[u]; ~i; i=e[i].nxt) {
        int v=e[i].v,w=e[i].w;
        if(v==p)continue;
        if((k-sz[v])) {
            g[v]=g[u]+f[u]-f[v]+((sz[v]==0)?(w+w):0);
            if(dis[v][0]+w==dis[u][0]) {
                up[v]=max(up[u],dis[u][1])+w;
            } else {
                up[v]=max(up[u],dis[u][0])+w;
            }
        }
        dp(v,u);
    }
}
signed main() {
    memset(head,-1,sizeof head);
    cnt=-1;
    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k);
    for(int i=1,u,v,w; i&lt;n; ++i) {
        scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w);
        add(u,v,w);
        add(v,u,w);
    }
    for(int i=1,tmp; i&lt;=k; ++i) {
        scanf(&quot;%lld&quot;,&amp;tmp);
        vis[tmp]=1;
    }
    dfs(1,0);
    dp(1,0);
    for(int i=1; i&lt;=n; ++i) {
        printf(&quot;%lld\n&quot;,f[i]+g[i]-max(dis[i][0],up[i]));
    }

    return 0;
}

</code></pre>
<ul>
<li>结论：</li>
</ul>
<p>1) 换根dp的套路就是处理子树内的信息，子树外的信息由子树内信息相减得到。</p>
<p>2) 处理子树内信息时，顺序为$v\to u$,即从叶子向上合并；处理子树外信息时，顺序为$u \to v$,即从根向下推。</p>
<blockquote>
<p>P3237</p>
</blockquote>
<p>~~看题就看了30min~~</p>
<p>然而看懂了题也不知道怎么做。</p>
<p>题意简化:</p>
<p>给一棵树，每个点有一个权值，要求修改一些点的权值，使得：</p>
<p>1) 同一个父亲的儿子权值必须相同</p>
<p>2) 父亲的取值必须是所有儿子权值之和</p>
<p><strong>一个重要结论</strong>：只要有一个点被确定了，那么整棵树的最终形态就随之确定了。</p>
<p>也就是说，一个点被确定后，只有与他"等价"的点不用改变，其他的都要变。</p>
<p>设最多的等价点个数总共有$ans$个，那么最终要改变$n-ans$个点。</p>
<p>下面要求出所有等价点。我们发现，两个节点等价需要满足：</p>
<p>$\prod_{i=1}^{d_x-1}son[v[i]]<em> a[x]=\prod_{i=1}^{d_y-1}son[v[i]]</em> a[y]$。</p>
<p>设$f[i]$表示上述式子，则：$f[x]=f[y]$</p>
<p>这样，我们就可以~~快乐地~~树形$dp$了.</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt; 
#define int long long 
using namespace std;
typedef double db;
const int N=5e5+10;
const db eps=1e-8,INF=1e8;
int n,u,v,cnt,tmp,ans;
int a[N],head[N];
db f[N];
struct node{
    int v,nxt;
}e[N&lt;&lt;1];
bool cmp(db a,db b){return a&lt;b;}
void add(int u,int v){e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt;}
void dfs(int u,int p,db t){
    f[u]+=t;
    int tot=0;
    for(int i=head[u];~i;i=e[i].nxt){
        int v=e[i].v;
        if(v==p)continue;
        ++tot;
    }
    for(int i=head[u];~i;i=e[i].nxt){
        int v=e[i].v;
        if(v==p)continue;
        dfs(v,u,t+log((db)(tot)));
    }
}
signed main(){
    memset(head,-1,sizeof head);cnt=-1;f[0]=-INF;
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i) scanf(&quot;%lld&quot;,&amp;a[i]),f[i]=log((db)(a[i]));
    for(int i=1;i&lt;n;++i) scanf(&quot;%lld%lld&quot;,&amp;u,&amp;v),add(u,v),add(v,u);
    dfs(1,0,0);
    sort(f+1,f+n+1,cmp);
    tmp=0,ans=0;
    for(int i=2;i&lt;=n;++i){
        if(f[i]-f[i-1]&lt;eps) ++tmp;
        else ans=max(ans,tmp),tmp=1;
    }
    ans=max(ans,tmp);
    printf(&quot;%lld&quot;,n-ans);
    return 0;
} 
</code></pre>
<blockquote>
<p>P3523</p>
</blockquote>
<p>问题可以转化为有用超过$m$个点来覆盖所有关键点，最大距离最小为$ans$.</p>
<p>如果使用贪心+二分，则需要保证每个新节点管辖的范围最大并且与其他节点管辖的节点重叠最小。这样能保证用的点最少。</p>
<p>所以可以设$f[i]$表示在$i$的子树里距离$i$最远的关键节点；$g[i]$表示在$i$的子树里距离$i$最近的已选中的节点。</p>
<p>初始值$f[u]=-\infty,g[u]=\infty$</p>
<p>转移：</p>
<p>$$
f[u]=\max_{v\in son(u)}(f[v]+1),g[u]=\min_{v\in son(u)}(g[v]+1)
$$</p>
<p>还有三个特判：</p>
<p>($k$为当前二分的距离)</p>
<p>1) $f[u]+g[u]&lt;=k$，说明当前的子树可以通过这个选中节点被完全覆盖，所以$f[u]=-\infty$,表示不对父节点的$f$产生影响</p>
<p>2) $g[u]&gt;k$，说明当前的子树上端不会被$u$的子孙完全覆盖，那么可以更新一下$f[u]$交给$u$的父亲处理，这样保证重叠最小。$f[u]=\max(f[u],0)$，表示如果没有未覆盖关键节点在子树里就只算它自己。</p>
<p>3) $f[u]==k$,说明当前节点恰好能用最小重叠覆盖整颗子树，并且因为这个更新是在回溯过程中的，要往上走，如果不选这个节点，后面就无法覆盖所有节点，所以强制选$u$,$f[u]=-\infty,g[u]=0,++tot$</p>
<p>最后特判一下根节点。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=3e5+10,INF=1e9+10;
int f[N],g[N],head[N],a[N];
int cnt,n,m,u,v,tot;
struct node{
    int v,nxt;
}e[N&lt;&lt;1];
void add(int u,int v){
    e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt;
}
void dfs(int u,int p,int k){
    f[u]=-INF,g[u]=INF;
    for(int i=head[u];~i;i=e[i].nxt){
        int v=e[i].v;
        if(v==p)continue;
        dfs(v,u,k);
        f[u]=max(f[u],f[v]+1);
        g[u]=min(g[u],g[v]+1);
    }
    if(f[u]+g[u]&lt;=k) f[u]=-INF;
    if(g[u]&gt;k &amp;&amp; a[u]) f[u]=max(f[u],0);
    if(f[u]==k) f[u]=-INF,g[u]=0,++tot;
}
bool check(int k){
    tot=0;
    dfs(1,0,k);
    if(f[1]&gt;=0) ++tot;
    return tot&lt;=m;
}
int main(){
    memset(head,-1,sizeof head);cnt=-1;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]);
    for(int i=1;i&lt;n;++i)scanf(&quot;%d%d&quot;,&amp;u,&amp;v),add(u,v),add(v,u);
    int l=0,r=n,ans=INF;
    while(l&lt;=r){
        int mid=l+r&gt;&gt;1;
        if(check(mid)) r=mid-1,ans=mid;     
        else l=mid+1;
    }
    printf(&quot;%d&quot;,ans);
    return 0;
}
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
