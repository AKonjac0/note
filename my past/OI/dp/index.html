<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>期望dp - My Docs</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">My Docs</a>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#dp" class="nav-link">期望dp</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#dp_1" class="nav-link">计数dp</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#_1" class="nav-link">字符串类计数</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#_2" class="nav-link">数字类计数</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#dp_2" class="nav-link">概率dp</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            
            <li class="nav-item" data-bs-level="1"><a href="#dagdp" class="nav-link">DAG上dp</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="dp">期望dp</h1>
<blockquote>
<p>P1850</p>
</blockquote>
<p>设$f[i][j][0/1]$表示考虑到第$i$个教室，用了$j$次交换权并且$i$换与不换的最小值。</p>
<p>每次的新贡献只用考虑$i$与$i-1$之间的最短路以及他们成功的概率.</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define db double
using namespace std;
const int N=2200,V=330;
const double INF=1e18;
int dis[N][N];
int n,m,v,e,a,b,w;
db f[N][N][2];
struct room{
    int c,d;db k;
}s[N];
void floyd(){
    for(int i=1;i&lt;=v;++i)dis[i][i]=0;
    for(int k=1;k&lt;=v;++k)
        for(int i=1;i&lt;=v;++i)
            for(int j=1;j&lt;=v;++j){
                if(i==j)continue;
                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
            }

}
void init(){
    memset(dis,0x3f,sizeof dis);
    for(int i=0;i&lt;=n+1;++i)
        for(int j=0;j&lt;=m+1;++j)
            f[i][j][0]=f[i][j][1]=INF;
}
inline db Min(db a,db b){return a&lt;b?a:b;}
int main(){
    scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;v,&amp;e);  
    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;s[i].c);
    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;s[i].d);
    for(int i=1;i&lt;=n;++i)scanf(&quot;%lf&quot;,&amp;s[i].k);
    init();

    for(int i=1;i&lt;=e;++i){
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);
        dis[a][b]=min(dis[a][b],w);
        dis[b][a]=min(dis[b][a],w);
    }
    floyd();
    f[1][0][0]=0.0;f[1][1][1]=0.0;

    for(int i=2;i&lt;=n;++i){
        for(int j=0;j&lt;=m;++j){
            db kv=s[i-1].k,ku=s[i].k;
            int uc=s[i].c,ud=s[i].d,vc=s[i-1].c,vd=s[i-1].d;
            f[i][j][0]=Min(f[i][j][0],f[i-1][j][0]+1.0*1.0*(double)dis[vc][uc]);
            f[i][j][0]=Min(f[i][j][0],f[i-1][j][1]+kv*(double)dis[vd][uc]+(1.0-kv)*(double)dis[vc][uc]);
            if(j==0)continue;
            f[i][j][1]=Min(f[i][j][1],f[i-1][j-1][0]+ku*(double)dis[vc][ud]+(1.0-ku)*(double)dis[vc][uc]);
            f[i][j][1]=Min(f[i][j][1],f[i-1][j-1][1]+
            ku*kv*(double)dis[vd][ud]+
            kv*(1.0-ku)*(double)dis[vd][uc]+
            ku*(1.0-kv)*(double)dis[vc][ud]+
            (1.0-ku)*(1.0-kv)*(double)dis[vc][uc]);
        }
    }
    db ans=INF;
    for(int i=0;i&lt;=m;++i)ans=Min(ans,Min(f[n][i][0],f[n][i][1]));
    printf(&quot;%.2lf&quot;,ans);
    return 0;
} 

</code></pre>
<hr />
<h1 id="dp_1">计数dp</h1>
<h2 id="_1">字符串类计数</h2>
<blockquote>
<p>P2679</p>
</blockquote>
<p>f[i][j][k][0/1]表示a串前i位匹配b串前j位，用了k个子串且i与j是否匹配时的答案</p>
<p>转移方程：</p>
<pre><code class="language-cpp">//1.
f[0][0][0][0]=1;
f[1][0][0][0]=1;
for(i)
  for(j)
    for(k)
            if(a[i]==b[j]){
                f[i][j][k][1]=f[i-1][j-1][k][1]+f[i-1][j-1][k-1][1]+f[i-1][j-1][k-1][0];
            }else{
                f[i][j][k][1]=0;
            }
            f[i][j][k][0]=f[i-1][j][k][0]+f[i-1][j][t][1];
//2.
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=m;++j)
            for(int l=1;l&lt;=k;++l)f[i%2][j][l][1]=f[i%2][j][l][0]=0;
        if(a[i-1]==b[0])f[i%2][1][1][1]=1;
        for(int j=1;j&lt;=m;++j){
            for(int l=1;l&lt;=k;++l){
                if(a[i-1]==b[j-1]){
                    f[i%2][j][l][1]=(f[i%2][j][l][1]+f[(i-1)%2][j-1][l-1][1]+f[(i-1)%2][j-1][l][1]+f[(i-1)%2][j-1][l-1][0])%P; 
                }else f[i%2][j][l][1]=0;
                f[i%2][j][l][0]=(f[i%2][j][l][0]+f[(i-1)%2][j][l][1]+f[(i-1)%2][j][l][0])%P;
            }
        }
    }
</code></pre>
<ul>
<li>将第一维滚动掉的方法：因为只与上一层有关，所以两层就够，使用i%2判断。</li>
</ul>
<p>注意需要第二种方法需要清零。</p>
<blockquote>
<p>P2389</p>
</blockquote>
<p>与P2679十分类似。少了一维，不用滚动。并且成了取最大值。
用f[i][j][0/1]表示用了j段，第i位是否取的答案。
转移方程：</p>
<pre><code class="language-cpp">    //memset(f,-0x3f,sizeof f);
    f[0][0][0]=0;
    f[0][0][1]=0;
    //f[1][0][0]=0;
    //f[1][0][1]=0;
    int ans=0;
    for(int i=1;i&lt;=n;++i){
        for(int j=1;j&lt;=k;++j){
            int max1=max(f[i-1][j][1],max(f[i-1][j-1][1],f[i-1][j-1][0]));
            f[i][j][1]=max(f[i][j][1],max1+a[i]);
            int max2=max(f[i-1][j][0],f[i-1][j][1]);
            f[i][j][0]=max(f[i][j][0],max2);
            ans=max(ans,max(f[i][j][0],f[i][j][1]));
        }
    }
</code></pre>
<p>注意取值可以为负，所以要将f赋值成$-\infty$,并和0去取max。</p>
<p>~~所以不就是初始化为零吗~~</p>
<h2 id="_2">数字类计数</h2>
<blockquote>
<p>P7961</p>
</blockquote>
<p>1) 第三维维护整体(加上第四维进位)的$1$的个数不好，因为可能会出现转移时第三位减少的情况，这样就可能溢出。</p>
<p>2) 快速幂不需要，直接预处理就行了。</p>
<p>3) 这种状态设计第一维到$m+1$就已经包含了所有状态，不能再往回找了。</p>
<p>正确做法是设$f[i][j][p][l]$表示考虑完第$i$个$a_i$，一共用了$j$个$a$,当前不包括$l$一共$p$个$1$,以及进位数$l$.</p>
<p>因为每次都会将$l/2$,并且每次$l$都不超过$n$,所以每次枚举$l$到$\frac n2$即可。</p>
<p>这样只要在统计答案时将$l$的$1$的个数再加回来即可。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define int long long
using namespace std;
const int N=33,M=110,P=998244353;
int f[M][N][N][20];
int C[N][N];
int v[M],num[N],pv[M][N];
int n,m,k;
inline int getnum(int i) {
    int ans=0;
    while(i)ans+=(i&amp;1),i&gt;&gt;=1;
    return ans;
}
void init() {
    for(int i=0; i&lt;=n; ++i) {
        C[i][0]=1;
        for(int j=1; j&lt;=i; ++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;
    }
    for(int i=0; i&lt;=n; ++i)num[i]=getnum(i);
    for(int i=0;i&lt;=m;++i){
        pv[i][0]=1;
        for(int j=1;j&lt;=n;++j)pv[i][j]=(pv[i][j-1]*v[i])%P;
    }
}
int dp() {
    f[0][0][0][0]=1;
    for(int i=0; i&lt;=m; ++i) 
        for(int j=0; j&lt;=n; ++j) 
            for(int p=0; p&lt;=k; ++p) 
                for(int l=0; l&lt;=(n&gt;&gt;1); ++l) 
                    for(int q=0; q+j&lt;=n; ++q) {
                        int tmp=((f[i][j][p][l]*pv[i][q]%P)*C[n-j][q])%P;
                        f[i+1][j+q][p+(q+l&amp;1)][(l+q)&gt;&gt;1]=(f[i+1][j+q][p+(q+l&amp;1)][(l+q)&gt;&gt;1]+tmp)%P;
                    }
    int ans=0;
    for(int p=0; p&lt;=k; ++p) 
        for(int l=0; l&lt;=(n&gt;&gt;1); ++l) 
            if(p+num[l]&lt;=k)ans=(ans+f[m+1][n][p][l])%P;
    return ans;
}
signed main() {
    //freopen(&quot;sequence2.in&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k);
    for(int i=0; i&lt;=m; ++i)scanf(&quot;%lld&quot;,&amp;v[i]);
    init();
    printf(&quot;%lld&quot;,dp());
    return 0;
}
</code></pre>
<blockquote>
<p>P1633</p>
</blockquote>
<p>我们可以设一个五维的状态，f[i][j][k][l][0/1],表示X中有i个1，Y中有j个1，Z中有k个1，当前比较到了第l位，且Z的第l位是0还是1.</p>
<p>对于X和Y的第l位，有两种选择，就是填0或1，所以有如下转移：</p>
<pre><code class="language-cpp">f[i][j][k][l][0]+0          -&gt;f[i][j][k][l+1][0]   //0 0
                +(1ll&lt;&lt;l-1) -&gt;f[i][j+1][k+1][l+1][0]    //0 1
                +(1ll&lt;&lt;l-1) -&gt;f[i+1][j][k+1][l+1][0]    //1 0
                +(1ll&lt;&lt;l)   -&gt;f[i+1][j+1][k+1][l+1][1]  //1 1

f[i][j][k][l][1]+0          -&gt;f[i][j][k][l+1][0]    //0 0
                +(1ll&lt;&lt;l-1) -&gt;f[i][j+1][k][l+1][1]      //0 1
                +(1ll&lt;&lt;l-1) -&gt;f[i+1][j][k][l+1][1]      //1 0
                +(1ll&lt;&lt;l)   -&gt;f[i+1][j+1][k+1][l+1][1]  //1 1

</code></pre>
<p>注意给第l位加个1相当于给原数加$2^{l-1}$,而不是$2^l$</p>
<p>举个例子，对于1111和11111这两种第l位分别是0和1的情况：~~(01111前导零不用管，只是表示第l位为0而已)~~</p>
<pre><code class="language-cpp">//左-&gt;右为低位-&gt;高位
    l        l
11110 -&gt;111100
i   0
j   0
11110 -&gt;111110 
i   0
j   1       
11110 -&gt;111110
i   1
j   0       
11110 -&gt;111111
i   1
j   1

    l        l
11111 -&gt;111110
i   0
j   0
11111 -&gt;111101 
i   0
j   1       
11111 -&gt;111101
i   1
j   0       
11111 -&gt;111111
i   1
j   1
</code></pre>
<p>分别加上贡献以后，再取个最小值就行了。</p>
<p>边界是$f[0][0][0][1][0]=0$,l从1开始.</p>
<p>对输入的a,b,c求出ll,na,nb,nc那么最终答案为$\min(f[na][nb][nc][0,1,...,ll][0,1])$</p>
<p>注：</p>
<p>$f[i][j][k][l][0]+2^{l-1}$不能转移给$f[i][j+1][k+1][l][1]$,而是转移给$f[i][j][k+1][l+1][0]$</p>
<p>因为l没有移动位置，下次还是在第l位加1，所以会出现X或Y同一位加了两次1，出现错误。</p>
<p>~~其实l那一维可以滚存的，但我懒~~</p>
<p><em>Code:</em> </p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define int long long 
using namespace std;
const int N=33,INF=5e18;
int f[N][N][N][N][2];
int n,a,b,c,na,nb,nc,la,lb,lc,ll;
void init() {
    memset(f,0x3f,sizeof f);
    na=0;nb=0;nc=0;la=0;lb=0;lc=0;
    while(a) {
        if(a&amp;1)na++;
        la++;
        a&gt;&gt;=1;
    }
    while(b) {
        if(b&amp;1)nb++;
        lb++;
        b&gt;&gt;=1;
    }
    while(c) {
        if(c&amp;1)nc++;
        lc++;
        c&gt;&gt;=1;
    }
    ll=max(la,max(lb,lc));
}
void work() {
    f[0][0][0][1][0]=0;
    for(int i=0; i&lt;=na; ++i) {
        for(int j=0; j&lt;=nb; ++j) {
            for(int k=0; k&lt;=nc; ++k) {
                for(int l=1; l&lt;=ll; ++l) {
                    f[i][j][k][l+1][0]=min(f[i][j][k][l+1][0],min(f[i][j][k][l][0],f[i][j][k][l][1]));
                    f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1],min(f[i][j][k][l][0],f[i][j][k][l][1])+(1ll&lt;&lt;l));//注意写法，1ll&lt;&lt;l要加括号

                    f[i][j+1][k+1][l+1][0]=min(f[i][j+1][k+1][l+1][0],f[i][j][k][l][0]+(1ll&lt;&lt;l-1));
                    f[i+1][j][k+1][l+1][0]=min(f[i+1][j][k+1][l+1][0],f[i][j][k][l][0]+(1ll&lt;&lt;l-1));
                    f[i][j+1][k][l+1][1]=min(f[i][j+1][k][l+1][1],f[i][j][k][l][1]+(1ll&lt;&lt;l-1));
                    f[i+1][j][k][l+1][1]=min(f[i+1][j][k][l+1][1],f[i][j][k][l][1]+(1ll&lt;&lt;l-1));             
                }
            }
        }
    }
}
signed main() {
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1; i&lt;=n; ++i) {
        scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);
        init();//初始化
        work();//dp
        int ans=INF;
        for(int i=0; i&lt;=ll; ++i) {
            int tmp1=f[na][nb][nc][i][0],cnt1=0;
            int tmp2=f[na][nb][nc][i][1],cnt2=0;
            while(tmp1&gt;0)tmp1&gt;&gt;=1,cnt1++;
            while(tmp2&gt;0)tmp2&gt;&gt;=1,cnt2++;
            if(cnt1&lt;=ll &amp;&amp; cnt1&gt;0)ans=min(ans,f[na][nb][nc][i][0]);//所有满足条件的数中取最小值
            if(cnt2&lt;=ll &amp;&amp; cnt2&gt;0)ans=min(ans,f[na][nb][nc][i][1]);
        }
        if(ans==INF)printf(&quot;-1\n&quot;);
        else printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}
</code></pre>
<hr />
<h1 id="dp_2">概率dp</h1>
<blockquote>
<p>P1769</p>
</blockquote>
<p>可以发现每个人的比赛路程就是一颗完全二叉树，所以按照线段树建图的方式预处理出每一轮每个人对战的所有可能对手的编号。</p>
<p>之后，每个人都有一个赢到第$j$层的概率，每个对手也有赢到第$j$层的概率，则第$i$个人赢下第$j$层获胜的总概率为：</p>
<p>$$
f[i][j]=\sum_{t=l}^r f[i][j-1]<em>f[t][j-1]</em> a[i][t]/100.0;
$$</p>
<p>最后统计谁赢到最后的总概率最大且编号最小即可。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define db double
using namespace std;
const int N=1100;
db f[N][N],a[N][N];
int n,k;
int kp[N],h[N][N];
struct node{
    int l,r;
}g[N&lt;&lt;2];
void init(){
    kp[0]=1;
    for(int i=1;i&lt;=k;++i)kp[i]=kp[i-1]&lt;&lt;1;
}
void build(int k,int i,int l,int r){
    g[i].l=l,g[i].r=r;
    for(int j=l;j&lt;=r;++j)h[j][k]=i;
    if(l==r){
        return;
    }
    int mid=l+r&gt;&gt;1;
    build(k+1,i&lt;&lt;1,l,mid);
    build(k+1,i&lt;&lt;1|1,mid+1,r);
}

int main(){
    scanf(&quot;%d&quot;,&amp;k);
    init();
    n=kp[k];
    for(int i=1;i&lt;=n;++i)
        for(int j=1;j&lt;=n;++j)scanf(&quot;%lf&quot;,&amp;a[i][j]);
    build(1,1,1,n);
    for(int i=1;i&lt;=n;++i)f[i][0]=1.0;
    for(int j=1;j&lt;=k;++j){
        for(int i=1;i&lt;=n;++i){
            int tmp=h[i][k+1-j+1]^1;
            for(int t=g[tmp].l;t&lt;=g[tmp].r;++t){
                f[i][j]+=f[i][j-1]*f[t][j-1]*a[i][t]/100.0;
            }
        }
    }
    db ans=0;
    int pos=0;
    for(int i=1;i&lt;=n;++i){
        if(ans&lt;f[i][k]){
            pos=i;
            ans=f[i][k];
        }
    }
    printf(&quot;%d&quot;,pos);

    return 0;
}
/*
2
0 90 50 50
10 0 10 10
50 90 0 50
50 90 50 0
*/

</code></pre>
<hr />
<h1 id="dagdp">DAG上dp</h1>
<blockquote>
<p>P3953</p>
</blockquote>
<p>这道题的无解情况就是当一条可行路径上包含了一个零环时,输出$-1$。</p>
<p>设$f[i][k]$表示走到第$i$个点，并且还有$k$的时间可以浪费的路径总条数。</p>
<p>每次转移相当于浪费了$dis[u]+w-dis[v]$的时间。</p>
<p>注意如果出现了非零的环，那么每转一圈都有不同状态的出现，所以不用判断$-1$;但是因为零环转一圈没有新的贡献，所以要判断。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;set&gt;
using namespace std;
typedef pair&lt;int,int&gt; PI;
const int N=2e5+10,M=55;
int T,n,m,u,v,w,K,P,cnt[2];
int head[2][N],dis[2][N],vis[N],flg[N][M],f[N][M];
struct node {
    int v,w,nxt;
} e[2][N&lt;&lt;1];
void add(int u,int v,int w,int t) {
    e[t][++cnt[t]].v=v,e[t][cnt[t]].w=w,e[t][cnt[t]].nxt=head[t][u],head[t][u]=cnt[t];
}
void dij(int t,int o) {
    memset(dis[o],0x3f,sizeof dis[o]);
    memset(vis,0,sizeof vis);
    dis[o][t]=0;
    set&lt;PI&gt; s;
    s.insert(make_pair(0,t));
    while(s.size()) {
        set&lt;PI&gt;::iterator it=s.begin();
        u=it-&gt;second;
        s.erase(*it);
        if(vis[u])continue;
        vis[u]=1;
        for(int i=head[o][u]; ~i; i=e[o][i].nxt) {
            int v=e[o][i].v,w=e[o][i].w;
            if(dis[o][v]&gt;dis[o][u]+w) {
                dis[o][v]=dis[o][u]+w;
                if(!vis[v])s.insert(make_pair(dis[o][v],v));
            }
        }
    }
}
int dfs(int u,int k) {
    if(k&lt;0 || k&gt;K)return 0;
    if(flg[u][k]) {//出现了环,并且因为走过一个环后k没有变化，说明这个环一定是个零环。
        if(dis[0][u]+dis[1][u]&lt;=dis[0][n]+K) {
            flg[u][k]=0;
            return -1;
        } else if(flg[u][k]&gt;=2) {//同一个零环又转了一圈，说明所有换上的点都已经用上面的语句判断过了，直接return
            return 0;
        }
    }
    if(f[u][k]!=-1)return f[u][k];
    flg[u][k]++;
    int res=0;
    if(u==n)res=1;
    for(int i=head[0][u]; ~i; i=e[0][i].nxt) {
        int v=e[0][i].v,w=e[0][i].w;
        int tmp=dfs(v,k-(dis[0][u]+w-dis[0][v]));
        if(tmp==-1) {
            flg[u][k]--;
            return -1;
        }
        res=(res+tmp)%P;
    }
    flg[u][k]--;
    return f[u][k]=res;
}
int main() {
    scanf(&quot;%d&quot;,&amp;T);
    while(T--) {
        memset(head,-1,sizeof head);
        cnt[0]=cnt[1]=-1;
        scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;K,&amp;P);
        for(int i=1; i&lt;=m; ++i) {
            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
            add(u,v,w,0);
            add(v,u,w,1);
        }
        dij(1,0);
        dij(n,1);
        memset(f,-1,sizeof f);
        memset(flg,0,sizeof flg);
        printf(&quot;%d\n&quot;,dfs(1,K));
    }
    return 0;
}

</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
