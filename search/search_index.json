{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"github blog","title":"About"},{"location":"my%20past/MCU/51/","text":"51\u5355\u7247\u673a \u4e32\u53e3\u901a\u4fe1UART \u4e32\u53e3\u6ce2\u7279\u7387\u4f7f\u7528\u5b9a\u65f6\u56681\uff0c\u8fd9\u91cc\u53ea\u9700\u8981\u5b9a\u65f6\u56681\u6ea2\u51fa\uff0c\u4e0d\u9700\u8981\u4ea7\u751f\u4e2d\u65ad,\u800c\u901a\u8fc7\u8bbe\u7f6e\u5b9a\u65f6\u56681\u7684TL\u548cTH\u521d\u59cb\u503c\u63a7\u5236T1\u6ea2\u51fa\u7387\uff0c\u6765\u63a7\u5236\u6ce2\u7279\u7387\u3002 \u6ce2\u7279\u7387\uff1a\u4e32\u53e3\u901a\u4fe1\u7684\u901f\u7387(\u53d1\u9001\u4e0e\u63a5\u6536\u5404\u6570\u636e\u4f4d\u7684\u95f4\u9694\u65f6\u95f4)\u3002\u6ce2\u7279\u7387\u8bef\u5dee\u8fc7\u5927\u4f1a\u5bfc\u81f4\u6570\u636e\u51fa\u9519\u3002(\u53ef\u4ee5\u7406\u89e3\u4e3a\u8fc7\u56fa\u5b9a\u65f6\u95f4\u53d6\u4e00\u4e2a\u533a\u95f4\u5185\u7684\u7535\u5e73\u6765\u786e\u5b9a0\u548c1) Q1 \u4e3a\u4ec0\u4e48\u5b9a\u65f6\u56681\u521d\u503c\u4e3a0xf4\u65f6\u624d\u80fd\u6b63\u5e38\u63a5\u6536\u6570\u636e\uff0c\u4e3a\u4ec0\u4e48\u53ea\u6709\u4e32\u53e3\u901a\u4fe1\u65f6\u752811.0592MHZ\u6676\u632f,\u7ea2\u5916\u7684\u4ee3\u7801\u91cc\u663e\u793a\u7528\u7684\u662f12.000MHZ\u6676\u632f Q2 \u5916\u90e8\u6676\u632f\u5982\u4f55\u8c03\u7528","title":"51\u5355\u7247\u673a"},{"location":"my%20past/MCU/51/#51","text":"","title":"51\u5355\u7247\u673a"},{"location":"my%20past/MCU/51/#uart","text":"\u4e32\u53e3\u6ce2\u7279\u7387\u4f7f\u7528\u5b9a\u65f6\u56681\uff0c\u8fd9\u91cc\u53ea\u9700\u8981\u5b9a\u65f6\u56681\u6ea2\u51fa\uff0c\u4e0d\u9700\u8981\u4ea7\u751f\u4e2d\u65ad,\u800c\u901a\u8fc7\u8bbe\u7f6e\u5b9a\u65f6\u56681\u7684TL\u548cTH\u521d\u59cb\u503c\u63a7\u5236T1\u6ea2\u51fa\u7387\uff0c\u6765\u63a7\u5236\u6ce2\u7279\u7387\u3002 \u6ce2\u7279\u7387\uff1a\u4e32\u53e3\u901a\u4fe1\u7684\u901f\u7387(\u53d1\u9001\u4e0e\u63a5\u6536\u5404\u6570\u636e\u4f4d\u7684\u95f4\u9694\u65f6\u95f4)\u3002\u6ce2\u7279\u7387\u8bef\u5dee\u8fc7\u5927\u4f1a\u5bfc\u81f4\u6570\u636e\u51fa\u9519\u3002(\u53ef\u4ee5\u7406\u89e3\u4e3a\u8fc7\u56fa\u5b9a\u65f6\u95f4\u53d6\u4e00\u4e2a\u533a\u95f4\u5185\u7684\u7535\u5e73\u6765\u786e\u5b9a0\u548c1)","title":"\u4e32\u53e3\u901a\u4fe1UART"},{"location":"my%20past/MCU/51/#q1-10xf4110592mhz12000mhz","text":"","title":"Q1 \u4e3a\u4ec0\u4e48\u5b9a\u65f6\u56681\u521d\u503c\u4e3a0xf4\u65f6\u624d\u80fd\u6b63\u5e38\u63a5\u6536\u6570\u636e\uff0c\u4e3a\u4ec0\u4e48\u53ea\u6709\u4e32\u53e3\u901a\u4fe1\u65f6\u752811.0592MHZ\u6676\u632f,\u7ea2\u5916\u7684\u4ee3\u7801\u91cc\u663e\u793a\u7528\u7684\u662f12.000MHZ\u6676\u632f"},{"location":"my%20past/MCU/51/#q2","text":"","title":"Q2 \u5916\u90e8\u6676\u632f\u5982\u4f55\u8c03\u7528"},{"location":"my%20past/OI/0.9loop%3D1/","text":"0.999...=1 \u76f4\u63a5\u8ba1\u7b97 $$\\frac19=0.111... \\ 9 * \\frac19=0.999... \\ 9 * \\frac19=1 \\ \\therefore 0.999...=1 $$ \u8bbe\u6570 $$x=0.999...\\ 10 * x=9.999... \\10 * x-1 * x=9 * x=9 \\x=1 \\\\therefore 0.999...=1 $$ \u6781\u9650 $$ 0.999...=\\lim_{n\\to\\infty}1-\\frac1{10^n}\\ \\lim_{n\\to\\infty}\\frac1{10^n}=0 \\\\therefore0.999...=1 $$ \u7136\u800c\uff0c\u8fd9\u4e9b\u90fd\u4e0d\u591f\u4e25\u8c28 \u6234\u5fb7\u91d1\u5206\u5272\uff08Dedekind\uff09 $$ \u8bbe t=0.999......\uff0c\u4f5c\u4e24\u4e2a\u6709\u7406\u6570\u96c6\u7684\u5206\u5272 \\ A={ [x|x =t,x\u6709\u7406\u6570]} \\ C={[x|x<1,x\u6709\u7406\u6570]}\uff0cD={[x|x>=1,x\u6709\u7406\u6570]} \\ \u5206\u5272A/B\u786e\u5b9a\u4e86\u5b9e\u6570t=0.999......(\u6211\u4eec\u6682\u65f6\u4e0d\u77e5\u9053t=0.999...\u662f\u6709\u7406\u6570\u8fd8\u662f\u65e0\u7406\u6570) \\ \u5206\u5272C/D\u786e\u5b9a\u4e86\u6709\u7406\u65701 \\ \u4e3a\u8bc1\u660e t=1\uff0c\u6211\u4eec\u53ea\u9700\u8981\u8bc1\u660e\u8fd9\u4e24\u4e2a\u5206\u5272\u662f\u76f8\u540c\u7684\uff0c\u5373\u8bc1\u660e A=C \\ \u82e5\u6709\u7406\u6570 x\u2208A\uff0c\u5219\u663e\u7136\u6709 x<1\uff0c\u4e8e\u662f x\u2208C \\ \u82e5\u6709\u7406\u6570 x\u2208C\uff0c\u5219 x<1\uff0c\u4e0d\u59a8\u8bbe x>0 \\ \u6839\u636e\u6709\u7406\u6570\u7684\u5b9a\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u628ax\u7528\u5206\u6570\u7684\u5f62\u5f0f\u8868\u793a\u4e3a \\ x=\\frac pq\uff0c(p\uff0cq\u4e3a\u6b63\u6574\u6570) \\ \u65e2\u71360<x<1\uff0c\u5219\u5fc5\u6709p< q \\ \u4e8e\u662f\u75311-\\frac pq>=\\frac 1q>0\uff0c\u53ef\u5f97\u5b58\u5728\u6b63\u6574\u6570n(\\frac{p+1}q<=1 \u53ef\u4ee5\u8bc1\u660e\uff0c\u56e0\u4e3ap,q\u90fd\u662f\u6b63\u6574\u6570)\uff0c\u4f7f\u5f97 \\ \\frac 1q>\\frac1{10^n}>0(x\u662f\u786e\u5b9a\u7684\u6570\uff0c\u5219q\u5b58\u5728\uff0c\u5219\u6bd4\u5b83\u9ad8\u9636\u7684n\u4e00\u5b9a\u5b58\u5728\uff0c\u4e0d\u7528\u7ea0\u7ed3\u65e0\u7a77\u5927\u7684\u4e8b) \\ x=\\frac pq<=1-\\frac 1q<1-\\frac1{10^n}=0.99...9(n\u4e2a9)< t \\ \u65e2\u7136x<t\uff0c\u8fd9\u5c31\u8bf4\u660ex\u2208A \\ \u7531\u4e0a\uff0c\u6211\u4eec\u5c31\u5f97\u5230\u4e86A=C\uff0c\u4ece\u800c\uff0cA/B\u548cC/D\u662f\u4e24\u4e2a\u76f8\u540c\u7684\u5206\u5272\uff0c\u56e0\u6b64\uff0c 0.999...=t=1 $$ Orz","title":"0.999...=1"},{"location":"my%20past/OI/0.9loop%3D1/#09991","text":"","title":"0.999...=1"},{"location":"my%20past/OI/0.9loop%3D1/#_1","text":"$$\\frac19=0.111... \\ 9 * \\frac19=0.999... \\ 9 * \\frac19=1 \\ \\therefore 0.999...=1 $$","title":"\u76f4\u63a5\u8ba1\u7b97"},{"location":"my%20past/OI/0.9loop%3D1/#_2","text":"$$x=0.999...\\ 10 * x=9.999... \\10 * x-1 * x=9 * x=9 \\x=1 \\\\therefore 0.999...=1 $$","title":"\u8bbe\u6570"},{"location":"my%20past/OI/0.9loop%3D1/#_3","text":"$$ 0.999...=\\lim_{n\\to\\infty}1-\\frac1{10^n}\\ \\lim_{n\\to\\infty}\\frac1{10^n}=0 \\\\therefore0.999...=1 $$ \u7136\u800c\uff0c\u8fd9\u4e9b\u90fd\u4e0d\u591f\u4e25\u8c28","title":"\u6781\u9650"},{"location":"my%20past/OI/0.9loop%3D1/#dedekind","text":"$$ \u8bbe t=0.999......\uff0c\u4f5c\u4e24\u4e2a\u6709\u7406\u6570\u96c6\u7684\u5206\u5272 \\ A={ [x|x =t,x\u6709\u7406\u6570]} \\ C={[x|x<1,x\u6709\u7406\u6570]}\uff0cD={[x|x>=1,x\u6709\u7406\u6570]} \\ \u5206\u5272A/B\u786e\u5b9a\u4e86\u5b9e\u6570t=0.999......(\u6211\u4eec\u6682\u65f6\u4e0d\u77e5\u9053t=0.999...\u662f\u6709\u7406\u6570\u8fd8\u662f\u65e0\u7406\u6570) \\ \u5206\u5272C/D\u786e\u5b9a\u4e86\u6709\u7406\u65701 \\ \u4e3a\u8bc1\u660e t=1\uff0c\u6211\u4eec\u53ea\u9700\u8981\u8bc1\u660e\u8fd9\u4e24\u4e2a\u5206\u5272\u662f\u76f8\u540c\u7684\uff0c\u5373\u8bc1\u660e A=C \\ \u82e5\u6709\u7406\u6570 x\u2208A\uff0c\u5219\u663e\u7136\u6709 x<1\uff0c\u4e8e\u662f x\u2208C \\ \u82e5\u6709\u7406\u6570 x\u2208C\uff0c\u5219 x<1\uff0c\u4e0d\u59a8\u8bbe x>0 \\ \u6839\u636e\u6709\u7406\u6570\u7684\u5b9a\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u628ax\u7528\u5206\u6570\u7684\u5f62\u5f0f\u8868\u793a\u4e3a \\ x=\\frac pq\uff0c(p\uff0cq\u4e3a\u6b63\u6574\u6570) \\ \u65e2\u71360<x<1\uff0c\u5219\u5fc5\u6709p< q \\ \u4e8e\u662f\u75311-\\frac pq>=\\frac 1q>0\uff0c\u53ef\u5f97\u5b58\u5728\u6b63\u6574\u6570n(\\frac{p+1}q<=1 \u53ef\u4ee5\u8bc1\u660e\uff0c\u56e0\u4e3ap,q\u90fd\u662f\u6b63\u6574\u6570)\uff0c\u4f7f\u5f97 \\ \\frac 1q>\\frac1{10^n}>0(x\u662f\u786e\u5b9a\u7684\u6570\uff0c\u5219q\u5b58\u5728\uff0c\u5219\u6bd4\u5b83\u9ad8\u9636\u7684n\u4e00\u5b9a\u5b58\u5728\uff0c\u4e0d\u7528\u7ea0\u7ed3\u65e0\u7a77\u5927\u7684\u4e8b) \\ x=\\frac pq<=1-\\frac 1q<1-\\frac1{10^n}=0.99...9(n\u4e2a9)< t \\ \u65e2\u7136x<t\uff0c\u8fd9\u5c31\u8bf4\u660ex\u2208A \\ \u7531\u4e0a\uff0c\u6211\u4eec\u5c31\u5f97\u5230\u4e86A=C\uff0c\u4ece\u800c\uff0cA/B\u548cC/D\u662f\u4e24\u4e2a\u76f8\u540c\u7684\u5206\u5272\uff0c\u56e0\u6b64\uff0c 0.999...=t=1 $$ Orz","title":"\u6234\u5fb7\u91d1\u5206\u5272\uff08Dedekind\uff09"},{"location":"my%20past/OI/01%E5%BA%8F%E5%88%97/","text":"\u5c06\u590d\u6742\u5e8f\u5217\u95ee\u9898\u8f6c\u6362\u621001\u5e8f\u5217\u6c42\u89e3\u7684\u4f18\u5316 \u6709\u4e9b\u9898\u770b\u4f3c\u590d\u6742\uff0c\u5b9e\u9645\u4e0a\u53ef\u4ee5\u7b80\u5316\u4e3a01\u5e8f\u5217\u8fd9\u79cd\u7b80\u5355\u7684\u5f62\u5f0f\uff0c\u6b64\u65f6\u89e3\u51b301\u5e8f\u5217\u5341\u5206\u7b80\u5355\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u5c06\u8be5\u95ee\u9898\u541101\u5e8f\u5217\u8f6c\u5316\u3002 \u4f8b\u9898\uff1aP1627,SP2713_GGS4\uff0cP2824","title":"\u5c06\u590d\u6742\u5e8f\u5217\u95ee\u9898\u8f6c\u6362\u621001\u5e8f\u5217\u6c42\u89e3\u7684\u4f18\u5316"},{"location":"my%20past/OI/01%E5%BA%8F%E5%88%97/#01","text":"\u6709\u4e9b\u9898\u770b\u4f3c\u590d\u6742\uff0c\u5b9e\u9645\u4e0a\u53ef\u4ee5\u7b80\u5316\u4e3a01\u5e8f\u5217\u8fd9\u79cd\u7b80\u5355\u7684\u5f62\u5f0f\uff0c\u6b64\u65f6\u89e3\u51b301\u5e8f\u5217\u5341\u5206\u7b80\u5355\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u5c06\u8be5\u95ee\u9898\u541101\u5e8f\u5217\u8f6c\u5316\u3002 \u4f8b\u9898\uff1aP1627,SP2713_GGS4\uff0cP2824","title":"\u5c06\u590d\u6742\u5e8f\u5217\u95ee\u9898\u8f6c\u6362\u621001\u5e8f\u5217\u6c42\u89e3\u7684\u4f18\u5316"},{"location":"my%20past/OI/2022%E6%95%B0%E8%81%94%E6%B8%B8%E8%AE%B0/","text":"2022\u6570\u8054\u6e38\u8bb0 \u5c45\u7136\u8981\u6c4224\u5c0f\u65f6\u5185\u6838\u9178\uff0c\u4f46\u6211\u4e0b\u53485\uff1a30\u624d\u505a\u5b8c\u6838\u9178\uff0c\u5bfc\u81f4\u524d\u4e00\u5929\u665a\u4e0a\u4e00\u76f4\u5fd0\u5fd1\u4f1a\u4e0d\u4f1a\u51fa\u4e0d\u4e86\u6838\u9178\u7ed3\u679c\u91cd\u8e48\u4e0a\u4e00\u6b21\u7684\u8986\u8f99(~~\u4e0a\u6b21\u662f\u54ea\u4e2aSB\u8003TACA\u6ca1\u670972\u5c0f\u65f6\u6838\u9178\u5bfc\u81f4\u4e00\u79d1\u90fd\u6ca1\u8003\uff0c\u6211\u4e0d\u8bf4~~)\uff0c\u6253\u7403\u90fd\u6ca1\u6253\u75db\u5feb\uff0c\u54ed \u8003\u8bd5\u524d\u7b2c\u4e00\u4e2a\u5230\u8003\u573a\uff0c\u7ed3\u679c\u7ad9\u5728\u8003\u573a\u5916\u9762\u5199\u4e86\u628a\u534a\u4e2a\u5c0f\u65f6\u4f18\u5316\u63a2\u7a76\uff0c\u4e50 \u5934\u4e00\u6b21\u542c\u89c1\u5e7f\u64ad\u6ce8\u610f\u4e8b\u9879\u8fd8TM\u5e26\u8bed\u6c14\u8bcd\u7684\uff0c\u7b11 \u867d\u7136\u60f3\u7740\u57fa\u7840\u586b\u7a7a\u4e0d\u80fd\u51fa\u9519\uff0c\u7ed3\u679c\u8fd8\u662f\u6709\u9053\u7acb\u4f53\u51e0\u4f55\u5c11\u7b97\u4e86\u4e00\u79cd\u60c5\u51b5\uff0c\u60b2 \u7ed3\u679c\u6700\u540e\u4e00\u9053\u586b\u7a7a\u8fd8\u662f\u7b97\u9519\u4e86\u3002\u4e8b\u5b9e\u8bc1\u660e\uff0c\u5982\u679c\u8003\u573a\u4e0a\u7ed9\u6211\u4e00\u53f0\u5e26DEV C++\u7684\u7535\u8111\uff0c\u8fd9\u9898\u5c31\u79d2\u4e86\uff0c\u6de6","title":"2022\u6570\u8054\u6e38\u8bb0"},{"location":"my%20past/OI/2022%E6%95%B0%E8%81%94%E6%B8%B8%E8%AE%B0/#2022","text":"\u5c45\u7136\u8981\u6c4224\u5c0f\u65f6\u5185\u6838\u9178\uff0c\u4f46\u6211\u4e0b\u53485\uff1a30\u624d\u505a\u5b8c\u6838\u9178\uff0c\u5bfc\u81f4\u524d\u4e00\u5929\u665a\u4e0a\u4e00\u76f4\u5fd0\u5fd1\u4f1a\u4e0d\u4f1a\u51fa\u4e0d\u4e86\u6838\u9178\u7ed3\u679c\u91cd\u8e48\u4e0a\u4e00\u6b21\u7684\u8986\u8f99(~~\u4e0a\u6b21\u662f\u54ea\u4e2aSB\u8003TACA\u6ca1\u670972\u5c0f\u65f6\u6838\u9178\u5bfc\u81f4\u4e00\u79d1\u90fd\u6ca1\u8003\uff0c\u6211\u4e0d\u8bf4~~)\uff0c\u6253\u7403\u90fd\u6ca1\u6253\u75db\u5feb\uff0c\u54ed \u8003\u8bd5\u524d\u7b2c\u4e00\u4e2a\u5230\u8003\u573a\uff0c\u7ed3\u679c\u7ad9\u5728\u8003\u573a\u5916\u9762\u5199\u4e86\u628a\u534a\u4e2a\u5c0f\u65f6\u4f18\u5316\u63a2\u7a76\uff0c\u4e50 \u5934\u4e00\u6b21\u542c\u89c1\u5e7f\u64ad\u6ce8\u610f\u4e8b\u9879\u8fd8TM\u5e26\u8bed\u6c14\u8bcd\u7684\uff0c\u7b11 \u867d\u7136\u60f3\u7740\u57fa\u7840\u586b\u7a7a\u4e0d\u80fd\u51fa\u9519\uff0c\u7ed3\u679c\u8fd8\u662f\u6709\u9053\u7acb\u4f53\u51e0\u4f55\u5c11\u7b97\u4e86\u4e00\u79cd\u60c5\u51b5\uff0c\u60b2 \u7ed3\u679c\u6700\u540e\u4e00\u9053\u586b\u7a7a\u8fd8\u662f\u7b97\u9519\u4e86\u3002\u4e8b\u5b9e\u8bc1\u660e\uff0c\u5982\u679c\u8003\u573a\u4e0a\u7ed9\u6211\u4e00\u53f0\u5e26DEV C++\u7684\u7535\u8111\uff0c\u8fd9\u9898\u5c31\u79d2\u4e86\uff0c\u6de6","title":"2022\u6570\u8054\u6e38\u8bb0"},{"location":"my%20past/OI/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","text":"AC\u81ea\u52a8\u673a \u6ce8\u610f:\u4e3a\u4ec0\u4e48\u5728get_fail\u4e2d\u8981\u5c06\u4e0d\u5b58\u5728\u7684\u513f\u5b50\u6307\u5411fail\u6307\u9488\u5bf9\u5e94\u7684\u513f\u5b50\uff1f\u56e0\u4e3a\u8fd9\u6837\u5904\u7406\uff0c\u7531\u4e8ebfs\u4ece\u4e0a\u5230\u4e0b\uff0c\u6240\u4ee5\u8fd9\u4e9b\u513f\u5b50\u7684\u66f4\u65b0\u4e5f\u662f\u4ece\u4e0a\u5230\u4e0b\uff0c\u53ef\u4ee5\u76f4\u63a5\u6307\u5230\u7b2c\u4e00\u4e2a\u5b58\u5728\u7684fail\u4e0a\uff0c\u800c\u4e0d\u9700\u8981\u5faa\u73af\u67e5\u627e\uff0c\u907f\u514d\u8d85\u65f6\u3002","title":"AC\u81ea\u52a8\u673a"},{"location":"my%20past/OI/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/#ac","text":"\u6ce8\u610f:\u4e3a\u4ec0\u4e48\u5728get_fail\u4e2d\u8981\u5c06\u4e0d\u5b58\u5728\u7684\u513f\u5b50\u6307\u5411fail\u6307\u9488\u5bf9\u5e94\u7684\u513f\u5b50\uff1f\u56e0\u4e3a\u8fd9\u6837\u5904\u7406\uff0c\u7531\u4e8ebfs\u4ece\u4e0a\u5230\u4e0b\uff0c\u6240\u4ee5\u8fd9\u4e9b\u513f\u5b50\u7684\u66f4\u65b0\u4e5f\u662f\u4ece\u4e0a\u5230\u4e0b\uff0c\u53ef\u4ee5\u76f4\u63a5\u6307\u5230\u7b2c\u4e00\u4e2a\u5b58\u5728\u7684fail\u4e0a\uff0c\u800c\u4e0d\u9700\u8981\u5faa\u73af\u67e5\u627e\uff0c\u907f\u514d\u8d85\u65f6\u3002","title":"AC\u81ea\u52a8\u673a"},{"location":"my%20past/OI/CF1896D/","text":"CF1896D \u63d0\u4f9b\u4e00\u79cd ~~\u5de8\u9ebb\u70e6~~ \u7684 bitset \u505a\u6cd5\u3002 \u5bf9\u4e8e\u4e00\u4e2a\u4e32\uff0c\u6211\u4eec\u5199\u4e00\u4e2a\u524d\u7f00\u548c\uff0c\u7528\u6811\u72b6\u6570\u7ec4\u52a8\u6001\u7ef4\u62a4\uff0c\u5219\u4f4d\u7f6e $1\\leq i < j \\leq n$ \u5bf9\u5e94\u5b50\u4e32\u7684\u548c\u53ef\u4ee5\u8868\u793a\u6210 $s_j-s_{i-1}$ \uff0c\u539f\u9898\u5c31\u662f\u6c42 $s_j-s_{i-1}=s$ \u662f\u5426\u53ef\u4ee5\u6ee1\u8db3\u3002 \u53d7 \u8fd9\u9053\u9898 \u7684\u542f\u53d1\uff0c\u8fd9\u9053\u9898\u91cc\u6211\u4eec\u53ef\u4ee5\u7528 bitset \u7ef4\u62a4\u8fd9\u4e2a\u524d\u7f00\u548c\u6570\u7ec4\uff0c\u5bf9\u4e8e\u4e00\u4e2a bitset<N> f \uff0c\u901a\u8fc7\u4f4d\u8fd0\u7b97\u5224\u65ad f&(f>>s) \uff0c\u82e5\u7ed3\u679c\u4e0d\u4e3a\u96f6\uff0c\u5219\u8bf4\u660e\u5b58\u5728\u8fd9\u6837\u7684\u5b50\u4e32\u3002 \u5bf9\u4e8e\u4fee\u6539\uff0c\u6211\u4eec\u53d1\u73b0\uff0c\u6bcf\u6b21\u4fee\u6539\u5bf9\u4e8e bitset \u4e2d $s_j-1$ \u4f4d\u7f6e\u4e4b\u524d\u7684\u4f4d\u65e0\u5f71\u54cd\uff0c\u5bf9\u4e8e $s_j$ \u4e4b\u540e\u7684\u4f4d\u7f6e\uff0c\u53f3\u79fb\u6216\u5de6\u79fb\u4e00\u4f4d\u5373\u53ef\u3002 \u6211\u4eec\u6784\u9020\u4e24\u4e2a bitset \u4e32\uff0c\u4e00\u4e2a\u4e32\u6ee1\u8db3\u524d $s_j-1$ \u4f4d\u90fd\u4e3a $1$ \uff0c\u53e6\u4e00\u4e2a\u4e32\u4e3a\u524d\u4e00\u4e2a\u4e32\u6309\u4f4d\u53d6\u53cd\u3002\u5c06\u539f\u4e32\u4e0e\u8fd9\u4e24\u4e2a\u4e32\u5206\u522b\u4e0e\u4e00\u4e0b\uff0c\u540e\u4e00\u4e2a\u4e32\u5de6/\u53f3\u79fb\u4e00\u4f4d\uff0c\u518d\u6216\u5728\u4e00\u8d77\uff0c\u5c31\u5b8c\u6210\u4e86\u4fee\u6539\u3002 \u73b0\u5728\u7684\u95ee\u9898\u5728\u4e8e\uff0c\u5982\u4f55\u5feb\u901f\u6784\u9020\u8fd9\u6837\u7684\u4e24\u4e2a\u4e32\u3002 \u66b4\u529b\u4e0d\u884c\uff0c\u6211\u4eec\u5c31\u7528\u7a7a\u95f4\u6362\u65f6\u95f4\u3002\u6211\u4eec\u91c7\u53d6\u5206\u5757\u7684\u601d\u60f3\uff0c\u8bbe\u5757\u957f\u4e3a $k$ \uff0c\u6784\u9020 $\\frac N k$ \u4e2a\u4e32\uff0c\u6bcf\u4e2a\u4e32\u4f9d\u6b21\u589e\u52a0 $k$ \u4e2a $1$\u3002\u6bcf\u6b21\u6839\u636e $s_j$ \u66b4\u529b\u4fee\u6539\u79bb\u4ed6\u6700\u201c\u8fd1\u201d\u7684\u4e32\uff0c\u5c31\u53ef\u4ee5\u5728 $O(k)$ \u7684\u65f6\u95f4\u5185\u6784\u9020\u51fa\u6211\u4eec\u8981\u7684\u4e32\u3002 \u534f\u8c03\u4e00\u4e0b\u65f6\u95f4\u7a7a\u95f4\uff0c\u53d6 $k=N^{\\frac 13}$ \uff0c\u518d\u7a0d\u7a0d\u5361\u5e38\u5c31\u53ef\u4ee5\u901a\u8fc7\u672c\u9898\u4e86\u3002 #pragma GCC optimize(2) #include<iostream> #include<bitset> #include<cmath> using namespace std; const int N=2e5+10,K=4e3; int T,n,q,len; bitset<N> s[K]; bitset<N> f,tmp,ttmp,g,h; int k[N],a[N],t[N]; int read1() { int x=0; char ch=getchar(); while(ch>'9' || ch<'0') ch=getchar(); while(ch<='9' && ch>='0') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x) { if(x>9) write1(x/10); putchar(x%10+'0'); } int lowbit(int x){ return x&(-x); } void change(int x,int d){ while(x<=n) t[x]+=d,x+=lowbit(x); } int sum(int x){ int ans=0; while(x>0) ans+=t[x],x-=lowbit(x); return ans; } void init() { s[0].set(0); len=pow(N,0.33); for(int i=1; i<N; ++i) k[i]=(i-1)/len+1; for(int i=1; i<=k[N-1]; ++i) { s[i]=s[i-1]; for(int j=(i-1)*len+1; j<=min(i*len,N-1); ++j) s[i].set(j); } } void solve() { n=read1(),q=read1(); f=s[0]; int ssum=0; for(int i=1;i<=n+n;++i) t[i]=0; for(int i=1; i<=n; ++i) { a[i]=read1(); ssum+=a[i]; f.set(ssum); change(i,a[i]); } for(int i=1,op,j,v; i<=q; ++i) { op=read1(); if(op==1) { j=read1(); if((f&(f>>j)).any()) putchar('Y'),putchar('E'),putchar('S'),putchar('\\n'); else putchar('N'),putchar('O'),putchar('\\n'); } else { j=read1(),v=read1(); if(v==a[j]) continue; int sumj=sum(j); int tmpk=k[sumj-1]; tmp=s[tmpk]; for(int t=min(N-1,tmpk*len); t>=sumj; --t) tmp.reset(t); ttmp=tmp; ttmp.flip(); g=tmp&f,h=ttmp&f; if(v-a[j]==1) f=(g)|(h<<1); else f=(g)|(h>>1); change(j,v-a[j]); a[j]=v; } } } int main() { T=read1(); init(); while(T--) solve(); return 0; }","title":"CF1896D"},{"location":"my%20past/OI/CRT/","text":"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406 \u7528\u6765\u6c42\u89e3\u8fd9\u6837\u7684\u65b9\u7a0b\u7ec4\uff1a $$ \\left { \\begin{aligned} x\\equiv a_1 \\pmod {m_1}\\ x\\equiv a_2 \\pmod {m_2}\\ ...\\ x\\equiv a_k \\pmod {m_k} \\end{aligned} \\right. $$ \u6240\u6709$m$\u4e92\u8d28\u3002 \u505a\u6cd5 \u5b9a\u4e49$M=\\prod_{i=1}^k m_i,M_i=\\frac M {m_i}$,\u5219 $\\gcd(M_i,m_i)=1$,\u56e0\u4e3a\u6240\u6709\u7684$m$\u90fd\u4e92\u8d28\u3002 \u6b64\u65f6\uff0c\u5b9a\u4e49$M_it_i\\equiv 1\\pmod {m_i},t_i=M_i^{-1}\\pmod {m_i}$ $t_i$\u53ef\u4ee5\u7528\u6269\u6b27\u6c42\u51fa\u3002 \u6240\u4ee5\uff1a$a_iM_it_i\\equiv a_i\\pmod{m_i}$ \u53c8\u56e0\u4e3a\u5bf9\u4e8e$i\\not = j,M_i=km_j$,\u6240\u4ee5$a_iM_it_i\\equiv 0\\pmod {m_j}$ \u56e0\u6b64\u53ef\u884c\u89e3\u4e3a$\\sum_{i=1}^ka_iM_it_i$ P1495 \u6a21\u677f\u9898\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e4+10; int n,M,_M,g,x,y,t,ans; int a[N],m[N]; void exgcd(int a,int b,int &d,int &x,int &y); signed main(){ M=1;scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld%lld\",&m[i],&a[i]),M*=m[i]; for(int i=1;i<=n;++i){ _M=M/m[i]; exgcd(_M,m[i],g,x,y); t=x; ans=(ans+t*_M*a[i])%M; } printf(\"%lld\",(ans+M)%M); return 0; } void exgcd(int a,int b,int &d,int &x,int &y){ if(!b)d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x; } P8178 \u975e\u5e38\u5999\u7684\u4e00\u9053\u9898\uff0c\u867d\u7136\u505a\u6cd5\u4e2d\u6ca1\u6709$CRT$\uff0c\u4f46\u662f\u6709\u4e00\u6761\u91cd\u8981\u6027\u8d28\u3002 \u9996\u5148\u9898\u610f\u53ef\u4ee5\u8f6c\u5316\u4e3a$A_if_0+B_i\\equiv 0\\pmod {p_i}$. \u5b9a\u4e49$A_i=\\prod_{i=1}^ka_i,B_i=\\sum_{i=1}^k(\\prod_{j=i+1}^ka_j)b_i$ \u5219\u6709$A_i=a_iA_{i-1},B_i=a_iB_{i-1}+b_i$ \u5219\u4ee4$B=B_i\\mod p_i,A=A_i\\mod p_i$ \u8fd9\u6837\uff0c\u5176\u4e2d\u4e00\u4e2a\u65b9\u7a0b\u7684\u89e3\u53ef\u4ee5\u8868\u793a\u4e3a$f_0=(p_i-B) A^{-1}\\mod p_i$ (1) * \uff0c$A^{-1}$\u4e3a\u9006\u5143\u3002 \u4f46\u662f\uff0c\u8fd9\u6837\u7684\u8bdd\uff0c\u6bcf\u4e2a\u65b9\u7a0b\u90fd\u53ef\u80fd\u6709\u4e00\u4e2a\u4e0d\u540c\u7684\u89e3\uff0c\u600e\u4e48\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u5408\u5e76\u4e3a\u4e00\u4e2a\u89e3\u5462\uff1f \u7b54\u6848\u662f\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff0c\u5bf9\u4e8e$x_i\\not = x_j$\u4e14$p_i=p_j$\u65f6\u65e0\u89e3\uff0c\u56e0\u6b64\u53ea\u8981\u4e0d\u5b58\u5728\u8fd9\u79cd\u60c5\u51b5\u90fd\u6709\u89e3\u3002 \u5177\u4f53\u5730\uff0c\u7531 (1) \u53ef\u77e5\uff0c\u4efb\u4f55\u65b9\u7a0b\u53ef\u4ee5\u8868\u793a\u4e3a$f_0\\equiv (p_i-B)* A^{-1} \\pmod {p_i}\\to x\\equiv a_i\\pmod{m_i}$,\u56e0\u6b64\u53ef\u4ee5\u7528$CRT$\u6c42\u89e3\u3002 \u6ce8\u610f\u7279\u5224$A=0$. #include<iostream> #include<cstdio> #include<cstring> #include<map> #define int long long using namespace std; const int N=2e3+10; int T,k,_A,_B,A,B; int a[N],b[N],p[N],vis[N]; map<int,int> M; int kp(int x,int p,int P){ if(p==0)return 1; if(p==1)return x; if(p&1)return x*kp(x*x%P,p>>1,P)%P; else return kp(x*x%P,p>>1,P)%P; } signed main(){ scanf(\"%lld\",&T); while(T--){ bool flag=true;memset(vis,0,sizeof vis); M.clear(); scanf(\"%lld\",&k); for(int i=1;i<=k;++i)scanf(\"%lld\",&a[i]); for(int i=1;i<=k;++i)scanf(\"%lld\",&b[i]); for(int i=1;i<=k;++i)scanf(\"%lld\",&p[i]); for(int i=1;i<=k;++i){ A=1,B=0; for(int j=1;j<=i;++j) A=(A*a[j])%p[i],B=(B*a[j]%p[i]+b[j])%p[i]; if(A==0 && B!=0){flag=false;break;} if(A==0 && B==0)continue; int tmp=(p[i]-B)*kp(A,p[i]-2,p[i])%p[i]; if(M.find(p[i])==M.end())M[p[i]]=tmp; else if(M[p[i]]!=tmp){flag=false;break;} } if(flag)printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0; }","title":"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406"},{"location":"my%20past/OI/CRT/#_1","text":"\u7528\u6765\u6c42\u89e3\u8fd9\u6837\u7684\u65b9\u7a0b\u7ec4\uff1a $$ \\left { \\begin{aligned} x\\equiv a_1 \\pmod {m_1}\\ x\\equiv a_2 \\pmod {m_2}\\ ...\\ x\\equiv a_k \\pmod {m_k} \\end{aligned} \\right. $$ \u6240\u6709$m$\u4e92\u8d28\u3002","title":"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406"},{"location":"my%20past/OI/CRT/#_2","text":"\u5b9a\u4e49$M=\\prod_{i=1}^k m_i,M_i=\\frac M {m_i}$,\u5219 $\\gcd(M_i,m_i)=1$,\u56e0\u4e3a\u6240\u6709\u7684$m$\u90fd\u4e92\u8d28\u3002 \u6b64\u65f6\uff0c\u5b9a\u4e49$M_it_i\\equiv 1\\pmod {m_i},t_i=M_i^{-1}\\pmod {m_i}$ $t_i$\u53ef\u4ee5\u7528\u6269\u6b27\u6c42\u51fa\u3002 \u6240\u4ee5\uff1a$a_iM_it_i\\equiv a_i\\pmod{m_i}$ \u53c8\u56e0\u4e3a\u5bf9\u4e8e$i\\not = j,M_i=km_j$,\u6240\u4ee5$a_iM_it_i\\equiv 0\\pmod {m_j}$ \u56e0\u6b64\u53ef\u884c\u89e3\u4e3a$\\sum_{i=1}^ka_iM_it_i$ P1495 \u6a21\u677f\u9898\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e4+10; int n,M,_M,g,x,y,t,ans; int a[N],m[N]; void exgcd(int a,int b,int &d,int &x,int &y); signed main(){ M=1;scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld%lld\",&m[i],&a[i]),M*=m[i]; for(int i=1;i<=n;++i){ _M=M/m[i]; exgcd(_M,m[i],g,x,y); t=x; ans=(ans+t*_M*a[i])%M; } printf(\"%lld\",(ans+M)%M); return 0; } void exgcd(int a,int b,int &d,int &x,int &y){ if(!b)d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x; } P8178 \u975e\u5e38\u5999\u7684\u4e00\u9053\u9898\uff0c\u867d\u7136\u505a\u6cd5\u4e2d\u6ca1\u6709$CRT$\uff0c\u4f46\u662f\u6709\u4e00\u6761\u91cd\u8981\u6027\u8d28\u3002 \u9996\u5148\u9898\u610f\u53ef\u4ee5\u8f6c\u5316\u4e3a$A_if_0+B_i\\equiv 0\\pmod {p_i}$. \u5b9a\u4e49$A_i=\\prod_{i=1}^ka_i,B_i=\\sum_{i=1}^k(\\prod_{j=i+1}^ka_j)b_i$ \u5219\u6709$A_i=a_iA_{i-1},B_i=a_iB_{i-1}+b_i$ \u5219\u4ee4$B=B_i\\mod p_i,A=A_i\\mod p_i$ \u8fd9\u6837\uff0c\u5176\u4e2d\u4e00\u4e2a\u65b9\u7a0b\u7684\u89e3\u53ef\u4ee5\u8868\u793a\u4e3a$f_0=(p_i-B) A^{-1}\\mod p_i$ (1) * \uff0c$A^{-1}$\u4e3a\u9006\u5143\u3002 \u4f46\u662f\uff0c\u8fd9\u6837\u7684\u8bdd\uff0c\u6bcf\u4e2a\u65b9\u7a0b\u90fd\u53ef\u80fd\u6709\u4e00\u4e2a\u4e0d\u540c\u7684\u89e3\uff0c\u600e\u4e48\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u5408\u5e76\u4e3a\u4e00\u4e2a\u89e3\u5462\uff1f \u7b54\u6848\u662f\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406\uff0c\u5bf9\u4e8e$x_i\\not = x_j$\u4e14$p_i=p_j$\u65f6\u65e0\u89e3\uff0c\u56e0\u6b64\u53ea\u8981\u4e0d\u5b58\u5728\u8fd9\u79cd\u60c5\u51b5\u90fd\u6709\u89e3\u3002 \u5177\u4f53\u5730\uff0c\u7531 (1) \u53ef\u77e5\uff0c\u4efb\u4f55\u65b9\u7a0b\u53ef\u4ee5\u8868\u793a\u4e3a$f_0\\equiv (p_i-B)* A^{-1} \\pmod {p_i}\\to x\\equiv a_i\\pmod{m_i}$,\u56e0\u6b64\u53ef\u4ee5\u7528$CRT$\u6c42\u89e3\u3002 \u6ce8\u610f\u7279\u5224$A=0$. #include<iostream> #include<cstdio> #include<cstring> #include<map> #define int long long using namespace std; const int N=2e3+10; int T,k,_A,_B,A,B; int a[N],b[N],p[N],vis[N]; map<int,int> M; int kp(int x,int p,int P){ if(p==0)return 1; if(p==1)return x; if(p&1)return x*kp(x*x%P,p>>1,P)%P; else return kp(x*x%P,p>>1,P)%P; } signed main(){ scanf(\"%lld\",&T); while(T--){ bool flag=true;memset(vis,0,sizeof vis); M.clear(); scanf(\"%lld\",&k); for(int i=1;i<=k;++i)scanf(\"%lld\",&a[i]); for(int i=1;i<=k;++i)scanf(\"%lld\",&b[i]); for(int i=1;i<=k;++i)scanf(\"%lld\",&p[i]); for(int i=1;i<=k;++i){ A=1,B=0; for(int j=1;j<=i;++j) A=(A*a[j])%p[i],B=(B*a[j]%p[i]+b[j])%p[i]; if(A==0 && B!=0){flag=false;break;} if(A==0 && B==0)continue; int tmp=(p[i]-B)*kp(A,p[i]-2,p[i])%p[i]; if(M.find(p[i])==M.end())M[p[i]]=tmp; else if(M[p[i]]!=tmp){flag=false;break;} } if(flag)printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0; }","title":"\u505a\u6cd5"},{"location":"my%20past/OI/CSP-S%202021/","text":"CSP-S 2021 P7913 \u5eca\u6865\u5206\u914d \u5e76\u67e5\u96c6+\u8d2a\u5fc3 \u5c06\u4e24\u7ec4\u6570\u636e\u6309\u8fdb\u5165\u673a\u573a\u7684\u65f6\u95f4\u6392\u5e8f\uff0c\u6bcf\u6b21\u9009\u6700\u5c0f\u4e14\u6ca1\u6709\u8bbf\u95ee\u8fc7\u7684\u822a\u73ed\uff0c\u5e76\u4e14\u901a\u8fc7lower_bound\u6c42\u51fa\u6574\u4e2a\u4e00\u6761\u94fe\uff0c\u5c06\u4ed6\u4eec\u90fd\u6253\u4e0a\u6807\u8bb0\u3002\u4e4b\u540e\u5c06\u6240\u6709\u94fe\u4e0a\u7684\u70b9\u5e76\u5728\u4e00\u8d77\u3002 \u590d\u6742\u5ea6$\\Theta (nlogn+k),k=1-n^2$,k\u662f\u5c06\u5df2\u7ecf\u641c\u8fc7\u7684\u70b9\u8df3\u8fc7\u7684\u641c\u7d22\u6b21\u6570\uff0c~~\u4e8b\u5b9e\u8bc1\u660eCCF\u7684\u6570\u636e\u662f\u771f\u7684\u6c34~~ ~~\u8fd9\u4e0d\u662f\u8bf4\u660e\u6211rp\u597d\u5417~~ P7915 \u56de\u6587 1.40pts (\u66b4\u529b)dfs+\u526a\u679d \u526a\u679d\u662f\u6307\u5728\u641c\u5230n+1~2n\u4e2a\u6570\u65f6\uff0c\u4e0e\u524d\u9762\u7684\u5e8f\u5217\u5224\u65ad\u662f\u5426\u56de\u6587\uff0c\u4e0d\u5408\u6cd5\u76f4\u63a5\u56de\u6eaf\uff1b\u5e76\u4e14\u56e0\u4e3a\u65f6\u6309\u7167\u5148\u5de6\u540e\u53f3\u7684\u987a\u5e8f\u641c\u7d22\uff0c\u6240\u4ee5\u7b2c\u4e00\u6b21\u641c\u5230\u7684\u4e00\u5b9a\u662f\u5de6\u53f3\u7686\uff0c\u540e\u9762\u7684\u90fd\u4e0d\u7528\u641c\uff0c\u7a0b\u5e8f\u76f4\u63a5\u7ed3\u675f\u3002 \u5bf9\u4e8en<=20\u5b8c\u5168ok \u5bf9\u4e8en<=100\u770brp ~~CCF\u6570\u636e\u592a\u5783\u573e\uff0c20min\u6c34\u8fc740pts~~ ~~\u8fd9\u4e0d\u662f\u8bf4\u660e\u6211rp\u633a\u597d\u5417 :)~~ 2.100pts \u6211\u4eec\u53d1\u73b0\u5bf9\u4e8e\u6bcf\u4e2a\u4e2d\u95f4\u5f62\u6001\uff0c\u5373\u5b50\u5e8f\u5217\uff0c\u5b83\u80fd\u62d3\u5c55\u7684\u70b9\u53ea\u6709\u5e8f\u5217\u5de6\u8fb9\u548c\u53f3\u8fb9\u4e00\u4e2a\uff0c\u56e0\u6b64\u67094\u4e2a\u6307\u9488\uff0c\u4e3a\u5e8f\u5217\u5de6\u53f3\u7684\u5f85\u53d6\u6307\u9488\u548c\u5b50\u5e8f\u5217\u7684\u5de6\u53f3\u6307\u9488\u3002\u6b64\u65f6\u5de6\u8fb9\u4e0d\u884c\u53d6\u53f3\u8fb9\uff0c\u53f3\u8fb9\u4e0d\u884c\u53d6\u5de6\u8fb9\uff0c\u90fd\u4e0d\u884c-1\uff0c\u90fd\u884c\u5c31\u53d6\u5de6\u8fb9\u3002 \u6ce8\u610f\u5224\u65ad\u6307\u9488\u662f\u5426\u91cd\u5408\u3002","title":"CSP-S 2021"},{"location":"my%20past/OI/CSP-S%202021/#csp-s-2021","text":"P7913 \u5eca\u6865\u5206\u914d \u5e76\u67e5\u96c6+\u8d2a\u5fc3 \u5c06\u4e24\u7ec4\u6570\u636e\u6309\u8fdb\u5165\u673a\u573a\u7684\u65f6\u95f4\u6392\u5e8f\uff0c\u6bcf\u6b21\u9009\u6700\u5c0f\u4e14\u6ca1\u6709\u8bbf\u95ee\u8fc7\u7684\u822a\u73ed\uff0c\u5e76\u4e14\u901a\u8fc7lower_bound\u6c42\u51fa\u6574\u4e2a\u4e00\u6761\u94fe\uff0c\u5c06\u4ed6\u4eec\u90fd\u6253\u4e0a\u6807\u8bb0\u3002\u4e4b\u540e\u5c06\u6240\u6709\u94fe\u4e0a\u7684\u70b9\u5e76\u5728\u4e00\u8d77\u3002 \u590d\u6742\u5ea6$\\Theta (nlogn+k),k=1-n^2$,k\u662f\u5c06\u5df2\u7ecf\u641c\u8fc7\u7684\u70b9\u8df3\u8fc7\u7684\u641c\u7d22\u6b21\u6570\uff0c~~\u4e8b\u5b9e\u8bc1\u660eCCF\u7684\u6570\u636e\u662f\u771f\u7684\u6c34~~ ~~\u8fd9\u4e0d\u662f\u8bf4\u660e\u6211rp\u597d\u5417~~ P7915 \u56de\u6587 1.40pts (\u66b4\u529b)dfs+\u526a\u679d \u526a\u679d\u662f\u6307\u5728\u641c\u5230n+1~2n\u4e2a\u6570\u65f6\uff0c\u4e0e\u524d\u9762\u7684\u5e8f\u5217\u5224\u65ad\u662f\u5426\u56de\u6587\uff0c\u4e0d\u5408\u6cd5\u76f4\u63a5\u56de\u6eaf\uff1b\u5e76\u4e14\u56e0\u4e3a\u65f6\u6309\u7167\u5148\u5de6\u540e\u53f3\u7684\u987a\u5e8f\u641c\u7d22\uff0c\u6240\u4ee5\u7b2c\u4e00\u6b21\u641c\u5230\u7684\u4e00\u5b9a\u662f\u5de6\u53f3\u7686\uff0c\u540e\u9762\u7684\u90fd\u4e0d\u7528\u641c\uff0c\u7a0b\u5e8f\u76f4\u63a5\u7ed3\u675f\u3002 \u5bf9\u4e8en<=20\u5b8c\u5168ok \u5bf9\u4e8en<=100\u770brp ~~CCF\u6570\u636e\u592a\u5783\u573e\uff0c20min\u6c34\u8fc740pts~~ ~~\u8fd9\u4e0d\u662f\u8bf4\u660e\u6211rp\u633a\u597d\u5417 :)~~ 2.100pts \u6211\u4eec\u53d1\u73b0\u5bf9\u4e8e\u6bcf\u4e2a\u4e2d\u95f4\u5f62\u6001\uff0c\u5373\u5b50\u5e8f\u5217\uff0c\u5b83\u80fd\u62d3\u5c55\u7684\u70b9\u53ea\u6709\u5e8f\u5217\u5de6\u8fb9\u548c\u53f3\u8fb9\u4e00\u4e2a\uff0c\u56e0\u6b64\u67094\u4e2a\u6307\u9488\uff0c\u4e3a\u5e8f\u5217\u5de6\u53f3\u7684\u5f85\u53d6\u6307\u9488\u548c\u5b50\u5e8f\u5217\u7684\u5de6\u53f3\u6307\u9488\u3002\u6b64\u65f6\u5de6\u8fb9\u4e0d\u884c\u53d6\u53f3\u8fb9\uff0c\u53f3\u8fb9\u4e0d\u884c\u53d6\u5de6\u8fb9\uff0c\u90fd\u4e0d\u884c-1\uff0c\u90fd\u884c\u5c31\u53d6\u5de6\u8fb9\u3002 \u6ce8\u610f\u5224\u65ad\u6307\u9488\u662f\u5426\u91cd\u5408\u3002","title":"CSP-S 2021"},{"location":"my%20past/OI/DLX/","text":"Dancing Links X \u5e94\u7528\uff1a\u89e3\u51b3\u7cbe\u786e\u8986\u76d6\u95ee\u9898\u3002 \u4f8b\u5982\u6570\u72ec\uff0ck\u7687\u540e\u7b49\u6d89\u53ca\u540c\u4e00\u4e2a\u6570\u5728\u4e00\u5b9a\u8303\u56f4\u5185\u503c\u51fa\u73b0\u4e00\u6b21\u7684\u95ee\u9898\u53ef\u4ee5\u7528DLX\u89e3\u51b3\u3002 \u6a21\u677f P4929 \u6ce8\u610f\uff1a 1.\u6bcf\u6b21\u5220\u9664\u548c\u6062\u590d\u7684\u90fd\u662f\u8868\u5934\u4e0b\u9762\u7684\u4e00\u6574\u5217\u4ee5\u53ca\u542b\u67091\u7684\u4e00\u6574\u884c\uff0c\u800c\u6574\u4e2a\u8fc7\u7a0b\u4e2d\u66f4\u6539\u7684\u53ea\u6709\u8868\u5934\u5de6\u53f3\u6307\u9488\u548c\u4e0d\u662f\u8868\u5934\u90a3\u5217\u76841\u7684\u4e0a\u4e0b\u6307\u9488 \uff08\u56e0\u4e3a\u6062\u590d\u8981\u4ece\u8868\u5934\u5411\u4e0b\u8bbf\u95ee\uff0c\u518d\u4ece\u884c\u5934\u5411\u53f3\u8bbf\u95ee\uff09\u3002 \u53ea\u6709\u8fd9\u6837\u624d\u80fd\u5b9e\u73b0\u8bbf\u95ee\u5230\u5df2\u5220\u9664\u76841\u3002 2.\u5341\u5b57\u94fe\u8868\u4e2d\u4e0a\u4e0b\uff0c\u5de6\u53f3\u7684\u987a\u5e8f\u65e0\u6240\u8c13\uff0c\u4f46\u5fc5\u987b\u7edf\u4e00\u3002 3.\u6ce8\u610f\u6240\u6709\u94fe\u8868\u90fd\u662f\u53cc\u5411\uff0c\u5373\u662f\u4e00\u4e2a\u73af\u3002\u5f53\u81ea\u5df1\u6307\u5411\u81ea\u5df1\u65f6\u4e3a\u7a7a\u3002 4.\u7b97\u6cd5\u5224\u5b9a\u7ed3\u679c\u9519\u8bef\u7684\u4f9d\u636e\u662f\u8868\u5934\u8fd8\u6709\u5269\u4f59\uff0c\u4f46\u5143\u7d20\u90fd\u5220\u5b8c\u4e86\uff0c\u8bf4\u660e\u4e4b\u524d\u6709\u4e24\u4e2a\u4ee5\u4e0a\u76841\u51b2\u7a81\u3002 5.\u5220\u9664\u65f6\u66f4\u6539\u4e0a\u4e0b\u5143\u7d20\u7684\u4e4b\u4e2d\u5462\u4e00\u5b9a\u6ce8\u610f\u987a\u5e8f\u3002 f[++cnt].u=C; f[cnt].d=f[C].d; f[f[C].d].u=cnt; f[C].d=cnt; f[cnt].row=R; f[cnt].col=C; 6.\u6bcf\u6b21\u9009\u75281\u4e2a\u6570\u6700\u5c0f\u7684\u5217\u5b9e\u9645\u4e5f\u662f\u526a\u679d\u4f18\u5316\uff0c\u4e3a\u4e86\u8ba9\u66f4\u591a\u76841\u5728\u5f53\u524d\u56de\u5408\u5c31\u88ab\u7b5b\u6389\uff0c\u4ee5\u51cf\u5c11\u641c\u7d22\u6b21\u6570\u3002 7.\u53bb\u9664\u5143\u7d20\u65f6\u662f\u53bb\u9664\u9664\u4e86\u8868\u5934\u5143\u7d20\u610f\u5916\u6240\u6709\u4e0b\u9762\u76841\uff0c\u548c\u9664\u4e86\u884c\u5934\u5916\u6240\u67091.\u4e3a\u4e86\u4e0b\u6b21\u4ece\u8868\u5934\uff0c\u884c\u5934\u8bbf\u95ee\u5230\u88ab\u5220\u9664\u7684\u70b9\u3002 code time: 1) \u6570\u7ec4\u7248\uff1a #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=550,M=N*N+N; int n,m,cnt; int d[M],u[M],l[M],r[M],row[M],col[M]; int s[M],h[M],ans[M]; void init(){ for(int i=0;i<=m;++i){ l[i]=i-1; r[i]=i+1; u[i]=d[i]=i; } r[m]=0; l[0]=m;//\u94fe\u8868\u5934\u5c3e\u7279\u5224 memset(h,-1,sizeof h); memset(s,0,sizeof s); cnt=m+1; } void add(int R,int C){ s[C]++; row[cnt]=R; col[cnt]=C; u[cnt]=C; d[cnt]=d[C]; u[d[C]]=cnt; d[C]=cnt;//\u6ce8\u610f\u987a\u5e8f\uff01 if(h[R]==-1){ h[R]=l[cnt]=r[cnt]=cnt; }else{ r[cnt]=h[R]; l[cnt]=l[h[R]]; r[l[h[R]]]=cnt; l[h[R]]=cnt;//\u987a\u5e8f } cnt++; } void remove(int C){ r[l[C]]=r[C],l[r[C]]=l[C]; for(int i=d[C];i!=C;i=d[i]){ for(int j=r[i];j!=i;j=r[j]){ u[d[j]]=u[j]; d[u[j]]=d[j];//\u53ea\u66f4\u6539\u4e0a\u4e0b\u6307\u9488\uff0c\u4e3a\u4e86\u4e0b\u6b21\u8fd8\u80fd\u8bbf\u95ee\u5230\u5e76\u6062\u590d s[col[j]]--; } } } void resume(int C){ for(int i=d[C];i!=C;i=d[i]){ for(int j=r[i];j!=i;j=r[j]){ u[d[j]]=j; d[u[j]]=j;//\u518d\u63a5\u56de\u6765 s[col[j]]++; } } l[r[C]]=C,r[l[C]]=C; } void print1(int tot){ for(int i=0;i<tot;++i)printf(\"%d \",ans[i]); } int dfs(int dep){ if(r[0]==0){ print1(dep); return 1;//\u4e00\u4e2a\u89e3\u5c31\u9000\u51fa } int c=r[0]; for(int i=r[0];i!=0;i=r[i]){ if(s[i]<s[c])c=i; }//\u526a\u679d\u4f18\u5316 remove(c);//\u53bb\u9664\u5f53\u524d\u8868\u5934\u4e0b\u90a3\u5217\uff08C'\uff09\u7684\u6240\u67091\uff0c\u8868\u793a\u5df2\u7ecf\u88ab\u7eb3\u5165\u9009\u62e9\u3002 for(int i=d[c];i!=c;i=d[i]){ ans[dep]=row[i];//\u9009\u62e9\u5f53\u524d\u884c\u3002 for(int j=r[i];j!=i;j=r[j])remove(col[j]);//\u53bb\u9664\u9664\u4e86C'\u4ee5\u5916\u7684\u5f53\u524d\u884c\u76841 if(dfs(dep+1))return 1; for(int j=r[i];j!=i;j=r[j])resume(col[j]); } resume(c);//\u56de\u6eaf return 0;//\u65e0\u89e3 } int read1(){ int x=0; char ch=getchar(); while(ch>'9' || ch<'0'){ ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x; } int main(){ n=read1(),m=read1(); init(); for(int i=1;i<=n;++i){ for(int j=1,tmp;j<=m;++j){ tmp=read1(); if(tmp)add(i,j); } } if(!dfs(0))printf(\"No Solution!\"); return 0; } 2) \u7ed3\u6784\u4f53\u7248\uff1a #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=550,M=N*N; int n,m,cnt; int s[M],h[M],ans[M]; struct node{ int u,d,l,r,row,col; }f[M]; void init(){ for(int i=0;i<=m;++i){ f[i].l=i-1; f[i].r=i+1; f[i].u=f[i].d=i; } f[m].r=0; f[0].l=m; cnt=m; memset(h,-1,sizeof h); memset(s,0,sizeof s); } void link(int R,int C){ s[C]++; f[++cnt].u=C; f[cnt].d=f[C].d; f[f[C].d].u=cnt; f[C].d=cnt; f[cnt].row=R; f[cnt].col=C; if(h[R]==-1){ h[R]=f[cnt].l=f[cnt].r=cnt; }else{ f[cnt].l=h[R]; f[cnt].r=f[h[R]].r; f[f[h[R]].r].l=cnt; f[h[R]].r=cnt; } } void remove(int C){ f[f[C].r].l=f[C].l,f[f[C].l].r=f[C].r; for(int i=f[C].d;i!=C;i=f[i].d){ for(int j=f[i].r;j!=i;j=f[j].r){ f[f[j].d].u=f[j].u; f[f[j].u].d=f[j].d; s[f[j].col]--; } } } void resume(int C){ for(int i=f[C].d;i!=C;i=f[i].d){ for(int j=f[i].r;j!=i;j=f[j].r){ f[f[j].d].u=j; f[f[j].u].d=j; s[f[j].col]++; } } f[f[C].l].r=C,f[f[C].r].l=C; } void print1(int tot){ for(int i=1;i<=tot;++i)printf(\"%d \",ans[i]); } int dfs(int dep){ if(f[0].r==0){ print1(dep-1); return 1; } int c=f[0].r; for(int i=f[0].r;i!=0;i=f[i].r)if(s[i]<s[c])c=i; remove(c); for(int i=f[c].d;i!=c;i=f[i].d){ ans[dep]=f[i].row; for(int j=f[i].r;j!=i;j=f[j].r)remove(f[j].col); if(dfs(dep+1))return 1; for(int j=f[i].r;j!=i;j=f[j].r)resume(f[j].col); } resume(c); return 0; } int main(){ scanf(\"%d%d\",&n,&m); init(); for(int i=1;i<=n;++i){ for(int j=1,tmp;j<=m;++j){ scanf(\"%d\",&tmp); if(tmp)link(i,j); } } if(!dfs(1))printf(\"No Solution!\"); return 0; }","title":"Dancing Links X"},{"location":"my%20past/OI/DLX/#dancing-links-x","text":"","title":"Dancing Links X"},{"location":"my%20past/OI/DLX/#_1","text":"\u4f8b\u5982\u6570\u72ec\uff0ck\u7687\u540e\u7b49\u6d89\u53ca\u540c\u4e00\u4e2a\u6570\u5728\u4e00\u5b9a\u8303\u56f4\u5185\u503c\u51fa\u73b0\u4e00\u6b21\u7684\u95ee\u9898\u53ef\u4ee5\u7528DLX\u89e3\u51b3\u3002","title":"\u5e94\u7528\uff1a\u89e3\u51b3\u7cbe\u786e\u8986\u76d6\u95ee\u9898\u3002"},{"location":"my%20past/OI/DLX/#_2","text":"P4929 \u6ce8\u610f\uff1a 1.\u6bcf\u6b21\u5220\u9664\u548c\u6062\u590d\u7684\u90fd\u662f\u8868\u5934\u4e0b\u9762\u7684\u4e00\u6574\u5217\u4ee5\u53ca\u542b\u67091\u7684\u4e00\u6574\u884c\uff0c\u800c\u6574\u4e2a\u8fc7\u7a0b\u4e2d\u66f4\u6539\u7684\u53ea\u6709\u8868\u5934\u5de6\u53f3\u6307\u9488\u548c\u4e0d\u662f\u8868\u5934\u90a3\u5217\u76841\u7684\u4e0a\u4e0b\u6307\u9488 \uff08\u56e0\u4e3a\u6062\u590d\u8981\u4ece\u8868\u5934\u5411\u4e0b\u8bbf\u95ee\uff0c\u518d\u4ece\u884c\u5934\u5411\u53f3\u8bbf\u95ee\uff09\u3002 \u53ea\u6709\u8fd9\u6837\u624d\u80fd\u5b9e\u73b0\u8bbf\u95ee\u5230\u5df2\u5220\u9664\u76841\u3002 2.\u5341\u5b57\u94fe\u8868\u4e2d\u4e0a\u4e0b\uff0c\u5de6\u53f3\u7684\u987a\u5e8f\u65e0\u6240\u8c13\uff0c\u4f46\u5fc5\u987b\u7edf\u4e00\u3002 3.\u6ce8\u610f\u6240\u6709\u94fe\u8868\u90fd\u662f\u53cc\u5411\uff0c\u5373\u662f\u4e00\u4e2a\u73af\u3002\u5f53\u81ea\u5df1\u6307\u5411\u81ea\u5df1\u65f6\u4e3a\u7a7a\u3002 4.\u7b97\u6cd5\u5224\u5b9a\u7ed3\u679c\u9519\u8bef\u7684\u4f9d\u636e\u662f\u8868\u5934\u8fd8\u6709\u5269\u4f59\uff0c\u4f46\u5143\u7d20\u90fd\u5220\u5b8c\u4e86\uff0c\u8bf4\u660e\u4e4b\u524d\u6709\u4e24\u4e2a\u4ee5\u4e0a\u76841\u51b2\u7a81\u3002 5.\u5220\u9664\u65f6\u66f4\u6539\u4e0a\u4e0b\u5143\u7d20\u7684\u4e4b\u4e2d\u5462\u4e00\u5b9a\u6ce8\u610f\u987a\u5e8f\u3002 f[++cnt].u=C; f[cnt].d=f[C].d; f[f[C].d].u=cnt; f[C].d=cnt; f[cnt].row=R; f[cnt].col=C; 6.\u6bcf\u6b21\u9009\u75281\u4e2a\u6570\u6700\u5c0f\u7684\u5217\u5b9e\u9645\u4e5f\u662f\u526a\u679d\u4f18\u5316\uff0c\u4e3a\u4e86\u8ba9\u66f4\u591a\u76841\u5728\u5f53\u524d\u56de\u5408\u5c31\u88ab\u7b5b\u6389\uff0c\u4ee5\u51cf\u5c11\u641c\u7d22\u6b21\u6570\u3002 7.\u53bb\u9664\u5143\u7d20\u65f6\u662f\u53bb\u9664\u9664\u4e86\u8868\u5934\u5143\u7d20\u610f\u5916\u6240\u6709\u4e0b\u9762\u76841\uff0c\u548c\u9664\u4e86\u884c\u5934\u5916\u6240\u67091.\u4e3a\u4e86\u4e0b\u6b21\u4ece\u8868\u5934\uff0c\u884c\u5934\u8bbf\u95ee\u5230\u88ab\u5220\u9664\u7684\u70b9\u3002 code time: 1) \u6570\u7ec4\u7248\uff1a #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=550,M=N*N+N; int n,m,cnt; int d[M],u[M],l[M],r[M],row[M],col[M]; int s[M],h[M],ans[M]; void init(){ for(int i=0;i<=m;++i){ l[i]=i-1; r[i]=i+1; u[i]=d[i]=i; } r[m]=0; l[0]=m;//\u94fe\u8868\u5934\u5c3e\u7279\u5224 memset(h,-1,sizeof h); memset(s,0,sizeof s); cnt=m+1; } void add(int R,int C){ s[C]++; row[cnt]=R; col[cnt]=C; u[cnt]=C; d[cnt]=d[C]; u[d[C]]=cnt; d[C]=cnt;//\u6ce8\u610f\u987a\u5e8f\uff01 if(h[R]==-1){ h[R]=l[cnt]=r[cnt]=cnt; }else{ r[cnt]=h[R]; l[cnt]=l[h[R]]; r[l[h[R]]]=cnt; l[h[R]]=cnt;//\u987a\u5e8f } cnt++; } void remove(int C){ r[l[C]]=r[C],l[r[C]]=l[C]; for(int i=d[C];i!=C;i=d[i]){ for(int j=r[i];j!=i;j=r[j]){ u[d[j]]=u[j]; d[u[j]]=d[j];//\u53ea\u66f4\u6539\u4e0a\u4e0b\u6307\u9488\uff0c\u4e3a\u4e86\u4e0b\u6b21\u8fd8\u80fd\u8bbf\u95ee\u5230\u5e76\u6062\u590d s[col[j]]--; } } } void resume(int C){ for(int i=d[C];i!=C;i=d[i]){ for(int j=r[i];j!=i;j=r[j]){ u[d[j]]=j; d[u[j]]=j;//\u518d\u63a5\u56de\u6765 s[col[j]]++; } } l[r[C]]=C,r[l[C]]=C; } void print1(int tot){ for(int i=0;i<tot;++i)printf(\"%d \",ans[i]); } int dfs(int dep){ if(r[0]==0){ print1(dep); return 1;//\u4e00\u4e2a\u89e3\u5c31\u9000\u51fa } int c=r[0]; for(int i=r[0];i!=0;i=r[i]){ if(s[i]<s[c])c=i; }//\u526a\u679d\u4f18\u5316 remove(c);//\u53bb\u9664\u5f53\u524d\u8868\u5934\u4e0b\u90a3\u5217\uff08C'\uff09\u7684\u6240\u67091\uff0c\u8868\u793a\u5df2\u7ecf\u88ab\u7eb3\u5165\u9009\u62e9\u3002 for(int i=d[c];i!=c;i=d[i]){ ans[dep]=row[i];//\u9009\u62e9\u5f53\u524d\u884c\u3002 for(int j=r[i];j!=i;j=r[j])remove(col[j]);//\u53bb\u9664\u9664\u4e86C'\u4ee5\u5916\u7684\u5f53\u524d\u884c\u76841 if(dfs(dep+1))return 1; for(int j=r[i];j!=i;j=r[j])resume(col[j]); } resume(c);//\u56de\u6eaf return 0;//\u65e0\u89e3 } int read1(){ int x=0; char ch=getchar(); while(ch>'9' || ch<'0'){ ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x; } int main(){ n=read1(),m=read1(); init(); for(int i=1;i<=n;++i){ for(int j=1,tmp;j<=m;++j){ tmp=read1(); if(tmp)add(i,j); } } if(!dfs(0))printf(\"No Solution!\"); return 0; } 2) \u7ed3\u6784\u4f53\u7248\uff1a #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=550,M=N*N; int n,m,cnt; int s[M],h[M],ans[M]; struct node{ int u,d,l,r,row,col; }f[M]; void init(){ for(int i=0;i<=m;++i){ f[i].l=i-1; f[i].r=i+1; f[i].u=f[i].d=i; } f[m].r=0; f[0].l=m; cnt=m; memset(h,-1,sizeof h); memset(s,0,sizeof s); } void link(int R,int C){ s[C]++; f[++cnt].u=C; f[cnt].d=f[C].d; f[f[C].d].u=cnt; f[C].d=cnt; f[cnt].row=R; f[cnt].col=C; if(h[R]==-1){ h[R]=f[cnt].l=f[cnt].r=cnt; }else{ f[cnt].l=h[R]; f[cnt].r=f[h[R]].r; f[f[h[R]].r].l=cnt; f[h[R]].r=cnt; } } void remove(int C){ f[f[C].r].l=f[C].l,f[f[C].l].r=f[C].r; for(int i=f[C].d;i!=C;i=f[i].d){ for(int j=f[i].r;j!=i;j=f[j].r){ f[f[j].d].u=f[j].u; f[f[j].u].d=f[j].d; s[f[j].col]--; } } } void resume(int C){ for(int i=f[C].d;i!=C;i=f[i].d){ for(int j=f[i].r;j!=i;j=f[j].r){ f[f[j].d].u=j; f[f[j].u].d=j; s[f[j].col]++; } } f[f[C].l].r=C,f[f[C].r].l=C; } void print1(int tot){ for(int i=1;i<=tot;++i)printf(\"%d \",ans[i]); } int dfs(int dep){ if(f[0].r==0){ print1(dep-1); return 1; } int c=f[0].r; for(int i=f[0].r;i!=0;i=f[i].r)if(s[i]<s[c])c=i; remove(c); for(int i=f[c].d;i!=c;i=f[i].d){ ans[dep]=f[i].row; for(int j=f[i].r;j!=i;j=f[j].r)remove(f[j].col); if(dfs(dep+1))return 1; for(int j=f[i].r;j!=i;j=f[j].r)resume(f[j].col); } resume(c); return 0; } int main(){ scanf(\"%d%d\",&n,&m); init(); for(int i=1;i<=n;++i){ for(int j=1,tmp;j<=m;++j){ scanf(\"%d\",&tmp); if(tmp)link(i,j); } } if(!dfs(1))printf(\"No Solution!\"); return 0; }","title":"\u6a21\u677f"},{"location":"my%20past/OI/FFT/","text":"\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362 FFT ~~\u4f17\u6240\u5468\u77e5\uff0cFFT\u5168\u79f0\u662fFast Fast TLE~~ \u8fd9\u662f\u4e00\u4e2a\u5341\u5206\u5de7\u5999\u4e14\u4f18\u7f8e\u7684\u7b97\u6cd5\uff0c\u5305\u62ec\u4e86\u5206\u6cbb\u8fed\u4ee3\u7b49\u91cd\u8981\u601d\u60f3\u3002 \u524d\u7f6e\u77e5\u8bc6 \u5177\u4f53\u53c2\u8003 \u8fd9\u7bc7\u6587\u7ae0 ,\u91cc\u9762\u8bb2\u7684\u5f88\u8be6\u7ec6\uff0c\u5305\u62ec\u591a\u9879\u5f0f\u4e58\u6cd5(\u5377\u79ef)\uff0c\u7cfb\u6570\u8868\u793a\u6cd5\u4e0e\u70b9\u503c\u8868\u793a\u6cd5\uff0c\u6734\u7d20\u7b97\u6cd5(\u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362DFT) \uff0c\u590d\u6570\u52a0\u6cd5\u4e58\u6cd5\uff0c\u5355\u4f4d\u6839\u53ca\u5176\u6027\u8d28\u7b49\u8bf8\u591a\u77e5\u8bc6\u70b9\u3002 FFT \u8fd9\u91cc\u53ea\u8bb2\u4e00\u4e9b\u5177\u4f53\u7684\uff0c\u539f\u6587\u6ca1\u8bb2\u6e05\u695a\u7684\u7ec6\u8282\u3002 \u9996\u5148\uff0c\u5047\u8bbe\u539f\u6765\u7684\u7cfb\u6570\u662f$a_0,a_1,...,a_n$,\u6c42\u51fa\u6765\u7684\u70b9\u503c\u8868\u793a\u4e3a$(x_0,y_0),(x_1,y_1),...,(x_n,y_n)$,\u518d\u5c06$y_0,y_1,...,y_n$\u4f5c\u4e3a\u7cfb\u6570\u9006\u53d8\u6362\u51fa\u70b9\u503c\u8868\u793a$(x_0',c_0),(x_1',c_1),...,(x_n',c_n)$,\u5219\u6b64\u65f6\u6ee1\u8db3$a_n=\\frac{c_n}{k}$ ~~\u4f5c\u4e3a\u849f\u84bb\u770b\u539f\u6587\u7adf\u7136\u770b\u4e86\u4e09\u5929\u624d\u770b\u61c2\uff0c\u6240\u4ee5\u89e3\u91ca\u4e00\u4e0b~~ \u5047\u8bbe\u591a\u9879\u5f0f$a,b$\u4e3a$n,m$\u6b21\u591a\u9879\u5f0f\uff0c\u5219\u5377\u79ef\u5377\u51fa\u6765\u7684\u591a\u9879\u5f0f\u4e3a$n+m$\u6b21\uff0c\u56e0\u6b64\u5728\u7b97\u6cd5\u4e2d\uff0c\u9700\u8981\u5c06$a,b$\u4e24\u4e2a\u591a\u9879\u5f0f\u7684\u7cfb\u6570\u8865\u5230$n+m$\u6b21\u3002\u5c31\u7b97\u7cfb\u6570\u662f$0$\u4e5f\u6ca1\u4e8b\u3002 \u539f\u6587\u4e2d\"\u95ee\u9898\u7f29\u5c0f\u4e00\u534a\uff0c\u53ef\u4ee5\u5206\u6cbb\"\u4f53\u73b0\u4e3a\uff1a\u5047\u8bbe\u7b97\u6cd5\u8fdb\u884c\u4e2d\u5df2\u7ecf\u7b97\u51fa$a_1,a_2$\u4e24\u4e2a\u5b50\u591a\u9879\u5f0f\u7684\u70b9\u503c\u8868\u793a\uff0c\u4e14\u4ed6\u4eec\u7684\u70b9\u503c\u5206\u522b\u5bf9\u5e94\u591a\u9879\u5f0f$a_1,a_2$\u53d6$W_n^0 ,W_n^1,...,W_n^k$\u65f6\u7684\u503c\uff0c\u90a3\u4e48\u53ef\u4ee5\u7528\u8fd9\u4e9b\u503c\u7b97\u51fa\u591a\u9879\u5f0f$a$\u53d6$W_n^0 ,W_n^1,...,W_n^{2k}$\u7684\u503c\uff0c\u8fd9\u6837\u4ece$k=1$\u4e00\u76f4\u5230$k=n$\uff0c\u6211\u4eec\u7528$O(n\\log n)$\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u7b97\u51fa\u4e86\u6574\u4e2a\u591a\u9879\u5f0f\u7684\u70b9\u503c\u8868\u793a\u3002 \u53e6\u5916\uff0c\u56e0\u4e3a\u9012\u5f52\u7684\u7a7a\u95f4\u5f00\u9500\u8fc7\u9ad8\uff0c\u6240\u4ee5\u8981\u91c7\u7528\u8fed\u4ee3(\u9012\u63a8)\u7684\u65b9\u5f0f\u5b9e\u73b0\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> using namespace std; typedef double db; const int N=4e6+10; const db Pi=acos(-1.0); struct c{ db x,y; c(db xx=0,db yy=0){x=xx,y=yy;} }a[N],b[N]; c operator +(c a,c b){return c(a.x+b.x,a.y+b.y);} c operator -(c a,c b){return c(a.x-b.x,a.y-b.y);} c operator *(c a,c b){return c(a.x*b.x-a.y*b.y,a.y*b.x+b.y*a.x);} int n,m,k,l; int r[N]; void init(){ l=0,k=1;while(k<=n+m)k<<=1,++l; for(int i=0;i<k;++i) r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));//\u627e\u89c4\u5f8b\u7684\u4e1c\u897f\u5c31\u80cc\u4e00\u80cc\u597d\u4e86 } void FFT(c* a,int t){ for(int i=0;i<k;++i)if(i<r[i])swap(a[i],a[r[i]]);//\u5f97\u5230\u6700\u5e95\u5c42\u7684\u591a\u9879\u5f0f\u7cfb\u6570 for(int mid=1;mid<k;mid<<=1){//\u679a\u4e3e\u4e2d\u70b9\uff0c\u5373\u533a\u95f4\u957f\u7684\u4e00\u534a c Wn(cos(Pi/mid),t*sin(Pi/mid));//\u5355\u4f4d\u6839 for(int L=mid<<1,j=0;j<k;j+=L){//L\u4e3a\u533a\u95f4\u957f\uff0cj\u4e3a\u533a\u95f4\u8d77\u70b9 c w(1,0);//p=0\u7684\u521d\u59cb\u72b6\u6001 for(int p=0;p<mid;++p,w=w*Wn){//\u8fd9\u91cc\u7684p\u5c31\u662f\u5355\u4f4d\u6839\u7684\u5e42\u6b21\uff0c\u4e3a0~mid c x=a[j+p],y=a[j+mid+p]*w;//\u8774\u8776\u64cd\u4f5c a[j+p]=x+y;//\u524d\u534a a[j+mid+p]=x-y;//\u540e\u534a } } } } int main(){ scanf(\"%d%d\",&n,&m); for(int i=0;i<=n;++i)scanf(\"%lf\",&a[i].x); for(int i=0;i<=m;++i)scanf(\"%lf\",&b[i].x); init(); FFT(a,1);//\u6b63\u53d8\u6362 FFT(b,1); for(int i=0;i<k;++i)a[i]=a[i]*b[i];//\u70b9\u503c\u76f4\u63a5O(n)\u76f8\u4e58 FFT(a,-1);//\u9006\u53d8\u6362 for(int i=0;i<=n+m;++i)printf(\"%d \",(int)(a[i].x/k+0.5)); return 0; }","title":"\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362 FFT"},{"location":"my%20past/OI/FFT/#fft","text":"~~\u4f17\u6240\u5468\u77e5\uff0cFFT\u5168\u79f0\u662fFast Fast TLE~~ \u8fd9\u662f\u4e00\u4e2a\u5341\u5206\u5de7\u5999\u4e14\u4f18\u7f8e\u7684\u7b97\u6cd5\uff0c\u5305\u62ec\u4e86\u5206\u6cbb\u8fed\u4ee3\u7b49\u91cd\u8981\u601d\u60f3\u3002","title":"\u5feb\u901f\u5085\u91cc\u53f6\u53d8\u6362 FFT"},{"location":"my%20past/OI/FFT/#_1","text":"\u5177\u4f53\u53c2\u8003 \u8fd9\u7bc7\u6587\u7ae0 ,\u91cc\u9762\u8bb2\u7684\u5f88\u8be6\u7ec6\uff0c\u5305\u62ec\u591a\u9879\u5f0f\u4e58\u6cd5(\u5377\u79ef)\uff0c\u7cfb\u6570\u8868\u793a\u6cd5\u4e0e\u70b9\u503c\u8868\u793a\u6cd5\uff0c\u6734\u7d20\u7b97\u6cd5(\u79bb\u6563\u5085\u91cc\u53f6\u53d8\u6362DFT) \uff0c\u590d\u6570\u52a0\u6cd5\u4e58\u6cd5\uff0c\u5355\u4f4d\u6839\u53ca\u5176\u6027\u8d28\u7b49\u8bf8\u591a\u77e5\u8bc6\u70b9\u3002","title":"\u524d\u7f6e\u77e5\u8bc6"},{"location":"my%20past/OI/FFT/#fft_1","text":"\u8fd9\u91cc\u53ea\u8bb2\u4e00\u4e9b\u5177\u4f53\u7684\uff0c\u539f\u6587\u6ca1\u8bb2\u6e05\u695a\u7684\u7ec6\u8282\u3002 \u9996\u5148\uff0c\u5047\u8bbe\u539f\u6765\u7684\u7cfb\u6570\u662f$a_0,a_1,...,a_n$,\u6c42\u51fa\u6765\u7684\u70b9\u503c\u8868\u793a\u4e3a$(x_0,y_0),(x_1,y_1),...,(x_n,y_n)$,\u518d\u5c06$y_0,y_1,...,y_n$\u4f5c\u4e3a\u7cfb\u6570\u9006\u53d8\u6362\u51fa\u70b9\u503c\u8868\u793a$(x_0',c_0),(x_1',c_1),...,(x_n',c_n)$,\u5219\u6b64\u65f6\u6ee1\u8db3$a_n=\\frac{c_n}{k}$ ~~\u4f5c\u4e3a\u849f\u84bb\u770b\u539f\u6587\u7adf\u7136\u770b\u4e86\u4e09\u5929\u624d\u770b\u61c2\uff0c\u6240\u4ee5\u89e3\u91ca\u4e00\u4e0b~~ \u5047\u8bbe\u591a\u9879\u5f0f$a,b$\u4e3a$n,m$\u6b21\u591a\u9879\u5f0f\uff0c\u5219\u5377\u79ef\u5377\u51fa\u6765\u7684\u591a\u9879\u5f0f\u4e3a$n+m$\u6b21\uff0c\u56e0\u6b64\u5728\u7b97\u6cd5\u4e2d\uff0c\u9700\u8981\u5c06$a,b$\u4e24\u4e2a\u591a\u9879\u5f0f\u7684\u7cfb\u6570\u8865\u5230$n+m$\u6b21\u3002\u5c31\u7b97\u7cfb\u6570\u662f$0$\u4e5f\u6ca1\u4e8b\u3002 \u539f\u6587\u4e2d\"\u95ee\u9898\u7f29\u5c0f\u4e00\u534a\uff0c\u53ef\u4ee5\u5206\u6cbb\"\u4f53\u73b0\u4e3a\uff1a\u5047\u8bbe\u7b97\u6cd5\u8fdb\u884c\u4e2d\u5df2\u7ecf\u7b97\u51fa$a_1,a_2$\u4e24\u4e2a\u5b50\u591a\u9879\u5f0f\u7684\u70b9\u503c\u8868\u793a\uff0c\u4e14\u4ed6\u4eec\u7684\u70b9\u503c\u5206\u522b\u5bf9\u5e94\u591a\u9879\u5f0f$a_1,a_2$\u53d6$W_n^0 ,W_n^1,...,W_n^k$\u65f6\u7684\u503c\uff0c\u90a3\u4e48\u53ef\u4ee5\u7528\u8fd9\u4e9b\u503c\u7b97\u51fa\u591a\u9879\u5f0f$a$\u53d6$W_n^0 ,W_n^1,...,W_n^{2k}$\u7684\u503c\uff0c\u8fd9\u6837\u4ece$k=1$\u4e00\u76f4\u5230$k=n$\uff0c\u6211\u4eec\u7528$O(n\\log n)$\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u7b97\u51fa\u4e86\u6574\u4e2a\u591a\u9879\u5f0f\u7684\u70b9\u503c\u8868\u793a\u3002 \u53e6\u5916\uff0c\u56e0\u4e3a\u9012\u5f52\u7684\u7a7a\u95f4\u5f00\u9500\u8fc7\u9ad8\uff0c\u6240\u4ee5\u8981\u91c7\u7528\u8fed\u4ee3(\u9012\u63a8)\u7684\u65b9\u5f0f\u5b9e\u73b0\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> using namespace std; typedef double db; const int N=4e6+10; const db Pi=acos(-1.0); struct c{ db x,y; c(db xx=0,db yy=0){x=xx,y=yy;} }a[N],b[N]; c operator +(c a,c b){return c(a.x+b.x,a.y+b.y);} c operator -(c a,c b){return c(a.x-b.x,a.y-b.y);} c operator *(c a,c b){return c(a.x*b.x-a.y*b.y,a.y*b.x+b.y*a.x);} int n,m,k,l; int r[N]; void init(){ l=0,k=1;while(k<=n+m)k<<=1,++l; for(int i=0;i<k;++i) r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));//\u627e\u89c4\u5f8b\u7684\u4e1c\u897f\u5c31\u80cc\u4e00\u80cc\u597d\u4e86 } void FFT(c* a,int t){ for(int i=0;i<k;++i)if(i<r[i])swap(a[i],a[r[i]]);//\u5f97\u5230\u6700\u5e95\u5c42\u7684\u591a\u9879\u5f0f\u7cfb\u6570 for(int mid=1;mid<k;mid<<=1){//\u679a\u4e3e\u4e2d\u70b9\uff0c\u5373\u533a\u95f4\u957f\u7684\u4e00\u534a c Wn(cos(Pi/mid),t*sin(Pi/mid));//\u5355\u4f4d\u6839 for(int L=mid<<1,j=0;j<k;j+=L){//L\u4e3a\u533a\u95f4\u957f\uff0cj\u4e3a\u533a\u95f4\u8d77\u70b9 c w(1,0);//p=0\u7684\u521d\u59cb\u72b6\u6001 for(int p=0;p<mid;++p,w=w*Wn){//\u8fd9\u91cc\u7684p\u5c31\u662f\u5355\u4f4d\u6839\u7684\u5e42\u6b21\uff0c\u4e3a0~mid c x=a[j+p],y=a[j+mid+p]*w;//\u8774\u8776\u64cd\u4f5c a[j+p]=x+y;//\u524d\u534a a[j+mid+p]=x-y;//\u540e\u534a } } } } int main(){ scanf(\"%d%d\",&n,&m); for(int i=0;i<=n;++i)scanf(\"%lf\",&a[i].x); for(int i=0;i<=m;++i)scanf(\"%lf\",&b[i].x); init(); FFT(a,1);//\u6b63\u53d8\u6362 FFT(b,1); for(int i=0;i<k;++i)a[i]=a[i]*b[i];//\u70b9\u503c\u76f4\u63a5O(n)\u76f8\u4e58 FFT(a,-1);//\u9006\u53d8\u6362 for(int i=0;i<=n+m;++i)printf(\"%d \",(int)(a[i].x/k+0.5)); return 0; }","title":"FFT"},{"location":"my%20past/OI/Fast%20IO/","text":"Fast io /* --------------- fast io --------------- */ // begin namespace Fread { const int SIZE=1<<21; char buf[SIZE],*S,*T; inline char getchar(){ if(S==T){ T=(S=buf)+fread(buf,1,SIZE,stdin); if(S==T) return EOF; } return *S++; } } // namespace Fread namespace Fwrite { const int SIZE=1<<21; char buf[SIZE],*S=buf,*T=buf+SIZE; inline void flush(){ fwrite(buf,1,S-buf,stdout); S=buf; } inline void putchar(char c) { *S++=c; if(S==T)flush(); } struct NTR { ~ NTR(){flush(); } }ztr; } // namespace Fwrite #define getchar Fread :: getchar #define putchar Fwrite :: putchar namespace Fastio{ struct Reader{ template<typename T> Reader& operator>>(T& x){ char c=getchar(); T f=1; while(c<'0'||c>'9'){ if(c=='-')f=-1; c=getchar(); } x=0; while(c>='0'&&c<='9') { x=x*10+(c-'0'); c=getchar(); } x*=f; return *this; } Reader& operator >> (char& c){ c=getchar(); while (c=='\\n'||c ==' ')c=getchar(); return *this; } Reader& operator >>(char* str) { int len=0; char c=getchar(); while (c=='\\n'||c==' ')c=getchar(); while (c!='\\n'&&c!=' '){ str[len++]=c; c=getchar(); } str[len]='\\0'; return *this; } Reader(){} }cin; const char endl = '\\n'; struct Writer { template<typename T> Writer&operator << (T x){ if(x==0){putchar('0');return *this; } if(x<0){putchar('-');x=-x; } static int sta[45]; int top=0; while(x){sta[++top]=x%10;x/=10;} while(top){putchar(sta[top]+'0');--top;} return *this; } Writer&operator<<(char c){ putchar(c); return *this; } Writer&operator<<(char* str) { int cur=0; while (str[cur])putchar(str[cur++]); return *this; } Writer&operator<<(const char* str) { int cur=0; while(str[cur])putchar(str[cur++]); return*this; } Writer(){} }cout; } // namespace Fastio #define cin Fastio :: cin #define cout Fastio :: cout #define endl Fastio :: endl /* --------------- fast io --------------- */ // end","title":"Fast io"},{"location":"my%20past/OI/Fast%20IO/#fast-io","text":"/* --------------- fast io --------------- */ // begin namespace Fread { const int SIZE=1<<21; char buf[SIZE],*S,*T; inline char getchar(){ if(S==T){ T=(S=buf)+fread(buf,1,SIZE,stdin); if(S==T) return EOF; } return *S++; } } // namespace Fread namespace Fwrite { const int SIZE=1<<21; char buf[SIZE],*S=buf,*T=buf+SIZE; inline void flush(){ fwrite(buf,1,S-buf,stdout); S=buf; } inline void putchar(char c) { *S++=c; if(S==T)flush(); } struct NTR { ~ NTR(){flush(); } }ztr; } // namespace Fwrite #define getchar Fread :: getchar #define putchar Fwrite :: putchar namespace Fastio{ struct Reader{ template<typename T> Reader& operator>>(T& x){ char c=getchar(); T f=1; while(c<'0'||c>'9'){ if(c=='-')f=-1; c=getchar(); } x=0; while(c>='0'&&c<='9') { x=x*10+(c-'0'); c=getchar(); } x*=f; return *this; } Reader& operator >> (char& c){ c=getchar(); while (c=='\\n'||c ==' ')c=getchar(); return *this; } Reader& operator >>(char* str) { int len=0; char c=getchar(); while (c=='\\n'||c==' ')c=getchar(); while (c!='\\n'&&c!=' '){ str[len++]=c; c=getchar(); } str[len]='\\0'; return *this; } Reader(){} }cin; const char endl = '\\n'; struct Writer { template<typename T> Writer&operator << (T x){ if(x==0){putchar('0');return *this; } if(x<0){putchar('-');x=-x; } static int sta[45]; int top=0; while(x){sta[++top]=x%10;x/=10;} while(top){putchar(sta[top]+'0');--top;} return *this; } Writer&operator<<(char c){ putchar(c); return *this; } Writer&operator<<(char* str) { int cur=0; while (str[cur])putchar(str[cur++]); return *this; } Writer&operator<<(const char* str) { int cur=0; while(str[cur])putchar(str[cur++]); return*this; } Writer(){} }cout; } // namespace Fastio #define cin Fastio :: cin #define cout Fastio :: cout #define endl Fastio :: endl /* --------------- fast io --------------- */ // end","title":"Fast io"},{"location":"my%20past/OI/Game%20with%20Marbles%20%28Hard%20Version%29/","text":"CF1914E2 \u9898\u610f Alice\u548cBob\u5206\u522b\u6709\u4e00\u4e9b\u77f3\u5934\uff0c\u77f3\u5934\u4e00\u5171\u6709 $n$ \u79cd\u4e0d\u540c\u989c\u8272\uff0cAlice\u6709 $a_i$ \u4e2a\u7b2c $i$ \u79cd\u77f3\u5934\uff0cBob\u6709 $b_i$ \u4e2a\u7b2c $i$ \u79cd\u77f3\u5934\u3002 \u6bcf\u56de\u5408(Alice\u5148\u624b)\u53ef\u4ee5\u9009\u62e9\u4e00\u79cd\u989c\u8272\u77f3\u5934\uff0c\u4e22\u5f03\u81ea\u5df1\u7684\u4e00\u4e2a\u77f3\u5934\uff0c\u5e76\u8ba9\u5bf9\u65b9\u4e22\u5f03\u6240\u6709\u8fd9\u79cd\u989c\u8272\u7684\u77f3\u5934\u3002\u5f53\u4e24\u4eba\u624b\u4e2d\u6ca1\u6709\u76f8\u540c\u989c\u8272\u77f3\u5934\u65f6\uff0c\u6e38\u620f\u7ed3\u675f\u3002 \u5bf9\u4e8e\u4e00\u573a\u6e38\u620f\uff0c\u5206\u6570\u4e3aAlice\u624b\u4e2d\u77f3\u5934\u4e0eBob\u77f3\u5934\u7684\u5dee\u503c\uff0c\u8bb0\u4e3a $A-B$\u3002Alice\u5e0c\u671b\u5206\u6570\u6700\u5927\u5316\uff0cBob\u5e0c\u671b\u5206\u6570\u6700\u5c0f\u5316\uff0c\u95ee\u6700\u7ec8\u5f97\u5206\u3002 \u601d\u8def \u5bf9\u4e8e\u4e24\u4e2a\u4eba\u6765\u8bf4\uff0c\u4ed6\u4eec\u90fd\u5e0c\u671b\u6bcf\u56de\u5408\u53ef\u4ee5\u9009\u62e9\u5bf9\u65b9\u6570\u91cf\u5c3d\u53ef\u80fd\u591a\u7684\u77f3\u5934\u4e22\u6389\uff0c\u5e76\u4e14\u81ea\u5df1\u7684\u8fd9\u79cd\u77f3\u5934\u6570\u91cf\u4e5f\u5c3d\u53ef\u80fd\u5927\u3002\u8fd9\u6837\u65e2\u53ef\u4ee5\u4fdd\u62a4\u81ea\u5df1\u7684\u8fd9\u79cd\u77f3\u5934\u4e0d\u88ab\u5bf9\u65b9\u4e22\u6389\uff0c\u53c8\u80fd\u6700\u5927\u9650\u5ea6\u5730\u524a\u51cf\u5bf9\u65b9\u77f3\u5934\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u4e24\u4eba\u5e0c\u671b\u5148\u9009\u62e9 $a_i+b_i$ \u6700\u5927\u7684\u77f3\u5934\u3002 \u5177\u4f53\u6765\u8bf4\uff0c\u5bf9\u4e8e\u5148\u624b\u7684\u4e00\u65b9\uff0c\u5047\u8bbe\u6709 $i$ \u548c $j$ \u989c\u8272\u77f3\u5b50\uff0c\u6ee1\u8db3 $a_i+b_i\\geq a_j+b_j$\uff0c\u5982\u679c\u5148\u624b\u65b9\u5148\u9009\u62e9 $j$ \u989c\u8272\u77f3\u5b50\uff0c\u540e\u624b\u65b9\u9009\u62e9 $i$ \u989c\u8272\u77f3\u5b50\u662f\u66f4\u4f18\u7684\u7b56\u7565\uff0c\u90a3\u4e48\u6700\u7ec8\u5bf9\u5f97\u5206\u8d21\u732e\u4e3a $(a_j-1+0)-(b_i-1+0)=a_j-b_i$\u3002\u800c\u5148\u624b\u65b9\u9009\u62e9 $i$ \u989c\u8272\u77f3\u5b50\u7684\u8d21\u732e\u4e3a $a_i-b_j$\u3002\u7531\u5047\u8bbe\u53ef\u77e5\uff0c$a_i-b_j\\geq a_j-b_i$\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u8fd9\u79cd\u7b56\u7565\u4e0d\u662f\u6700\u597d\u7684\u7b56\u7565\u3002 \u6240\u4ee5\uff0c\u5bf9\u4e8e\u5148\u624b\u65b9(Alice)\uff0c\u4e00\u5b9a\u5148\u9009 $a_i+b_i$ \u6700\u5927\u7684\u4e00\u79cd\u77f3\u5b50\u3002 \u5bf9\u4e8e\u540e\u624b\u65b9(Bob)\uff0c\u5728\u4e00\u4e2a\u56de\u5408\u540e\u53d8\u4e3a\u5148\u624b\u65b9\uff0c\u56e0\u6b64\u91c7\u53d6\u540c\u6837\u7b56\u7565\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\uff0c\u53ea\u8981\u5c06\u6bcf\u79cd\u77f3\u5934\u6309\u7167 $a_i+b_i$ \u4ece\u5927\u5230\u5c0f\u6392\u5e8f\uff0c\u4f9d\u6b21\u9009\u62e9\u8ba1\u7b97\u5f97\u5206\uff0c\u5f97\u5230\u7684\u7ed3\u679c\u5c31\u662f\u6211\u4eec\u60f3\u8981\u7684\u7b54\u6848\u3002 \u8bb0\u5f97\u5f00 long long \u3002 Code #include<iostream> #include<algorithm> #define int long long using namespace std; const int N=2e5+10; struct node{ int a,b,c; }q[N]; int T,n; bool cmp(node x,node y){ return x.c>y.c; } signed main(){ scanf(\"%lld\",&T); while(T--){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i) scanf(\"%lld\",&q[i].a); for(int i=1;i<=n;++i) scanf(\"%lld\",&q[i].b),q[i].c=q[i].b+q[i].a; sort(q+1,q+n+1,cmp); int sum=0; for(int i=1;i<=n;++i){ if(i&1){ sum+=q[i].a-1; }else{ sum-=q[i].b-1; } } printf(\"%lld\\n\",sum); } return 0; }","title":"CF1914E2"},{"location":"my%20past/OI/Game%20with%20Marbles%20%28Hard%20Version%29/#cf1914e2","text":"","title":"CF1914E2"},{"location":"my%20past/OI/Game%20with%20Marbles%20%28Hard%20Version%29/#_1","text":"Alice\u548cBob\u5206\u522b\u6709\u4e00\u4e9b\u77f3\u5934\uff0c\u77f3\u5934\u4e00\u5171\u6709 $n$ \u79cd\u4e0d\u540c\u989c\u8272\uff0cAlice\u6709 $a_i$ \u4e2a\u7b2c $i$ \u79cd\u77f3\u5934\uff0cBob\u6709 $b_i$ \u4e2a\u7b2c $i$ \u79cd\u77f3\u5934\u3002 \u6bcf\u56de\u5408(Alice\u5148\u624b)\u53ef\u4ee5\u9009\u62e9\u4e00\u79cd\u989c\u8272\u77f3\u5934\uff0c\u4e22\u5f03\u81ea\u5df1\u7684\u4e00\u4e2a\u77f3\u5934\uff0c\u5e76\u8ba9\u5bf9\u65b9\u4e22\u5f03\u6240\u6709\u8fd9\u79cd\u989c\u8272\u7684\u77f3\u5934\u3002\u5f53\u4e24\u4eba\u624b\u4e2d\u6ca1\u6709\u76f8\u540c\u989c\u8272\u77f3\u5934\u65f6\uff0c\u6e38\u620f\u7ed3\u675f\u3002 \u5bf9\u4e8e\u4e00\u573a\u6e38\u620f\uff0c\u5206\u6570\u4e3aAlice\u624b\u4e2d\u77f3\u5934\u4e0eBob\u77f3\u5934\u7684\u5dee\u503c\uff0c\u8bb0\u4e3a $A-B$\u3002Alice\u5e0c\u671b\u5206\u6570\u6700\u5927\u5316\uff0cBob\u5e0c\u671b\u5206\u6570\u6700\u5c0f\u5316\uff0c\u95ee\u6700\u7ec8\u5f97\u5206\u3002","title":"\u9898\u610f"},{"location":"my%20past/OI/Game%20with%20Marbles%20%28Hard%20Version%29/#_2","text":"\u5bf9\u4e8e\u4e24\u4e2a\u4eba\u6765\u8bf4\uff0c\u4ed6\u4eec\u90fd\u5e0c\u671b\u6bcf\u56de\u5408\u53ef\u4ee5\u9009\u62e9\u5bf9\u65b9\u6570\u91cf\u5c3d\u53ef\u80fd\u591a\u7684\u77f3\u5934\u4e22\u6389\uff0c\u5e76\u4e14\u81ea\u5df1\u7684\u8fd9\u79cd\u77f3\u5934\u6570\u91cf\u4e5f\u5c3d\u53ef\u80fd\u5927\u3002\u8fd9\u6837\u65e2\u53ef\u4ee5\u4fdd\u62a4\u81ea\u5df1\u7684\u8fd9\u79cd\u77f3\u5934\u4e0d\u88ab\u5bf9\u65b9\u4e22\u6389\uff0c\u53c8\u80fd\u6700\u5927\u9650\u5ea6\u5730\u524a\u51cf\u5bf9\u65b9\u77f3\u5934\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u4e24\u4eba\u5e0c\u671b\u5148\u9009\u62e9 $a_i+b_i$ \u6700\u5927\u7684\u77f3\u5934\u3002 \u5177\u4f53\u6765\u8bf4\uff0c\u5bf9\u4e8e\u5148\u624b\u7684\u4e00\u65b9\uff0c\u5047\u8bbe\u6709 $i$ \u548c $j$ \u989c\u8272\u77f3\u5b50\uff0c\u6ee1\u8db3 $a_i+b_i\\geq a_j+b_j$\uff0c\u5982\u679c\u5148\u624b\u65b9\u5148\u9009\u62e9 $j$ \u989c\u8272\u77f3\u5b50\uff0c\u540e\u624b\u65b9\u9009\u62e9 $i$ \u989c\u8272\u77f3\u5b50\u662f\u66f4\u4f18\u7684\u7b56\u7565\uff0c\u90a3\u4e48\u6700\u7ec8\u5bf9\u5f97\u5206\u8d21\u732e\u4e3a $(a_j-1+0)-(b_i-1+0)=a_j-b_i$\u3002\u800c\u5148\u624b\u65b9\u9009\u62e9 $i$ \u989c\u8272\u77f3\u5b50\u7684\u8d21\u732e\u4e3a $a_i-b_j$\u3002\u7531\u5047\u8bbe\u53ef\u77e5\uff0c$a_i-b_j\\geq a_j-b_i$\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u8fd9\u79cd\u7b56\u7565\u4e0d\u662f\u6700\u597d\u7684\u7b56\u7565\u3002 \u6240\u4ee5\uff0c\u5bf9\u4e8e\u5148\u624b\u65b9(Alice)\uff0c\u4e00\u5b9a\u5148\u9009 $a_i+b_i$ \u6700\u5927\u7684\u4e00\u79cd\u77f3\u5b50\u3002 \u5bf9\u4e8e\u540e\u624b\u65b9(Bob)\uff0c\u5728\u4e00\u4e2a\u56de\u5408\u540e\u53d8\u4e3a\u5148\u624b\u65b9\uff0c\u56e0\u6b64\u91c7\u53d6\u540c\u6837\u7b56\u7565\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\uff0c\u53ea\u8981\u5c06\u6bcf\u79cd\u77f3\u5934\u6309\u7167 $a_i+b_i$ \u4ece\u5927\u5230\u5c0f\u6392\u5e8f\uff0c\u4f9d\u6b21\u9009\u62e9\u8ba1\u7b97\u5f97\u5206\uff0c\u5f97\u5230\u7684\u7ed3\u679c\u5c31\u662f\u6211\u4eec\u60f3\u8981\u7684\u7b54\u6848\u3002 \u8bb0\u5f97\u5f00 long long \u3002","title":"\u601d\u8def"},{"location":"my%20past/OI/Game%20with%20Marbles%20%28Hard%20Version%29/#code","text":"#include<iostream> #include<algorithm> #define int long long using namespace std; const int N=2e5+10; struct node{ int a,b,c; }q[N]; int T,n; bool cmp(node x,node y){ return x.c>y.c; } signed main(){ scanf(\"%lld\",&T); while(T--){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i) scanf(\"%lld\",&q[i].a); for(int i=1;i<=n;++i) scanf(\"%lld\",&q[i].b),q[i].c=q[i].b+q[i].a; sort(q+1,q+n+1,cmp); int sum=0; for(int i=1;i<=n;++i){ if(i&1){ sum+=q[i].a-1; }else{ sum-=q[i].b-1; } } printf(\"%lld\\n\",sum); } return 0; }","title":"Code"},{"location":"my%20past/OI/MST/","text":"\u6700\u5c0f\u751f\u6210\u6811MST \u57fa\u7840\u65b9\u6cd5\u6709$Kruskal$,$Prim$\u548c$B$\u7b97\u6cd5\uff0c\u5c31\u4e0d\u591a\u8bf4\u4e86\u3002 P2573 \u6ce8\u610f\u5230\u8fd9\u662f\u4e2a\u6709\u5411\u56fe\uff0c\u6240\u4ee5\u4e0d\u80fd\u76f4\u63a5\u7684\u8dd1$kruskal$. \u7b2c\u4e00\u95ee\u5c31\u76f4\u63a5$dfs$\u6c42\u51fa\u70b9\u6570\uff0c\u6ce8\u610f\u6211\u4eec\u53ea\u8981$h[u]\\geq h[v]$\u7684\u8fb9\u3002\u5e76\u4e14\uff0c\u8981\u5c06\u6bcf\u4e2a\u70b9\u62d3\u5c55\u5230\u7684\u8fb9\u8bb0\u5f55\u4e0b\u6765\uff0c\u4f5c\u4e3a\u7b2c\u4e8c\u95ee\u7684\u65b0\u56fe\u3002 \u7b2c\u4e8c\u95ee\u4e2d\uff0c\u6211\u4eec\u8981\u5c06\u8fb9\u6309\u7ec8\u70b9\u9ad8\u5ea6\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\uff0c\u8fb9\u6743\u4e3a\u7b2c\u4e8c\u5173\u952e\u5b57\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u3002 \u81f3\u4e8e\u4e3a\u4ec0\u4e48\u53ea\u6709\u8fd9\u6837\u624d\u5bf9\uff0c\u8003\u8651\u8fd9\u7ec4\u6570\u636e~~made by AKonjac_~~ 4 4 4 3 2 1 1 3 1000000001 1 2 1000000004 2 3 1000000002 2 4 1000000003 \u5982\u679c\u53ea\u6309\u8fb9\u6743\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u751f\u6210\u7684\u6700\u5c0f\u751f\u6210\u6811\u65e0\u6cd5\u5230\u8fbe$2$\u53f7\u70b9\uff0c\u6240\u4ee5\u9519\u8bef\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4e3a\u4e86\u4fdd\u8bc1\u6709\u5411\u751f\u6210\u6811\u4e00\u5b9a\u8054\u901a\uff0c\u5c31\u8981\u6309\u7167\u7ec8\u70b9\u4ece\u5927\u5230\u5c0f\u7684\u987a\u5e8f\u66f4\u65b0\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define ll long long using namespace std; const int N=1e5+10,M=1e6+10; struct edge{ int u,v,w,nxt; }e[M<<1],E[M<<1]; int fa[N],vis[N],head[N],Head[N],h[N]; int cnt,Cnt,tot,nod,u,v,w,n,m; ll ans; int getfa(int u){ return fa[u]==u?u:fa[u]=getfa(fa[u]); } void add(int u,int v,int w){ e[++cnt].u=u,e[cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void Add(int u,int v,int w){ E[++Cnt].u=u,E[Cnt].v=v,E[Cnt].w=w,E[Cnt].nxt=Head[u],Head[u]=Cnt; } void dfs(int u){ vis[u]=1;++tot; for(int i=head[u];~i;i=e[i].nxt){ int u=e[i].u,v=e[i].v,w=e[i].w; Add(u,v,w); if(!vis[v]) dfs(v); } } bool Cmp(edge a,edge b){ if(h[a.v]==h[b.v]) return a.w<b.w; return h[a.v]>h[b.v]; } int main(){ memset(head,-1,sizeof head);cnt=-1; memset(Head,-1,sizeof Head);Cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i) scanf(\"%d\",&h[i]); for(int i=1;i<=m;++i){ scanf(\"%d%d%d\",&u,&v,&w); if(h[u]>=h[v]) add(u,v,w); if(h[u]<=h[v]) add(v,u,w); } dfs(1); sort(E,E+Cnt+1,Cmp);nod=0; for(int i=1;i<=n;++i) fa[i]=i; for(int i=0;i<=Cnt;++i){ int u=E[i].u,v=E[i].v; ll w=(ll)E[i].w; int uu=getfa(u),vv=getfa(v); if(uu!=vv){ fa[uu]=vv; ans+=w;++nod; } if(nod>=tot-1) break; } printf(\"%d %lld\",tot,ans); return 0; }","title":"\u6700\u5c0f\u751f\u6210\u6811MST"},{"location":"my%20past/OI/MST/#mst","text":"\u57fa\u7840\u65b9\u6cd5\u6709$Kruskal$,$Prim$\u548c$B$\u7b97\u6cd5\uff0c\u5c31\u4e0d\u591a\u8bf4\u4e86\u3002 P2573 \u6ce8\u610f\u5230\u8fd9\u662f\u4e2a\u6709\u5411\u56fe\uff0c\u6240\u4ee5\u4e0d\u80fd\u76f4\u63a5\u7684\u8dd1$kruskal$. \u7b2c\u4e00\u95ee\u5c31\u76f4\u63a5$dfs$\u6c42\u51fa\u70b9\u6570\uff0c\u6ce8\u610f\u6211\u4eec\u53ea\u8981$h[u]\\geq h[v]$\u7684\u8fb9\u3002\u5e76\u4e14\uff0c\u8981\u5c06\u6bcf\u4e2a\u70b9\u62d3\u5c55\u5230\u7684\u8fb9\u8bb0\u5f55\u4e0b\u6765\uff0c\u4f5c\u4e3a\u7b2c\u4e8c\u95ee\u7684\u65b0\u56fe\u3002 \u7b2c\u4e8c\u95ee\u4e2d\uff0c\u6211\u4eec\u8981\u5c06\u8fb9\u6309\u7ec8\u70b9\u9ad8\u5ea6\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\uff0c\u8fb9\u6743\u4e3a\u7b2c\u4e8c\u5173\u952e\u5b57\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u3002 \u81f3\u4e8e\u4e3a\u4ec0\u4e48\u53ea\u6709\u8fd9\u6837\u624d\u5bf9\uff0c\u8003\u8651\u8fd9\u7ec4\u6570\u636e~~made by AKonjac_~~ 4 4 4 3 2 1 1 3 1000000001 1 2 1000000004 2 3 1000000002 2 4 1000000003 \u5982\u679c\u53ea\u6309\u8fb9\u6743\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u751f\u6210\u7684\u6700\u5c0f\u751f\u6210\u6811\u65e0\u6cd5\u5230\u8fbe$2$\u53f7\u70b9\uff0c\u6240\u4ee5\u9519\u8bef\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u4e3a\u4e86\u4fdd\u8bc1\u6709\u5411\u751f\u6210\u6811\u4e00\u5b9a\u8054\u901a\uff0c\u5c31\u8981\u6309\u7167\u7ec8\u70b9\u4ece\u5927\u5230\u5c0f\u7684\u987a\u5e8f\u66f4\u65b0\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define ll long long using namespace std; const int N=1e5+10,M=1e6+10; struct edge{ int u,v,w,nxt; }e[M<<1],E[M<<1]; int fa[N],vis[N],head[N],Head[N],h[N]; int cnt,Cnt,tot,nod,u,v,w,n,m; ll ans; int getfa(int u){ return fa[u]==u?u:fa[u]=getfa(fa[u]); } void add(int u,int v,int w){ e[++cnt].u=u,e[cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void Add(int u,int v,int w){ E[++Cnt].u=u,E[Cnt].v=v,E[Cnt].w=w,E[Cnt].nxt=Head[u],Head[u]=Cnt; } void dfs(int u){ vis[u]=1;++tot; for(int i=head[u];~i;i=e[i].nxt){ int u=e[i].u,v=e[i].v,w=e[i].w; Add(u,v,w); if(!vis[v]) dfs(v); } } bool Cmp(edge a,edge b){ if(h[a.v]==h[b.v]) return a.w<b.w; return h[a.v]>h[b.v]; } int main(){ memset(head,-1,sizeof head);cnt=-1; memset(Head,-1,sizeof Head);Cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i) scanf(\"%d\",&h[i]); for(int i=1;i<=m;++i){ scanf(\"%d%d%d\",&u,&v,&w); if(h[u]>=h[v]) add(u,v,w); if(h[u]<=h[v]) add(v,u,w); } dfs(1); sort(E,E+Cnt+1,Cmp);nod=0; for(int i=1;i<=n;++i) fa[i]=i; for(int i=0;i<=Cnt;++i){ int u=E[i].u,v=E[i].v; ll w=(ll)E[i].w; int uu=getfa(u),vv=getfa(v); if(uu!=vv){ fa[uu]=vv; ans+=w;++nod; } if(nod>=tot-1) break; } printf(\"%d %lld\",tot,ans); return 0; }","title":"\u6700\u5c0f\u751f\u6210\u6811MST"},{"location":"my%20past/OI/NOI%20Online%202022/","text":"NOI Online 2022 \u63d0\u9ad8\uff1a \u4f30\u8ba150+10+10 \u6c11\u95f4\u6570\u636e100+30+10 \u6ca1\u60f3\u5230\u778e\u5199\u7684\u4e3b\u5e2d\u6811\u4e5f\u80fd\u8fc7... ~~\u8bdd\u8bf4\u4e3a\u4ec0\u4e48\u6bcf\u6b21\u6211\u90fd\u88ab\u4eba\u540a\u625310pts~20pts\u5462~~ update:2022.3.31 \u603b\u5206140\uff0c\u548c\u4f30\u7684\u5206\u4e00\u6837\u3002 ~~\u7ec8\u4e8e\u6ca1\u6709\u88ab\u4eba\u540a\u6253\uff0c\u62ff\u4e86\u4e2aTJ\u7b2c\u4e8c\u3002~~ \u666e\u53ca\uff1a \u76f4\u63a5\u6446\u70c2\uff0c\u4f30\u8ba1100+60 updata:2022.3.31 \u603b\u5206145.","title":"NOI Online 2022"},{"location":"my%20past/OI/NOI%20Online%202022/#noi-online-2022","text":"","title":"NOI Online 2022"},{"location":"my%20past/OI/NOI%20Online%202022/#_1","text":"\u4f30\u8ba150+10+10 \u6c11\u95f4\u6570\u636e100+30+10 \u6ca1\u60f3\u5230\u778e\u5199\u7684\u4e3b\u5e2d\u6811\u4e5f\u80fd\u8fc7... ~~\u8bdd\u8bf4\u4e3a\u4ec0\u4e48\u6bcf\u6b21\u6211\u90fd\u88ab\u4eba\u540a\u625310pts~20pts\u5462~~ update:2022.3.31 \u603b\u5206140\uff0c\u548c\u4f30\u7684\u5206\u4e00\u6837\u3002 ~~\u7ec8\u4e8e\u6ca1\u6709\u88ab\u4eba\u540a\u6253\uff0c\u62ff\u4e86\u4e2aTJ\u7b2c\u4e8c\u3002~~","title":"\u63d0\u9ad8\uff1a"},{"location":"my%20past/OI/NOI%20Online%202022/#_2","text":"\u76f4\u63a5\u6446\u70c2\uff0c\u4f30\u8ba1100+60 updata:2022.3.31 \u603b\u5206145.","title":"\u666e\u53ca\uff1a"},{"location":"my%20past/OI/P1633/","text":"\u6211\u4eec\u53ef\u4ee5\u8bbe\u4e00\u4e2a\u4e94\u7ef4\u7684\u72b6\u6001\uff0cf[i][j][k][l][0/1],\u8868\u793aX\u4e2d\u6709i\u4e2a1\uff0cY\u4e2d\u6709j\u4e2a1\uff0cZ\u4e2d\u6709k\u4e2a1\uff0c\u5f53\u524d\u6bd4\u8f83\u5230\u4e86\u7b2cl\u4f4d\uff0c\u4e14Z\u7684\u7b2cl\u4f4d\u662f0\u8fd8\u662f1. \u5bf9\u4e8eX\u548cY\u7684\u7b2cl\u4f4d\uff0c\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u5c31\u662f\u586b0\u62161\uff0c\u6240\u4ee5\u6709\u5982\u4e0b\u8f6c\u79fb\uff1a f[i][j][k][l][0]+0 ->f[i][j][k][l+1][0] //0 0 +(1ll<<l-1) ->f[i][j+1][k+1][l+1][0] //0 1 +(1ll<<l-1) ->f[i+1][j][k+1][l+1][0] //1 0 +(1ll<<l) ->f[i+1][j+1][k+1][l+1][1] //1 1 f[i][j][k][l][1]+0 ->f[i][j][k][l+1][0] //0 0 +(1ll<<l-1) ->f[i][j+1][k][l+1][1] //0 1 +(1ll<<l-1) ->f[i+1][j][k][l+1][1] //1 0 +(1ll<<l) ->f[i+1][j+1][k+1][l+1][1] //1 1 \u6ce8\u610f\u7ed9\u7b2cl\u4f4d\u52a0\u4e2a1\u76f8\u5f53\u4e8e\u7ed9\u539f\u6570\u52a0$2^{l-1}$,\u800c\u4e0d\u662f$2^l$ \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5bf9\u4e8e1111\u548c11111\u8fd9\u4e24\u79cd\u7b2cl\u4f4d\u5206\u522b\u662f0\u548c1\u7684\u60c5\u51b5\uff1a~~(01111\u524d\u5bfc\u96f6\u4e0d\u7528\u7ba1\uff0c\u53ea\u662f\u8868\u793a\u7b2cl\u4f4d\u4e3a0\u800c\u5df2)~~ //\u5de6->\u53f3\u4e3a\u4f4e\u4f4d->\u9ad8\u4f4d l l 11110 ->111100 i 0 j 0 11110 ->111110 i 0 j 1 11110 ->111110 i 1 j 0 11110 ->111111 i 1 j 1 l l 11111 ->111110 i 0 j 0 11111 ->111101 i 0 j 1 11111 ->111101 i 1 j 0 11111 ->111111 i 1 j 1 \u5206\u522b\u52a0\u4e0a\u8d21\u732e\u4ee5\u540e\uff0c\u518d\u53d6\u4e2a\u6700\u5c0f\u503c\u5c31\u884c\u4e86\u3002 \u8fb9\u754c\u662f$f[0][0][0][1][0]=0$,l\u4ece1\u5f00\u59cb. \u5bf9\u8f93\u5165\u7684a,b,c\u6c42\u51fall,na,nb,nc\u90a3\u4e48\u6700\u7ec8\u7b54\u6848\u4e3a$\\min(f[na][nb][nc][0,1,...,ll][0,1])$ \u6ce8\uff1a $f[i][j][k][l][0]+2^{l-1}$\u4e0d\u80fd\u8f6c\u79fb\u7ed9$f[i][j+1][k+1][l][1]$,\u800c\u662f\u8f6c\u79fb\u7ed9$f[i][j][k+1][l+1][0]$ \u56e0\u4e3al\u6ca1\u6709\u79fb\u52a8\u4f4d\u7f6e\uff0c\u4e0b\u6b21\u8fd8\u662f\u5728\u7b2cl\u4f4d\u52a01\uff0c\u6240\u4ee5\u4f1a\u51fa\u73b0X\u6216Y\u540c\u4e00\u4f4d\u52a0\u4e86\u4e24\u6b211\uff0c\u51fa\u73b0\u9519\u8bef\u3002 ~~\u5176\u5b9el\u90a3\u4e00\u7ef4\u53ef\u4ee5\u6eda\u5b58\u7684\uff0c\u4f46\u6211\u61d2~~ Code: #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=33,INF=5e18; int f[N][N][N][N][2]; int n,a,b,c,na,nb,nc,la,lb,lc,ll; void init() { memset(f,0x3f,sizeof f); na=0;nb=0;nc=0;la=0;lb=0;lc=0; while(a) { if(a&1)na++; la++; a>>=1; } while(b) { if(b&1)nb++; lb++; b>>=1; } while(c) { if(c&1)nc++; lc++; c>>=1; } ll=max(la,max(lb,lc)); } void work() { f[0][0][0][1][0]=0; for(int i=0; i<=na; ++i) { for(int j=0; j<=nb; ++j) { for(int k=0; k<=nc; ++k) { for(int l=1; l<=ll; ++l) { f[i][j][k][l+1][0]=min(f[i][j][k][l+1][0],min(f[i][j][k][l][0],f[i][j][k][l][1])); f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1],min(f[i][j][k][l][0],f[i][j][k][l][1])+(1ll<<l));//\u6ce8\u610f\u5199\u6cd5\uff0c1ll<<l\u8981\u52a0\u62ec\u53f7 f[i][j+1][k+1][l+1][0]=min(f[i][j+1][k+1][l+1][0],f[i][j][k][l][0]+(1ll<<l-1)); f[i+1][j][k+1][l+1][0]=min(f[i+1][j][k+1][l+1][0],f[i][j][k][l][0]+(1ll<<l-1)); f[i][j+1][k][l+1][1]=min(f[i][j+1][k][l+1][1],f[i][j][k][l][1]+(1ll<<l-1)); f[i+1][j][k][l+1][1]=min(f[i+1][j][k][l+1][1],f[i][j][k][l][1]+(1ll<<l-1)); } } } } } signed main() { scanf(\"%lld\",&n); for(int i=1; i<=n; ++i) { scanf(\"%lld%lld%lld\",&a,&b,&c); init();//\u521d\u59cb\u5316 work();//dp int ans=INF; for(int i=0; i<=ll; ++i) { int tmp1=f[na][nb][nc][i][0],cnt1=0; int tmp2=f[na][nb][nc][i][1],cnt2=0; while(tmp1>0)tmp1>>=1,cnt1++; while(tmp2>0)tmp2>>=1,cnt2++; if(cnt1<=ll && cnt1>0)ans=min(ans,f[na][nb][nc][i][0]);//\u6240\u6709\u6ee1\u8db3\u6761\u4ef6\u7684\u6570\u4e2d\u53d6\u6700\u5c0f\u503c if(cnt2<=ll && cnt2>0)ans=min(ans,f[na][nb][nc][i][1]); } if(ans==INF)printf(\"-1\\n\"); else printf(\"%lld\\n\",ans); } return 0; }","title":"P1633"},{"location":"my%20past/OI/STL/","text":"STL vector \u6a21\u677f\uff08\u57fa\u672c\u64cd\u4f5c\uff09 #include <vector> #include <iostream> #include <algorithm> using namespace std; int main() { //\u987a\u5e8f\u8bbf\u95ee vector<int>obj; for(int i=0;i<10;i++) { obj.push_back(i); } cout<<\"\u76f4\u63a5\u5229\u7528\u6570\u7ec4\uff1a\"; for(int i=0;i<10;i++)//\u65b9\u6cd5\u4e00 { cout<<obj[i]<<\" \"; } cout<<endl; cout<<\"\u5229\u7528\u8fed\u4ee3\u5668\uff1a\" ; //\u65b9\u6cd5\u4e8c\uff0c\u4f7f\u7528\u8fed\u4ee3\u5668\u5c06\u5bb9\u5668\u4e2d\u6570\u636e\u8f93\u51fa vector<int>::iterator it;//\u58f0\u660e\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u6765\u8bbf\u95eevector\u5bb9\u5668\uff0c\u4f5c\u7528\uff1a\u904d\u5386\u6216\u8005\u6307\u5411vector\u5bb9\u5668\u7684\u5143\u7d20 for(it=obj.begin();it!=obj.end();it++) { cout<<*it<<\" \"; } return 0; } vector + lower_bound(upper_bound) //\u67e5\u8be2 int pl=(lower_bound(v[c].begin(),v[c].end(),l)-v[c].begin()); //\u4fee\u6539 //1.lower_bound\u8fd4\u56de\u5730\u5740\uff0c\u6240\u4ee5\u76f4\u63a5\u53d6\u503c (*lower_bound(a.begin(),a.end(),x))++; //2.\u5c06\u4f4d\u7f6e\u53d6\u51fa\u6765\uff0c\u518d\u505a\u66f4\u6539\uff0c\u66f4\u76f4\u89c2 int pl=lower_bound(a.begin(),a.end(),x)-a.begin(); a[pl]++; P3939 \u76f4\u63a5\u7528vector< int> v[N]\u4fdd\u5b58\u503c\u57df\u4e2d\u6bcf\u4e2a\u6570\u51fa\u73b0\u7684\u4f4d\u7f6e\uff0c\u67e5\u8be2\u548c\u4fee\u6539\u90fd\u7528\u4e8c\u5206\u67e5\u627e\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<vector> #include<algorithm> using namespace std; const int N=3e5+10; vector<int> v[N]; int n,m,l,r,c,x,op; int a[N]; int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=1;i<=n;++i){ v[a[i]].push_back(i); } for(int i=1;i<=m;++i){ scanf(\"%d\",&op); if(op==1){ scanf(\"%d%d%d\",&l,&r,&c); int pl=(lower_bound(v[c].begin(),v[c].end(),l)-v[c].begin()); int pr=(upper_bound(v[c].begin(),v[c].end(),r)-v[c].begin()-1); printf(\"%d\\n\",pr-pl+1); }else{ scanf(\"%d\",&x); int tx=a[x]; int ty=a[x+1]; if(tx!=ty){ int pl=lower_bound(v[tx].begin(),v[tx].end(),x)-v[tx].begin(); int pr=lower_bound(v[ty].begin(),v[ty].end(),x+1)-v[ty].begin(); v[tx][pl]++; v[ty][pr]--; //(*lower_bound(v[tx].begin(),v[tx].end(),x))++; //(*lower_bound(v[ty].begin(),v[ty].end(),x+1))--; swap(a[x],a[x+1]); } } } return 0; } STL\u8fed\u4ee3\u5668 Iterator\uff08\u8fed\u4ee3\u5668\uff09\u6a21\u5f0f\u53c8\u79f0Cursor\uff08\u6e38\u6807\uff09\u6a21\u5f0f\uff0c\u7528\u4e8e\u63d0\u4f9b\u4e00\u79cd\u65b9\u6cd5\u987a\u5e8f\u8bbf\u95ee\u4e00\u4e2a\u805a\u5408\u5bf9\u8c61\u4e2d\u5404\u4e2a\u5143\u7d20, \u800c\u53c8\u4e0d\u9700\u66b4\u9732\u8be5\u5bf9\u8c61\u7684\u5185\u90e8\u8868\u793a\u3002\u6216\u8005\u8fd9\u6837\u8bf4\u53ef\u80fd\u66f4\u5bb9\u6613\u7406\u89e3\uff1aIterator\u6a21\u5f0f\u662f\u8fd0\u7528\u4e8e\u805a\u5408\u5bf9\u8c61\u7684\u4e00\u79cd\u6a21\u5f0f\uff0c\u901a\u8fc7\u8fd0\u7528\u8be5\u6a21\u5f0f\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5728\u4e0d\u77e5\u9053\u5bf9\u8c61\u5185\u90e8\u8868\u793a\u7684\u60c5\u51b5\u4e0b\uff0c\u6309\u7167\u4e00\u5b9a\u987a\u5e8f\uff08\u7531iterator\u63d0\u4f9b\u7684\u65b9\u6cd5\uff09\u8bbf\u95ee\u805a\u5408\u5bf9\u8c61\u4e2d\u7684\u5404\u4e2a\u5143\u7d20\u3002 \u8fed\u4ee3\u5668\u7684\u4f5c\u7528\uff1a\u80fd\u591f\u8ba9\u8fed\u4ee3\u5668\u4e0e\u7b97\u6cd5\u4e0d\u5e72\u6270\u7684\u76f8\u4e92\u53d1\u5c55\uff0c\u6700\u540e\u53c8\u80fd\u65e0\u95f4\u9699\u7684\u7c98\u5408\u8d77\u6765\uff0c\u91cd\u8f7d\u4e86* \uff0c\uff0b\uff0b\uff0c\uff1d\uff1d\uff0c\uff01\uff1d\uff0c\uff1d\u8fd0\u7b97\u7b26\u3002\u7528\u4ee5\u64cd\u4f5c\u590d\u6742\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5bb9\u5668\u63d0\u4f9b\u8fed\u4ee3\u5668\uff0c\u7b97\u6cd5\u4f7f\u7528\u8fed\u4ee3\u5668\uff1b\u5e38\u89c1\u7684\u4e00\u4e9b\u8fed\u4ee3\u5668\u7c7b\u578b\uff1aiterator\u3001const_iterator\u3001reverse_iterator\u548cconst_reverse_iterator.","title":"STL"},{"location":"my%20past/OI/STL/#stl","text":"","title":"STL"},{"location":"my%20past/OI/STL/#vector","text":"","title":"vector"},{"location":"my%20past/OI/STL/#_1","text":"#include <vector> #include <iostream> #include <algorithm> using namespace std; int main() { //\u987a\u5e8f\u8bbf\u95ee vector<int>obj; for(int i=0;i<10;i++) { obj.push_back(i); } cout<<\"\u76f4\u63a5\u5229\u7528\u6570\u7ec4\uff1a\"; for(int i=0;i<10;i++)//\u65b9\u6cd5\u4e00 { cout<<obj[i]<<\" \"; } cout<<endl; cout<<\"\u5229\u7528\u8fed\u4ee3\u5668\uff1a\" ; //\u65b9\u6cd5\u4e8c\uff0c\u4f7f\u7528\u8fed\u4ee3\u5668\u5c06\u5bb9\u5668\u4e2d\u6570\u636e\u8f93\u51fa vector<int>::iterator it;//\u58f0\u660e\u4e00\u4e2a\u8fed\u4ee3\u5668\uff0c\u6765\u8bbf\u95eevector\u5bb9\u5668\uff0c\u4f5c\u7528\uff1a\u904d\u5386\u6216\u8005\u6307\u5411vector\u5bb9\u5668\u7684\u5143\u7d20 for(it=obj.begin();it!=obj.end();it++) { cout<<*it<<\" \"; } return 0; }","title":"\u6a21\u677f\uff08\u57fa\u672c\u64cd\u4f5c\uff09"},{"location":"my%20past/OI/STL/#vector-lower_boundupper_bound","text":"//\u67e5\u8be2 int pl=(lower_bound(v[c].begin(),v[c].end(),l)-v[c].begin()); //\u4fee\u6539 //1.lower_bound\u8fd4\u56de\u5730\u5740\uff0c\u6240\u4ee5\u76f4\u63a5\u53d6\u503c (*lower_bound(a.begin(),a.end(),x))++; //2.\u5c06\u4f4d\u7f6e\u53d6\u51fa\u6765\uff0c\u518d\u505a\u66f4\u6539\uff0c\u66f4\u76f4\u89c2 int pl=lower_bound(a.begin(),a.end(),x)-a.begin(); a[pl]++; P3939 \u76f4\u63a5\u7528vector< int> v[N]\u4fdd\u5b58\u503c\u57df\u4e2d\u6bcf\u4e2a\u6570\u51fa\u73b0\u7684\u4f4d\u7f6e\uff0c\u67e5\u8be2\u548c\u4fee\u6539\u90fd\u7528\u4e8c\u5206\u67e5\u627e\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<vector> #include<algorithm> using namespace std; const int N=3e5+10; vector<int> v[N]; int n,m,l,r,c,x,op; int a[N]; int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=1;i<=n;++i){ v[a[i]].push_back(i); } for(int i=1;i<=m;++i){ scanf(\"%d\",&op); if(op==1){ scanf(\"%d%d%d\",&l,&r,&c); int pl=(lower_bound(v[c].begin(),v[c].end(),l)-v[c].begin()); int pr=(upper_bound(v[c].begin(),v[c].end(),r)-v[c].begin()-1); printf(\"%d\\n\",pr-pl+1); }else{ scanf(\"%d\",&x); int tx=a[x]; int ty=a[x+1]; if(tx!=ty){ int pl=lower_bound(v[tx].begin(),v[tx].end(),x)-v[tx].begin(); int pr=lower_bound(v[ty].begin(),v[ty].end(),x+1)-v[ty].begin(); v[tx][pl]++; v[ty][pr]--; //(*lower_bound(v[tx].begin(),v[tx].end(),x))++; //(*lower_bound(v[ty].begin(),v[ty].end(),x+1))--; swap(a[x],a[x+1]); } } } return 0; }","title":"vector + lower_bound(upper_bound)"},{"location":"my%20past/OI/STL/#stl_1","text":"Iterator\uff08\u8fed\u4ee3\u5668\uff09\u6a21\u5f0f\u53c8\u79f0Cursor\uff08\u6e38\u6807\uff09\u6a21\u5f0f\uff0c\u7528\u4e8e\u63d0\u4f9b\u4e00\u79cd\u65b9\u6cd5\u987a\u5e8f\u8bbf\u95ee\u4e00\u4e2a\u805a\u5408\u5bf9\u8c61\u4e2d\u5404\u4e2a\u5143\u7d20, \u800c\u53c8\u4e0d\u9700\u66b4\u9732\u8be5\u5bf9\u8c61\u7684\u5185\u90e8\u8868\u793a\u3002\u6216\u8005\u8fd9\u6837\u8bf4\u53ef\u80fd\u66f4\u5bb9\u6613\u7406\u89e3\uff1aIterator\u6a21\u5f0f\u662f\u8fd0\u7528\u4e8e\u805a\u5408\u5bf9\u8c61\u7684\u4e00\u79cd\u6a21\u5f0f\uff0c\u901a\u8fc7\u8fd0\u7528\u8be5\u6a21\u5f0f\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5728\u4e0d\u77e5\u9053\u5bf9\u8c61\u5185\u90e8\u8868\u793a\u7684\u60c5\u51b5\u4e0b\uff0c\u6309\u7167\u4e00\u5b9a\u987a\u5e8f\uff08\u7531iterator\u63d0\u4f9b\u7684\u65b9\u6cd5\uff09\u8bbf\u95ee\u805a\u5408\u5bf9\u8c61\u4e2d\u7684\u5404\u4e2a\u5143\u7d20\u3002 \u8fed\u4ee3\u5668\u7684\u4f5c\u7528\uff1a\u80fd\u591f\u8ba9\u8fed\u4ee3\u5668\u4e0e\u7b97\u6cd5\u4e0d\u5e72\u6270\u7684\u76f8\u4e92\u53d1\u5c55\uff0c\u6700\u540e\u53c8\u80fd\u65e0\u95f4\u9699\u7684\u7c98\u5408\u8d77\u6765\uff0c\u91cd\u8f7d\u4e86* \uff0c\uff0b\uff0b\uff0c\uff1d\uff1d\uff0c\uff01\uff1d\uff0c\uff1d\u8fd0\u7b97\u7b26\u3002\u7528\u4ee5\u64cd\u4f5c\u590d\u6742\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5bb9\u5668\u63d0\u4f9b\u8fed\u4ee3\u5668\uff0c\u7b97\u6cd5\u4f7f\u7528\u8fed\u4ee3\u5668\uff1b\u5e38\u89c1\u7684\u4e00\u4e9b\u8fed\u4ee3\u5668\u7c7b\u578b\uff1aiterator\u3001const_iterator\u3001reverse_iterator\u548cconst_reverse_iterator.","title":"STL\u8fed\u4ee3\u5668"},{"location":"my%20past/OI/Trie/","text":"Trie 0-1 Trie \u5e38\u89c1\u5e94\u7528: \u5f02\u6216\u7c7b\u95ee\u9898 CF888G \u9898\u76ee\u8981\u6c42\u7528\u4e24\u4e2a\u6743\u503c\u76f8\u4e92\u5f02\u6216\u5f97\u51fa\u7684\u8fb9\u6c42\u6700\u5c0f\u751f\u6210\u6811\uff0c\u4e00\u5171$\\frac{n(n-1)}{2}$\u6761\u8fb9\u3002 \u5982\u679c\u6211\u4eec\u5bf9\u4e8e$n$\u4e2a\u6743\u503c\u5efa\u51fa$0-1 Trie $\u6811\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0$u,v$\u7684\u5f02\u6216\u503c\u5c31\u662f\u4ece$lca_{u,v}$\u5206\u522b\u5230$u,v$\u6240\u8868\u793a\u7684\u6570\u7684\u5f02\u6216\u503c(\u56e0\u4e3a$lca$\u4e4b\u524d\u5f02\u6216\u6ca1\u4e86)\uff0c\u90a3\u4e48\u6211\u4eec\u6240\u6c42\u7684\u6070\u597d\u8f6c\u5316\u4e3a\u6c42\u51fa\u6240\u6709\u53ef\u80fd\u7684$lca$\u3002 \u770b\u56fe\u4f1a\u53d1\u73b0\uff0c\u5982\u679c\u70b9\u6743\u503c\u4e92\u4e0d\u76f8\u540c\uff0c\u90a3\u4e48\u8fd9\u6837\u7684$lca$\u6070\u6709$n-1$\u4e2a\uff0c\u6ee1\u8db3\u751f\u6210\u6811\u7684\u6761\u4ef6\u3002\u5982\u679c\u6709\u76f8\u540c\u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u76f8\u5f53\u4e8e\u591a\u51fa\u4e86\u51e0\u6761\u8fb9\u6743\u4e3a$0$\u7684\u8fb9\uff0c\u7531\u4e8e\u4e00\u5b9a\u8981\u9009\uff0c\u6545\u4e0d\u5f71\u54cd\u6700\u7ec8\u7b54\u6848\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u76f4\u63a5\u5728$Trie$\u6811\u4e0a$dfs$,\u5982\u679c\u78b0\u5230\u6709\u4e24\u4e2a\u5b50\u8282\u70b9\u7684$lca$,\u5c31\u641c\u7d22\u4e00\u904d\u5b50\u6811\uff0c\u5f97\u51fa\u7b54\u6848\u3002(\u641c\u7d22\u51fd\u6570\u4f5c\u7528\u662f\u5728\u4e24\u4e2a\u4e0d\u540c\u5b50\u6811\u4e2d\u5206\u522b\u627e\u51fa\u4e00\u4e2a\u53f6\u5b50\u8282\u70b9\uff0c\u4f7f\u5176\u5f02\u6216\u548c\u6700\u5c0f) \u800c\u641c\u7d22\u51fd\u6570$find$\u4e2d\uff0c\u8981\u5206\u60c5\u51b5\u8ba8\u8bba\u3002 \u5f53\u524d\u6df1\u5ea6\u65e0\u8d21\u732e \u5373\u4ece\u5f53\u524d\u8282\u70b9\u5230\u4e24\u4e2a\u5b50\u8282\u70b9\u7684\u8fb9\u76f8\u540c\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f\u4e24\u4e2a\u5b50\u6811\u7684\u7b54\u6848\u53d6$\\min$. \u5f53\u524d\u6df1\u5ea6\u6709\u8d21\u732e \u5373\u4e24\u6761\u8fb9\u4e0d\u540c\uff0c\u90a3\u4e48\u7b54\u6848\u662f\u4e24\u5b50\u6811\u7b54\u6848\u53d6$\\min$\u52a0\u4e0a$2^{dep}$. \u5982\u679c\u6ca1\u6709\u6ee1\u8db3\u6761\u4ef6\u7684\u4e24\u6761\u8fb9\uff0c\u5c31\u8fd4\u56de$INF$. \u5982\u679c\u4e24\u79cd\u60c5\u51b5\u4e0b\u4e24\u4e2a\u5b50\u6811\u90fd\u662f$INF$,\u5c31\u8bf4\u660e\u4e24\u4e2a\u5b50\u6811\u5df2\u7ecf\u662f\u53f6\u5b50\u8282\u70b9\uff0c\u5219\u8fd4\u56de$0$. #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2e5+10,DEP=30,M=N*DEP,INF=1e18; int n,m,tot,rt,ans; int a[N]; int T[M][2]; bool cmp(int a,int b){ return a<b; } void Insert(int now,int x){ for(int i=DEP;i>=0;--i){ int id=(x>>i)&1; if(!T[now][id]) T[now][id]=++tot; now=T[now][id]; } } int Find(int r1,int r2,int dep){ if(dep<0) return 0; int a1=INF,a2=INF,a=-1; if(T[r1][0] && T[r2][0]) a1=Find(T[r1][0],T[r2][0],dep-1); if(T[r1][1] && T[r2][1]) a2=Find(T[r1][1],T[r2][1],dep-1); a=min(a1,a2); if(a!=INF) return a; a1=INF,a2=INF,a=-1; if(T[r1][0] && T[r2][1]) a1=Find(T[r1][0],T[r2][1],dep-1)+(1ll<<dep); if(T[r1][1] && T[r2][0]) a2=Find(T[r1][1],T[r2][0],dep-1)+(1ll<<dep); a=min(a1,a2); if(a!=INF) return a; return 0; } void dfs(int x,int dep){ if(dep<0) return; if(T[x][0] && T[x][1]) ans+=Find(T[x][0],T[x][1],dep-1)+(1ll<<dep); if(T[x][0]) dfs(T[x][0],dep-1); if(T[x][1]) dfs(T[x][1],dep-1); } signed main(){ scanf(\"%lld\",&n);rt=tot=ans=0; for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i]),Insert(rt,a[i]); dfs(rt,DEP); printf(\"%lld\",ans); return 0; }","title":"Trie"},{"location":"my%20past/OI/Trie/#trie","text":"","title":"Trie"},{"location":"my%20past/OI/Trie/#0-1-trie","text":"\u5e38\u89c1\u5e94\u7528: \u5f02\u6216\u7c7b\u95ee\u9898 CF888G \u9898\u76ee\u8981\u6c42\u7528\u4e24\u4e2a\u6743\u503c\u76f8\u4e92\u5f02\u6216\u5f97\u51fa\u7684\u8fb9\u6c42\u6700\u5c0f\u751f\u6210\u6811\uff0c\u4e00\u5171$\\frac{n(n-1)}{2}$\u6761\u8fb9\u3002 \u5982\u679c\u6211\u4eec\u5bf9\u4e8e$n$\u4e2a\u6743\u503c\u5efa\u51fa$0-1 Trie $\u6811\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0$u,v$\u7684\u5f02\u6216\u503c\u5c31\u662f\u4ece$lca_{u,v}$\u5206\u522b\u5230$u,v$\u6240\u8868\u793a\u7684\u6570\u7684\u5f02\u6216\u503c(\u56e0\u4e3a$lca$\u4e4b\u524d\u5f02\u6216\u6ca1\u4e86)\uff0c\u90a3\u4e48\u6211\u4eec\u6240\u6c42\u7684\u6070\u597d\u8f6c\u5316\u4e3a\u6c42\u51fa\u6240\u6709\u53ef\u80fd\u7684$lca$\u3002 \u770b\u56fe\u4f1a\u53d1\u73b0\uff0c\u5982\u679c\u70b9\u6743\u503c\u4e92\u4e0d\u76f8\u540c\uff0c\u90a3\u4e48\u8fd9\u6837\u7684$lca$\u6070\u6709$n-1$\u4e2a\uff0c\u6ee1\u8db3\u751f\u6210\u6811\u7684\u6761\u4ef6\u3002\u5982\u679c\u6709\u76f8\u540c\u7684\u60c5\u51b5\uff0c\u90a3\u4e48\u76f8\u5f53\u4e8e\u591a\u51fa\u4e86\u51e0\u6761\u8fb9\u6743\u4e3a$0$\u7684\u8fb9\uff0c\u7531\u4e8e\u4e00\u5b9a\u8981\u9009\uff0c\u6545\u4e0d\u5f71\u54cd\u6700\u7ec8\u7b54\u6848\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u76f4\u63a5\u5728$Trie$\u6811\u4e0a$dfs$,\u5982\u679c\u78b0\u5230\u6709\u4e24\u4e2a\u5b50\u8282\u70b9\u7684$lca$,\u5c31\u641c\u7d22\u4e00\u904d\u5b50\u6811\uff0c\u5f97\u51fa\u7b54\u6848\u3002(\u641c\u7d22\u51fd\u6570\u4f5c\u7528\u662f\u5728\u4e24\u4e2a\u4e0d\u540c\u5b50\u6811\u4e2d\u5206\u522b\u627e\u51fa\u4e00\u4e2a\u53f6\u5b50\u8282\u70b9\uff0c\u4f7f\u5176\u5f02\u6216\u548c\u6700\u5c0f) \u800c\u641c\u7d22\u51fd\u6570$find$\u4e2d\uff0c\u8981\u5206\u60c5\u51b5\u8ba8\u8bba\u3002 \u5f53\u524d\u6df1\u5ea6\u65e0\u8d21\u732e \u5373\u4ece\u5f53\u524d\u8282\u70b9\u5230\u4e24\u4e2a\u5b50\u8282\u70b9\u7684\u8fb9\u76f8\u540c\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f\u4e24\u4e2a\u5b50\u6811\u7684\u7b54\u6848\u53d6$\\min$. \u5f53\u524d\u6df1\u5ea6\u6709\u8d21\u732e \u5373\u4e24\u6761\u8fb9\u4e0d\u540c\uff0c\u90a3\u4e48\u7b54\u6848\u662f\u4e24\u5b50\u6811\u7b54\u6848\u53d6$\\min$\u52a0\u4e0a$2^{dep}$. \u5982\u679c\u6ca1\u6709\u6ee1\u8db3\u6761\u4ef6\u7684\u4e24\u6761\u8fb9\uff0c\u5c31\u8fd4\u56de$INF$. \u5982\u679c\u4e24\u79cd\u60c5\u51b5\u4e0b\u4e24\u4e2a\u5b50\u6811\u90fd\u662f$INF$,\u5c31\u8bf4\u660e\u4e24\u4e2a\u5b50\u6811\u5df2\u7ecf\u662f\u53f6\u5b50\u8282\u70b9\uff0c\u5219\u8fd4\u56de$0$. #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2e5+10,DEP=30,M=N*DEP,INF=1e18; int n,m,tot,rt,ans; int a[N]; int T[M][2]; bool cmp(int a,int b){ return a<b; } void Insert(int now,int x){ for(int i=DEP;i>=0;--i){ int id=(x>>i)&1; if(!T[now][id]) T[now][id]=++tot; now=T[now][id]; } } int Find(int r1,int r2,int dep){ if(dep<0) return 0; int a1=INF,a2=INF,a=-1; if(T[r1][0] && T[r2][0]) a1=Find(T[r1][0],T[r2][0],dep-1); if(T[r1][1] && T[r2][1]) a2=Find(T[r1][1],T[r2][1],dep-1); a=min(a1,a2); if(a!=INF) return a; a1=INF,a2=INF,a=-1; if(T[r1][0] && T[r2][1]) a1=Find(T[r1][0],T[r2][1],dep-1)+(1ll<<dep); if(T[r1][1] && T[r2][0]) a2=Find(T[r1][1],T[r2][0],dep-1)+(1ll<<dep); a=min(a1,a2); if(a!=INF) return a; return 0; } void dfs(int x,int dep){ if(dep<0) return; if(T[x][0] && T[x][1]) ans+=Find(T[x][0],T[x][1],dep-1)+(1ll<<dep); if(T[x][0]) dfs(T[x][0],dep-1); if(T[x][1]) dfs(T[x][1],dep-1); } signed main(){ scanf(\"%lld\",&n);rt=tot=ans=0; for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i]),Insert(rt,a[i]); dfs(rt,DEP); printf(\"%lld\",ans); return 0; }","title":"0-1 Trie"},{"location":"my%20past/OI/algorithm/","text":"algorithm \u4e8c\u5206\u67e5\u627e 1.lower_bound(\u8d77\u59cb\u5730\u5740\uff0c\u7ed3\u675f\u5730\u5740\uff0c\u8981\u67e5\u627e\u7684\u6570\u503c) \u8fd4\u56de\u7684\u662f\u6570\u503c \u7b2c\u4e00\u4e2a \u51fa\u73b0\u7684\u4f4d\u7f6e\u3002(\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e \u6570\u503c \u7684\u6570\u7684\u4f4d\u7f6e) 2.upper_bound(\u8d77\u59cb\u5730\u5740\uff0c\u7ed3\u675f\u5730\u5740\uff0c\u8981\u67e5\u627e\u7684\u6570\u503c) \u8fd4\u56de\u7684\u662f\u6570\u503c \u6700\u540e\u4e00\u4e2a \u51fa\u73b0\u7684\u4f4d\u7f6e\u3002(\u7b2c\u4e00\u4e2a\u5927\u4e8e \u6570\u503c \u7684\u6570\u7684\u4f4d\u7f6e) 3.binary_search(\u8d77\u59cb\u5730\u5740\uff0c\u7ed3\u675f\u5730\u5740\uff0c\u8981\u67e5\u627e\u7684\u6570\u503c) \u8fd4\u56de\u7684\u662f\u662f\u5426\u5b58\u5728\u8fd9\u4e48\u4e00\u4e2a\u6570\uff0c\u662f\u4e00\u4e2abool\u503c\u3002 gcd __gcd(x,y)\u8f97\u8f6c\u76f8\u9664\u6cd5\u6c42\u4e24\u6570\u7684gcd unique int tot=unique(a+1,a+n+1)-a-1;//\u7b2c\u4e00\u79cd\uff0c\u5bf9\u6570\u7ec4\u76f4\u63a5\u53bb\u91cd int tot=unique(a+1,a+n+1,cmp)-a-1;//\u7b2c\u4e8c\u79cd\uff0c\u5bf9\u7ed3\u6784\u4f53\u53bb\u91cd\uff0c\u53ef\u4ee5\u81ea\u5b9a\u4e49\u5143\u7d20\u662f\u5426\u76f8\u7b49\uff0c\u6bd4\u5982\u53ea\u5224\u65ad\u7ed3\u6784\u4f53\u67d0\u4e00\u5143\u7d20","title":"algorithm"},{"location":"my%20past/OI/algorithm/#algorithm","text":"","title":"algorithm"},{"location":"my%20past/OI/algorithm/#_1","text":"1.lower_bound(\u8d77\u59cb\u5730\u5740\uff0c\u7ed3\u675f\u5730\u5740\uff0c\u8981\u67e5\u627e\u7684\u6570\u503c) \u8fd4\u56de\u7684\u662f\u6570\u503c \u7b2c\u4e00\u4e2a \u51fa\u73b0\u7684\u4f4d\u7f6e\u3002(\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e \u6570\u503c \u7684\u6570\u7684\u4f4d\u7f6e) 2.upper_bound(\u8d77\u59cb\u5730\u5740\uff0c\u7ed3\u675f\u5730\u5740\uff0c\u8981\u67e5\u627e\u7684\u6570\u503c) \u8fd4\u56de\u7684\u662f\u6570\u503c \u6700\u540e\u4e00\u4e2a \u51fa\u73b0\u7684\u4f4d\u7f6e\u3002(\u7b2c\u4e00\u4e2a\u5927\u4e8e \u6570\u503c \u7684\u6570\u7684\u4f4d\u7f6e) 3.binary_search(\u8d77\u59cb\u5730\u5740\uff0c\u7ed3\u675f\u5730\u5740\uff0c\u8981\u67e5\u627e\u7684\u6570\u503c) \u8fd4\u56de\u7684\u662f\u662f\u5426\u5b58\u5728\u8fd9\u4e48\u4e00\u4e2a\u6570\uff0c\u662f\u4e00\u4e2abool\u503c\u3002","title":"\u4e8c\u5206\u67e5\u627e"},{"location":"my%20past/OI/algorithm/#gcd","text":"__gcd(x,y)\u8f97\u8f6c\u76f8\u9664\u6cd5\u6c42\u4e24\u6570\u7684gcd","title":"gcd"},{"location":"my%20past/OI/algorithm/#unique","text":"int tot=unique(a+1,a+n+1)-a-1;//\u7b2c\u4e00\u79cd\uff0c\u5bf9\u6570\u7ec4\u76f4\u63a5\u53bb\u91cd int tot=unique(a+1,a+n+1,cmp)-a-1;//\u7b2c\u4e8c\u79cd\uff0c\u5bf9\u7ed3\u6784\u4f53\u53bb\u91cd\uff0c\u53ef\u4ee5\u81ea\u5b9a\u4e49\u5143\u7d20\u662f\u5426\u76f8\u7b49\uff0c\u6bd4\u5982\u53ea\u5224\u65ad\u7ed3\u6784\u4f53\u67d0\u4e00\u5143\u7d20","title":"unique"},{"location":"my%20past/OI/cstring/","text":"cstring strcmp \u6bd4\u8f83\u4e24\u4e2a\u5b57\u7b26\u4e32\uff0cstr1>str2\u8fd4\u56de\u6b63\u6570\uff0cstr1==str2\u8fd4\u56de0,str1< str2\u8fd4\u56de\u8d1f\u6570 sscanf \u8bfb\u53d6\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u4e32(?) //0.\u683c\u5f0f sscanf(a,\".......\",b);//a\u4e32\uff0c\u6b63\u5219\u8868\u8fbe\u5f0f\uff0cb\u4e32 //1.\u8bfb\u53d6\u6307\u5b9a\u7684\u5b57\u7b26\u96c6\uff1a sscanf(a,\"%[a-z1-9A-Z]\",b); //2.\u8df3\u8fc7\u8bfb\u53d6 sscanf(a,\"%*[]%*s%*d %s%[]%d\",b); //3.\u8bfb\u53d6\u6307\u5b9a\u4e00\u6bb5\u533a\u95f4\u7684\u5b57\u7b26\uff0c\u5c24\u5176\u662f\u4e00\u6574\u884c\u5e26\u7a7a\u683c\u7684\u5b57\u7b26\u4e32\uff0c\u50cf\u8bfb\u53d6\u6bcf\u4e2a\u5c0f\u4e32\uff0c\u5c31\u8981\u5728\u6bcf\u4e2a\u7a7a\u683c\u5904\u6253\u6807\u8bb0'$' sscanf(a,\"%*[^$]$%[^ ]\",b); \u8f93\u5165\u8f93\u51fa 1.puts(),gets()\u5e26\u7a7a\u683c 2.scanf(),printf()\u4e0d\u5e26\u7a7a\u683c \u4e24\u79cd\u8f93\u5165\u78b0\u5230\u6362\u884c\u90fd\u7ed3\u675f","title":"cstring"},{"location":"my%20past/OI/cstring/#cstring","text":"","title":"cstring"},{"location":"my%20past/OI/cstring/#strcmp","text":"\u6bd4\u8f83\u4e24\u4e2a\u5b57\u7b26\u4e32\uff0cstr1>str2\u8fd4\u56de\u6b63\u6570\uff0cstr1==str2\u8fd4\u56de0,str1< str2\u8fd4\u56de\u8d1f\u6570","title":"strcmp"},{"location":"my%20past/OI/cstring/#sscanf","text":"\u8bfb\u53d6\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\u4e32(?) //0.\u683c\u5f0f sscanf(a,\".......\",b);//a\u4e32\uff0c\u6b63\u5219\u8868\u8fbe\u5f0f\uff0cb\u4e32 //1.\u8bfb\u53d6\u6307\u5b9a\u7684\u5b57\u7b26\u96c6\uff1a sscanf(a,\"%[a-z1-9A-Z]\",b); //2.\u8df3\u8fc7\u8bfb\u53d6 sscanf(a,\"%*[]%*s%*d %s%[]%d\",b); //3.\u8bfb\u53d6\u6307\u5b9a\u4e00\u6bb5\u533a\u95f4\u7684\u5b57\u7b26\uff0c\u5c24\u5176\u662f\u4e00\u6574\u884c\u5e26\u7a7a\u683c\u7684\u5b57\u7b26\u4e32\uff0c\u50cf\u8bfb\u53d6\u6bcf\u4e2a\u5c0f\u4e32\uff0c\u5c31\u8981\u5728\u6bcf\u4e2a\u7a7a\u683c\u5904\u6253\u6807\u8bb0'$' sscanf(a,\"%*[^$]$%[^ ]\",b);","title":"sscanf"},{"location":"my%20past/OI/cstring/#_1","text":"1.puts(),gets()\u5e26\u7a7a\u683c 2.scanf(),printf()\u4e0d\u5e26\u7a7a\u683c \u4e24\u79cd\u8f93\u5165\u78b0\u5230\u6362\u884c\u90fd\u7ed3\u675f","title":"\u8f93\u5165\u8f93\u51fa"},{"location":"my%20past/OI/dp/","text":"\u671f\u671bdp P1850 \u8bbe$f[i][j][0/1]$\u8868\u793a\u8003\u8651\u5230\u7b2c$i$\u4e2a\u6559\u5ba4\uff0c\u7528\u4e86$j$\u6b21\u4ea4\u6362\u6743\u5e76\u4e14$i$\u6362\u4e0e\u4e0d\u6362\u7684\u6700\u5c0f\u503c\u3002 \u6bcf\u6b21\u7684\u65b0\u8d21\u732e\u53ea\u7528\u8003\u8651$i$\u4e0e$i-1$\u4e4b\u95f4\u7684\u6700\u77ed\u8def\u4ee5\u53ca\u4ed6\u4eec\u6210\u529f\u7684\u6982\u7387. #include<iostream> #include<cstdio> #include<cstring> #define db double using namespace std; const int N=2200,V=330; const double INF=1e18; int dis[N][N]; int n,m,v,e,a,b,w; db f[N][N][2]; struct room{ int c,d;db k; }s[N]; void floyd(){ for(int i=1;i<=v;++i)dis[i][i]=0; for(int k=1;k<=v;++k) for(int i=1;i<=v;++i) for(int j=1;j<=v;++j){ if(i==j)continue; dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); } } void init(){ memset(dis,0x3f,sizeof dis); for(int i=0;i<=n+1;++i) for(int j=0;j<=m+1;++j) f[i][j][0]=f[i][j][1]=INF; } inline db Min(db a,db b){return a<b?a:b;} int main(){ scanf(\"%d%d%d%d\",&n,&m,&v,&e); for(int i=1;i<=n;++i)scanf(\"%d\",&s[i].c); for(int i=1;i<=n;++i)scanf(\"%d\",&s[i].d); for(int i=1;i<=n;++i)scanf(\"%lf\",&s[i].k); init(); for(int i=1;i<=e;++i){ scanf(\"%d%d%d\",&a,&b,&w); dis[a][b]=min(dis[a][b],w); dis[b][a]=min(dis[b][a],w); } floyd(); f[1][0][0]=0.0;f[1][1][1]=0.0; for(int i=2;i<=n;++i){ for(int j=0;j<=m;++j){ db kv=s[i-1].k,ku=s[i].k; int uc=s[i].c,ud=s[i].d,vc=s[i-1].c,vd=s[i-1].d; f[i][j][0]=Min(f[i][j][0],f[i-1][j][0]+1.0*1.0*(double)dis[vc][uc]); f[i][j][0]=Min(f[i][j][0],f[i-1][j][1]+kv*(double)dis[vd][uc]+(1.0-kv)*(double)dis[vc][uc]); if(j==0)continue; f[i][j][1]=Min(f[i][j][1],f[i-1][j-1][0]+ku*(double)dis[vc][ud]+(1.0-ku)*(double)dis[vc][uc]); f[i][j][1]=Min(f[i][j][1],f[i-1][j-1][1]+ ku*kv*(double)dis[vd][ud]+ kv*(1.0-ku)*(double)dis[vd][uc]+ ku*(1.0-kv)*(double)dis[vc][ud]+ (1.0-ku)*(1.0-kv)*(double)dis[vc][uc]); } } db ans=INF; for(int i=0;i<=m;++i)ans=Min(ans,Min(f[n][i][0],f[n][i][1])); printf(\"%.2lf\",ans); return 0; } \u8ba1\u6570dp \u5b57\u7b26\u4e32\u7c7b\u8ba1\u6570 P2679 f[i][j][k][0/1]\u8868\u793aa\u4e32\u524di\u4f4d\u5339\u914db\u4e32\u524dj\u4f4d\uff0c\u7528\u4e86k\u4e2a\u5b50\u4e32\u4e14i\u4e0ej\u662f\u5426\u5339\u914d\u65f6\u7684\u7b54\u6848 \u8f6c\u79fb\u65b9\u7a0b\uff1a //1. f[0][0][0][0]=1; f[1][0][0][0]=1; for(i) for(j) for(k) if(a[i]==b[j]){ f[i][j][k][1]=f[i-1][j-1][k][1]+f[i-1][j-1][k-1][1]+f[i-1][j-1][k-1][0]; }else{ f[i][j][k][1]=0; } f[i][j][k][0]=f[i-1][j][k][0]+f[i-1][j][t][1]; //2. for(int i=1;i<=n;++i){ for(int j=1;j<=m;++j) for(int l=1;l<=k;++l)f[i%2][j][l][1]=f[i%2][j][l][0]=0; if(a[i-1]==b[0])f[i%2][1][1][1]=1; for(int j=1;j<=m;++j){ for(int l=1;l<=k;++l){ if(a[i-1]==b[j-1]){ f[i%2][j][l][1]=(f[i%2][j][l][1]+f[(i-1)%2][j-1][l-1][1]+f[(i-1)%2][j-1][l][1]+f[(i-1)%2][j-1][l-1][0])%P; }else f[i%2][j][l][1]=0; f[i%2][j][l][0]=(f[i%2][j][l][0]+f[(i-1)%2][j][l][1]+f[(i-1)%2][j][l][0])%P; } } } \u5c06\u7b2c\u4e00\u7ef4\u6eda\u52a8\u6389\u7684\u65b9\u6cd5\uff1a\u56e0\u4e3a\u53ea\u4e0e\u4e0a\u4e00\u5c42\u6709\u5173\uff0c\u6240\u4ee5\u4e24\u5c42\u5c31\u591f\uff0c\u4f7f\u7528i%2\u5224\u65ad\u3002 \u6ce8\u610f\u9700\u8981\u7b2c\u4e8c\u79cd\u65b9\u6cd5\u9700\u8981\u6e05\u96f6\u3002 P2389 \u4e0eP2679\u5341\u5206\u7c7b\u4f3c\u3002\u5c11\u4e86\u4e00\u7ef4\uff0c\u4e0d\u7528\u6eda\u52a8\u3002\u5e76\u4e14\u6210\u4e86\u53d6\u6700\u5927\u503c\u3002 \u7528f[i][j][0/1]\u8868\u793a\u7528\u4e86j\u6bb5\uff0c\u7b2ci\u4f4d\u662f\u5426\u53d6\u7684\u7b54\u6848\u3002 \u8f6c\u79fb\u65b9\u7a0b\uff1a //memset(f,-0x3f,sizeof f); f[0][0][0]=0; f[0][0][1]=0; //f[1][0][0]=0; //f[1][0][1]=0; int ans=0; for(int i=1;i<=n;++i){ for(int j=1;j<=k;++j){ int max1=max(f[i-1][j][1],max(f[i-1][j-1][1],f[i-1][j-1][0])); f[i][j][1]=max(f[i][j][1],max1+a[i]); int max2=max(f[i-1][j][0],f[i-1][j][1]); f[i][j][0]=max(f[i][j][0],max2); ans=max(ans,max(f[i][j][0],f[i][j][1])); } } \u6ce8\u610f\u53d6\u503c\u53ef\u4ee5\u4e3a\u8d1f\uff0c\u6240\u4ee5\u8981\u5c06f\u8d4b\u503c\u6210$-\\infty$,\u5e76\u548c0\u53bb\u53d6max\u3002 ~~\u6240\u4ee5\u4e0d\u5c31\u662f\u521d\u59cb\u5316\u4e3a\u96f6\u5417~~ \u6570\u5b57\u7c7b\u8ba1\u6570 P7961 1) \u7b2c\u4e09\u7ef4\u7ef4\u62a4\u6574\u4f53(\u52a0\u4e0a\u7b2c\u56db\u7ef4\u8fdb\u4f4d)\u7684$1$\u7684\u4e2a\u6570\u4e0d\u597d\uff0c\u56e0\u4e3a\u53ef\u80fd\u4f1a\u51fa\u73b0\u8f6c\u79fb\u65f6\u7b2c\u4e09\u4f4d\u51cf\u5c11\u7684\u60c5\u51b5\uff0c\u8fd9\u6837\u5c31\u53ef\u80fd\u6ea2\u51fa\u3002 2) \u5feb\u901f\u5e42\u4e0d\u9700\u8981\uff0c\u76f4\u63a5\u9884\u5904\u7406\u5c31\u884c\u4e86\u3002 3) \u8fd9\u79cd\u72b6\u6001\u8bbe\u8ba1\u7b2c\u4e00\u7ef4\u5230$m+1$\u5c31\u5df2\u7ecf\u5305\u542b\u4e86\u6240\u6709\u72b6\u6001\uff0c\u4e0d\u80fd\u518d\u5f80\u56de\u627e\u4e86\u3002 \u6b63\u786e\u505a\u6cd5\u662f\u8bbe$f[i][j][p][l]$\u8868\u793a\u8003\u8651\u5b8c\u7b2c$i$\u4e2a$a_i$\uff0c\u4e00\u5171\u7528\u4e86$j$\u4e2a$a$,\u5f53\u524d\u4e0d\u5305\u62ec$l$\u4e00\u5171$p$\u4e2a$1$,\u4ee5\u53ca\u8fdb\u4f4d\u6570$l$. \u56e0\u4e3a\u6bcf\u6b21\u90fd\u4f1a\u5c06$l/2$,\u5e76\u4e14\u6bcf\u6b21$l$\u90fd\u4e0d\u8d85\u8fc7$n$,\u6240\u4ee5\u6bcf\u6b21\u679a\u4e3e$l$\u5230$\\frac n2$\u5373\u53ef\u3002 \u8fd9\u6837\u53ea\u8981\u5728\u7edf\u8ba1\u7b54\u6848\u65f6\u5c06$l$\u7684$1$\u7684\u4e2a\u6570\u518d\u52a0\u56de\u6765\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=33,M=110,P=998244353; int f[M][N][N][20]; int C[N][N]; int v[M],num[N],pv[M][N]; int n,m,k; inline int getnum(int i) { int ans=0; while(i)ans+=(i&1),i>>=1; return ans; } void init() { for(int i=0; i<=n; ++i) { C[i][0]=1; for(int j=1; j<=i; ++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%P; } for(int i=0; i<=n; ++i)num[i]=getnum(i); for(int i=0;i<=m;++i){ pv[i][0]=1; for(int j=1;j<=n;++j)pv[i][j]=(pv[i][j-1]*v[i])%P; } } int dp() { f[0][0][0][0]=1; for(int i=0; i<=m; ++i) for(int j=0; j<=n; ++j) for(int p=0; p<=k; ++p) for(int l=0; l<=(n>>1); ++l) for(int q=0; q+j<=n; ++q) { int tmp=((f[i][j][p][l]*pv[i][q]%P)*C[n-j][q])%P; f[i+1][j+q][p+(q+l&1)][(l+q)>>1]=(f[i+1][j+q][p+(q+l&1)][(l+q)>>1]+tmp)%P; } int ans=0; for(int p=0; p<=k; ++p) for(int l=0; l<=(n>>1); ++l) if(p+num[l]<=k)ans=(ans+f[m+1][n][p][l])%P; return ans; } signed main() { //freopen(\"sequence2.in\",\"r\",stdin); scanf(\"%lld%lld%lld\",&n,&m,&k); for(int i=0; i<=m; ++i)scanf(\"%lld\",&v[i]); init(); printf(\"%lld\",dp()); return 0; } P1633 \u6211\u4eec\u53ef\u4ee5\u8bbe\u4e00\u4e2a\u4e94\u7ef4\u7684\u72b6\u6001\uff0cf[i][j][k][l][0/1],\u8868\u793aX\u4e2d\u6709i\u4e2a1\uff0cY\u4e2d\u6709j\u4e2a1\uff0cZ\u4e2d\u6709k\u4e2a1\uff0c\u5f53\u524d\u6bd4\u8f83\u5230\u4e86\u7b2cl\u4f4d\uff0c\u4e14Z\u7684\u7b2cl\u4f4d\u662f0\u8fd8\u662f1. \u5bf9\u4e8eX\u548cY\u7684\u7b2cl\u4f4d\uff0c\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u5c31\u662f\u586b0\u62161\uff0c\u6240\u4ee5\u6709\u5982\u4e0b\u8f6c\u79fb\uff1a f[i][j][k][l][0]+0 ->f[i][j][k][l+1][0] //0 0 +(1ll<<l-1) ->f[i][j+1][k+1][l+1][0] //0 1 +(1ll<<l-1) ->f[i+1][j][k+1][l+1][0] //1 0 +(1ll<<l) ->f[i+1][j+1][k+1][l+1][1] //1 1 f[i][j][k][l][1]+0 ->f[i][j][k][l+1][0] //0 0 +(1ll<<l-1) ->f[i][j+1][k][l+1][1] //0 1 +(1ll<<l-1) ->f[i+1][j][k][l+1][1] //1 0 +(1ll<<l) ->f[i+1][j+1][k+1][l+1][1] //1 1 \u6ce8\u610f\u7ed9\u7b2cl\u4f4d\u52a0\u4e2a1\u76f8\u5f53\u4e8e\u7ed9\u539f\u6570\u52a0$2^{l-1}$,\u800c\u4e0d\u662f$2^l$ \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5bf9\u4e8e1111\u548c11111\u8fd9\u4e24\u79cd\u7b2cl\u4f4d\u5206\u522b\u662f0\u548c1\u7684\u60c5\u51b5\uff1a~~(01111\u524d\u5bfc\u96f6\u4e0d\u7528\u7ba1\uff0c\u53ea\u662f\u8868\u793a\u7b2cl\u4f4d\u4e3a0\u800c\u5df2)~~ //\u5de6->\u53f3\u4e3a\u4f4e\u4f4d->\u9ad8\u4f4d l l 11110 ->111100 i 0 j 0 11110 ->111110 i 0 j 1 11110 ->111110 i 1 j 0 11110 ->111111 i 1 j 1 l l 11111 ->111110 i 0 j 0 11111 ->111101 i 0 j 1 11111 ->111101 i 1 j 0 11111 ->111111 i 1 j 1 \u5206\u522b\u52a0\u4e0a\u8d21\u732e\u4ee5\u540e\uff0c\u518d\u53d6\u4e2a\u6700\u5c0f\u503c\u5c31\u884c\u4e86\u3002 \u8fb9\u754c\u662f$f[0][0][0][1][0]=0$,l\u4ece1\u5f00\u59cb. \u5bf9\u8f93\u5165\u7684a,b,c\u6c42\u51fall,na,nb,nc\u90a3\u4e48\u6700\u7ec8\u7b54\u6848\u4e3a$\\min(f[na][nb][nc][0,1,...,ll][0,1])$ \u6ce8\uff1a $f[i][j][k][l][0]+2^{l-1}$\u4e0d\u80fd\u8f6c\u79fb\u7ed9$f[i][j+1][k+1][l][1]$,\u800c\u662f\u8f6c\u79fb\u7ed9$f[i][j][k+1][l+1][0]$ \u56e0\u4e3al\u6ca1\u6709\u79fb\u52a8\u4f4d\u7f6e\uff0c\u4e0b\u6b21\u8fd8\u662f\u5728\u7b2cl\u4f4d\u52a01\uff0c\u6240\u4ee5\u4f1a\u51fa\u73b0X\u6216Y\u540c\u4e00\u4f4d\u52a0\u4e86\u4e24\u6b211\uff0c\u51fa\u73b0\u9519\u8bef\u3002 ~~\u5176\u5b9el\u90a3\u4e00\u7ef4\u53ef\u4ee5\u6eda\u5b58\u7684\uff0c\u4f46\u6211\u61d2~~ Code: #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=33,INF=5e18; int f[N][N][N][N][2]; int n,a,b,c,na,nb,nc,la,lb,lc,ll; void init() { memset(f,0x3f,sizeof f); na=0;nb=0;nc=0;la=0;lb=0;lc=0; while(a) { if(a&1)na++; la++; a>>=1; } while(b) { if(b&1)nb++; lb++; b>>=1; } while(c) { if(c&1)nc++; lc++; c>>=1; } ll=max(la,max(lb,lc)); } void work() { f[0][0][0][1][0]=0; for(int i=0; i<=na; ++i) { for(int j=0; j<=nb; ++j) { for(int k=0; k<=nc; ++k) { for(int l=1; l<=ll; ++l) { f[i][j][k][l+1][0]=min(f[i][j][k][l+1][0],min(f[i][j][k][l][0],f[i][j][k][l][1])); f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1],min(f[i][j][k][l][0],f[i][j][k][l][1])+(1ll<<l));//\u6ce8\u610f\u5199\u6cd5\uff0c1ll<<l\u8981\u52a0\u62ec\u53f7 f[i][j+1][k+1][l+1][0]=min(f[i][j+1][k+1][l+1][0],f[i][j][k][l][0]+(1ll<<l-1)); f[i+1][j][k+1][l+1][0]=min(f[i+1][j][k+1][l+1][0],f[i][j][k][l][0]+(1ll<<l-1)); f[i][j+1][k][l+1][1]=min(f[i][j+1][k][l+1][1],f[i][j][k][l][1]+(1ll<<l-1)); f[i+1][j][k][l+1][1]=min(f[i+1][j][k][l+1][1],f[i][j][k][l][1]+(1ll<<l-1)); } } } } } signed main() { scanf(\"%lld\",&n); for(int i=1; i<=n; ++i) { scanf(\"%lld%lld%lld\",&a,&b,&c); init();//\u521d\u59cb\u5316 work();//dp int ans=INF; for(int i=0; i<=ll; ++i) { int tmp1=f[na][nb][nc][i][0],cnt1=0; int tmp2=f[na][nb][nc][i][1],cnt2=0; while(tmp1>0)tmp1>>=1,cnt1++; while(tmp2>0)tmp2>>=1,cnt2++; if(cnt1<=ll && cnt1>0)ans=min(ans,f[na][nb][nc][i][0]);//\u6240\u6709\u6ee1\u8db3\u6761\u4ef6\u7684\u6570\u4e2d\u53d6\u6700\u5c0f\u503c if(cnt2<=ll && cnt2>0)ans=min(ans,f[na][nb][nc][i][1]); } if(ans==INF)printf(\"-1\\n\"); else printf(\"%lld\\n\",ans); } return 0; } \u6982\u7387dp P1769 \u53ef\u4ee5\u53d1\u73b0\u6bcf\u4e2a\u4eba\u7684\u6bd4\u8d5b\u8def\u7a0b\u5c31\u662f\u4e00\u9897\u5b8c\u5168\u4e8c\u53c9\u6811\uff0c\u6240\u4ee5\u6309\u7167\u7ebf\u6bb5\u6811\u5efa\u56fe\u7684\u65b9\u5f0f\u9884\u5904\u7406\u51fa\u6bcf\u4e00\u8f6e\u6bcf\u4e2a\u4eba\u5bf9\u6218\u7684\u6240\u6709\u53ef\u80fd\u5bf9\u624b\u7684\u7f16\u53f7\u3002 \u4e4b\u540e\uff0c\u6bcf\u4e2a\u4eba\u90fd\u6709\u4e00\u4e2a\u8d62\u5230\u7b2c$j$\u5c42\u7684\u6982\u7387\uff0c\u6bcf\u4e2a\u5bf9\u624b\u4e5f\u6709\u8d62\u5230\u7b2c$j$\u5c42\u7684\u6982\u7387\uff0c\u5219\u7b2c$i$\u4e2a\u4eba\u8d62\u4e0b\u7b2c$j$\u5c42\u83b7\u80dc\u7684\u603b\u6982\u7387\u4e3a\uff1a $$ f[i][j]=\\sum_{t=l}^r f[i][j-1] f[t][j-1] a[i][t]/100.0; $$ \u6700\u540e\u7edf\u8ba1\u8c01\u8d62\u5230\u6700\u540e\u7684\u603b\u6982\u7387\u6700\u5927\u4e14\u7f16\u53f7\u6700\u5c0f\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #define db double using namespace std; const int N=1100; db f[N][N],a[N][N]; int n,k; int kp[N],h[N][N]; struct node{ int l,r; }g[N<<2]; void init(){ kp[0]=1; for(int i=1;i<=k;++i)kp[i]=kp[i-1]<<1; } void build(int k,int i,int l,int r){ g[i].l=l,g[i].r=r; for(int j=l;j<=r;++j)h[j][k]=i; if(l==r){ return; } int mid=l+r>>1; build(k+1,i<<1,l,mid); build(k+1,i<<1|1,mid+1,r); } int main(){ scanf(\"%d\",&k); init(); n=kp[k]; for(int i=1;i<=n;++i) for(int j=1;j<=n;++j)scanf(\"%lf\",&a[i][j]); build(1,1,1,n); for(int i=1;i<=n;++i)f[i][0]=1.0; for(int j=1;j<=k;++j){ for(int i=1;i<=n;++i){ int tmp=h[i][k+1-j+1]^1; for(int t=g[tmp].l;t<=g[tmp].r;++t){ f[i][j]+=f[i][j-1]*f[t][j-1]*a[i][t]/100.0; } } } db ans=0; int pos=0; for(int i=1;i<=n;++i){ if(ans<f[i][k]){ pos=i; ans=f[i][k]; } } printf(\"%d\",pos); return 0; } /* 2 0 90 50 50 10 0 10 10 50 90 0 50 50 90 50 0 */ DAG\u4e0adp P3953 \u8fd9\u9053\u9898\u7684\u65e0\u89e3\u60c5\u51b5\u5c31\u662f\u5f53\u4e00\u6761\u53ef\u884c\u8def\u5f84\u4e0a\u5305\u542b\u4e86\u4e00\u4e2a\u96f6\u73af\u65f6,\u8f93\u51fa$-1$\u3002 \u8bbe$f[i][k]$\u8868\u793a\u8d70\u5230\u7b2c$i$\u4e2a\u70b9\uff0c\u5e76\u4e14\u8fd8\u6709$k$\u7684\u65f6\u95f4\u53ef\u4ee5\u6d6a\u8d39\u7684\u8def\u5f84\u603b\u6761\u6570\u3002 \u6bcf\u6b21\u8f6c\u79fb\u76f8\u5f53\u4e8e\u6d6a\u8d39\u4e86$dis[u]+w-dis[v]$\u7684\u65f6\u95f4\u3002 \u6ce8\u610f\u5982\u679c\u51fa\u73b0\u4e86\u975e\u96f6\u7684\u73af\uff0c\u90a3\u4e48\u6bcf\u8f6c\u4e00\u5708\u90fd\u6709\u4e0d\u540c\u72b6\u6001\u7684\u51fa\u73b0\uff0c\u6240\u4ee5\u4e0d\u7528\u5224\u65ad$-1$;\u4f46\u662f\u56e0\u4e3a\u96f6\u73af\u8f6c\u4e00\u5708\u6ca1\u6709\u65b0\u7684\u8d21\u732e\uff0c\u6240\u4ee5\u8981\u5224\u65ad\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<set> using namespace std; typedef pair<int,int> PI; const int N=2e5+10,M=55; int T,n,m,u,v,w,K,P,cnt[2]; int head[2][N],dis[2][N],vis[N],flg[N][M],f[N][M]; struct node { int v,w,nxt; } e[2][N<<1]; void add(int u,int v,int w,int t) { e[t][++cnt[t]].v=v,e[t][cnt[t]].w=w,e[t][cnt[t]].nxt=head[t][u],head[t][u]=cnt[t]; } void dij(int t,int o) { memset(dis[o],0x3f,sizeof dis[o]); memset(vis,0,sizeof vis); dis[o][t]=0; set<PI> s; s.insert(make_pair(0,t)); while(s.size()) { set<PI>::iterator it=s.begin(); u=it->second; s.erase(*it); if(vis[u])continue; vis[u]=1; for(int i=head[o][u]; ~i; i=e[o][i].nxt) { int v=e[o][i].v,w=e[o][i].w; if(dis[o][v]>dis[o][u]+w) { dis[o][v]=dis[o][u]+w; if(!vis[v])s.insert(make_pair(dis[o][v],v)); } } } } int dfs(int u,int k) { if(k<0 || k>K)return 0; if(flg[u][k]) {//\u51fa\u73b0\u4e86\u73af,\u5e76\u4e14\u56e0\u4e3a\u8d70\u8fc7\u4e00\u4e2a\u73af\u540ek\u6ca1\u6709\u53d8\u5316\uff0c\u8bf4\u660e\u8fd9\u4e2a\u73af\u4e00\u5b9a\u662f\u4e2a\u96f6\u73af\u3002 if(dis[0][u]+dis[1][u]<=dis[0][n]+K) { flg[u][k]=0; return -1; } else if(flg[u][k]>=2) {//\u540c\u4e00\u4e2a\u96f6\u73af\u53c8\u8f6c\u4e86\u4e00\u5708\uff0c\u8bf4\u660e\u6240\u6709\u6362\u4e0a\u7684\u70b9\u90fd\u5df2\u7ecf\u7528\u4e0a\u9762\u7684\u8bed\u53e5\u5224\u65ad\u8fc7\u4e86\uff0c\u76f4\u63a5return return 0; } } if(f[u][k]!=-1)return f[u][k]; flg[u][k]++; int res=0; if(u==n)res=1; for(int i=head[0][u]; ~i; i=e[0][i].nxt) { int v=e[0][i].v,w=e[0][i].w; int tmp=dfs(v,k-(dis[0][u]+w-dis[0][v])); if(tmp==-1) { flg[u][k]--; return -1; } res=(res+tmp)%P; } flg[u][k]--; return f[u][k]=res; } int main() { scanf(\"%d\",&T); while(T--) { memset(head,-1,sizeof head); cnt[0]=cnt[1]=-1; scanf(\"%d%d%d%d\",&n,&m,&K,&P); for(int i=1; i<=m; ++i) { scanf(\"%d%d%d\",&u,&v,&w); add(u,v,w,0); add(v,u,w,1); } dij(1,0); dij(n,1); memset(f,-1,sizeof f); memset(flg,0,sizeof flg); printf(\"%d\\n\",dfs(1,K)); } return 0; }","title":"\u671f\u671bdp"},{"location":"my%20past/OI/dp/#dp","text":"P1850 \u8bbe$f[i][j][0/1]$\u8868\u793a\u8003\u8651\u5230\u7b2c$i$\u4e2a\u6559\u5ba4\uff0c\u7528\u4e86$j$\u6b21\u4ea4\u6362\u6743\u5e76\u4e14$i$\u6362\u4e0e\u4e0d\u6362\u7684\u6700\u5c0f\u503c\u3002 \u6bcf\u6b21\u7684\u65b0\u8d21\u732e\u53ea\u7528\u8003\u8651$i$\u4e0e$i-1$\u4e4b\u95f4\u7684\u6700\u77ed\u8def\u4ee5\u53ca\u4ed6\u4eec\u6210\u529f\u7684\u6982\u7387. #include<iostream> #include<cstdio> #include<cstring> #define db double using namespace std; const int N=2200,V=330; const double INF=1e18; int dis[N][N]; int n,m,v,e,a,b,w; db f[N][N][2]; struct room{ int c,d;db k; }s[N]; void floyd(){ for(int i=1;i<=v;++i)dis[i][i]=0; for(int k=1;k<=v;++k) for(int i=1;i<=v;++i) for(int j=1;j<=v;++j){ if(i==j)continue; dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]); } } void init(){ memset(dis,0x3f,sizeof dis); for(int i=0;i<=n+1;++i) for(int j=0;j<=m+1;++j) f[i][j][0]=f[i][j][1]=INF; } inline db Min(db a,db b){return a<b?a:b;} int main(){ scanf(\"%d%d%d%d\",&n,&m,&v,&e); for(int i=1;i<=n;++i)scanf(\"%d\",&s[i].c); for(int i=1;i<=n;++i)scanf(\"%d\",&s[i].d); for(int i=1;i<=n;++i)scanf(\"%lf\",&s[i].k); init(); for(int i=1;i<=e;++i){ scanf(\"%d%d%d\",&a,&b,&w); dis[a][b]=min(dis[a][b],w); dis[b][a]=min(dis[b][a],w); } floyd(); f[1][0][0]=0.0;f[1][1][1]=0.0; for(int i=2;i<=n;++i){ for(int j=0;j<=m;++j){ db kv=s[i-1].k,ku=s[i].k; int uc=s[i].c,ud=s[i].d,vc=s[i-1].c,vd=s[i-1].d; f[i][j][0]=Min(f[i][j][0],f[i-1][j][0]+1.0*1.0*(double)dis[vc][uc]); f[i][j][0]=Min(f[i][j][0],f[i-1][j][1]+kv*(double)dis[vd][uc]+(1.0-kv)*(double)dis[vc][uc]); if(j==0)continue; f[i][j][1]=Min(f[i][j][1],f[i-1][j-1][0]+ku*(double)dis[vc][ud]+(1.0-ku)*(double)dis[vc][uc]); f[i][j][1]=Min(f[i][j][1],f[i-1][j-1][1]+ ku*kv*(double)dis[vd][ud]+ kv*(1.0-ku)*(double)dis[vd][uc]+ ku*(1.0-kv)*(double)dis[vc][ud]+ (1.0-ku)*(1.0-kv)*(double)dis[vc][uc]); } } db ans=INF; for(int i=0;i<=m;++i)ans=Min(ans,Min(f[n][i][0],f[n][i][1])); printf(\"%.2lf\",ans); return 0; }","title":"\u671f\u671bdp"},{"location":"my%20past/OI/dp/#dp_1","text":"","title":"\u8ba1\u6570dp"},{"location":"my%20past/OI/dp/#_1","text":"P2679 f[i][j][k][0/1]\u8868\u793aa\u4e32\u524di\u4f4d\u5339\u914db\u4e32\u524dj\u4f4d\uff0c\u7528\u4e86k\u4e2a\u5b50\u4e32\u4e14i\u4e0ej\u662f\u5426\u5339\u914d\u65f6\u7684\u7b54\u6848 \u8f6c\u79fb\u65b9\u7a0b\uff1a //1. f[0][0][0][0]=1; f[1][0][0][0]=1; for(i) for(j) for(k) if(a[i]==b[j]){ f[i][j][k][1]=f[i-1][j-1][k][1]+f[i-1][j-1][k-1][1]+f[i-1][j-1][k-1][0]; }else{ f[i][j][k][1]=0; } f[i][j][k][0]=f[i-1][j][k][0]+f[i-1][j][t][1]; //2. for(int i=1;i<=n;++i){ for(int j=1;j<=m;++j) for(int l=1;l<=k;++l)f[i%2][j][l][1]=f[i%2][j][l][0]=0; if(a[i-1]==b[0])f[i%2][1][1][1]=1; for(int j=1;j<=m;++j){ for(int l=1;l<=k;++l){ if(a[i-1]==b[j-1]){ f[i%2][j][l][1]=(f[i%2][j][l][1]+f[(i-1)%2][j-1][l-1][1]+f[(i-1)%2][j-1][l][1]+f[(i-1)%2][j-1][l-1][0])%P; }else f[i%2][j][l][1]=0; f[i%2][j][l][0]=(f[i%2][j][l][0]+f[(i-1)%2][j][l][1]+f[(i-1)%2][j][l][0])%P; } } } \u5c06\u7b2c\u4e00\u7ef4\u6eda\u52a8\u6389\u7684\u65b9\u6cd5\uff1a\u56e0\u4e3a\u53ea\u4e0e\u4e0a\u4e00\u5c42\u6709\u5173\uff0c\u6240\u4ee5\u4e24\u5c42\u5c31\u591f\uff0c\u4f7f\u7528i%2\u5224\u65ad\u3002 \u6ce8\u610f\u9700\u8981\u7b2c\u4e8c\u79cd\u65b9\u6cd5\u9700\u8981\u6e05\u96f6\u3002 P2389 \u4e0eP2679\u5341\u5206\u7c7b\u4f3c\u3002\u5c11\u4e86\u4e00\u7ef4\uff0c\u4e0d\u7528\u6eda\u52a8\u3002\u5e76\u4e14\u6210\u4e86\u53d6\u6700\u5927\u503c\u3002 \u7528f[i][j][0/1]\u8868\u793a\u7528\u4e86j\u6bb5\uff0c\u7b2ci\u4f4d\u662f\u5426\u53d6\u7684\u7b54\u6848\u3002 \u8f6c\u79fb\u65b9\u7a0b\uff1a //memset(f,-0x3f,sizeof f); f[0][0][0]=0; f[0][0][1]=0; //f[1][0][0]=0; //f[1][0][1]=0; int ans=0; for(int i=1;i<=n;++i){ for(int j=1;j<=k;++j){ int max1=max(f[i-1][j][1],max(f[i-1][j-1][1],f[i-1][j-1][0])); f[i][j][1]=max(f[i][j][1],max1+a[i]); int max2=max(f[i-1][j][0],f[i-1][j][1]); f[i][j][0]=max(f[i][j][0],max2); ans=max(ans,max(f[i][j][0],f[i][j][1])); } } \u6ce8\u610f\u53d6\u503c\u53ef\u4ee5\u4e3a\u8d1f\uff0c\u6240\u4ee5\u8981\u5c06f\u8d4b\u503c\u6210$-\\infty$,\u5e76\u548c0\u53bb\u53d6max\u3002 ~~\u6240\u4ee5\u4e0d\u5c31\u662f\u521d\u59cb\u5316\u4e3a\u96f6\u5417~~","title":"\u5b57\u7b26\u4e32\u7c7b\u8ba1\u6570"},{"location":"my%20past/OI/dp/#_2","text":"P7961 1) \u7b2c\u4e09\u7ef4\u7ef4\u62a4\u6574\u4f53(\u52a0\u4e0a\u7b2c\u56db\u7ef4\u8fdb\u4f4d)\u7684$1$\u7684\u4e2a\u6570\u4e0d\u597d\uff0c\u56e0\u4e3a\u53ef\u80fd\u4f1a\u51fa\u73b0\u8f6c\u79fb\u65f6\u7b2c\u4e09\u4f4d\u51cf\u5c11\u7684\u60c5\u51b5\uff0c\u8fd9\u6837\u5c31\u53ef\u80fd\u6ea2\u51fa\u3002 2) \u5feb\u901f\u5e42\u4e0d\u9700\u8981\uff0c\u76f4\u63a5\u9884\u5904\u7406\u5c31\u884c\u4e86\u3002 3) \u8fd9\u79cd\u72b6\u6001\u8bbe\u8ba1\u7b2c\u4e00\u7ef4\u5230$m+1$\u5c31\u5df2\u7ecf\u5305\u542b\u4e86\u6240\u6709\u72b6\u6001\uff0c\u4e0d\u80fd\u518d\u5f80\u56de\u627e\u4e86\u3002 \u6b63\u786e\u505a\u6cd5\u662f\u8bbe$f[i][j][p][l]$\u8868\u793a\u8003\u8651\u5b8c\u7b2c$i$\u4e2a$a_i$\uff0c\u4e00\u5171\u7528\u4e86$j$\u4e2a$a$,\u5f53\u524d\u4e0d\u5305\u62ec$l$\u4e00\u5171$p$\u4e2a$1$,\u4ee5\u53ca\u8fdb\u4f4d\u6570$l$. \u56e0\u4e3a\u6bcf\u6b21\u90fd\u4f1a\u5c06$l/2$,\u5e76\u4e14\u6bcf\u6b21$l$\u90fd\u4e0d\u8d85\u8fc7$n$,\u6240\u4ee5\u6bcf\u6b21\u679a\u4e3e$l$\u5230$\\frac n2$\u5373\u53ef\u3002 \u8fd9\u6837\u53ea\u8981\u5728\u7edf\u8ba1\u7b54\u6848\u65f6\u5c06$l$\u7684$1$\u7684\u4e2a\u6570\u518d\u52a0\u56de\u6765\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=33,M=110,P=998244353; int f[M][N][N][20]; int C[N][N]; int v[M],num[N],pv[M][N]; int n,m,k; inline int getnum(int i) { int ans=0; while(i)ans+=(i&1),i>>=1; return ans; } void init() { for(int i=0; i<=n; ++i) { C[i][0]=1; for(int j=1; j<=i; ++j)C[i][j]=(C[i-1][j-1]+C[i-1][j])%P; } for(int i=0; i<=n; ++i)num[i]=getnum(i); for(int i=0;i<=m;++i){ pv[i][0]=1; for(int j=1;j<=n;++j)pv[i][j]=(pv[i][j-1]*v[i])%P; } } int dp() { f[0][0][0][0]=1; for(int i=0; i<=m; ++i) for(int j=0; j<=n; ++j) for(int p=0; p<=k; ++p) for(int l=0; l<=(n>>1); ++l) for(int q=0; q+j<=n; ++q) { int tmp=((f[i][j][p][l]*pv[i][q]%P)*C[n-j][q])%P; f[i+1][j+q][p+(q+l&1)][(l+q)>>1]=(f[i+1][j+q][p+(q+l&1)][(l+q)>>1]+tmp)%P; } int ans=0; for(int p=0; p<=k; ++p) for(int l=0; l<=(n>>1); ++l) if(p+num[l]<=k)ans=(ans+f[m+1][n][p][l])%P; return ans; } signed main() { //freopen(\"sequence2.in\",\"r\",stdin); scanf(\"%lld%lld%lld\",&n,&m,&k); for(int i=0; i<=m; ++i)scanf(\"%lld\",&v[i]); init(); printf(\"%lld\",dp()); return 0; } P1633 \u6211\u4eec\u53ef\u4ee5\u8bbe\u4e00\u4e2a\u4e94\u7ef4\u7684\u72b6\u6001\uff0cf[i][j][k][l][0/1],\u8868\u793aX\u4e2d\u6709i\u4e2a1\uff0cY\u4e2d\u6709j\u4e2a1\uff0cZ\u4e2d\u6709k\u4e2a1\uff0c\u5f53\u524d\u6bd4\u8f83\u5230\u4e86\u7b2cl\u4f4d\uff0c\u4e14Z\u7684\u7b2cl\u4f4d\u662f0\u8fd8\u662f1. \u5bf9\u4e8eX\u548cY\u7684\u7b2cl\u4f4d\uff0c\u6709\u4e24\u79cd\u9009\u62e9\uff0c\u5c31\u662f\u586b0\u62161\uff0c\u6240\u4ee5\u6709\u5982\u4e0b\u8f6c\u79fb\uff1a f[i][j][k][l][0]+0 ->f[i][j][k][l+1][0] //0 0 +(1ll<<l-1) ->f[i][j+1][k+1][l+1][0] //0 1 +(1ll<<l-1) ->f[i+1][j][k+1][l+1][0] //1 0 +(1ll<<l) ->f[i+1][j+1][k+1][l+1][1] //1 1 f[i][j][k][l][1]+0 ->f[i][j][k][l+1][0] //0 0 +(1ll<<l-1) ->f[i][j+1][k][l+1][1] //0 1 +(1ll<<l-1) ->f[i+1][j][k][l+1][1] //1 0 +(1ll<<l) ->f[i+1][j+1][k+1][l+1][1] //1 1 \u6ce8\u610f\u7ed9\u7b2cl\u4f4d\u52a0\u4e2a1\u76f8\u5f53\u4e8e\u7ed9\u539f\u6570\u52a0$2^{l-1}$,\u800c\u4e0d\u662f$2^l$ \u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5bf9\u4e8e1111\u548c11111\u8fd9\u4e24\u79cd\u7b2cl\u4f4d\u5206\u522b\u662f0\u548c1\u7684\u60c5\u51b5\uff1a~~(01111\u524d\u5bfc\u96f6\u4e0d\u7528\u7ba1\uff0c\u53ea\u662f\u8868\u793a\u7b2cl\u4f4d\u4e3a0\u800c\u5df2)~~ //\u5de6->\u53f3\u4e3a\u4f4e\u4f4d->\u9ad8\u4f4d l l 11110 ->111100 i 0 j 0 11110 ->111110 i 0 j 1 11110 ->111110 i 1 j 0 11110 ->111111 i 1 j 1 l l 11111 ->111110 i 0 j 0 11111 ->111101 i 0 j 1 11111 ->111101 i 1 j 0 11111 ->111111 i 1 j 1 \u5206\u522b\u52a0\u4e0a\u8d21\u732e\u4ee5\u540e\uff0c\u518d\u53d6\u4e2a\u6700\u5c0f\u503c\u5c31\u884c\u4e86\u3002 \u8fb9\u754c\u662f$f[0][0][0][1][0]=0$,l\u4ece1\u5f00\u59cb. \u5bf9\u8f93\u5165\u7684a,b,c\u6c42\u51fall,na,nb,nc\u90a3\u4e48\u6700\u7ec8\u7b54\u6848\u4e3a$\\min(f[na][nb][nc][0,1,...,ll][0,1])$ \u6ce8\uff1a $f[i][j][k][l][0]+2^{l-1}$\u4e0d\u80fd\u8f6c\u79fb\u7ed9$f[i][j+1][k+1][l][1]$,\u800c\u662f\u8f6c\u79fb\u7ed9$f[i][j][k+1][l+1][0]$ \u56e0\u4e3al\u6ca1\u6709\u79fb\u52a8\u4f4d\u7f6e\uff0c\u4e0b\u6b21\u8fd8\u662f\u5728\u7b2cl\u4f4d\u52a01\uff0c\u6240\u4ee5\u4f1a\u51fa\u73b0X\u6216Y\u540c\u4e00\u4f4d\u52a0\u4e86\u4e24\u6b211\uff0c\u51fa\u73b0\u9519\u8bef\u3002 ~~\u5176\u5b9el\u90a3\u4e00\u7ef4\u53ef\u4ee5\u6eda\u5b58\u7684\uff0c\u4f46\u6211\u61d2~~ Code: #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=33,INF=5e18; int f[N][N][N][N][2]; int n,a,b,c,na,nb,nc,la,lb,lc,ll; void init() { memset(f,0x3f,sizeof f); na=0;nb=0;nc=0;la=0;lb=0;lc=0; while(a) { if(a&1)na++; la++; a>>=1; } while(b) { if(b&1)nb++; lb++; b>>=1; } while(c) { if(c&1)nc++; lc++; c>>=1; } ll=max(la,max(lb,lc)); } void work() { f[0][0][0][1][0]=0; for(int i=0; i<=na; ++i) { for(int j=0; j<=nb; ++j) { for(int k=0; k<=nc; ++k) { for(int l=1; l<=ll; ++l) { f[i][j][k][l+1][0]=min(f[i][j][k][l+1][0],min(f[i][j][k][l][0],f[i][j][k][l][1])); f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1],min(f[i][j][k][l][0],f[i][j][k][l][1])+(1ll<<l));//\u6ce8\u610f\u5199\u6cd5\uff0c1ll<<l\u8981\u52a0\u62ec\u53f7 f[i][j+1][k+1][l+1][0]=min(f[i][j+1][k+1][l+1][0],f[i][j][k][l][0]+(1ll<<l-1)); f[i+1][j][k+1][l+1][0]=min(f[i+1][j][k+1][l+1][0],f[i][j][k][l][0]+(1ll<<l-1)); f[i][j+1][k][l+1][1]=min(f[i][j+1][k][l+1][1],f[i][j][k][l][1]+(1ll<<l-1)); f[i+1][j][k][l+1][1]=min(f[i+1][j][k][l+1][1],f[i][j][k][l][1]+(1ll<<l-1)); } } } } } signed main() { scanf(\"%lld\",&n); for(int i=1; i<=n; ++i) { scanf(\"%lld%lld%lld\",&a,&b,&c); init();//\u521d\u59cb\u5316 work();//dp int ans=INF; for(int i=0; i<=ll; ++i) { int tmp1=f[na][nb][nc][i][0],cnt1=0; int tmp2=f[na][nb][nc][i][1],cnt2=0; while(tmp1>0)tmp1>>=1,cnt1++; while(tmp2>0)tmp2>>=1,cnt2++; if(cnt1<=ll && cnt1>0)ans=min(ans,f[na][nb][nc][i][0]);//\u6240\u6709\u6ee1\u8db3\u6761\u4ef6\u7684\u6570\u4e2d\u53d6\u6700\u5c0f\u503c if(cnt2<=ll && cnt2>0)ans=min(ans,f[na][nb][nc][i][1]); } if(ans==INF)printf(\"-1\\n\"); else printf(\"%lld\\n\",ans); } return 0; }","title":"\u6570\u5b57\u7c7b\u8ba1\u6570"},{"location":"my%20past/OI/dp/#dp_2","text":"P1769 \u53ef\u4ee5\u53d1\u73b0\u6bcf\u4e2a\u4eba\u7684\u6bd4\u8d5b\u8def\u7a0b\u5c31\u662f\u4e00\u9897\u5b8c\u5168\u4e8c\u53c9\u6811\uff0c\u6240\u4ee5\u6309\u7167\u7ebf\u6bb5\u6811\u5efa\u56fe\u7684\u65b9\u5f0f\u9884\u5904\u7406\u51fa\u6bcf\u4e00\u8f6e\u6bcf\u4e2a\u4eba\u5bf9\u6218\u7684\u6240\u6709\u53ef\u80fd\u5bf9\u624b\u7684\u7f16\u53f7\u3002 \u4e4b\u540e\uff0c\u6bcf\u4e2a\u4eba\u90fd\u6709\u4e00\u4e2a\u8d62\u5230\u7b2c$j$\u5c42\u7684\u6982\u7387\uff0c\u6bcf\u4e2a\u5bf9\u624b\u4e5f\u6709\u8d62\u5230\u7b2c$j$\u5c42\u7684\u6982\u7387\uff0c\u5219\u7b2c$i$\u4e2a\u4eba\u8d62\u4e0b\u7b2c$j$\u5c42\u83b7\u80dc\u7684\u603b\u6982\u7387\u4e3a\uff1a $$ f[i][j]=\\sum_{t=l}^r f[i][j-1] f[t][j-1] a[i][t]/100.0; $$ \u6700\u540e\u7edf\u8ba1\u8c01\u8d62\u5230\u6700\u540e\u7684\u603b\u6982\u7387\u6700\u5927\u4e14\u7f16\u53f7\u6700\u5c0f\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #define db double using namespace std; const int N=1100; db f[N][N],a[N][N]; int n,k; int kp[N],h[N][N]; struct node{ int l,r; }g[N<<2]; void init(){ kp[0]=1; for(int i=1;i<=k;++i)kp[i]=kp[i-1]<<1; } void build(int k,int i,int l,int r){ g[i].l=l,g[i].r=r; for(int j=l;j<=r;++j)h[j][k]=i; if(l==r){ return; } int mid=l+r>>1; build(k+1,i<<1,l,mid); build(k+1,i<<1|1,mid+1,r); } int main(){ scanf(\"%d\",&k); init(); n=kp[k]; for(int i=1;i<=n;++i) for(int j=1;j<=n;++j)scanf(\"%lf\",&a[i][j]); build(1,1,1,n); for(int i=1;i<=n;++i)f[i][0]=1.0; for(int j=1;j<=k;++j){ for(int i=1;i<=n;++i){ int tmp=h[i][k+1-j+1]^1; for(int t=g[tmp].l;t<=g[tmp].r;++t){ f[i][j]+=f[i][j-1]*f[t][j-1]*a[i][t]/100.0; } } } db ans=0; int pos=0; for(int i=1;i<=n;++i){ if(ans<f[i][k]){ pos=i; ans=f[i][k]; } } printf(\"%d\",pos); return 0; } /* 2 0 90 50 50 10 0 10 10 50 90 0 50 50 90 50 0 */","title":"\u6982\u7387dp"},{"location":"my%20past/OI/dp/#dagdp","text":"P3953 \u8fd9\u9053\u9898\u7684\u65e0\u89e3\u60c5\u51b5\u5c31\u662f\u5f53\u4e00\u6761\u53ef\u884c\u8def\u5f84\u4e0a\u5305\u542b\u4e86\u4e00\u4e2a\u96f6\u73af\u65f6,\u8f93\u51fa$-1$\u3002 \u8bbe$f[i][k]$\u8868\u793a\u8d70\u5230\u7b2c$i$\u4e2a\u70b9\uff0c\u5e76\u4e14\u8fd8\u6709$k$\u7684\u65f6\u95f4\u53ef\u4ee5\u6d6a\u8d39\u7684\u8def\u5f84\u603b\u6761\u6570\u3002 \u6bcf\u6b21\u8f6c\u79fb\u76f8\u5f53\u4e8e\u6d6a\u8d39\u4e86$dis[u]+w-dis[v]$\u7684\u65f6\u95f4\u3002 \u6ce8\u610f\u5982\u679c\u51fa\u73b0\u4e86\u975e\u96f6\u7684\u73af\uff0c\u90a3\u4e48\u6bcf\u8f6c\u4e00\u5708\u90fd\u6709\u4e0d\u540c\u72b6\u6001\u7684\u51fa\u73b0\uff0c\u6240\u4ee5\u4e0d\u7528\u5224\u65ad$-1$;\u4f46\u662f\u56e0\u4e3a\u96f6\u73af\u8f6c\u4e00\u5708\u6ca1\u6709\u65b0\u7684\u8d21\u732e\uff0c\u6240\u4ee5\u8981\u5224\u65ad\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<set> using namespace std; typedef pair<int,int> PI; const int N=2e5+10,M=55; int T,n,m,u,v,w,K,P,cnt[2]; int head[2][N],dis[2][N],vis[N],flg[N][M],f[N][M]; struct node { int v,w,nxt; } e[2][N<<1]; void add(int u,int v,int w,int t) { e[t][++cnt[t]].v=v,e[t][cnt[t]].w=w,e[t][cnt[t]].nxt=head[t][u],head[t][u]=cnt[t]; } void dij(int t,int o) { memset(dis[o],0x3f,sizeof dis[o]); memset(vis,0,sizeof vis); dis[o][t]=0; set<PI> s; s.insert(make_pair(0,t)); while(s.size()) { set<PI>::iterator it=s.begin(); u=it->second; s.erase(*it); if(vis[u])continue; vis[u]=1; for(int i=head[o][u]; ~i; i=e[o][i].nxt) { int v=e[o][i].v,w=e[o][i].w; if(dis[o][v]>dis[o][u]+w) { dis[o][v]=dis[o][u]+w; if(!vis[v])s.insert(make_pair(dis[o][v],v)); } } } } int dfs(int u,int k) { if(k<0 || k>K)return 0; if(flg[u][k]) {//\u51fa\u73b0\u4e86\u73af,\u5e76\u4e14\u56e0\u4e3a\u8d70\u8fc7\u4e00\u4e2a\u73af\u540ek\u6ca1\u6709\u53d8\u5316\uff0c\u8bf4\u660e\u8fd9\u4e2a\u73af\u4e00\u5b9a\u662f\u4e2a\u96f6\u73af\u3002 if(dis[0][u]+dis[1][u]<=dis[0][n]+K) { flg[u][k]=0; return -1; } else if(flg[u][k]>=2) {//\u540c\u4e00\u4e2a\u96f6\u73af\u53c8\u8f6c\u4e86\u4e00\u5708\uff0c\u8bf4\u660e\u6240\u6709\u6362\u4e0a\u7684\u70b9\u90fd\u5df2\u7ecf\u7528\u4e0a\u9762\u7684\u8bed\u53e5\u5224\u65ad\u8fc7\u4e86\uff0c\u76f4\u63a5return return 0; } } if(f[u][k]!=-1)return f[u][k]; flg[u][k]++; int res=0; if(u==n)res=1; for(int i=head[0][u]; ~i; i=e[0][i].nxt) { int v=e[0][i].v,w=e[0][i].w; int tmp=dfs(v,k-(dis[0][u]+w-dis[0][v])); if(tmp==-1) { flg[u][k]--; return -1; } res=(res+tmp)%P; } flg[u][k]--; return f[u][k]=res; } int main() { scanf(\"%d\",&T); while(T--) { memset(head,-1,sizeof head); cnt[0]=cnt[1]=-1; scanf(\"%d%d%d%d\",&n,&m,&K,&P); for(int i=1; i<=m; ++i) { scanf(\"%d%d%d\",&u,&v,&w); add(u,v,w,0); add(v,u,w,1); } dij(1,0); dij(n,1); memset(f,-1,sizeof f); memset(flg,0,sizeof flg); printf(\"%d\\n\",dfs(1,K)); } return 0; }","title":"DAG\u4e0adp"},{"location":"my%20past/OI/dp%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","text":"dp\u5e38\u7528\u65b9\u6cd5 1.\u5e38\u7528\u7684\u586b\u8868\u6cd5\u548c\u5237\u8868\u6cd5\uff1a \u586b\u8868\u6cd5\u5c31\u662f\u5229\u7528\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u548c\u4e0a\u4e00\u4e2a\u72b6\u6001\u6765\u63a8\u5bfc\u51fa\u73b0\u5728\u7684\u72b6\u6001\uff08\u76f8\u5f53\u4e8e\u77e5\u9053\u5df2\u77e5\u6761\u4ef6\uff0c\u5c06\u7b54\u6848\u586b\u5165\uff09 \u5237\u8868\u6cd5\u5c31\u662f\u5229\u7528\u5f53\u524d\u7684\u72b6\u6001\uff0c\u628a\u6709\u5173\u8054\u7684\u4e0b\u4e00\u72b6\u6001\u90fd\u63a8\u51fa\u6765\u3002 2.\u53d6\u6700\u5927\u503c\u548c\u7edf\u8ba1\u7b54\u6848\u533a\u522b\uff1a\u6700\u5927\u503c\u7684\u9898\u76ee\uff0c\u4e0d\u5141\u8bb8\u6709\u7a7a\u7f3a\u4e3a0\u7684\u60c5\u51b5\uff0c\u5fc5\u987b\u4e00\u6b65\u4e00\u6b65\u7684\u8f6c\u79fb\uff0c\u4e0d\u80fd\u8df3\u6b65\uff1b \u800c\u7edf\u8ba1\u7b54\u6848\u7684\u9898\u76ee\uff0c\u53ef\u4ee5\u53ea\u7531\u6709\u7b54\u6848\u7684\u72b6\u6001\u8df3\u5230\u4e0b\u4e00\u5408\u6cd5\u72b6\u6001\uff0c\u4e0d\u5408\u6cd5\u72b6\u6001\u53ef\u4ee5\u4e3a0\u3002 3.\u6eda\u52a8\u6570\u7ec4\u4e24\u79cd\u65b9\u6cd5\uff1a \u4e00\u79cd\u662f\u76f4\u63a5\u8986\u76d6\uff0c\u5982\u80cc\u5305\u7684\u4f18\u5316\uff1b\u7b2c\u4e8c\u79cd\u662f\u9700\u8981\u4e0e\u4e0a\u4e00\u884c\u8fdb\u884c\u65e0\u5e8f\u6bd4\u8f83\uff0c\u6709\u53ef\u80fd\u8981\u6bd4\u8f83\u5230\u6240\u6709\u72b6\u6001\uff0c\u6240\u4ee5\u5b9a\u4e49\u4e24\u884c\u7684\u6570\u7ec4\uff0c\u7528i%2\u6765\u6362\u884c\u3002 4.\u6700\u4f18\u5b50\u7ed3\u6784\u4e0e\u65e0\u540e\u6548\u6027\uff1a \u6700\u4f18\u5b50\u7ed3\u6784\u5373\u5b50\u95ee\u9898\u7684\u6700\u4f18\u89e3\u4e00\u5b9a\u80fd\u63a8\u51fa\u6765\u5f53\u524d\u95ee\u9898\u7684\u6700\u4f18\u89e3\uff1b \u65e0\u540e\u6548\u6027\u5373\u5f53\u524d\u72b6\u6001\u5df2\u7ecf\u786e\u5b9a\uff0c\u5219\u4ee5\u540e\u7684\u72b6\u6001\u4e0e\u4e4b\u524d\u7684\u72b6\u6001\u65e0\u5173\u3002 \u5178\u578b\u7684\u4f8b\u5b50\uff1a 1\uff09.\u4f20\u7eb8\u6761\u7c7b\u578b\u7684\u9898\uff0c\u5982\u679c\u4e0a\u4e0b\u5de6\u53f3\u90fd\u80fd\u8d70\uff0c\u5c31\u4f1a\u5177\u6709\u540e\u6548\u6027\u3002 2\uff09.P1437.\u5982\u679c\u6309\u6b63\u5e38\u987a\u5e8f\u4ece\u4e0a\u5f80\u4e0b\u641c\uff0c\u5c31\u4f1a\u53d1\u73b0\u6709\u4e4b\u524d\u7684\u72b6\u6001\u91cd\u590d\u8ba1\u7b97\u7684\u60c5\u51b5\uff0c\u56e0\u6b64\u8981\u4ece\u53f3\u5f80\u5de6\u641c\u3002 5.\u5e38\u7528\u907f\u514d\u4e0d\u5408\u6cd5\u72b6\u6001\u8f6c\u79fb\u7684\u65b9\u6cd5\uff1a\u5982\u679c\u662f\u53d6\u6700\u5927\u503c\uff0c\u5c31\u8bbe\u6570\u7ec4\u4e3a\u8d1f\u65e0\u7a77\uff0c\u5c06\u521d\u59cb\u72b6\u6001\u521d\u59cb\u5316\u4e3a0.\u8fd9\u6837\u5f53\u78b0\u5230\u4e0d\u5408\u6cd5\u7684\u72b6\u6001\u65f6\uff0c\u8fd9\u5c4a\u8ba1\u7b97\u51fa\u8d1f\u65e0\u7a77\uff0c\u8fbe\u5230\u820d\u53bb\u7684\u76ee\u7684\u3002 6.\u5e38\u7528\u63a8\u8f6c\u79fb\u65b9\u7a0b\u7684\u65b9\u6cd5\uff1a ~~0).\u601d\u8003\u95ee\u9898\u662f\u5426\u6ee1\u8db3\u65e0\u540e\u6548\u6027\u548c\u6700\u4f18\u5b50\u7ed3\u6784\uff0c\u6ca1\u6709\u8fd8\u505a\u4e2ap~~ 1).\u601d\u8003\u51fa\u5f53\u524d\u6240\u6709\u7684\u72b6\u6001f[i][j][k][...]\uff08f[i][j][0], f[i][j][1] \u6216\u53ea\u6709 f[i][j][k]\uff09 2).\u6839\u636e\u9898\u610f\u5217\u51fa\u6bcf\u79cd\u72b6\u6001\u6240\u6709\u7684\u51b3\u7b56(\u8df3\u8f6c\u673a\u5236)\uff0c\u5373\u5404\u79cd\u53d6max\u64cd\u4f5c\u6216\u8fde\u52a0\u8fde\u4e58\u3002 (f[i][j][k] -> max(...), +=..., * =...) 3).\u5c06\u4e0b\u4e00\u72b6\u6001\u901a\u8fc7\u51b3\u7b56\u679a\u4e3e\u51fa\u6765(f[i+1][j][k], f[i+1][j+1][k], f[i+1][v][k-j],v>=j-1) \u4ee5\u4e0a\u5c31\u53ef\u4ee5\u505a\u9898\u4e86\uff0c\u4f46\u7528\u7684\u662f\u5237\u8868\u6cd5\u3002 (\u91cd\u70b9) 4).\u5c06\u4e0b\u4e00\u72b6\u6001\u4e0e\u5f53\u524d\u72b6\u6001\u901a\u8fc7\u51b3\u7b56\u5efa\u7acb\u8054\u7cfb\uff0c\u5e76\u5c06i+1,j-1,k+v\u7b49\u4e0b\u4e00\u72b6\u6001\u7684\u7cfb\u6570\u8fed\u4ee3\u4e3ai,j,k,\u4ee5\u5c06\u4e0b\u4e00\u72b6\u6001\u5f53\u4f5c\u5f53\u524d\u72b6\u6001\uff0c\u5c06\u5f53\u524d\u72b6\u6001\u8f6c\u5316\u4e3a\u4e0a\u4e00\u72b6\u6001\uff0c\u7528\u586b\u8868\u6cd5\u505a\u9898\u3002(f[i+1][j][k]->f[i][j][k],f[i+1][j+1][k]->f[i][j][k] \u53ef\u4ee5\u53d8\u4e3a f[i][j][k]=max(f[i-1][j][k],f[i-1][j-1][k])) 5) \u5e38\u89c1\u8df3\u8f6c\u4e0e\u72b6\u6001\u8bbe\u7f6e 1.\u8bbe\u8003\u8651\u5230\u7b2c$i$\u4e2a\u65f6\u7684$f[i]$,\u4e0b\u4e00\u6b21\u8df3\u8f6c\u5230$f[i+1]$\uff0c\u5982\u4f20\u7edf\u80cc\u5305 2.\u8bbe\u8003\u8651\u5230\u524d$i$\u4e2a\u65f6\u7684$f[i]$,\u8df3\u8f6c\u53ef\u80fd\u662f\u5c06\u7b2c$i+1$\u4e2a\u63d2\u5165\u5230\u524d$i$\u4e2a\u91cc\uff0c\u4e5f\u53ef\u80fd\u76f4\u63a5\u8df3\u8f6c\u5230$j(j>i)$\uff0c\u5ffd\u7565$[i+1,j-1]$\u7684\u7269\u54c1\u3002","title":"dp\u5e38\u7528\u65b9\u6cd5"},{"location":"my%20past/OI/dp%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/#dp","text":"1.\u5e38\u7528\u7684\u586b\u8868\u6cd5\u548c\u5237\u8868\u6cd5\uff1a \u586b\u8868\u6cd5\u5c31\u662f\u5229\u7528\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u548c\u4e0a\u4e00\u4e2a\u72b6\u6001\u6765\u63a8\u5bfc\u51fa\u73b0\u5728\u7684\u72b6\u6001\uff08\u76f8\u5f53\u4e8e\u77e5\u9053\u5df2\u77e5\u6761\u4ef6\uff0c\u5c06\u7b54\u6848\u586b\u5165\uff09 \u5237\u8868\u6cd5\u5c31\u662f\u5229\u7528\u5f53\u524d\u7684\u72b6\u6001\uff0c\u628a\u6709\u5173\u8054\u7684\u4e0b\u4e00\u72b6\u6001\u90fd\u63a8\u51fa\u6765\u3002 2.\u53d6\u6700\u5927\u503c\u548c\u7edf\u8ba1\u7b54\u6848\u533a\u522b\uff1a\u6700\u5927\u503c\u7684\u9898\u76ee\uff0c\u4e0d\u5141\u8bb8\u6709\u7a7a\u7f3a\u4e3a0\u7684\u60c5\u51b5\uff0c\u5fc5\u987b\u4e00\u6b65\u4e00\u6b65\u7684\u8f6c\u79fb\uff0c\u4e0d\u80fd\u8df3\u6b65\uff1b \u800c\u7edf\u8ba1\u7b54\u6848\u7684\u9898\u76ee\uff0c\u53ef\u4ee5\u53ea\u7531\u6709\u7b54\u6848\u7684\u72b6\u6001\u8df3\u5230\u4e0b\u4e00\u5408\u6cd5\u72b6\u6001\uff0c\u4e0d\u5408\u6cd5\u72b6\u6001\u53ef\u4ee5\u4e3a0\u3002 3.\u6eda\u52a8\u6570\u7ec4\u4e24\u79cd\u65b9\u6cd5\uff1a \u4e00\u79cd\u662f\u76f4\u63a5\u8986\u76d6\uff0c\u5982\u80cc\u5305\u7684\u4f18\u5316\uff1b\u7b2c\u4e8c\u79cd\u662f\u9700\u8981\u4e0e\u4e0a\u4e00\u884c\u8fdb\u884c\u65e0\u5e8f\u6bd4\u8f83\uff0c\u6709\u53ef\u80fd\u8981\u6bd4\u8f83\u5230\u6240\u6709\u72b6\u6001\uff0c\u6240\u4ee5\u5b9a\u4e49\u4e24\u884c\u7684\u6570\u7ec4\uff0c\u7528i%2\u6765\u6362\u884c\u3002 4.\u6700\u4f18\u5b50\u7ed3\u6784\u4e0e\u65e0\u540e\u6548\u6027\uff1a \u6700\u4f18\u5b50\u7ed3\u6784\u5373\u5b50\u95ee\u9898\u7684\u6700\u4f18\u89e3\u4e00\u5b9a\u80fd\u63a8\u51fa\u6765\u5f53\u524d\u95ee\u9898\u7684\u6700\u4f18\u89e3\uff1b \u65e0\u540e\u6548\u6027\u5373\u5f53\u524d\u72b6\u6001\u5df2\u7ecf\u786e\u5b9a\uff0c\u5219\u4ee5\u540e\u7684\u72b6\u6001\u4e0e\u4e4b\u524d\u7684\u72b6\u6001\u65e0\u5173\u3002 \u5178\u578b\u7684\u4f8b\u5b50\uff1a 1\uff09.\u4f20\u7eb8\u6761\u7c7b\u578b\u7684\u9898\uff0c\u5982\u679c\u4e0a\u4e0b\u5de6\u53f3\u90fd\u80fd\u8d70\uff0c\u5c31\u4f1a\u5177\u6709\u540e\u6548\u6027\u3002 2\uff09.P1437.\u5982\u679c\u6309\u6b63\u5e38\u987a\u5e8f\u4ece\u4e0a\u5f80\u4e0b\u641c\uff0c\u5c31\u4f1a\u53d1\u73b0\u6709\u4e4b\u524d\u7684\u72b6\u6001\u91cd\u590d\u8ba1\u7b97\u7684\u60c5\u51b5\uff0c\u56e0\u6b64\u8981\u4ece\u53f3\u5f80\u5de6\u641c\u3002 5.\u5e38\u7528\u907f\u514d\u4e0d\u5408\u6cd5\u72b6\u6001\u8f6c\u79fb\u7684\u65b9\u6cd5\uff1a\u5982\u679c\u662f\u53d6\u6700\u5927\u503c\uff0c\u5c31\u8bbe\u6570\u7ec4\u4e3a\u8d1f\u65e0\u7a77\uff0c\u5c06\u521d\u59cb\u72b6\u6001\u521d\u59cb\u5316\u4e3a0.\u8fd9\u6837\u5f53\u78b0\u5230\u4e0d\u5408\u6cd5\u7684\u72b6\u6001\u65f6\uff0c\u8fd9\u5c4a\u8ba1\u7b97\u51fa\u8d1f\u65e0\u7a77\uff0c\u8fbe\u5230\u820d\u53bb\u7684\u76ee\u7684\u3002 6.\u5e38\u7528\u63a8\u8f6c\u79fb\u65b9\u7a0b\u7684\u65b9\u6cd5\uff1a ~~0).\u601d\u8003\u95ee\u9898\u662f\u5426\u6ee1\u8db3\u65e0\u540e\u6548\u6027\u548c\u6700\u4f18\u5b50\u7ed3\u6784\uff0c\u6ca1\u6709\u8fd8\u505a\u4e2ap~~ 1).\u601d\u8003\u51fa\u5f53\u524d\u6240\u6709\u7684\u72b6\u6001f[i][j][k][...]\uff08f[i][j][0], f[i][j][1] \u6216\u53ea\u6709 f[i][j][k]\uff09 2).\u6839\u636e\u9898\u610f\u5217\u51fa\u6bcf\u79cd\u72b6\u6001\u6240\u6709\u7684\u51b3\u7b56(\u8df3\u8f6c\u673a\u5236)\uff0c\u5373\u5404\u79cd\u53d6max\u64cd\u4f5c\u6216\u8fde\u52a0\u8fde\u4e58\u3002 (f[i][j][k] -> max(...), +=..., * =...) 3).\u5c06\u4e0b\u4e00\u72b6\u6001\u901a\u8fc7\u51b3\u7b56\u679a\u4e3e\u51fa\u6765(f[i+1][j][k], f[i+1][j+1][k], f[i+1][v][k-j],v>=j-1) \u4ee5\u4e0a\u5c31\u53ef\u4ee5\u505a\u9898\u4e86\uff0c\u4f46\u7528\u7684\u662f\u5237\u8868\u6cd5\u3002 (\u91cd\u70b9) 4).\u5c06\u4e0b\u4e00\u72b6\u6001\u4e0e\u5f53\u524d\u72b6\u6001\u901a\u8fc7\u51b3\u7b56\u5efa\u7acb\u8054\u7cfb\uff0c\u5e76\u5c06i+1,j-1,k+v\u7b49\u4e0b\u4e00\u72b6\u6001\u7684\u7cfb\u6570\u8fed\u4ee3\u4e3ai,j,k,\u4ee5\u5c06\u4e0b\u4e00\u72b6\u6001\u5f53\u4f5c\u5f53\u524d\u72b6\u6001\uff0c\u5c06\u5f53\u524d\u72b6\u6001\u8f6c\u5316\u4e3a\u4e0a\u4e00\u72b6\u6001\uff0c\u7528\u586b\u8868\u6cd5\u505a\u9898\u3002(f[i+1][j][k]->f[i][j][k],f[i+1][j+1][k]->f[i][j][k] \u53ef\u4ee5\u53d8\u4e3a f[i][j][k]=max(f[i-1][j][k],f[i-1][j-1][k])) 5) \u5e38\u89c1\u8df3\u8f6c\u4e0e\u72b6\u6001\u8bbe\u7f6e 1.\u8bbe\u8003\u8651\u5230\u7b2c$i$\u4e2a\u65f6\u7684$f[i]$,\u4e0b\u4e00\u6b21\u8df3\u8f6c\u5230$f[i+1]$\uff0c\u5982\u4f20\u7edf\u80cc\u5305 2.\u8bbe\u8003\u8651\u5230\u524d$i$\u4e2a\u65f6\u7684$f[i]$,\u8df3\u8f6c\u53ef\u80fd\u662f\u5c06\u7b2c$i+1$\u4e2a\u63d2\u5165\u5230\u524d$i$\u4e2a\u91cc\uff0c\u4e5f\u53ef\u80fd\u76f4\u63a5\u8df3\u8f6c\u5230$j(j>i)$\uff0c\u5ffd\u7565$[i+1,j-1]$\u7684\u7269\u54c1\u3002","title":"dp\u5e38\u7528\u65b9\u6cd5"},{"location":"my%20past/OI/dp%E8%BD%AC%E7%A7%BB/","text":"dp\u8f6c\u79fb \u8bb0\u5f55\u65b9\u6848 P6454 \u672c\u9898\u6709dp\u7684 $O(n)$ \u89e3\u6cd5\u3002\u8bbe\u5df2\u7ecf\u7528\u5b8c $1$ \u5230 $i$ \u7684\u9ebb\u5c06\uff0c\u6709 $j$ \u7ec4\u4ece $i-2$ \u5f00\u59cb\u7684\u987a\u5b50\uff0c$k$ \u7ec4\u4ece $i-1$ \u5f00\u59cb\u7684\u987a\u5b50\uff0c\u662f\u5426\u5df2\u7ecf\u786e\u5b9a\u96c0\u5934\uff0c\u6ca1\u6709\u52a0\u5165\u4efb\u4f55\u724c\u7684\u9ebb\u5c06\u7ec4\u5408\u662f\u5426\u80fd\u548c\u4e3a $g[i][j][k][0/1]$\uff0c\u5bf9\u4e8e\u5df2\u7ecf\u52a0\u5165\u4e00\u5f20\u724c\u7684\u8bb0\u4e3a $f[i][j][k][0/1]$\u3002\u8f6c\u79fb\u96be\u5904\u5728\u4e8e\uff0c\u4ece $g$ \u5230 $f$ \u8f6c\u79fb\u65f6\uff0c\u6ca1\u6cd5\u8bb0\u5f55\u52a0\u5165\u4e86\u90a3\u5f20\u724c\u3002 \u6240\u4ee5\u628a\u6240\u6709 $g$ \u5230 $f$ \u7684\u8f6c\u79fb\u53d8\u6210\u5efa\u8fb9(\u7b2c\u4e00\u79cd\u8fb9)\uff0c\u6240\u6709 $f$ \u5230 $f$ \u7684\u8f6c\u79fb\u53d8\u6210\u7b2c\u4e8c\u79cd\u8fb9(\u56e0\u4e3a\u53ea\u6709\u80fd\u591f\u901a\u8fc7\u7b2c\u4e8c\u79cd\u8fb9\u5230\u8fbe\u7ec8\u70b9\u72b6\u6001\u7684\u7b2c\u4e00\u79cd\u8fb9\u662f\u53ef\u884c\u89e3)\u3002\u6700\u540e\u4ece $f(n,0,0,1)$\u4ee3\u8868\u7684\u70b9\uff0c\u901a\u8fc7\u7b2c\u4e8c\u79cd\u8fb9\u8fdb\u884cdfs\uff0c\u6bcf\u6b21\u5230\u4e00\u4e2a\u70b9\u679a\u4e3e\u7b2c\u4e00\u79cd\u8fb9\uff0c\u5bf9 $v$ \u6807\u8bb0\u4e3a\u53ef\u884c\u89e3\u3002 #include<iostream> #include<vector> using namespace std; const int N=5e3+10,M=2e5+10; int g[N][3][3][2]; inline int id(int i,int j,int k,int p){ return i*18+j*6+k*2+p; } int n,m,tmp; int a[N],cnt[2],lst[2],ans[N],vis[M],res[N]; vector<int> G[M],E[M]; void dfs(int u){ vis[u]=1; for(int i=0;i<E[u].size();++i){ int v=E[u][i]; ans[v]=1; } for(int i=0;i<G[u].size();++i){ int v=G[u][i]; if(!vis[v]) dfs(v); } } int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=m;++i) scanf(\"%d\",&tmp),a[tmp]++; for(int i=1;i<=n;++i) cnt[a[i]%2]++,lst[a[i]%2]=i; g[0][0][0][0]=1; for(int i=0;i<n;++i){ for(int j=0;j<3;++j){ for(int k=0;k<3;++k){ for(int p=0;p<2;++p){ if(!g[i][j][k][p]) continue; if(a[i+1]>=j+k) g[i+1][k][(a[i+1]-j-k)%3][p]=g[i][j][k][p]; if(!p && a[i+1]>=j+k+2) g[i+1][k][(a[i+1]-j-k-2)%3][1]=g[i][j][k][p]; } } } for(int j=0;j<3;++j){ for(int k=0;k<3;++k){ for(int p=0;p<2;++p){ //if(!f[i][j][k][p]) continue; int t=id(i,j,k,p); if(a[i+1]>=j+k) G[id(i+1,k,(a[i+1]-j-k)%3,p)].push_back(t); if(!p && a[i+1]>=j+k+2) G[id(i+1,k,(a[i+1]-j-k-2)%3,1)].push_back(t); } } } ++a[i+1]; for(int j=0;j<3;++j){ for(int k=0;k<3;++k){ for(int p=0;p<2;++p){ if(!g[i][j][k][p]) continue; if(a[i+1]>=j+k) E[id(i+1,k,(a[i+1]-j-k)%3,p)].push_back(i+1); if(!p && a[i+1]>=j+k+2) E[id(i+1,k,(a[i+1]-j-k-2)%3,1)].push_back(i+1); } } } } dfs(id(n,0,0,1)); if(cnt[1]==1) ans[lst[1]]=1; int tot=0; for(int i=1;i<=n;++i){ if(ans[i]) res[++tot]=i; } printf(\"%d\\n\",tot); for(int i=1;i<=tot;++i) printf(\"%d \",res[i]); return 0; }","title":"dp\u8f6c\u79fb"},{"location":"my%20past/OI/dp%E8%BD%AC%E7%A7%BB/#dp","text":"","title":"dp\u8f6c\u79fb"},{"location":"my%20past/OI/dp%E8%BD%AC%E7%A7%BB/#_1","text":"P6454 \u672c\u9898\u6709dp\u7684 $O(n)$ \u89e3\u6cd5\u3002\u8bbe\u5df2\u7ecf\u7528\u5b8c $1$ \u5230 $i$ \u7684\u9ebb\u5c06\uff0c\u6709 $j$ \u7ec4\u4ece $i-2$ \u5f00\u59cb\u7684\u987a\u5b50\uff0c$k$ \u7ec4\u4ece $i-1$ \u5f00\u59cb\u7684\u987a\u5b50\uff0c\u662f\u5426\u5df2\u7ecf\u786e\u5b9a\u96c0\u5934\uff0c\u6ca1\u6709\u52a0\u5165\u4efb\u4f55\u724c\u7684\u9ebb\u5c06\u7ec4\u5408\u662f\u5426\u80fd\u548c\u4e3a $g[i][j][k][0/1]$\uff0c\u5bf9\u4e8e\u5df2\u7ecf\u52a0\u5165\u4e00\u5f20\u724c\u7684\u8bb0\u4e3a $f[i][j][k][0/1]$\u3002\u8f6c\u79fb\u96be\u5904\u5728\u4e8e\uff0c\u4ece $g$ \u5230 $f$ \u8f6c\u79fb\u65f6\uff0c\u6ca1\u6cd5\u8bb0\u5f55\u52a0\u5165\u4e86\u90a3\u5f20\u724c\u3002 \u6240\u4ee5\u628a\u6240\u6709 $g$ \u5230 $f$ \u7684\u8f6c\u79fb\u53d8\u6210\u5efa\u8fb9(\u7b2c\u4e00\u79cd\u8fb9)\uff0c\u6240\u6709 $f$ \u5230 $f$ \u7684\u8f6c\u79fb\u53d8\u6210\u7b2c\u4e8c\u79cd\u8fb9(\u56e0\u4e3a\u53ea\u6709\u80fd\u591f\u901a\u8fc7\u7b2c\u4e8c\u79cd\u8fb9\u5230\u8fbe\u7ec8\u70b9\u72b6\u6001\u7684\u7b2c\u4e00\u79cd\u8fb9\u662f\u53ef\u884c\u89e3)\u3002\u6700\u540e\u4ece $f(n,0,0,1)$\u4ee3\u8868\u7684\u70b9\uff0c\u901a\u8fc7\u7b2c\u4e8c\u79cd\u8fb9\u8fdb\u884cdfs\uff0c\u6bcf\u6b21\u5230\u4e00\u4e2a\u70b9\u679a\u4e3e\u7b2c\u4e00\u79cd\u8fb9\uff0c\u5bf9 $v$ \u6807\u8bb0\u4e3a\u53ef\u884c\u89e3\u3002 #include<iostream> #include<vector> using namespace std; const int N=5e3+10,M=2e5+10; int g[N][3][3][2]; inline int id(int i,int j,int k,int p){ return i*18+j*6+k*2+p; } int n,m,tmp; int a[N],cnt[2],lst[2],ans[N],vis[M],res[N]; vector<int> G[M],E[M]; void dfs(int u){ vis[u]=1; for(int i=0;i<E[u].size();++i){ int v=E[u][i]; ans[v]=1; } for(int i=0;i<G[u].size();++i){ int v=G[u][i]; if(!vis[v]) dfs(v); } } int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=m;++i) scanf(\"%d\",&tmp),a[tmp]++; for(int i=1;i<=n;++i) cnt[a[i]%2]++,lst[a[i]%2]=i; g[0][0][0][0]=1; for(int i=0;i<n;++i){ for(int j=0;j<3;++j){ for(int k=0;k<3;++k){ for(int p=0;p<2;++p){ if(!g[i][j][k][p]) continue; if(a[i+1]>=j+k) g[i+1][k][(a[i+1]-j-k)%3][p]=g[i][j][k][p]; if(!p && a[i+1]>=j+k+2) g[i+1][k][(a[i+1]-j-k-2)%3][1]=g[i][j][k][p]; } } } for(int j=0;j<3;++j){ for(int k=0;k<3;++k){ for(int p=0;p<2;++p){ //if(!f[i][j][k][p]) continue; int t=id(i,j,k,p); if(a[i+1]>=j+k) G[id(i+1,k,(a[i+1]-j-k)%3,p)].push_back(t); if(!p && a[i+1]>=j+k+2) G[id(i+1,k,(a[i+1]-j-k-2)%3,1)].push_back(t); } } } ++a[i+1]; for(int j=0;j<3;++j){ for(int k=0;k<3;++k){ for(int p=0;p<2;++p){ if(!g[i][j][k][p]) continue; if(a[i+1]>=j+k) E[id(i+1,k,(a[i+1]-j-k)%3,p)].push_back(i+1); if(!p && a[i+1]>=j+k+2) E[id(i+1,k,(a[i+1]-j-k-2)%3,1)].push_back(i+1); } } } } dfs(id(n,0,0,1)); if(cnt[1]==1) ans[lst[1]]=1; int tot=0; for(int i=1;i<=n;++i){ if(ans[i]) res[++tot]=i; } printf(\"%d\\n\",tot); for(int i=1;i<=tot;++i) printf(\"%d \",res[i]); return 0; }","title":"\u8bb0\u5f55\u65b9\u6848"},{"location":"my%20past/OI/gcd/","text":"\u6b27\u51e0\u91cc\u5f97&\u6269\u5c55\u6b27\u51e0\u91cc\u5f97 \u6734\u7d20\u6b27\u51e0\u91cc\u5f97 \u5c31\u662f\u8f97\u8f6c\u76f8\u9664\u6cd5\u3002$\\gcd(a,b)=\\gcd(b,a\\mod b)$ int gcd(int a, int b) { return !b ? a : gcd(b, a % b); } \u590d\u6742\u5ea6$O(\\log n)$ \u6269\u5c55\u6b27\u51e0\u91cc\u5f97 \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u4e3b\u8981\u7528\u6765\u6c42\u89e3\uff1a $ax+by=\\gcd(a,b)$\u7684\u7279\u6b8a\u89e3\u3002 \u53ef\u4ee5\u7528\u5b83\u6c42\u89e3\u8fd9\u6837\u7684\u6a21\u7ebf\u6027\u65b9\u7a0b\uff1a $ax \\equiv b\\pmod n$ \u5176\u5b9e\u5c31\u662f\u6c42$ax+ny=b$\u7684\u89e3\u3002 \u800c\u8fd9\u4e2a\u65b9\u7a0b\u6709\u89e3\u7684\u524d\u63d0\u662f$b \\mod \\gcd(a,n)=0$,\u5373$b$\u662f$\\gcd(a,n)$\u7684\u500d\u6570\u3002\u8fd9\u6837\u624d\u80fd\u8f6c\u5316\u4e3a\u6c42$ax+ny=\\gcd(a,n)$\u7684\u4e00\u7ec4\u89e3\uff0c\u5728\u63a8\u5230$ax+ny=b$\u4e0a\u3002 \u6a21\u677f\uff1a void exgcd(int a,int b,int &d,int &x,int &y){ if(!b)d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x; } \u8fd9\u4e2a\u9012\u5f52\u7684\u539f\u7406\u662f\uff1a \u5047\u8bbe\u5f53\u524d$ax+by=\\gcd(b,a\\mod b)$\u6709\u4e00\u7ec4\u89e3$(x_1,y_1)$,\u5219\u6709\uff1a $$\\gcd(a,b)=\\gcd(b,a \\mod b)\\ ax+by=bx_1+(a-\\lfloor\\frac ab\\rfloor b)y_1\\ ax+by=a(y_1)+b(x_1-\\lfloor\\frac ab\\rfloor y_1) $$ \u56e0\u6b64$x=y_1,y=x_1-\\lfloor\\frac ab\\rfloor y_1$,\u8fd9\u6837\u8fed\u4ee3\u5373\u53ef\u5f97\u51fa\u4e00\u7ec4\u7279\u6b8a\u89e3\u3002 \u7279\u522b\u5730\uff0c\u5f53$b=0$\u65f6\uff0c$x=1,y=0$. \u6709\u4e86\u8fd9\u7ec4\u89e3\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4efb\u610f$c$\u6ee1\u8db3$ax+by=c,c \\mod \\gcd(a,b)=0$\u7684\u4e00\u7ec4\u7279\u6b8a\u89e3\u4e3a$(\\frac{x_0c}{\\gcd(a,b)},\\frac{y_0c}{\\gcd(a,b)})$ (1) \u90a3\u5982\u679c\u6211\u60f3\u6c42\u4efb\u610f\u4e00\u7ec4\u53ef\u884c\u89e3\u5462? \u5047\u8bbe$a'=a/ \\gcd(a,b) ,b'=b/ \\gcd(a,b)$ \u90a3\u4e48\u5bf9\u4e8e\u4e00\u7ec4$ax+by=c$\u7684\u89e3$(x_1,y_1)$,\u6709\u4efb\u610f\u6574\u6570\u89e3$(x_1+kb',y_1-ka')$ (2) \u8fd9\u662f\u56e0\u4e3a\u5bf9\u4e8e\u4efb\u610f\u4e00\u7ec4\u89e3$(x_2,y_2)$,\u6709\uff1a $$ ax_1+by_1=ax_2+by_2\\ a(x_1-x_2)=b(y_2-y_1)\\ \u8bbe\\gcd(a,b)=g,\u5219\\ a'(x_1-x_2)=b'(y_2-y_1)\\ \\because a'\u4e0eb'\u4e92\u8d28\\ \\therefore x_1-x_2=kb'\\ y_2-y_1=ka' $$ \u5982\u679c\u8981\u6c42\u6c42\u51fa\u6307\u5b9a\u7684\u89e3(\u5982\u6700\u5c0f\u975e\u8d1f\u6574\u6570\u89e3)\uff0c\u6839\u636e\u8981\u6c42\u5411$x_0$\u52a0\u51cf$b$\u5373\u53ef\u3002 \u6ce8\u610f (1) \u548c (2) \u987a\u5e8f\u4e0d\u80fd\u5012\uff0c\u56e0\u4e3a\u51482\u540e1\u76f8\u5f53\u4e8e\u5c06$b' \\to \\frac{b'c}{g}$,\u5c31\u4e0d\u6ee1\u8db32\u7684\u6027\u8d28\u4e86\u3002 \u590d\u6742\u5ea6\u540c\u6837\u4e3a$O(\\log n)$ P1082 \u6a21\u677f\u9898\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; void exgcd(int a,int b,int &d,int &x,int &y){ if(!b)d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x; } int a,b,gcd,x,y; signed main(){ scanf(\"%lld%lld\",&a,&b); exgcd(a,b,gcd,x,y); x=(x%b+b)%b;//\u6ce8\u610f\uff0c\u8fd9\u91cc\u4e0d\u7528\u63a8\u5bfcb'\u65f6\u56e0\u4e3a\u9898\u76ee\u89c4\u5b9agcd(a,b)=1,\u4e0d\u662f\u6ca1\u6709\u5fc5\u8981\u3002 printf(\"%lld\",x); return 0; } P1516 \u5316\u7b80\u9898\u610f\u540e\uff0c\u6211\u4eec\u77e5\u9053\u539f\u9898\u8981\u6c42\u7684\u662f\u4e00\u4e2a\u6700\u5c0f\u975e\u8d1f\u6574\u6570\u89e3$i$\uff0c\u6ee1\u8db3\uff1a $$x+mi\\equiv y+ni\\pmod L\\ (m-n)i\\equiv y-x\\pmod L\\ \u8bbea=m-n,b=L,c=y-x,\u5219\\ ai+bj=c $$ \u5230\u6b64\uff0c\u539f\u9898\u53d8\u4e3a\u6269\u6b27\u6a21\u677f\u9898\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; void exgcd(int a,int b,int &d,int &x,int &y){ if(!b)d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x; } int x,y,n,m,L,a,b,c,g,i,j,_b,_a; signed main(){ scanf(\"%lld%lld%lld%lld%lld\",&x,&y,&m,&n,&L); a=m-n,c=y-x,b=L; if(a<0 && b>0){ while(a<0)a+=b; }else if(a>0 && b<0){ while(b<0)b+=a; }else if(a<0 && b<0)a=-a,b=-b;//\u6ce8\u610f\u8fd9\u91cc\u7684\u8d1f\u6570\u5904\u7406\u65b9\u5f0f\u3002 exgcd(a,b,g,i,j); _a=a/g,_b=b/g; if(c%g!=0){ printf(\"Impossible\"); return 0; } i=(c/g)*i; i=(i%_b+_b)%_b; printf(\"%lld\",i); return 0; }","title":"\u6b27\u51e0\u91cc\u5f97&amp;\u6269\u5c55\u6b27\u51e0\u91cc\u5f97"},{"location":"my%20past/OI/gcd/#_1","text":"","title":"\u6b27\u51e0\u91cc\u5f97&amp;\u6269\u5c55\u6b27\u51e0\u91cc\u5f97"},{"location":"my%20past/OI/gcd/#_2","text":"\u5c31\u662f\u8f97\u8f6c\u76f8\u9664\u6cd5\u3002$\\gcd(a,b)=\\gcd(b,a\\mod b)$ int gcd(int a, int b) { return !b ? a : gcd(b, a % b); } \u590d\u6742\u5ea6$O(\\log n)$","title":"\u6734\u7d20\u6b27\u51e0\u91cc\u5f97"},{"location":"my%20past/OI/gcd/#_3","text":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u4e3b\u8981\u7528\u6765\u6c42\u89e3\uff1a $ax+by=\\gcd(a,b)$\u7684\u7279\u6b8a\u89e3\u3002 \u53ef\u4ee5\u7528\u5b83\u6c42\u89e3\u8fd9\u6837\u7684\u6a21\u7ebf\u6027\u65b9\u7a0b\uff1a $ax \\equiv b\\pmod n$ \u5176\u5b9e\u5c31\u662f\u6c42$ax+ny=b$\u7684\u89e3\u3002 \u800c\u8fd9\u4e2a\u65b9\u7a0b\u6709\u89e3\u7684\u524d\u63d0\u662f$b \\mod \\gcd(a,n)=0$,\u5373$b$\u662f$\\gcd(a,n)$\u7684\u500d\u6570\u3002\u8fd9\u6837\u624d\u80fd\u8f6c\u5316\u4e3a\u6c42$ax+ny=\\gcd(a,n)$\u7684\u4e00\u7ec4\u89e3\uff0c\u5728\u63a8\u5230$ax+ny=b$\u4e0a\u3002 \u6a21\u677f\uff1a void exgcd(int a,int b,int &d,int &x,int &y){ if(!b)d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x; } \u8fd9\u4e2a\u9012\u5f52\u7684\u539f\u7406\u662f\uff1a \u5047\u8bbe\u5f53\u524d$ax+by=\\gcd(b,a\\mod b)$\u6709\u4e00\u7ec4\u89e3$(x_1,y_1)$,\u5219\u6709\uff1a $$\\gcd(a,b)=\\gcd(b,a \\mod b)\\ ax+by=bx_1+(a-\\lfloor\\frac ab\\rfloor b)y_1\\ ax+by=a(y_1)+b(x_1-\\lfloor\\frac ab\\rfloor y_1) $$ \u56e0\u6b64$x=y_1,y=x_1-\\lfloor\\frac ab\\rfloor y_1$,\u8fd9\u6837\u8fed\u4ee3\u5373\u53ef\u5f97\u51fa\u4e00\u7ec4\u7279\u6b8a\u89e3\u3002 \u7279\u522b\u5730\uff0c\u5f53$b=0$\u65f6\uff0c$x=1,y=0$. \u6709\u4e86\u8fd9\u7ec4\u89e3\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4efb\u610f$c$\u6ee1\u8db3$ax+by=c,c \\mod \\gcd(a,b)=0$\u7684\u4e00\u7ec4\u7279\u6b8a\u89e3\u4e3a$(\\frac{x_0c}{\\gcd(a,b)},\\frac{y_0c}{\\gcd(a,b)})$ (1) \u90a3\u5982\u679c\u6211\u60f3\u6c42\u4efb\u610f\u4e00\u7ec4\u53ef\u884c\u89e3\u5462? \u5047\u8bbe$a'=a/ \\gcd(a,b) ,b'=b/ \\gcd(a,b)$ \u90a3\u4e48\u5bf9\u4e8e\u4e00\u7ec4$ax+by=c$\u7684\u89e3$(x_1,y_1)$,\u6709\u4efb\u610f\u6574\u6570\u89e3$(x_1+kb',y_1-ka')$ (2) \u8fd9\u662f\u56e0\u4e3a\u5bf9\u4e8e\u4efb\u610f\u4e00\u7ec4\u89e3$(x_2,y_2)$,\u6709\uff1a $$ ax_1+by_1=ax_2+by_2\\ a(x_1-x_2)=b(y_2-y_1)\\ \u8bbe\\gcd(a,b)=g,\u5219\\ a'(x_1-x_2)=b'(y_2-y_1)\\ \\because a'\u4e0eb'\u4e92\u8d28\\ \\therefore x_1-x_2=kb'\\ y_2-y_1=ka' $$ \u5982\u679c\u8981\u6c42\u6c42\u51fa\u6307\u5b9a\u7684\u89e3(\u5982\u6700\u5c0f\u975e\u8d1f\u6574\u6570\u89e3)\uff0c\u6839\u636e\u8981\u6c42\u5411$x_0$\u52a0\u51cf$b$\u5373\u53ef\u3002 \u6ce8\u610f (1) \u548c (2) \u987a\u5e8f\u4e0d\u80fd\u5012\uff0c\u56e0\u4e3a\u51482\u540e1\u76f8\u5f53\u4e8e\u5c06$b' \\to \\frac{b'c}{g}$,\u5c31\u4e0d\u6ee1\u8db32\u7684\u6027\u8d28\u4e86\u3002 \u590d\u6742\u5ea6\u540c\u6837\u4e3a$O(\\log n)$ P1082 \u6a21\u677f\u9898\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; void exgcd(int a,int b,int &d,int &x,int &y){ if(!b)d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x; } int a,b,gcd,x,y; signed main(){ scanf(\"%lld%lld\",&a,&b); exgcd(a,b,gcd,x,y); x=(x%b+b)%b;//\u6ce8\u610f\uff0c\u8fd9\u91cc\u4e0d\u7528\u63a8\u5bfcb'\u65f6\u56e0\u4e3a\u9898\u76ee\u89c4\u5b9agcd(a,b)=1,\u4e0d\u662f\u6ca1\u6709\u5fc5\u8981\u3002 printf(\"%lld\",x); return 0; } P1516 \u5316\u7b80\u9898\u610f\u540e\uff0c\u6211\u4eec\u77e5\u9053\u539f\u9898\u8981\u6c42\u7684\u662f\u4e00\u4e2a\u6700\u5c0f\u975e\u8d1f\u6574\u6570\u89e3$i$\uff0c\u6ee1\u8db3\uff1a $$x+mi\\equiv y+ni\\pmod L\\ (m-n)i\\equiv y-x\\pmod L\\ \u8bbea=m-n,b=L,c=y-x,\u5219\\ ai+bj=c $$ \u5230\u6b64\uff0c\u539f\u9898\u53d8\u4e3a\u6269\u6b27\u6a21\u677f\u9898\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; void exgcd(int a,int b,int &d,int &x,int &y){ if(!b)d=a,x=1,y=0; else exgcd(b,a%b,d,y,x),y-=a/b*x; } int x,y,n,m,L,a,b,c,g,i,j,_b,_a; signed main(){ scanf(\"%lld%lld%lld%lld%lld\",&x,&y,&m,&n,&L); a=m-n,c=y-x,b=L; if(a<0 && b>0){ while(a<0)a+=b; }else if(a>0 && b<0){ while(b<0)b+=a; }else if(a<0 && b<0)a=-a,b=-b;//\u6ce8\u610f\u8fd9\u91cc\u7684\u8d1f\u6570\u5904\u7406\u65b9\u5f0f\u3002 exgcd(a,b,g,i,j); _a=a/g,_b=b/g; if(c%g!=0){ printf(\"Impossible\"); return 0; } i=(c/g)*i; i=(i%_b+_b)%_b; printf(\"%lld\",i); return 0; }","title":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97"},{"location":"my%20past/OI/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/","text":"kruskal\u91cd\u6784\u6811 \u5e94\u7528 \u89e3\u51b3\u7c7b\u4f3c \u4ece\u67d0\u70b9v\u5f00\u59cb\u7ecf\u8fc7\u4e0d\u8d85\u8fc7\u8fb9\u6743x\u7684\u8fb9\u6240\u80fd\u5230\u8fbe\u7684\u8282\u70b9 \u7684\u95ee\u9898\u3002 \u539f\u7406 \u5728$kruskal$\u8fc7\u7a0b\u4e2d\uff0c\u5982\u679c\u6709\u8fb9$(u,v,w)$,\u5176\u6240\u5c5e\u4e24\u4e2a\u96c6\u5408\u7684\u6839\u4e3a$uu,vv$\u5e76\u4e14\u4e0d\u76f8\u540c\uff0c\u90a3\u4e48\u5c31\u65b0\u5efa\u4e00\u4e2a\u8282\u70b9$p$\uff0c\u5c06$p$\u7684\u70b9\u6743\u503c\u8bbe\u4e3a$w$\uff0c\u5e76\u5c06$p$\u4e8e$u,v$\u8fde\u8fb9\u3002 \u6700\u540e\u6784\u6210\u4e86\u4e00\u68f5\u6811\uff0c\u5373$kruskal$\u91cd\u6784\u6811\u3002(\u56e0\u4e3a\u4e00\u5171$n$\u4e2a\u70b9\u7684\u539f\u56fe\u751f\u6210\u6811\u4e00\u5171\u6709$n-1$\u6761\u8fb9\uff0c\u5bf9\u5e94$n-1$\u4e2a\u65b0\u70b9\uff0c\u800c\u6bcf\u4e2a\u65b0\u70b9\u8fde\u51fa$2$\u6761\u65b0\u8fb9\uff0c\u6240\u4ee5\u91cd\u6784\u6811\u4e00\u5171$2n-1$\u4e2a\u70b9\uff0c$2n-2$\u6761\u8fb9) \u5f53\u8be2\u95ee\u4ece$v$\u7ecf\u8fc7$\\leq x$\u7684\u8fb9\u8d70\u8fc7\u7684\u8282\u70b9\u65f6\uff0c\u53ea\u9700\u8981\u4ece$v$\u5411\u4e0a\u500d\u589e\u627e\u5230\u70b9\u6743$\\leq x$\u7684\u70b9\u6743\u6700\u5927\u7684\u70b9\uff0c\u7ef4\u62a4\u8fd9\u4e2a\u70b9\u7684\u5b50\u6811\u5373\u53ef\u3002 P4197 & P7834 \u8f6c\u5316\u4e3a$kruskal$\u91cd\u6784\u6811\u540e\uff0c\u53d1\u73b0\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u5bf9\u5e94\u4e00\u4e2a\u533a\u95f4\uff0c\u800c\u8be2\u95ee\u5c31\u662f\u95ee\u4e00\u4e2a\u533a\u95f4\u7684\u7b2c$k$\u5927\uff0c\u4e3b\u5e2d\u6811\u5373\u53ef\u3002 \u6ce8\u610f\u5230\u7a7a\u95f4\u5361\u7684\u6bd4\u8f83\u6b7b\uff0c\u6240\u4ee5\u79bb\u6563\u5316\u4e00\u4e0b\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e5+10,M=5e5+10,K=22,INF=1e6+10; int n,m,q,cnt,u,v,w,tot,x,k,dfn,id,btot; int h[N],b[N],Fa[N<<1],a[N<<1],fa[N<<1][K],head[N<<1],l[N<<1],r[N<<1],rt[N<<1]; int ls[N*K],rs[N*K],sum[N*K]; struct edge{ int u,v,w; edge(int uu=0,int vv=0,int ww=0){ u=uu,v=vv,w=ww; } }f[M]; struct Edge{ int v,nxt; }e[M<<1]; bool cmp(edge a,edge b){ return a.w<b.w; } bool Cmp(int a,int b){ return a<b; } void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } int getfa(int u){ return u==Fa[u]?u:Fa[u]=getfa(Fa[u]); } void kruskal(){ sort(f+1,f+m+1,cmp); for(int i=1;i<=n;++i) Fa[i]=i; tot=n;int count=0; for(int i=1;i<=m;++i){ int u=f[i].u,v=f[i].v,w=f[i].w,uu=getfa(u),vv=getfa(v),p=0; if(uu!=vv){ ++count; p=++tot,Fa[uu]=Fa[vv]=Fa[p]=p,a[p]=w; add(p,uu),add(uu,p),add(vv,p),add(p,vv); } if(count>=n-1) break; } } void change(int &now,int pre,int l,int r,int pos){ now=++id; ls[now]=ls[pre],rs[now]=rs[pre],sum[now]=sum[pre]+1; if(l==r) return; int mid=l+r>>1; if(pos<=mid) change(ls[now],ls[pre],l,mid,pos); else change(rs[now],rs[pre],mid+1,r,pos); } int query(int pre,int nxt,int l,int r,int pos){ int mid=l+r>>1,tmp=sum[ls[nxt]]-sum[ls[pre]]; if(l==r) return l; if(tmp>=pos) return query(ls[pre],ls[nxt],l,mid,pos); else return query(rs[pre],rs[nxt],mid+1,r,pos-tmp); } void dfs(int u,int p){ fa[u][0]=p; for(int i=1;i<K;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; l[u]=dfn; int top=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; dfs(v,u);++top; } if(!top) ++dfn,change(rt[dfn],rt[dfn-1],1,btot,h[u]); r[u]=dfn; } void lsh(){ sort(b+1,b+n+1,Cmp); btot=unique(b+1,b+n+1)-b-1; for(int i=1;i<=n;++i) h[i]=lower_bound(b+1,b+btot+1,h[i])-b; } int main(){ scanf(\"%d%d%d\",&n,&m,&q); memset(head,-1,sizeof head),cnt=-1; for(int i=1;i<=n;++i) scanf(\"%d\",&h[i]),b[i]=h[i]; lsh(); for(int i=1;i<=m;++i) scanf(\"%d%d%d\",&u,&v,&w),f[i]=edge(u,v,w); kruskal(); dfs(tot,0); for(int i=1;i<=q;++i){ scanf(\"%d%d%d\",&v,&x,&k); u=v; for(int j=K-1;j>=0;--j) if(fa[u][j] && a[fa[u][j]]<=x) u=fa[u][j]; int tmp=sum[rt[r[u]]]-sum[rt[l[u]]],ans=0; if(tmp<k) printf(\"-1\\n\"); else{ ans=query(rt[l[u]],rt[r[u]],1,btot,tmp-k+1); printf(\"%d\\n\",b[ans]); } } return 0; }","title":"kruskal\u91cd\u6784\u6811"},{"location":"my%20past/OI/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/#kruskal","text":"","title":"kruskal\u91cd\u6784\u6811"},{"location":"my%20past/OI/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/#_1","text":"\u89e3\u51b3\u7c7b\u4f3c \u4ece\u67d0\u70b9v\u5f00\u59cb\u7ecf\u8fc7\u4e0d\u8d85\u8fc7\u8fb9\u6743x\u7684\u8fb9\u6240\u80fd\u5230\u8fbe\u7684\u8282\u70b9 \u7684\u95ee\u9898\u3002","title":"\u5e94\u7528"},{"location":"my%20past/OI/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/#_2","text":"\u5728$kruskal$\u8fc7\u7a0b\u4e2d\uff0c\u5982\u679c\u6709\u8fb9$(u,v,w)$,\u5176\u6240\u5c5e\u4e24\u4e2a\u96c6\u5408\u7684\u6839\u4e3a$uu,vv$\u5e76\u4e14\u4e0d\u76f8\u540c\uff0c\u90a3\u4e48\u5c31\u65b0\u5efa\u4e00\u4e2a\u8282\u70b9$p$\uff0c\u5c06$p$\u7684\u70b9\u6743\u503c\u8bbe\u4e3a$w$\uff0c\u5e76\u5c06$p$\u4e8e$u,v$\u8fde\u8fb9\u3002 \u6700\u540e\u6784\u6210\u4e86\u4e00\u68f5\u6811\uff0c\u5373$kruskal$\u91cd\u6784\u6811\u3002(\u56e0\u4e3a\u4e00\u5171$n$\u4e2a\u70b9\u7684\u539f\u56fe\u751f\u6210\u6811\u4e00\u5171\u6709$n-1$\u6761\u8fb9\uff0c\u5bf9\u5e94$n-1$\u4e2a\u65b0\u70b9\uff0c\u800c\u6bcf\u4e2a\u65b0\u70b9\u8fde\u51fa$2$\u6761\u65b0\u8fb9\uff0c\u6240\u4ee5\u91cd\u6784\u6811\u4e00\u5171$2n-1$\u4e2a\u70b9\uff0c$2n-2$\u6761\u8fb9) \u5f53\u8be2\u95ee\u4ece$v$\u7ecf\u8fc7$\\leq x$\u7684\u8fb9\u8d70\u8fc7\u7684\u8282\u70b9\u65f6\uff0c\u53ea\u9700\u8981\u4ece$v$\u5411\u4e0a\u500d\u589e\u627e\u5230\u70b9\u6743$\\leq x$\u7684\u70b9\u6743\u6700\u5927\u7684\u70b9\uff0c\u7ef4\u62a4\u8fd9\u4e2a\u70b9\u7684\u5b50\u6811\u5373\u53ef\u3002 P4197 & P7834 \u8f6c\u5316\u4e3a$kruskal$\u91cd\u6784\u6811\u540e\uff0c\u53d1\u73b0\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u5bf9\u5e94\u4e00\u4e2a\u533a\u95f4\uff0c\u800c\u8be2\u95ee\u5c31\u662f\u95ee\u4e00\u4e2a\u533a\u95f4\u7684\u7b2c$k$\u5927\uff0c\u4e3b\u5e2d\u6811\u5373\u53ef\u3002 \u6ce8\u610f\u5230\u7a7a\u95f4\u5361\u7684\u6bd4\u8f83\u6b7b\uff0c\u6240\u4ee5\u79bb\u6563\u5316\u4e00\u4e0b\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e5+10,M=5e5+10,K=22,INF=1e6+10; int n,m,q,cnt,u,v,w,tot,x,k,dfn,id,btot; int h[N],b[N],Fa[N<<1],a[N<<1],fa[N<<1][K],head[N<<1],l[N<<1],r[N<<1],rt[N<<1]; int ls[N*K],rs[N*K],sum[N*K]; struct edge{ int u,v,w; edge(int uu=0,int vv=0,int ww=0){ u=uu,v=vv,w=ww; } }f[M]; struct Edge{ int v,nxt; }e[M<<1]; bool cmp(edge a,edge b){ return a.w<b.w; } bool Cmp(int a,int b){ return a<b; } void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } int getfa(int u){ return u==Fa[u]?u:Fa[u]=getfa(Fa[u]); } void kruskal(){ sort(f+1,f+m+1,cmp); for(int i=1;i<=n;++i) Fa[i]=i; tot=n;int count=0; for(int i=1;i<=m;++i){ int u=f[i].u,v=f[i].v,w=f[i].w,uu=getfa(u),vv=getfa(v),p=0; if(uu!=vv){ ++count; p=++tot,Fa[uu]=Fa[vv]=Fa[p]=p,a[p]=w; add(p,uu),add(uu,p),add(vv,p),add(p,vv); } if(count>=n-1) break; } } void change(int &now,int pre,int l,int r,int pos){ now=++id; ls[now]=ls[pre],rs[now]=rs[pre],sum[now]=sum[pre]+1; if(l==r) return; int mid=l+r>>1; if(pos<=mid) change(ls[now],ls[pre],l,mid,pos); else change(rs[now],rs[pre],mid+1,r,pos); } int query(int pre,int nxt,int l,int r,int pos){ int mid=l+r>>1,tmp=sum[ls[nxt]]-sum[ls[pre]]; if(l==r) return l; if(tmp>=pos) return query(ls[pre],ls[nxt],l,mid,pos); else return query(rs[pre],rs[nxt],mid+1,r,pos-tmp); } void dfs(int u,int p){ fa[u][0]=p; for(int i=1;i<K;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; l[u]=dfn; int top=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; dfs(v,u);++top; } if(!top) ++dfn,change(rt[dfn],rt[dfn-1],1,btot,h[u]); r[u]=dfn; } void lsh(){ sort(b+1,b+n+1,Cmp); btot=unique(b+1,b+n+1)-b-1; for(int i=1;i<=n;++i) h[i]=lower_bound(b+1,b+btot+1,h[i])-b; } int main(){ scanf(\"%d%d%d\",&n,&m,&q); memset(head,-1,sizeof head),cnt=-1; for(int i=1;i<=n;++i) scanf(\"%d\",&h[i]),b[i]=h[i]; lsh(); for(int i=1;i<=m;++i) scanf(\"%d%d%d\",&u,&v,&w),f[i]=edge(u,v,w); kruskal(); dfs(tot,0); for(int i=1;i<=q;++i){ scanf(\"%d%d%d\",&v,&x,&k); u=v; for(int j=K-1;j>=0;--j) if(fa[u][j] && a[fa[u][j]]<=x) u=fa[u][j]; int tmp=sum[rt[r[u]]]-sum[rt[l[u]]],ans=0; if(tmp<k) printf(\"-1\\n\"); else{ ans=query(rt[l[u]],rt[r[u]],1,btot,tmp-k+1); printf(\"%d\\n\",b[ans]); } } return 0; }","title":"\u539f\u7406"},{"location":"my%20past/OI/manacher/","text":"manacher\u7b97\u6cd5 \u5e94\u7528 \u7528\u6765\u5904\u7406\u6700\u957f\u56de\u6587\u4e32\u95ee\u9898\u3002 \u6a21\u677f void init(){ a[1]=-1; for(int i=1;i<=n;++i) a[i*2]=0,a[i*2+1]=ch[i]-'a'+1; tot=2*n+2,a[tot]=0; } void manacher(){ init(); for(int i=1;i<=tot;++i){ if(i<r) p[i]=min(p[mid*2-i],r-i); else p[i]=0; while(i+p[i]+1<=tot && i-p[i]-1>=1 && a[i+p[i]+1]==a[i-p[i]-1]) p[i]++; if(i+p[i]>r) mid=i,r=i+p[i]; ans=max(ans,p[i]); } } P4555 \u60f3\u5230$L[i],R[i]$\u5206\u522b\u8868\u793a\u5de6\u7aef\u70b9/\u53f3\u7aef\u70b9\u4e3a$i$\u65f6\u7684\u6700\u957f\u56de\u6587\u4e32\uff0c\u5219\u7b54\u6848\u4e3a$\\max_{i=2}^n(R[i-1]+L[i])$. \u800c$L[i],R[i]$\u6570\u7ec4\u53ef\u4ee5\u7528\u8d2a\u5fc3\uff0c\u76f4\u63a5\u53cc\u6307\u9488\u5904\u7406\u3002 \u8bbe$j$\u4e3a\u7b2c\u4e00\u4e2a\u6ee1\u8db3$j+p[j]\\geq i$\u7684,\u5728\u6e90\u5b57\u7b26\u4e32\u4e2d\u4f4d\u7f6e\u4e3a$k$\uff0c\u65b0\u5b57\u7b26\u4e32\u4e2d\u4f4d\u7f6e\u4e3a$i$\u7684\u4e2d\u95f4\u70b9\uff0c\u5219$R[k]=\\min(p[j],i-j+1)$; \u7c7b\u4f3c\u7684$L[k]=min(p[j],j-i+1)$\uff1b \u81f3\u4e8e\u4e3a\u4ec0\u4e48\u8d2a\u5fc3\u662f\u5bf9\u7684\uff0c\u8003\u8651\u53f3\u7aef\u70b9\u4e3a$i$\u7684\u56de\u6587\u4e32\u6700\u957f\u5c31\u662f$i-j+1$\u7684\u957f\u5ea6(\u6307\u7684\u662f\u65b0\u5b57\u7b26\u4e32\u4e2d\u7684\u4e0b\u6807\u5dee)\uff0c\u56e0\u6b64\u5982\u679c\u6709$j$\u6ee1\u8db3$j+p[j]\\geq i$,\u90a3\u4e48$j+1,j+2,...$\u5904\u7684\u56de\u6587\u4e32\u4e00\u5b9a\u77ed\u4e8e$j$\u5904\u7684,\u5373\u7b2c\u4e00\u4e2a\u6ee1\u8db3\u4e0a\u8ff0\u5f0f\u5b50\u7684$j$\u5904\u7684\u56de\u6587\u4e32\u4e3a\u6240\u6c42\u6700\u957f\u4e32\u3002\u53ef\u4ee5\u770b\u51fa$j$\u5355\u8c03\u9012\u589e\uff0c\u590d\u6742\u5ea6$O(n)$. #include<bits/stdc++.h> using namespace std; const int N=2e5+10; int p[N],a[N],R[N],L[N]; char ch[N]; int n,tot,r,mid; void init(){ a[1]=-1; for(int i=1;i<=n;++i) a[i*2]=0,a[i*2+1]=ch[i]-'a'+1; tot=2*n+2,a[tot]=0; } void manacher(){ init(); for(int i=1;i<=tot;++i){ if(i<r) p[i]=min(p[mid*2-i],r-i); else p[i]=0; while(i+p[i]+1<=tot && i-p[i]-1>=1 && a[i+p[i]+1]==a[i-p[i]-1]) p[i]++; if(i+p[i]>r) mid=i,r=i+p[i]; } } int main(){ scanf(\"%s\",ch+1);n=strlen(ch+1); manacher(); int j=0,i=0; for(int k=1;k<=n;++k){ i=k*2+1; while(j+p[j]<i && j<=tot) ++j; R[k]=min(p[j],i-j+1); } j=tot; for(int k=n;k>=1;--k){ i=k*2+1; while(i<j-p[j] && j>=1) --j; L[k]=min(p[j],j-i+1); } int ans=0; for(int i=2;i<=n;++i) ans=max(ans,R[i-1]+L[i]); printf(\"%d\",ans); return 0; }","title":"manacher\u7b97\u6cd5"},{"location":"my%20past/OI/manacher/#manacher","text":"","title":"manacher\u7b97\u6cd5"},{"location":"my%20past/OI/manacher/#_1","text":"\u7528\u6765\u5904\u7406\u6700\u957f\u56de\u6587\u4e32\u95ee\u9898\u3002","title":"\u5e94\u7528"},{"location":"my%20past/OI/manacher/#_2","text":"void init(){ a[1]=-1; for(int i=1;i<=n;++i) a[i*2]=0,a[i*2+1]=ch[i]-'a'+1; tot=2*n+2,a[tot]=0; } void manacher(){ init(); for(int i=1;i<=tot;++i){ if(i<r) p[i]=min(p[mid*2-i],r-i); else p[i]=0; while(i+p[i]+1<=tot && i-p[i]-1>=1 && a[i+p[i]+1]==a[i-p[i]-1]) p[i]++; if(i+p[i]>r) mid=i,r=i+p[i]; ans=max(ans,p[i]); } } P4555 \u60f3\u5230$L[i],R[i]$\u5206\u522b\u8868\u793a\u5de6\u7aef\u70b9/\u53f3\u7aef\u70b9\u4e3a$i$\u65f6\u7684\u6700\u957f\u56de\u6587\u4e32\uff0c\u5219\u7b54\u6848\u4e3a$\\max_{i=2}^n(R[i-1]+L[i])$. \u800c$L[i],R[i]$\u6570\u7ec4\u53ef\u4ee5\u7528\u8d2a\u5fc3\uff0c\u76f4\u63a5\u53cc\u6307\u9488\u5904\u7406\u3002 \u8bbe$j$\u4e3a\u7b2c\u4e00\u4e2a\u6ee1\u8db3$j+p[j]\\geq i$\u7684,\u5728\u6e90\u5b57\u7b26\u4e32\u4e2d\u4f4d\u7f6e\u4e3a$k$\uff0c\u65b0\u5b57\u7b26\u4e32\u4e2d\u4f4d\u7f6e\u4e3a$i$\u7684\u4e2d\u95f4\u70b9\uff0c\u5219$R[k]=\\min(p[j],i-j+1)$; \u7c7b\u4f3c\u7684$L[k]=min(p[j],j-i+1)$\uff1b \u81f3\u4e8e\u4e3a\u4ec0\u4e48\u8d2a\u5fc3\u662f\u5bf9\u7684\uff0c\u8003\u8651\u53f3\u7aef\u70b9\u4e3a$i$\u7684\u56de\u6587\u4e32\u6700\u957f\u5c31\u662f$i-j+1$\u7684\u957f\u5ea6(\u6307\u7684\u662f\u65b0\u5b57\u7b26\u4e32\u4e2d\u7684\u4e0b\u6807\u5dee)\uff0c\u56e0\u6b64\u5982\u679c\u6709$j$\u6ee1\u8db3$j+p[j]\\geq i$,\u90a3\u4e48$j+1,j+2,...$\u5904\u7684\u56de\u6587\u4e32\u4e00\u5b9a\u77ed\u4e8e$j$\u5904\u7684,\u5373\u7b2c\u4e00\u4e2a\u6ee1\u8db3\u4e0a\u8ff0\u5f0f\u5b50\u7684$j$\u5904\u7684\u56de\u6587\u4e32\u4e3a\u6240\u6c42\u6700\u957f\u4e32\u3002\u53ef\u4ee5\u770b\u51fa$j$\u5355\u8c03\u9012\u589e\uff0c\u590d\u6742\u5ea6$O(n)$. #include<bits/stdc++.h> using namespace std; const int N=2e5+10; int p[N],a[N],R[N],L[N]; char ch[N]; int n,tot,r,mid; void init(){ a[1]=-1; for(int i=1;i<=n;++i) a[i*2]=0,a[i*2+1]=ch[i]-'a'+1; tot=2*n+2,a[tot]=0; } void manacher(){ init(); for(int i=1;i<=tot;++i){ if(i<r) p[i]=min(p[mid*2-i],r-i); else p[i]=0; while(i+p[i]+1<=tot && i-p[i]-1>=1 && a[i+p[i]+1]==a[i-p[i]-1]) p[i]++; if(i+p[i]>r) mid=i,r=i+p[i]; } } int main(){ scanf(\"%s\",ch+1);n=strlen(ch+1); manacher(); int j=0,i=0; for(int k=1;k<=n;++k){ i=k*2+1; while(j+p[j]<i && j<=tot) ++j; R[k]=min(p[j],i-j+1); } j=tot; for(int k=n;k>=1;--k){ i=k*2+1; while(i<j-p[j] && j>=1) --j; L[k]=min(p[j],j-i+1); } int ans=0; for(int i=2;i<=n;++i) ans=max(ans,R[i-1]+L[i]); printf(\"%d\",ans); return 0; }","title":"\u6a21\u677f"},{"location":"my%20past/OI/wqs%E4%BA%8C%E5%88%86/","text":"wqs\u4e8c\u5206 \u5e94\u7528 \u6709$n$\u4e2a\u7269\u54c1\uff0c\u8981\u6c42\u4f60\u9009\u51fa $m$ \u4e2a\uff0c\u9009\u7684\u65f6\u5019\u5e26\u6709\u9650\u5236\uff0c\u8981\u4f60\u6c42\u51fa\u6700\u4f18\u7684\u65b9\u6848\u3002 P1484 \u4e0d\u5e26\u9650\u5236\u6c42\u89e3\u53ef\u4ee5\u7528$dp$. \u8bbe$f[i][0/1]$\u8868\u793a\u5f53\u524d\u4e3a\u7b2c$i$\u4e2a\u5751\uff0c\u9009\u6216\u4e0d\u9009\u65f6\u7684\u6700\u5927\u83b7\u5229\uff0c$g[i][0/1]$\u4e3a\u5bf9\u5e94$f[i][0/1]$\u7684\u6700\u5c0f\u6316\u5751\u6b21\u6570\u3002 \u90a3\u4e48\u6211\u4eec\u53ea\u8981\u5224\u65ad\u6700\u5927\u83b7\u5229\u65f6\u7684\u6700\u5c0f\u6b21\u6570\u662f\u5426\u6ee1\u8db3$\\leq m$\u5373\u53ef\u4e8c\u5206\u3002 #include<bits/stdc++.h> #define int long long using namespace std; const int N=5e5+10,INF=0x3f3f3f3f; int a[N],f[N][2],g[N][2]; int n,m,maxn,ans,cnt; bool check(int k){ //memset(f,0,sizeof f),memset(g,0,sizeof g); f[0][0]=f[0][1]=g[0][0]=g[0][1]=0; for(int i=1;i<=n;++i){ if(f[i-1][0]>f[i-1][1] || (f[i-1][0]==f[i-1][1] && g[i-1][0]<g[i-1][1])) f[i][0]=f[i-1][0],g[i][0]=g[i-1][0]; else f[i][0]=f[i-1][1],g[i][0]=g[i-1][1]; f[i][1]=f[i-1][0]+a[i]-k,g[i][1]=g[i-1][0]+1; } ans=-INF,cnt=0; if(f[n][0]>f[n][1] || (f[n][0]==f[n][1] && g[n][0]<g[n][1])) ans=f[n][0],cnt=g[n][0]; else ans=f[n][1],cnt=g[n][1]; return cnt<=m; } signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i]); if(check(0)){ printf(\"%lld\",ans);return 0; } int l=0,r=INF,res=0; while(l<=r){ int mid=l+r>>1; if(check(mid)) res=ans+m*mid,r=mid-1; else l=mid+1; } printf(\"%lld\",res); return 0; }","title":"wqs\u4e8c\u5206"},{"location":"my%20past/OI/wqs%E4%BA%8C%E5%88%86/#wqs","text":"","title":"wqs\u4e8c\u5206"},{"location":"my%20past/OI/wqs%E4%BA%8C%E5%88%86/#_1","text":"\u6709$n$\u4e2a\u7269\u54c1\uff0c\u8981\u6c42\u4f60\u9009\u51fa $m$ \u4e2a\uff0c\u9009\u7684\u65f6\u5019\u5e26\u6709\u9650\u5236\uff0c\u8981\u4f60\u6c42\u51fa\u6700\u4f18\u7684\u65b9\u6848\u3002 P1484 \u4e0d\u5e26\u9650\u5236\u6c42\u89e3\u53ef\u4ee5\u7528$dp$. \u8bbe$f[i][0/1]$\u8868\u793a\u5f53\u524d\u4e3a\u7b2c$i$\u4e2a\u5751\uff0c\u9009\u6216\u4e0d\u9009\u65f6\u7684\u6700\u5927\u83b7\u5229\uff0c$g[i][0/1]$\u4e3a\u5bf9\u5e94$f[i][0/1]$\u7684\u6700\u5c0f\u6316\u5751\u6b21\u6570\u3002 \u90a3\u4e48\u6211\u4eec\u53ea\u8981\u5224\u65ad\u6700\u5927\u83b7\u5229\u65f6\u7684\u6700\u5c0f\u6b21\u6570\u662f\u5426\u6ee1\u8db3$\\leq m$\u5373\u53ef\u4e8c\u5206\u3002 #include<bits/stdc++.h> #define int long long using namespace std; const int N=5e5+10,INF=0x3f3f3f3f; int a[N],f[N][2],g[N][2]; int n,m,maxn,ans,cnt; bool check(int k){ //memset(f,0,sizeof f),memset(g,0,sizeof g); f[0][0]=f[0][1]=g[0][0]=g[0][1]=0; for(int i=1;i<=n;++i){ if(f[i-1][0]>f[i-1][1] || (f[i-1][0]==f[i-1][1] && g[i-1][0]<g[i-1][1])) f[i][0]=f[i-1][0],g[i][0]=g[i-1][0]; else f[i][0]=f[i-1][1],g[i][0]=g[i-1][1]; f[i][1]=f[i-1][0]+a[i]-k,g[i][1]=g[i-1][0]+1; } ans=-INF,cnt=0; if(f[n][0]>f[n][1] || (f[n][0]==f[n][1] && g[n][0]<g[n][1])) ans=f[n][0],cnt=g[n][0]; else ans=f[n][1],cnt=g[n][1]; return cnt<=m; } signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i]); if(check(0)){ printf(\"%lld\",ans);return 0; } int l=0,r=INF,res=0; while(l<=r){ int mid=l+r>>1; if(check(mid)) res=ans+m*mid,r=mid-1; else l=mid+1; } printf(\"%lld\",res); return 0; }","title":"\u5e94\u7528"},{"location":"my%20past/OI/xor/","text":"\u5f02\u6216 P3760 \u5bf9\u4e8e\u8fde\u7eed\u533a\u95f4\uff0c\u53ef\u4ee5\u60f3\u5230\u7528\u524d\u7f00\u548c$s[j]-s[i-1]$\u8868\u793a$\\sum_{k=i}^{j}a[k]$\u3002 \u90a3\u4e48\uff0c\u5bf9\u4e8e\u7b54\u6848\u6bcf\u4e00\u4f4d$k$\uff0c\u6c42\u51fa\u6709\u591a\u5c11$s[j]-s[i]$\u7b2c$k$\u4f4d\u4e3a1\u3002 \u90a3\u4e48\uff0c\u4ece\u5934\u5230\u5c3e\u626b\u63cf$s[j]$,\u7528\u6743\u503c\u6811\u72b6\u6570\u7ec4(\u4e24\u4e2a\uff0c\u4e00\u4e2a\u7ef4\u62a4\u7b2ck\u4f4d\u662f0\uff0c\u4e00\u4e2a\u7ef4\u62a4\u7b2ck\u4f4d\u662f1)\u7ef4\u62a4\u4e4b\u524d\u7684$s[i]$,\u5bf9\u8fd9\u4e00\u4f4d\u7684\u7b54\u6848\u6709\u8d21\u732e\u7684\u53ea\u6709\u90a3\u4e9b\u7b2ck\u4f4d\u4e3a1\u4e14\u7b2ck\u4f4d\u5411\u53f3\u7684\u6570\u6bd4s[i]\u7b2ck\u4f4d\u5411\u53f3\u7684\u6570\u5927\u7684\u6216\u8005\u7b2ck\u4f4d\u4e3a0\u4e14\u7b2ck\u4f4d\u5411\u53f3\u7684\u6570\u4e0d\u6bd4s[i]\u7b2ck\u4f4d\u5411\u53f3\u7684\u6570\u5927\u7684\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long #define lowbit(x) (x&-x) using namespace std; const int N=1e5+10,C=1e6+10; int s[N],a[N],f[C][2]; int n,maxn,ans; void change(int i,int x,int d){ while(x<C)f[x][i]+=d,x+=lowbit(x); } int sum(int i,int x){ int ans=0; while(x>0)ans+=f[x][i],x-=lowbit(x); return ans; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),s[i]=s[i-1]+a[i],maxn=max(maxn,s[i]); for(int v=0;v<=20;++v){ if((1<<v)>maxn)break; int cnt=0; memset(f,0,sizeof f); change(0,1,1); for(int i=1;i<=n;++i){ int tmp=s[i]&((1<<v)-1),type=(s[i]>>v)&1; if(type)cnt+=sum(1,C-1)-sum(1,tmp+1)+sum(0,tmp+1); else cnt+=sum(0,C-1)-sum(0,tmp+1)+sum(1,tmp+1); change(type,tmp+1,1); } if(cnt%2)ans|=(1<<v); } printf(\"%lld\",ans); return 0; }","title":"\u5f02\u6216"},{"location":"my%20past/OI/xor/#_1","text":"P3760 \u5bf9\u4e8e\u8fde\u7eed\u533a\u95f4\uff0c\u53ef\u4ee5\u60f3\u5230\u7528\u524d\u7f00\u548c$s[j]-s[i-1]$\u8868\u793a$\\sum_{k=i}^{j}a[k]$\u3002 \u90a3\u4e48\uff0c\u5bf9\u4e8e\u7b54\u6848\u6bcf\u4e00\u4f4d$k$\uff0c\u6c42\u51fa\u6709\u591a\u5c11$s[j]-s[i]$\u7b2c$k$\u4f4d\u4e3a1\u3002 \u90a3\u4e48\uff0c\u4ece\u5934\u5230\u5c3e\u626b\u63cf$s[j]$,\u7528\u6743\u503c\u6811\u72b6\u6570\u7ec4(\u4e24\u4e2a\uff0c\u4e00\u4e2a\u7ef4\u62a4\u7b2ck\u4f4d\u662f0\uff0c\u4e00\u4e2a\u7ef4\u62a4\u7b2ck\u4f4d\u662f1)\u7ef4\u62a4\u4e4b\u524d\u7684$s[i]$,\u5bf9\u8fd9\u4e00\u4f4d\u7684\u7b54\u6848\u6709\u8d21\u732e\u7684\u53ea\u6709\u90a3\u4e9b\u7b2ck\u4f4d\u4e3a1\u4e14\u7b2ck\u4f4d\u5411\u53f3\u7684\u6570\u6bd4s[i]\u7b2ck\u4f4d\u5411\u53f3\u7684\u6570\u5927\u7684\u6216\u8005\u7b2ck\u4f4d\u4e3a0\u4e14\u7b2ck\u4f4d\u5411\u53f3\u7684\u6570\u4e0d\u6bd4s[i]\u7b2ck\u4f4d\u5411\u53f3\u7684\u6570\u5927\u7684\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long #define lowbit(x) (x&-x) using namespace std; const int N=1e5+10,C=1e6+10; int s[N],a[N],f[C][2]; int n,maxn,ans; void change(int i,int x,int d){ while(x<C)f[x][i]+=d,x+=lowbit(x); } int sum(int i,int x){ int ans=0; while(x>0)ans+=f[x][i],x-=lowbit(x); return ans; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),s[i]=s[i-1]+a[i],maxn=max(maxn,s[i]); for(int v=0;v<=20;++v){ if((1<<v)>maxn)break; int cnt=0; memset(f,0,sizeof f); change(0,1,1); for(int i=1;i<=n;++i){ int tmp=s[i]&((1<<v)-1),type=(s[i]>>v)&1; if(type)cnt+=sum(1,C-1)-sum(1,tmp+1)+sum(0,tmp+1); else cnt+=sum(0,C-1)-sum(0,tmp+1)+sum(1,tmp+1); change(type,tmp+1,1); } if(cnt%2)ans|=(1<<v); } printf(\"%lld\",ans); return 0; }","title":"\u5f02\u6216"},{"location":"my%20past/OI/%E4%B8%BB%E5%B8%AD%E6%A0%91/","text":"\u4e3b\u5e2d\u6811 3939 \u6ce8\u610f\u52a8\u6001\u5f00\u70b9\u7684\u5199\u6cd5\u4ee5\u53ca\u4fee\u6539\u64cd\u4f5c\uff1a\u4fee\u6539\u53ea\u9700\u8981\u6539\u524d\u4e00\u4e2a\u70b9\uff0c\u540e\u4e00\u4e2a\u70b9\u7ef4\u62a4\u7684\u503c\u4e0d\u53d8. #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=3e5+10; int rt[N],ls[N*60],rs[N*60],a[N],tre[N*60]; int n,m,op,l,r,c,x,cnt; void change(int &x,int x1,int l,int r,int pos,int k) { x=++cnt; rs[x]=rs[x1];//\u6ce8\u610f ls[x]=ls[x1]; tre[x]=tre[x1]+k; if(l==r) { return; } int mid=l+r>>1; if(mid>=pos) { change(ls[x],ls[x1],l,mid,pos,k); } else { change(rs[x],rs[x1],mid+1,r,pos,k); } return; } int abs1(int x){ return x>0?x:-x; } int query(int x1,int x2,int l,int r,int pos) { if(l==r){ return abs1(tre[x2]-tre[x1]); } int mid=l+r>>1; if(mid>=pos) { return query(ls[x1],ls[x2],l,mid,pos); } else { return query(rs[x1],rs[x2],mid+1,r,pos); } } int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); return; } int main() { cnt=0; n=read1(),m=read1(); for(int i=1; i<=n; ++i)a[i]=read1(); for(int i=1; i<=n; ++i){ change(rt[i],rt[i-1],0,N+1,a[i],1); } for(int i=1; i<=m; ++i) { op=read1(); if(op==1) { l=read1(),r=read1(),c=read1(); int ans=query(rt[l-1],rt[r],0,N+1,c); write1(ans); putchar('\\n'); } else { x=read1(); change(rt[x],rt[x],0,N+1,a[x],-1); change(rt[x],rt[x],0,N+1,a[x+1], 1); swap(a[x],a[x+1]); } } return 0; } P6166 & P1383 \u4e24\u4e2a\u9898\u5dee\u4e0d\u591a\uff0c\u90fd\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\u8f93\u5165\uff0c\u8f93\u51fa\u548c\u64a4\u56de\u3002 \u6ce8\u610f\u64a4\u56de\u53ef\u4ee5\u64a4\u56de\u64a4\u56de\u3002~~???~~ \u5bf9\u4e8e\u6bcf\u4e2a\u6839\u8282\u70b9\uff0c\u6211\u4eec\u53ef\u4ee5\u8bb0\u5f55\u4e00\u4e2anum\u6570\u7ec4\uff0c\u4ee3\u8868\u8fd9\u4e2a\u7248\u672c\u7684\u5b57\u7b26\u4e32\u4e2d\u6709\u51e0\u4e2a\u5b57\u7b26; \u6240\u4ee5\u6709\uff1a num[rt[tot]]=num[rt[tot-1]]+1 \u90a3\u4e48\u5bf9\u4e8e\u8f93\u5165\u64cd\u4f5c\uff0c\u5c31\u76f4\u63a5\u5728num[tot]\u7684\u4f4d\u7f6e\u63d2\u5165\u5b57\u6bcd\u5373\u53ef\u3002\u5728\u9012\u5f52\u5230\u6700\u540e\u4e00\u5c42\u65f6\u5728val\u6570\u7ec4\u4e2d\u8bb0\u5f55\u3002(l==r) \u8f93\u51fa\u64cd\u4f5c\u6ce8\u610f\u662f\u67e5\u8be2p+1,\u56e0\u4e3ap\u4ece0\u5f00\u59cb\u3002 \u64a4\u56de\u64cd\u4f5c\u76f4\u63a5\u8d4b\u503c\u6839\u8282\u70b9\u5373\u53ef\u3002 code time: #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=1e6+10,M=N*21; int n,cnt,tot,p,u; int ls[M],rs[M],val[M],num[N],rt[N]; char ch[5]; void add(int &now,int pre,int l,int r,int pos,int k){ now=++cnt; ls[now]=ls[pre]; rs[now]=rs[pre]; if(l==r){ val[now]=k; return; } int mid=l+r>>1; if(pos<=mid)add(ls[now],ls[pre],l,mid,pos,k); else add(rs[now],rs[pre],mid+1,r,pos,k); return; } int query(int x,int l,int r,int pos){ if(l==r)return val[x]; int mid=l+r>>1; if(pos<=mid)return query(ls[x],l,mid,pos); else return query(rs[x],mid+1,r,pos); } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i){ scanf(\"%s\",ch); if(ch[0]=='T'){ scanf(\"%s\",ch); int c=ch[0]-'a'+1; ++tot; num[tot]=num[tot-1]+1; add(rt[tot],rt[tot-1],1,N,num[tot],c); }else if(ch[0]=='P'){ scanf(\"%d\",&p); int q=query(rt[tot],1,N,p+1); printf(\"%c\\n\",q+'a'-1); }else{ scanf(\"%d\",&u); tot++; rt[tot]=rt[tot-u-1]; num[tot]=num[tot-u-1]; } } return 0; } P2633 & SP10628 \u8fd9\u4e24\u9053\u9898\u5f88\u597d\uff0c\u6709\u5f88\u591a\u7ec6\u8282\u503c\u5f97\u8bf4\u8bf4\u3002 \u9996\u5148\uff0c\u770b\u5230\u5728\u6811\u4e0a\u6c42\u4e24\u70b9\u95f4\u5185\u5bb9\u7684\u95ee\u9898\uff0c\u5c31\u4e0d\u96be\u60f3\u5230\u6811\u5256lca\uff0c\u800c\u4e14\u662f\u7b2ck\u5c0f\uff0c\u5c31\u8981\u7528\u4e3b\u5e2d\u6811\uff0c\u800c\u8fd9\u9053\u9898\u4e5f\u662f\u4e00\u6837\u3002 \u53ea\u4e0d\u8fc7\u6bcf\u6b21\u8df3top\u65f6\u7d2f\u52a0\u7684\u4e0d\u518d\u662f\u5177\u4f53\u7684\u503c\uff0c\u800c\u662f\u4e00\u4e2a\u533a\u95f4\u4e24\u7aef\u5bf9\u5e94\u7684\u6839\u8282\u70b9\u3002 \u8fd9\u6837\uff0c\u5728\u6574\u4f53\u67e5\u8be2\u65f6\uff0c\u5c06\u6240\u6709\u53f3\u7aef\u70b9\u52a0\u8d77\u6765\uff0c\u6240\u6709\u5de6\u7aef\u70b9\u51cf\u4e0b\u53bb\uff0c\u5c31\u53ef\u4ee5\u7ec4\u6210\u7531\u4e24\u70b9\u95f4\u6240\u6709\u6743\u503c\u7ec4\u6210\u7684\u4e3b\u5e2d\u6811\u4e86\u3002 \u4e00\u4e9b\u7ec6\u8282\uff1a 1) \u6811\u5256\u65f6\u8fd8\u662f\u6ce8\u610f\uff0cdfs\u5e8f\u8981\u5148\u91cd\u513f\u5b50\u518d\u8f7b\u513f\u5b50\u3002 2) \u7b2ck\u5c0f\u4eff\u7167treap\u7684\u5199\u6cd5\uff0c\u6bcf\u6b21\u5411\u53f3\u641c\u90fd\u5c06k-tmp; 3) \u6743\u503c\u662f0\\~MAXINT,\u6240\u4ee5\u4e3b\u5e2d\u6811\u6570\u7ec4\u522b\u5f00\u5c0f\u4e86\uff0c\u81f3\u5c1131\u500d. 4) b1,b2\u6570\u7ec4\u8bb0\u5f55\u7684\u65f6\u7531dfs\u5e8f\u5f97\u51fa\u7684\u6839\u8282\u70b9\u5e8f\u53f7\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u7528\u3002 5) \u6ce8\u610f\u6240\u6709\u5de6\u7aef\u70b9\u90fd\u662f\u6df1\u5ea6\u4f4e\u7684\u70b9\uff0c\u5e76\u4e14\u56e0\u4e3a\u5dee\u5206\uff0cdfs\u5e8f\u8981-1\uff1b 6) \u5efa\u4e3b\u5e2d\u6811\u6309\u7167dfs\u5e8f\u5efa\u3002 code time: #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e5+10,M=N*40,C=3e9; int rt[N],ls[M],rs[M],num[M]; int n,m,cnt,tot,cur,u,v,k; int a[N],head[N],sz[N],fa[N],son[N],dep[N],top[N],dfn[N],b1[N],b2[N],id[N]; struct node{ int v,nxt; }e[N<<1]; void add(int u,int v){ e[++cnt].v=v; e[cnt].nxt=head[u]; head[u]=cnt; } void dfs1(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; dep[v]=dep[u]+1; fa[v]=u; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]>sz[son[u]])son[u]=v; } } void dfs2(int u,int t){ top[u]=t; id[u]=++tot; dfn[tot]=u; if(son[u])dfs2(son[u],t); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==fa[u] || v==son[u])continue; dfs2(v,v); } } void add(int &now,int pre,int l,int r,int pos){ now=++cur; ls[now]=ls[pre]; rs[now]=rs[pre]; num[now]=num[pre]+1; if(l==r){ return; } int mid=l+r>>1; if(pos<=mid)add(ls[now],ls[pre],l,mid,pos); else add(rs[now],rs[pre],mid+1,r,pos); } int query(int l,int r,int k){ if(l==r)return l; int tmp=0,mid=l+r>>1; for(int i=1;i<=b1[0];++i){ tmp+=num[ls[b1[i]]]; } for(int i=1;i<=b2[0];++i){ tmp-=num[ls[b2[i]]]; } if(k<=tmp){ for(int i=1;i<=b1[0];++i){ b1[i]=ls[b1[i]]; } for(int i=1;i<=b2[0];++i){ b2[i]=ls[b2[i]]; } return query(l,mid,k); }else{ for(int i=1;i<=b1[0];++i){ b1[i]=rs[b1[i]]; } for(int i=1;i<=b2[0];++i){ b2[i]=rs[b2[i]]; } return query(mid+1,r,k-tmp); } } int get1(int u,int v,int k){ b1[0]=0; b2[0]=0; while(top[u]!=top[v]){ if(dep[top[u]]<dep[top[v]])swap(u,v); b1[++b1[0]]=rt[id[u]]; b2[++b2[0]]=rt[id[top[u]]-1]; u=fa[top[u]]; } if(dep[u]<dep[v])swap(u,v); b1[++b1[0]]=rt[id[u]]; b2[++b2[0]]=rt[id[v]-1]; return query(0,C,k); } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i){ scanf(\"%lld\",&a[i]); } for(int i=1;i<n;++i){ scanf(\"%lld%lld\",&u,&v); add(u,v); add(v,u); } tot=0; dfs1(1,1); dfs2(1,1); cur=0; for(int i=1;i<=tot;++i){ add(rt[i],rt[i-1],0,C,a[dfn[i]]); } int last=0; for(int i=1;i<=m;++i){ scanf(\"%lld%lld%lld\",&u,&v,&k); u^=last; int tmp=get1(u,v,k); printf(\"%lld\\n\",tmp); last=tmp; } return 0; } ~~Q.\u5982\u4f55\u589e\u52a0\u505a\u9898\u91cf\uff1fA.\u53cc\u500d\u7ecf\u9a8c!~~","title":"\u4e3b\u5e2d\u6811"},{"location":"my%20past/OI/%E4%B8%BB%E5%B8%AD%E6%A0%91/#_1","text":"3939 \u6ce8\u610f\u52a8\u6001\u5f00\u70b9\u7684\u5199\u6cd5\u4ee5\u53ca\u4fee\u6539\u64cd\u4f5c\uff1a\u4fee\u6539\u53ea\u9700\u8981\u6539\u524d\u4e00\u4e2a\u70b9\uff0c\u540e\u4e00\u4e2a\u70b9\u7ef4\u62a4\u7684\u503c\u4e0d\u53d8. #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=3e5+10; int rt[N],ls[N*60],rs[N*60],a[N],tre[N*60]; int n,m,op,l,r,c,x,cnt; void change(int &x,int x1,int l,int r,int pos,int k) { x=++cnt; rs[x]=rs[x1];//\u6ce8\u610f ls[x]=ls[x1]; tre[x]=tre[x1]+k; if(l==r) { return; } int mid=l+r>>1; if(mid>=pos) { change(ls[x],ls[x1],l,mid,pos,k); } else { change(rs[x],rs[x1],mid+1,r,pos,k); } return; } int abs1(int x){ return x>0?x:-x; } int query(int x1,int x2,int l,int r,int pos) { if(l==r){ return abs1(tre[x2]-tre[x1]); } int mid=l+r>>1; if(mid>=pos) { return query(ls[x1],ls[x2],l,mid,pos); } else { return query(rs[x1],rs[x2],mid+1,r,pos); } } int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); return; } int main() { cnt=0; n=read1(),m=read1(); for(int i=1; i<=n; ++i)a[i]=read1(); for(int i=1; i<=n; ++i){ change(rt[i],rt[i-1],0,N+1,a[i],1); } for(int i=1; i<=m; ++i) { op=read1(); if(op==1) { l=read1(),r=read1(),c=read1(); int ans=query(rt[l-1],rt[r],0,N+1,c); write1(ans); putchar('\\n'); } else { x=read1(); change(rt[x],rt[x],0,N+1,a[x],-1); change(rt[x],rt[x],0,N+1,a[x+1], 1); swap(a[x],a[x+1]); } } return 0; } P6166 & P1383 \u4e24\u4e2a\u9898\u5dee\u4e0d\u591a\uff0c\u90fd\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\u8f93\u5165\uff0c\u8f93\u51fa\u548c\u64a4\u56de\u3002 \u6ce8\u610f\u64a4\u56de\u53ef\u4ee5\u64a4\u56de\u64a4\u56de\u3002~~???~~ \u5bf9\u4e8e\u6bcf\u4e2a\u6839\u8282\u70b9\uff0c\u6211\u4eec\u53ef\u4ee5\u8bb0\u5f55\u4e00\u4e2anum\u6570\u7ec4\uff0c\u4ee3\u8868\u8fd9\u4e2a\u7248\u672c\u7684\u5b57\u7b26\u4e32\u4e2d\u6709\u51e0\u4e2a\u5b57\u7b26; \u6240\u4ee5\u6709\uff1a num[rt[tot]]=num[rt[tot-1]]+1 \u90a3\u4e48\u5bf9\u4e8e\u8f93\u5165\u64cd\u4f5c\uff0c\u5c31\u76f4\u63a5\u5728num[tot]\u7684\u4f4d\u7f6e\u63d2\u5165\u5b57\u6bcd\u5373\u53ef\u3002\u5728\u9012\u5f52\u5230\u6700\u540e\u4e00\u5c42\u65f6\u5728val\u6570\u7ec4\u4e2d\u8bb0\u5f55\u3002(l==r) \u8f93\u51fa\u64cd\u4f5c\u6ce8\u610f\u662f\u67e5\u8be2p+1,\u56e0\u4e3ap\u4ece0\u5f00\u59cb\u3002 \u64a4\u56de\u64cd\u4f5c\u76f4\u63a5\u8d4b\u503c\u6839\u8282\u70b9\u5373\u53ef\u3002 code time: #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=1e6+10,M=N*21; int n,cnt,tot,p,u; int ls[M],rs[M],val[M],num[N],rt[N]; char ch[5]; void add(int &now,int pre,int l,int r,int pos,int k){ now=++cnt; ls[now]=ls[pre]; rs[now]=rs[pre]; if(l==r){ val[now]=k; return; } int mid=l+r>>1; if(pos<=mid)add(ls[now],ls[pre],l,mid,pos,k); else add(rs[now],rs[pre],mid+1,r,pos,k); return; } int query(int x,int l,int r,int pos){ if(l==r)return val[x]; int mid=l+r>>1; if(pos<=mid)return query(ls[x],l,mid,pos); else return query(rs[x],mid+1,r,pos); } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i){ scanf(\"%s\",ch); if(ch[0]=='T'){ scanf(\"%s\",ch); int c=ch[0]-'a'+1; ++tot; num[tot]=num[tot-1]+1; add(rt[tot],rt[tot-1],1,N,num[tot],c); }else if(ch[0]=='P'){ scanf(\"%d\",&p); int q=query(rt[tot],1,N,p+1); printf(\"%c\\n\",q+'a'-1); }else{ scanf(\"%d\",&u); tot++; rt[tot]=rt[tot-u-1]; num[tot]=num[tot-u-1]; } } return 0; } P2633 & SP10628 \u8fd9\u4e24\u9053\u9898\u5f88\u597d\uff0c\u6709\u5f88\u591a\u7ec6\u8282\u503c\u5f97\u8bf4\u8bf4\u3002 \u9996\u5148\uff0c\u770b\u5230\u5728\u6811\u4e0a\u6c42\u4e24\u70b9\u95f4\u5185\u5bb9\u7684\u95ee\u9898\uff0c\u5c31\u4e0d\u96be\u60f3\u5230\u6811\u5256lca\uff0c\u800c\u4e14\u662f\u7b2ck\u5c0f\uff0c\u5c31\u8981\u7528\u4e3b\u5e2d\u6811\uff0c\u800c\u8fd9\u9053\u9898\u4e5f\u662f\u4e00\u6837\u3002 \u53ea\u4e0d\u8fc7\u6bcf\u6b21\u8df3top\u65f6\u7d2f\u52a0\u7684\u4e0d\u518d\u662f\u5177\u4f53\u7684\u503c\uff0c\u800c\u662f\u4e00\u4e2a\u533a\u95f4\u4e24\u7aef\u5bf9\u5e94\u7684\u6839\u8282\u70b9\u3002 \u8fd9\u6837\uff0c\u5728\u6574\u4f53\u67e5\u8be2\u65f6\uff0c\u5c06\u6240\u6709\u53f3\u7aef\u70b9\u52a0\u8d77\u6765\uff0c\u6240\u6709\u5de6\u7aef\u70b9\u51cf\u4e0b\u53bb\uff0c\u5c31\u53ef\u4ee5\u7ec4\u6210\u7531\u4e24\u70b9\u95f4\u6240\u6709\u6743\u503c\u7ec4\u6210\u7684\u4e3b\u5e2d\u6811\u4e86\u3002 \u4e00\u4e9b\u7ec6\u8282\uff1a 1) \u6811\u5256\u65f6\u8fd8\u662f\u6ce8\u610f\uff0cdfs\u5e8f\u8981\u5148\u91cd\u513f\u5b50\u518d\u8f7b\u513f\u5b50\u3002 2) \u7b2ck\u5c0f\u4eff\u7167treap\u7684\u5199\u6cd5\uff0c\u6bcf\u6b21\u5411\u53f3\u641c\u90fd\u5c06k-tmp; 3) \u6743\u503c\u662f0\\~MAXINT,\u6240\u4ee5\u4e3b\u5e2d\u6811\u6570\u7ec4\u522b\u5f00\u5c0f\u4e86\uff0c\u81f3\u5c1131\u500d. 4) b1,b2\u6570\u7ec4\u8bb0\u5f55\u7684\u65f6\u7531dfs\u5e8f\u5f97\u51fa\u7684\u6839\u8282\u70b9\u5e8f\u53f7\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u7528\u3002 5) \u6ce8\u610f\u6240\u6709\u5de6\u7aef\u70b9\u90fd\u662f\u6df1\u5ea6\u4f4e\u7684\u70b9\uff0c\u5e76\u4e14\u56e0\u4e3a\u5dee\u5206\uff0cdfs\u5e8f\u8981-1\uff1b 6) \u5efa\u4e3b\u5e2d\u6811\u6309\u7167dfs\u5e8f\u5efa\u3002 code time: #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e5+10,M=N*40,C=3e9; int rt[N],ls[M],rs[M],num[M]; int n,m,cnt,tot,cur,u,v,k; int a[N],head[N],sz[N],fa[N],son[N],dep[N],top[N],dfn[N],b1[N],b2[N],id[N]; struct node{ int v,nxt; }e[N<<1]; void add(int u,int v){ e[++cnt].v=v; e[cnt].nxt=head[u]; head[u]=cnt; } void dfs1(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; dep[v]=dep[u]+1; fa[v]=u; dfs1(v,u); sz[u]+=sz[v]; if(sz[v]>sz[son[u]])son[u]=v; } } void dfs2(int u,int t){ top[u]=t; id[u]=++tot; dfn[tot]=u; if(son[u])dfs2(son[u],t); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==fa[u] || v==son[u])continue; dfs2(v,v); } } void add(int &now,int pre,int l,int r,int pos){ now=++cur; ls[now]=ls[pre]; rs[now]=rs[pre]; num[now]=num[pre]+1; if(l==r){ return; } int mid=l+r>>1; if(pos<=mid)add(ls[now],ls[pre],l,mid,pos); else add(rs[now],rs[pre],mid+1,r,pos); } int query(int l,int r,int k){ if(l==r)return l; int tmp=0,mid=l+r>>1; for(int i=1;i<=b1[0];++i){ tmp+=num[ls[b1[i]]]; } for(int i=1;i<=b2[0];++i){ tmp-=num[ls[b2[i]]]; } if(k<=tmp){ for(int i=1;i<=b1[0];++i){ b1[i]=ls[b1[i]]; } for(int i=1;i<=b2[0];++i){ b2[i]=ls[b2[i]]; } return query(l,mid,k); }else{ for(int i=1;i<=b1[0];++i){ b1[i]=rs[b1[i]]; } for(int i=1;i<=b2[0];++i){ b2[i]=rs[b2[i]]; } return query(mid+1,r,k-tmp); } } int get1(int u,int v,int k){ b1[0]=0; b2[0]=0; while(top[u]!=top[v]){ if(dep[top[u]]<dep[top[v]])swap(u,v); b1[++b1[0]]=rt[id[u]]; b2[++b2[0]]=rt[id[top[u]]-1]; u=fa[top[u]]; } if(dep[u]<dep[v])swap(u,v); b1[++b1[0]]=rt[id[u]]; b2[++b2[0]]=rt[id[v]-1]; return query(0,C,k); } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i){ scanf(\"%lld\",&a[i]); } for(int i=1;i<n;++i){ scanf(\"%lld%lld\",&u,&v); add(u,v); add(v,u); } tot=0; dfs1(1,1); dfs2(1,1); cur=0; for(int i=1;i<=tot;++i){ add(rt[i],rt[i-1],0,C,a[dfn[i]]); } int last=0; for(int i=1;i<=m;++i){ scanf(\"%lld%lld%lld\",&u,&v,&k); u^=last; int tmp=get1(u,v,k); printf(\"%lld\\n\",tmp); last=tmp; } return 0; } ~~Q.\u5982\u4f55\u589e\u52a0\u505a\u9898\u91cf\uff1fA.\u53cc\u500d\u7ecf\u9a8c!~~","title":"\u4e3b\u5e2d\u6811"},{"location":"my%20past/OI/%E4%BA%8C%E5%88%86/","text":"\u4e8c\u5206 P1663 \u4e8c\u5206\u5f53\u524d\u7684yy\u5750\u6807\uff0c\u6709\u4e09\u79cd\u60c5\u51b5\uff1a 1.\u4e24\u4e2a\u70b9\u4e00\u6837\u9ad8\uff0cy\u5750\u6807\u76f8\u540c\uff0c\u5219\u53ea\u8981yy\u5c0f\u4e8ey\u5c31\u4e0d\u6ee1\u8db3 2.\u5de6\u70b9\u4f4e\u53f3\u70b9\u9ad8\uff0c\u5219\u6839\u636e\u4e24\u70b9\u8868\u793a\u76f4\u7ebf\uff0cxx\u5e94\u4e3a $$ \\frac{x_2-x_1}{y_2-y_1}=\\frac{xx-x_1}{yy-y_1} \\ xx=\\frac{x_2-x_1}{y_2-y_1}* (yy-y_1)+x_1 $$ \u90a3\u4e48R=min(R,xx) 3.\u5de6\u8fb9\u9ad8\uff0c\u540c\u7406\uff0cL=max(L,xx) #include<iostream> #include<cstdio> #include<cstring> using namespace std; const double P=0.001,INF=1000001.0; const int N=1e5+10; struct node{ double x,y; }q[N]; int n; bool check(double y){ double L=0,R=INF; for(int i=2;i<=n;++i){ if(q[i].y==q[i-1].y){ if(y<q[i].y)return false; } else if(q[i].y>q[i-1].y){ double x1=q[i-1].x,x2=q[i].x,y1=q[i-1].y,y2=q[i].y; double x=((x2-x1)/(y2-y1))*(y-y1)+x1; R=min(R,x); } else{ double x1=q[i-1].x,x2=q[i].x,y1=q[i-1].y,y2=q[i].y; double x=((x2-x1)/(y2-y1))*(y-y1)+x1; L=max(L,x); } } return L<=R; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i){ scanf(\"%lf%lf\",&q[i].x,&q[i].y); } double l=0.0,r=INF,ans=-1.0; while(l+P<=r){ double mid=(l+r)/2.0; if(check(mid)){ r=mid; ans=mid; }else l=mid+P; } printf(\"%.2lf\",ans); return 0; } P1661 \u4e8c\u5206\u65f6\u95f4\uff0c\u5224\u65ad(\u66fc\u54c8\u987f\u8ddd\u79bb+1)/2\u662f\u5426\u5c0f\u4e8e\u7b49\u4e8e\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u6ee1\u8db3\u5c31\u5c06\u4e24\u4e2a\u70b9\u7528\u5e76\u67e5\u96c6\u8fde\u63a5\uff0c\u6700\u540e\u68c0\u67e5\u662f\u5426\u90fd\u5e76\u5728\u4e00\u4e2a\u70b9\u4e0a\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=55,INF=1e10; int abs1(int x){return x>0?x:-x;} int dis(int x1,int y1,int x2,int y2){return abs1(x1-x2)+abs1(y1-y2);} struct node{ int x,y; }q[N]; int n; int fa[N],vis[N]; int getfa(int u){ if(fa[u]==u)return u; return fa[u]=getfa(fa[u]); } bool check(int x){ for(int i=1;i<=n;++i)fa[i]=i; for(int i=1;i<n;++i){ for(int j=i+1;j<=n;++j){ int d=dis(q[i].x,q[i].y,q[j].x,q[j].y),t=(d+1)>>1; if(t<=x)fa[getfa(i)]=getfa(j); } } memset(vis,0,sizeof vis); for(int i=1;i<=n;++i)vis[getfa(i)]++; for(int i=1;i<=n;++i)if(vis[i]>=n)return true; return false; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld%lld\",&q[i].x,&q[i].y); int ans=0,l=0,r=INF; while(l<r){ int mid=l+r>>1; if(check(mid)){ r=mid; ans=mid; }else l=mid+1; } printf(\"%lld\",ans); return 0; } P7514 \u53ef\u4ee5\u4e8c\u5206\u4e00\u4e0b\u6781\u5dee$x$\uff0c\u5e76\u679a\u4e3e\u4e00\u4e0b\u533a\u95f4$[L,L+x]$,\u5176\u4e2d$L$\u53ef\u4ee5\u662f\u6240\u6709\u6b63\u53cd\u9762\u4e2d\u7684\u4efb\u610f\u503c\uff0c\u4e00\u5171$2n$\u4e2a\u3002\u56e0\u4e3a\u6240\u6709\u7684$a_i$\u662f\u5355\u589e\u7684\uff0c\u6240\u6709\u4e0d\u5728\u533a\u95f4\u7684\u6570\u4e00\u5b9a\u6784\u6210\u524d\u540e\u7f00\uff0c\u90a3\u4e48\u8fd9\u4e9b\u5361\u724c\u4e00\u5b9a\u8981\u7ffb\u9762\uff0c\u5e76\u4e14\u7ffb\u5b8c\u9762\u7684$b_i$\u4e5f\u8981\u5728\u533a\u95f4\u5185\uff0c\u6240\u4ee5\u8fd9\u6837\u679a\u4e3e\u5c31\u53ef\u4ee5\u5c06\u95ee\u9898\u8f6c\u5316\u6210\u524d\u540e\u7f00\u7684$RMQ$\u6700\u5927\u548c\u6700\u5c0f\u662f\u5426\u90fd\u5728\u533a\u95f4\u5185\uff0c\u4ee5\u53ca\u524d\u540e\u7f00\u662f\u5426\u8d85\u8fc7\u4e86$m$\u4e2a\u6570\u3002\u786e\u5b9a\u524d\u540e\u7f00\u7684\u4f4d\u7f6e\u53ef\u4ee5\u53cc\u6307\u9488\u722c\u4e00\u4e0b\u7ef4\u62a4\uff0c\u662f$O(n)$\u7684\u3002$RMQ$\u4e5f\u662f$O(n)$\u7684($st$\u8868)\uff0c\u6240\u4ee5\u603b\u590d\u6742\u5ea6$O(n\\log n)$ ~~\u5927\u5e38\u6570\u9009\u624b\u8868\u793a\u5f88\u6de6~~ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1000010,K=21,INF=1e9+10; struct node{ int a,b; }a[N]; int n,m,cnt; int b[N+N],Log[N],Max[N][K],Min[N][K]; int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } bool cmp(int a,int b){ return a<b; } void init(){ Log[1]=0; for(int i=2;i<=n;++i) Log[i]=Log[i>>1]+1; for(int i=1;i<=n;++i) Max[i][0]=Min[i][0]=a[i].b; for(int j=1;(1<<j)<=n;++j) for(int i=1;i+(1<<(j-1))<=n;++i) Min[i][j]=INF,Min[i][j]=min(Min[i][j-1],Min[i+(1<<(j-1))][j-1]),Max[i][j]=max(Max[i][j-1],Max[i+(1<<(j-1))][j-1]); } int query(int t,int l,int r){ if(l>r){ if(!t) return INF; else return 0; } int k=Log[r-l+1]; if(!t) return min(Min[l][k],Min[r-(1<<k)+1][k]); else return max(Max[l][k],Max[r-(1<<k)+1][k]); } bool check(int x){ bool flag=false; int l=1,r=0,L=0,R=0,_min=0,_max=0,tot=0; for(int i=1;i<=cnt;++i){ L=b[i],R=b[i]+x; while(a[l].a<L && l<=n) ++l; while(a[r+1].a<=R && r+1<=n) ++r; tot=l-1+n-r; if(tot>m)continue; _min=min(query(0,1,l-1),query(0,r+1,n)),_max=max(query(1,1,l-1),query(1,r+1,n)); if(_min<L || _max>R)continue; if(_min>=L && _max<=R){ flag=true;break; } } return flag; } int main(){ //freopen(\"P7514_9.txt\",\"r\",stdin); n=read1(),m=read1();cnt=0; for(int i=1;i<=n;++i) a[i].a=read1(),b[++cnt]=a[i].a; for(int i=1;i<=n;++i) a[i].b=read1(),b[++cnt]=a[i].b; sort(b+1,b+cnt+1,cmp); init(); int l=0,r=b[cnt]-b[1],ans=0; while(l<=r){ int mid=l+r>>1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; } printf(\"%d\",ans); return 0; }","title":"\u4e8c\u5206"},{"location":"my%20past/OI/%E4%BA%8C%E5%88%86/#_1","text":"P1663 \u4e8c\u5206\u5f53\u524d\u7684yy\u5750\u6807\uff0c\u6709\u4e09\u79cd\u60c5\u51b5\uff1a 1.\u4e24\u4e2a\u70b9\u4e00\u6837\u9ad8\uff0cy\u5750\u6807\u76f8\u540c\uff0c\u5219\u53ea\u8981yy\u5c0f\u4e8ey\u5c31\u4e0d\u6ee1\u8db3 2.\u5de6\u70b9\u4f4e\u53f3\u70b9\u9ad8\uff0c\u5219\u6839\u636e\u4e24\u70b9\u8868\u793a\u76f4\u7ebf\uff0cxx\u5e94\u4e3a $$ \\frac{x_2-x_1}{y_2-y_1}=\\frac{xx-x_1}{yy-y_1} \\ xx=\\frac{x_2-x_1}{y_2-y_1}* (yy-y_1)+x_1 $$ \u90a3\u4e48R=min(R,xx) 3.\u5de6\u8fb9\u9ad8\uff0c\u540c\u7406\uff0cL=max(L,xx) #include<iostream> #include<cstdio> #include<cstring> using namespace std; const double P=0.001,INF=1000001.0; const int N=1e5+10; struct node{ double x,y; }q[N]; int n; bool check(double y){ double L=0,R=INF; for(int i=2;i<=n;++i){ if(q[i].y==q[i-1].y){ if(y<q[i].y)return false; } else if(q[i].y>q[i-1].y){ double x1=q[i-1].x,x2=q[i].x,y1=q[i-1].y,y2=q[i].y; double x=((x2-x1)/(y2-y1))*(y-y1)+x1; R=min(R,x); } else{ double x1=q[i-1].x,x2=q[i].x,y1=q[i-1].y,y2=q[i].y; double x=((x2-x1)/(y2-y1))*(y-y1)+x1; L=max(L,x); } } return L<=R; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i){ scanf(\"%lf%lf\",&q[i].x,&q[i].y); } double l=0.0,r=INF,ans=-1.0; while(l+P<=r){ double mid=(l+r)/2.0; if(check(mid)){ r=mid; ans=mid; }else l=mid+P; } printf(\"%.2lf\",ans); return 0; } P1661 \u4e8c\u5206\u65f6\u95f4\uff0c\u5224\u65ad(\u66fc\u54c8\u987f\u8ddd\u79bb+1)/2\u662f\u5426\u5c0f\u4e8e\u7b49\u4e8e\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u6ee1\u8db3\u5c31\u5c06\u4e24\u4e2a\u70b9\u7528\u5e76\u67e5\u96c6\u8fde\u63a5\uff0c\u6700\u540e\u68c0\u67e5\u662f\u5426\u90fd\u5e76\u5728\u4e00\u4e2a\u70b9\u4e0a\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=55,INF=1e10; int abs1(int x){return x>0?x:-x;} int dis(int x1,int y1,int x2,int y2){return abs1(x1-x2)+abs1(y1-y2);} struct node{ int x,y; }q[N]; int n; int fa[N],vis[N]; int getfa(int u){ if(fa[u]==u)return u; return fa[u]=getfa(fa[u]); } bool check(int x){ for(int i=1;i<=n;++i)fa[i]=i; for(int i=1;i<n;++i){ for(int j=i+1;j<=n;++j){ int d=dis(q[i].x,q[i].y,q[j].x,q[j].y),t=(d+1)>>1; if(t<=x)fa[getfa(i)]=getfa(j); } } memset(vis,0,sizeof vis); for(int i=1;i<=n;++i)vis[getfa(i)]++; for(int i=1;i<=n;++i)if(vis[i]>=n)return true; return false; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld%lld\",&q[i].x,&q[i].y); int ans=0,l=0,r=INF; while(l<r){ int mid=l+r>>1; if(check(mid)){ r=mid; ans=mid; }else l=mid+1; } printf(\"%lld\",ans); return 0; } P7514 \u53ef\u4ee5\u4e8c\u5206\u4e00\u4e0b\u6781\u5dee$x$\uff0c\u5e76\u679a\u4e3e\u4e00\u4e0b\u533a\u95f4$[L,L+x]$,\u5176\u4e2d$L$\u53ef\u4ee5\u662f\u6240\u6709\u6b63\u53cd\u9762\u4e2d\u7684\u4efb\u610f\u503c\uff0c\u4e00\u5171$2n$\u4e2a\u3002\u56e0\u4e3a\u6240\u6709\u7684$a_i$\u662f\u5355\u589e\u7684\uff0c\u6240\u6709\u4e0d\u5728\u533a\u95f4\u7684\u6570\u4e00\u5b9a\u6784\u6210\u524d\u540e\u7f00\uff0c\u90a3\u4e48\u8fd9\u4e9b\u5361\u724c\u4e00\u5b9a\u8981\u7ffb\u9762\uff0c\u5e76\u4e14\u7ffb\u5b8c\u9762\u7684$b_i$\u4e5f\u8981\u5728\u533a\u95f4\u5185\uff0c\u6240\u4ee5\u8fd9\u6837\u679a\u4e3e\u5c31\u53ef\u4ee5\u5c06\u95ee\u9898\u8f6c\u5316\u6210\u524d\u540e\u7f00\u7684$RMQ$\u6700\u5927\u548c\u6700\u5c0f\u662f\u5426\u90fd\u5728\u533a\u95f4\u5185\uff0c\u4ee5\u53ca\u524d\u540e\u7f00\u662f\u5426\u8d85\u8fc7\u4e86$m$\u4e2a\u6570\u3002\u786e\u5b9a\u524d\u540e\u7f00\u7684\u4f4d\u7f6e\u53ef\u4ee5\u53cc\u6307\u9488\u722c\u4e00\u4e0b\u7ef4\u62a4\uff0c\u662f$O(n)$\u7684\u3002$RMQ$\u4e5f\u662f$O(n)$\u7684($st$\u8868)\uff0c\u6240\u4ee5\u603b\u590d\u6742\u5ea6$O(n\\log n)$ ~~\u5927\u5e38\u6570\u9009\u624b\u8868\u793a\u5f88\u6de6~~ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1000010,K=21,INF=1e9+10; struct node{ int a,b; }a[N]; int n,m,cnt; int b[N+N],Log[N],Max[N][K],Min[N][K]; int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } bool cmp(int a,int b){ return a<b; } void init(){ Log[1]=0; for(int i=2;i<=n;++i) Log[i]=Log[i>>1]+1; for(int i=1;i<=n;++i) Max[i][0]=Min[i][0]=a[i].b; for(int j=1;(1<<j)<=n;++j) for(int i=1;i+(1<<(j-1))<=n;++i) Min[i][j]=INF,Min[i][j]=min(Min[i][j-1],Min[i+(1<<(j-1))][j-1]),Max[i][j]=max(Max[i][j-1],Max[i+(1<<(j-1))][j-1]); } int query(int t,int l,int r){ if(l>r){ if(!t) return INF; else return 0; } int k=Log[r-l+1]; if(!t) return min(Min[l][k],Min[r-(1<<k)+1][k]); else return max(Max[l][k],Max[r-(1<<k)+1][k]); } bool check(int x){ bool flag=false; int l=1,r=0,L=0,R=0,_min=0,_max=0,tot=0; for(int i=1;i<=cnt;++i){ L=b[i],R=b[i]+x; while(a[l].a<L && l<=n) ++l; while(a[r+1].a<=R && r+1<=n) ++r; tot=l-1+n-r; if(tot>m)continue; _min=min(query(0,1,l-1),query(0,r+1,n)),_max=max(query(1,1,l-1),query(1,r+1,n)); if(_min<L || _max>R)continue; if(_min>=L && _max<=R){ flag=true;break; } } return flag; } int main(){ //freopen(\"P7514_9.txt\",\"r\",stdin); n=read1(),m=read1();cnt=0; for(int i=1;i<=n;++i) a[i].a=read1(),b[++cnt]=a[i].a; for(int i=1;i<=n;++i) a[i].b=read1(),b[++cnt]=a[i].b; sort(b+1,b+cnt+1,cmp); init(); int l=0,r=b[cnt]-b[1],ans=0; while(l<=r){ int mid=l+r>>1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; } printf(\"%d\",ans); return 0; }","title":"\u4e8c\u5206"},{"location":"my%20past/OI/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/","text":"\u4e8c\u7ef4\u6570\u7ec4\u4e0e\u4e8c\u7ea7\u6307\u9488 \u4e8c\u7ef4\u6570\u7ec4\u4f20\u53c2\u65f6\u4e0d\u53ef\u9000\u5316\u6210\u4e8c\u7ea7\u6307\u9488\uff0c\u4f46\u662f\u53ef\u4ee5\u8fdb\u884c\u5982\u4e0b~~\u9a9a~~\u64cd\u4f5c #include<iostream> using namespace std; void f(char **p){ for(int i=0;i<10;++i){ for(int j=0;j<10;++j) cout<<(int)(*(p[i]+j))<<\" \"; cout<<endl; } } char *a[10]; char b[10][10]; int main(){ for(int i=0;i<10;++i) for(int j=0;j<10;++j) b[i][j]=i*10+j; for(int i=0;i<10;++i) a[i]=b[i]; char **p=a; f(p); return 0; } \u53ef\u4ee5\u7528\u4e00\u7ef4\u6307\u9488\u6570\u7ec4\u628a\u4e8c\u7ef4\u6570\u7ec4\u5b58\u4e0b\u6765\uff0c\u518d\u7528\u4e8c\u7ea7\u6307\u9488\u5b58\u6307\u9488\u6570\u7ec4\u7684\u6570\u7ec4\u540d\u3002 \u6240\u4ee5\u8bf4\u6307\u9488\u6570\u7ec4\u7684\u6570\u7ec4\u540d\u5e94\u8be5\u4e5f\u662f\u4e2a\u6307\u9488\u3002 \u6309\u7406\u6765\u8bf4\u4e8c\u7ef4\u6570\u7ec4\u7684\u6570\u7ec4\u540d\u4e5f\u662f\u4e2a\u6307\u5411\u6307\u9488\u6570\u7ec4\u7684\u6307\u9488\u3002~~\u4f46\u662f\u5c31\u662f\u4e0d\u80fd\u76f4\u63a5\u4f20\u53c2\u7ed9\u4e8c\u7ea7\u6307\u9488~~","title":"\u4e8c\u7ef4\u6570\u7ec4\u4e0e\u4e8c\u7ea7\u6307\u9488"},{"location":"my%20past/OI/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/#_1","text":"\u4e8c\u7ef4\u6570\u7ec4\u4f20\u53c2\u65f6\u4e0d\u53ef\u9000\u5316\u6210\u4e8c\u7ea7\u6307\u9488\uff0c\u4f46\u662f\u53ef\u4ee5\u8fdb\u884c\u5982\u4e0b~~\u9a9a~~\u64cd\u4f5c #include<iostream> using namespace std; void f(char **p){ for(int i=0;i<10;++i){ for(int j=0;j<10;++j) cout<<(int)(*(p[i]+j))<<\" \"; cout<<endl; } } char *a[10]; char b[10][10]; int main(){ for(int i=0;i<10;++i) for(int j=0;j<10;++j) b[i][j]=i*10+j; for(int i=0;i<10;++i) a[i]=b[i]; char **p=a; f(p); return 0; } \u53ef\u4ee5\u7528\u4e00\u7ef4\u6307\u9488\u6570\u7ec4\u628a\u4e8c\u7ef4\u6570\u7ec4\u5b58\u4e0b\u6765\uff0c\u518d\u7528\u4e8c\u7ea7\u6307\u9488\u5b58\u6307\u9488\u6570\u7ec4\u7684\u6570\u7ec4\u540d\u3002 \u6240\u4ee5\u8bf4\u6307\u9488\u6570\u7ec4\u7684\u6570\u7ec4\u540d\u5e94\u8be5\u4e5f\u662f\u4e2a\u6307\u9488\u3002 \u6309\u7406\u6765\u8bf4\u4e8c\u7ef4\u6570\u7ec4\u7684\u6570\u7ec4\u540d\u4e5f\u662f\u4e2a\u6307\u5411\u6307\u9488\u6570\u7ec4\u7684\u6307\u9488\u3002~~\u4f46\u662f\u5c31\u662f\u4e0d\u80fd\u76f4\u63a5\u4f20\u53c2\u7ed9\u4e8c\u7ea7\u6307\u9488~~","title":"\u4e8c\u7ef4\u6570\u7ec4\u4e0e\u4e8c\u7ea7\u6307\u9488"},{"location":"my%20past/OI/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","text":"\u4f18\u5148\u961f\u5217/\u4e8c\u53c9\u5806 P7913 \u76f4\u63a5\u7528\u5806\u4f18\u5316\u6a21\u62df\u3002 \u5efa\u4e24\u4e2a\u5806\uff0c\u5206\u522b\u7ef4\u62a4$lq:$\u51fa\u53d1\u65f6\u95f4+\u5360\u636e\u5eca\u6865\u7f16\u53f7\uff0c\u548c$wq:$\u7a7a\u95f2\u5eca\u6865\u7f16\u53f7\u3002 \u6bcf\u6b21\u5c06\u5c0f\u4e8e$tmp[i].l$\u7684\u5eca\u6865\u4ece$lq$\u79cd\u91ca\u653e\u51fa\u6765\uff0c\u52a0\u5165$wq$\u4e2d\u3002 \u5982\u679c\u6ca1\u6709\u7a7a\u95f2\u5eca\u6865\u76f4\u63a5\u8df3\u8fc7(\u8fdc\u533a\u60c5\u51b5) \u5426\u5219\u5c31\u5c06\u5b83\u52a0\u5230\u7f16\u53f7\u6700\u5c0f\u7684\u5eca\u6865$pos$\u4e2d\uff0c\u5e76\u5c06\u8fd9\u4e2a\u5eca\u6865\u4ece$wq$\u4e2d\u53bb\u9664\uff0c\u52a0\u5165$lq$. make_pair(tmp[i].r,pos); #include<iostream> #include<cstring> #include<cstdio> #include<algorithm> #include<queue> #include<vector> using namespace std; const int N=1e5+10; typedef pair<int,int> pii; struct node{ int l,r; }s[N],t[N]; int n,m1,m2,ans; int f[N],g[N]; bool cmp(node a,node b){return a.l<b.l;} void cal(node* tmp,int m,int* res){ priority_queue<pii, vector<pii> ,greater<pii> > lq; priority_queue<int, vector<int> ,greater<int> > wq; for(int i=1;i<=n;++i)wq.push(i); for(int i=1;i<=m;++i){ while(!lq.empty() && tmp[i].l>=lq.top().first){ wq.push(lq.top().second); lq.pop(); } if(wq.empty())continue; int pos=wq.top();wq.pop(); res[pos]++; lq.push(make_pair(tmp[i].r,pos)); } for(int i=1;i<=n;++i)res[i]+=res[i-1]; } int main(){ scanf(\"%d%d%d\",&n,&m1,&m2); for(int i=1;i<=m1;++i)scanf(\"%d%d\",&s[i].l,&s[i].r); for(int i=1;i<=m2;++i)scanf(\"%d%d\",&t[i].l,&t[i].r); sort(s+1,s+m1+1,cmp); sort(t+1,t+m2+1,cmp); cal(s,m1,f); cal(t,m2,g); ans=0; for(int i=0;i<=n;++i)ans=max(ans,f[i]+g[n-i]); printf(\"%d\",ans); return 0; } P1631 ~~\u6211\u662fSB~~ \u5bf9\u4e8ea\u4e0eb\u6570\u7ec4\u7531\u4e0b\u5217\u4e0d\u7b49\u5f0f\u5173\u7cfb\uff1a a[1]+b[1]<=a[1]+b[2]<=...<=a[1]+b[n] a[2]+b[1]<=a[2]+b[2]<=...<=a[2]+b[n] . . . a[n]+b[1]<=a[n]+b[2]<=...<=a[n]+b[n] \u90a3\u4e48\u5c31\u5c06n\u4e2a\u4e0d\u7b49\u5f0f\u7684\u7b2c\u4e00\u4e2a\u6570\u63a8\u8fdb\u5806\u91cc\uff0c\u6bcf\u6b21\u5f39\u51fa\u6700\u5c0f\u7684\uff0c\u5e76\u5c06\u5b83\u5bf9\u5e94\u7684\u4e0d\u7b49\u5f0f\u4e2d\u5b83\u7684\u4e0b\u4e00\u4e2a\u6570\u5165\u5806\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> using namespace std; const int N=2e5+10; int a[N],b[N],c[N]; int n; struct node{ int i,j,s; node(int x,int y,int z){ i=x; j=y; s=z; } bool operator <(const node &a)const{ return a.s<s; } }; void solve(){ priority_queue<node> q; for(int i=1;i<=n;++i){ int tmp=a[1]+b[i]; q.push(node(1,i,tmp)); } int cnt=0; for(int i=1;i<=n;++i){ c[++cnt]=q.top().s; int x1=q.top().i,y1=q.top().j; q.pop(); int z1=a[x1+1]+b[y1]; q.push(node(x1+1,y1,z1)); } for(int i=1;i<=n;++i)printf(\"%d \",c[i]); } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=1;i<=n;++i)scanf(\"%d\",&b[i]); solve(); return 0; } P2827 \u8fd9\u9898\u7528\u5806\u6216\u4f18\u5148\u961f\u5217\"\u53ea\u80fd\"\u62ff85pts~~\u8fd9\u5bf9\u4e8e\u8003\u8bd5\u5c31\u591f\u4e86\uff0c\u8981\u4ec0\u4e48\u6b63\u89e3~~ \u6b63\u89e3\u662f\"\u770b\u51fa\"\u5b83\u7684\u5355\u8c03\u6027\u3002 $\u5982\u679ca>b,a\u5206\u6210a_1,a_2,b\u5206\u6210b_1,b_2,\u5219a_1>b_1,a_2>b_2.$ \u5176\u5b9e\u8fd9\u4e5f\u5f88\u597d\u7406\u89e3\uff0c\u6240\u4ee5\u8bc1\u660e\u7565\u3002 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u4e09\u4e2a\u6570\u7ec4\u6a21\u62df\u961f\u5217\uff0c\u4e00\u4e2a\u5b58$a$,\u4e00\u4e2a\u5b58$a_1$,\u4e00\u4e2a\u5b58$a_2$. UVA11997 \u4e0e\u4e0a\u4e00\u9898\u7c7b\u4f3c\uff0c\u53ea\u4e0d\u8fc7\u53d8\u6210\u4e86$k$\u4e2a\u6570\u7ec4\uff0c\u6b64\u65f6\u4e00\u884c\u4e00\u884c\u505a\u5373\u53ef\u3002 \u95ee\u9898\u662f\uff0c\u5f53\u524d\u56de\u5408\u629b\u5f03\u7684\u5927\u6570\u4f1a\u4e0d\u4f1a\u5728\u4e0b\u56de\u5408\u7528\u5230\uff1f \u8003\u8651\u53cd\u8bc1\uff0c\u5047\u8bbe$k+1$\u5927\u7684\u6570\u4e0b\u56de\u5408\u7528\u5230\uff0c\u6b64\u65f6\u524d$k$\u5927\u7684\u6570\u52a0\u4e0b\u56de\u5408\u6700\u5c0f\u7684\u6570\u4e00\u5b9a\u6bd4$k+1$\u5927\u7684\u6570\u52a0\u4e0b\u56de\u5408\u6700\u5c0f\u7684\u6570\u5c0f\uff0c\u5373\u4e00\u5b9a\u5b58\u5728\u81f3\u5c11$k$\u4e2a\u6bd4\u4ed6\u5c0f\u7684\u6570\uff0c\u6240\u4ee5\u7b2c$k+1$\u5927\u7684\u6570\u5c31\u53ef\u4ee5\u5ffd\u7565\uff0c\u6bcf\u6b21\u53ea\u9700\u8981\u7ef4\u62a4$k$\u4e2a\u6570\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #include<algorithm> #define int long long using namespace std; const int N=810; int a[N][N]; int k; struct node{ int s,b; node(int ss,int bb){ s=ss,b=bb; } bool operator <(const node &x)const{ return x.s<s; } }; bool cmp(int a,int b){return a<b;} void merge(int j){ priority_queue<node> q; for(int i=1;i<=k;++i)q.push(node(a[1][i]+a[j][1],1)); for(int i=1;i<=k;++i){ node tmp=q.top();q.pop(); int s=tmp.s,b=tmp.b; a[1][i]=s; if(b<k)q.push(node(s-a[j][b]+a[j][b+1],b+1)); } } signed main(){ //freopen(\"UVA11997.txt\",\"r\",stdin); while(scanf(\"%lld\",&k)!=EOF){ memset(a,0,sizeof a); for(int i=1;i<=k;++i){ for(int j=1;j<=k;++j)scanf(\"%lld\",&a[i][j]); sort(a[i]+1,a[i]+k+1,cmp); } for(int i=2;i<=k;++i)merge(i); printf(\"%lld\",a[1][1]); for(int i=2;i<=k;++i)printf(\" %lld\",a[1][i]); printf(\"\\n\"); } return 0; } P8179 16pts: \u76f4\u63a5\u66b4\u529b$dp$. \u8bbe$g[i]$\u8868\u793a\u8003\u8651\u4e86\u524d$i$\u5708\u662f\u7684\u6700\u5c0f\u8d21\u732e\u3002\u5c06\u6362\u53f0\u7684\u65f6\u95f4\u52a0\u5728\u7b2c\u4e00\u5708\u7684\u8d21\u732e\u4e0a\u9762\uff0c\u76f8\u5f53\u4e8e\u53bb\u6389\u4e86\u6362\u80ce\u7684\u64cd\u4f5c\u3002 \u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a $f[i]=\\min_{j=0}^i(f[i],f[i-j]+c(o,j))$,$o$\u8868\u793a\u5f53\u524d\u8003\u8651\u7684\u662f\u54ea\u4e00\u4e2a\u8f6e\u5b50\u3002 \u590d\u6742\u5ea6$O(nm^2)$. 13pts: \u5bf9\u4e8e$t=0$\u7684\u60c5\u51b5\u5176\u5b9e\u5c31\u76f8\u5f53\u4e8e\u7ed9\u4f60$n$\u4e2a\u957f\u5ea6\u4e3a$m$\u7684\u4e0d\u7b49\u5f0f\uff0c\u8ba9\u4f60\u5408\u5e76\u51fa\u524d$m$\u4e2a\u6700\u5c0f\u7684\u503c\u3002\u76f4\u63a5\u7528\u5806+\u8d2a\u5fc3\u7ef4\u62a4\u5373\u53ef\u3002 \u6b63\u89e3: \u6211\u4eec\u4e0d\u80fd\u7528\u5806\u7ef4\u62a4\u7684\u539f\u56e0\u5728\u4e8e\u5e8f\u5217\u4e0d\u5355\u8c03\uff0c\u8fd9\u662f\u7531\u6362\u80ce\u65f6\u95f4\u5f15\u8d77\u7684\uff0c\u800c$dp$\u4e0d\u4f1a\u53d7\u5f71\u54cd\u3002 \u6ce8\u610f\u5230\u4e00\u4e2a\u8f6e\u80ce\u6700\u591a\u5728\u4f7f\u7528$25$\u5708\u540e\uff0c\u4f7f\u7528\u5f53\u524d\u8f6e\u80ce\u7684\u65f6\u95f4\u5c31\u4f1a\u5927\u4e8e\u6362\u80ce\u7684\u65f6\u95f4\u52a0\u7b2c\u4e00\u5708\u6240\u7528\u65f6\u95f4\uff0c\u5e8f\u5217\u53c8\u4e00\u6b21\u53d8\u5f97\u5355\u8c03\u3002 \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5c06\u6bcf\u4e2a\u8f6e\u80ce\u524d$25$\u5708\u505a$dp$\uff0c\u540e\u9762\u7528\u5806\u7ef4\u62a4\u3002 \u5e76\u4e0d\u4f1a\u51fa\u73b0\"\u65ad\u5c42\"\uff0c\u5373\u524d\u9762$dp$\u6ca1\u53d6\u5230\u7684\u5708\u6570\uff0c\u8be5\u8f6e\u80ce\u5728\u540e\u9762\u5806\u4e2d\u53d6\u5230\u4e86\uff0c\u56e0\u4e3a\u524d\u9762\u7684\u4e00\u5b9a\u6bd4\u540e\u9762\u7684\u66f4\u4f18\uff0c\u53d6\u6700\u4f18\u89e3\u65f6\u4f1a\u81ea\u52a8\u6dd8\u6c70\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=510,M=2e5+10,INF=2e18,T=25; int n,m,t,s; int a[N],b[N],c[N]; int g[M],h[M],f[N][T+T]; inline int d(int i,int j){return a[i]+(j-1)*(j-1)*b[i];} struct node{ int n,m,val; bool operator <(const node &x)const{ return x.val<val; } node(int _n,int _m,int _val){ n=_n,m=_m,val=_val; } }; void init(){ for(int i=1;i<=n;++i){ f[i][0]=t; for(int j=1;j<=T;++j) f[i][j]=f[i][j-1]+d(i,j); } } void heap_greedy(){ priority_queue<node> q; for(int i=1;i<=n;++i)q.push(node(i,T+1,d(i,T+1))); for(int i=1;i<=m;++i){ node tmp=q.top();q.pop(); h[i]=h[i-1]+tmp.val; q.push(node(tmp.n,tmp.m+1,d(tmp.n,tmp.m+1))); } } void dp(){ memset(g,0x3f,sizeof g); g[0]=0; for(int o=1;o<=n;++o){ s=min(s+T,m); for(int j=s;j>=0;--j) for(int k=min(j,T);k>=0;--k) g[j]=min(g[j],g[j-k]+f[o][k]); } } signed main(){ scanf(\"%lld%lld%lld\",&n,&m,&t); for(int i=1;i<=n;++i)scanf(\"%lld%lld\",&a[i],&b[i]); init(); dp(); heap_greedy(); int ans=INF; for(int i=1;i<=min(m,s);++i) ans=min(ans,g[i]+h[m-i]); printf(\"%lld\",ans-t); return 0; }","title":"\u4f18\u5148\u961f\u5217/\u4e8c\u53c9\u5806"},{"location":"my%20past/OI/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/#_1","text":"P7913 \u76f4\u63a5\u7528\u5806\u4f18\u5316\u6a21\u62df\u3002 \u5efa\u4e24\u4e2a\u5806\uff0c\u5206\u522b\u7ef4\u62a4$lq:$\u51fa\u53d1\u65f6\u95f4+\u5360\u636e\u5eca\u6865\u7f16\u53f7\uff0c\u548c$wq:$\u7a7a\u95f2\u5eca\u6865\u7f16\u53f7\u3002 \u6bcf\u6b21\u5c06\u5c0f\u4e8e$tmp[i].l$\u7684\u5eca\u6865\u4ece$lq$\u79cd\u91ca\u653e\u51fa\u6765\uff0c\u52a0\u5165$wq$\u4e2d\u3002 \u5982\u679c\u6ca1\u6709\u7a7a\u95f2\u5eca\u6865\u76f4\u63a5\u8df3\u8fc7(\u8fdc\u533a\u60c5\u51b5) \u5426\u5219\u5c31\u5c06\u5b83\u52a0\u5230\u7f16\u53f7\u6700\u5c0f\u7684\u5eca\u6865$pos$\u4e2d\uff0c\u5e76\u5c06\u8fd9\u4e2a\u5eca\u6865\u4ece$wq$\u4e2d\u53bb\u9664\uff0c\u52a0\u5165$lq$. make_pair(tmp[i].r,pos); #include<iostream> #include<cstring> #include<cstdio> #include<algorithm> #include<queue> #include<vector> using namespace std; const int N=1e5+10; typedef pair<int,int> pii; struct node{ int l,r; }s[N],t[N]; int n,m1,m2,ans; int f[N],g[N]; bool cmp(node a,node b){return a.l<b.l;} void cal(node* tmp,int m,int* res){ priority_queue<pii, vector<pii> ,greater<pii> > lq; priority_queue<int, vector<int> ,greater<int> > wq; for(int i=1;i<=n;++i)wq.push(i); for(int i=1;i<=m;++i){ while(!lq.empty() && tmp[i].l>=lq.top().first){ wq.push(lq.top().second); lq.pop(); } if(wq.empty())continue; int pos=wq.top();wq.pop(); res[pos]++; lq.push(make_pair(tmp[i].r,pos)); } for(int i=1;i<=n;++i)res[i]+=res[i-1]; } int main(){ scanf(\"%d%d%d\",&n,&m1,&m2); for(int i=1;i<=m1;++i)scanf(\"%d%d\",&s[i].l,&s[i].r); for(int i=1;i<=m2;++i)scanf(\"%d%d\",&t[i].l,&t[i].r); sort(s+1,s+m1+1,cmp); sort(t+1,t+m2+1,cmp); cal(s,m1,f); cal(t,m2,g); ans=0; for(int i=0;i<=n;++i)ans=max(ans,f[i]+g[n-i]); printf(\"%d\",ans); return 0; } P1631 ~~\u6211\u662fSB~~ \u5bf9\u4e8ea\u4e0eb\u6570\u7ec4\u7531\u4e0b\u5217\u4e0d\u7b49\u5f0f\u5173\u7cfb\uff1a a[1]+b[1]<=a[1]+b[2]<=...<=a[1]+b[n] a[2]+b[1]<=a[2]+b[2]<=...<=a[2]+b[n] . . . a[n]+b[1]<=a[n]+b[2]<=...<=a[n]+b[n] \u90a3\u4e48\u5c31\u5c06n\u4e2a\u4e0d\u7b49\u5f0f\u7684\u7b2c\u4e00\u4e2a\u6570\u63a8\u8fdb\u5806\u91cc\uff0c\u6bcf\u6b21\u5f39\u51fa\u6700\u5c0f\u7684\uff0c\u5e76\u5c06\u5b83\u5bf9\u5e94\u7684\u4e0d\u7b49\u5f0f\u4e2d\u5b83\u7684\u4e0b\u4e00\u4e2a\u6570\u5165\u5806\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> using namespace std; const int N=2e5+10; int a[N],b[N],c[N]; int n; struct node{ int i,j,s; node(int x,int y,int z){ i=x; j=y; s=z; } bool operator <(const node &a)const{ return a.s<s; } }; void solve(){ priority_queue<node> q; for(int i=1;i<=n;++i){ int tmp=a[1]+b[i]; q.push(node(1,i,tmp)); } int cnt=0; for(int i=1;i<=n;++i){ c[++cnt]=q.top().s; int x1=q.top().i,y1=q.top().j; q.pop(); int z1=a[x1+1]+b[y1]; q.push(node(x1+1,y1,z1)); } for(int i=1;i<=n;++i)printf(\"%d \",c[i]); } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=1;i<=n;++i)scanf(\"%d\",&b[i]); solve(); return 0; } P2827 \u8fd9\u9898\u7528\u5806\u6216\u4f18\u5148\u961f\u5217\"\u53ea\u80fd\"\u62ff85pts~~\u8fd9\u5bf9\u4e8e\u8003\u8bd5\u5c31\u591f\u4e86\uff0c\u8981\u4ec0\u4e48\u6b63\u89e3~~ \u6b63\u89e3\u662f\"\u770b\u51fa\"\u5b83\u7684\u5355\u8c03\u6027\u3002 $\u5982\u679ca>b,a\u5206\u6210a_1,a_2,b\u5206\u6210b_1,b_2,\u5219a_1>b_1,a_2>b_2.$ \u5176\u5b9e\u8fd9\u4e5f\u5f88\u597d\u7406\u89e3\uff0c\u6240\u4ee5\u8bc1\u660e\u7565\u3002 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u4e09\u4e2a\u6570\u7ec4\u6a21\u62df\u961f\u5217\uff0c\u4e00\u4e2a\u5b58$a$,\u4e00\u4e2a\u5b58$a_1$,\u4e00\u4e2a\u5b58$a_2$. UVA11997 \u4e0e\u4e0a\u4e00\u9898\u7c7b\u4f3c\uff0c\u53ea\u4e0d\u8fc7\u53d8\u6210\u4e86$k$\u4e2a\u6570\u7ec4\uff0c\u6b64\u65f6\u4e00\u884c\u4e00\u884c\u505a\u5373\u53ef\u3002 \u95ee\u9898\u662f\uff0c\u5f53\u524d\u56de\u5408\u629b\u5f03\u7684\u5927\u6570\u4f1a\u4e0d\u4f1a\u5728\u4e0b\u56de\u5408\u7528\u5230\uff1f \u8003\u8651\u53cd\u8bc1\uff0c\u5047\u8bbe$k+1$\u5927\u7684\u6570\u4e0b\u56de\u5408\u7528\u5230\uff0c\u6b64\u65f6\u524d$k$\u5927\u7684\u6570\u52a0\u4e0b\u56de\u5408\u6700\u5c0f\u7684\u6570\u4e00\u5b9a\u6bd4$k+1$\u5927\u7684\u6570\u52a0\u4e0b\u56de\u5408\u6700\u5c0f\u7684\u6570\u5c0f\uff0c\u5373\u4e00\u5b9a\u5b58\u5728\u81f3\u5c11$k$\u4e2a\u6bd4\u4ed6\u5c0f\u7684\u6570\uff0c\u6240\u4ee5\u7b2c$k+1$\u5927\u7684\u6570\u5c31\u53ef\u4ee5\u5ffd\u7565\uff0c\u6bcf\u6b21\u53ea\u9700\u8981\u7ef4\u62a4$k$\u4e2a\u6570\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #include<algorithm> #define int long long using namespace std; const int N=810; int a[N][N]; int k; struct node{ int s,b; node(int ss,int bb){ s=ss,b=bb; } bool operator <(const node &x)const{ return x.s<s; } }; bool cmp(int a,int b){return a<b;} void merge(int j){ priority_queue<node> q; for(int i=1;i<=k;++i)q.push(node(a[1][i]+a[j][1],1)); for(int i=1;i<=k;++i){ node tmp=q.top();q.pop(); int s=tmp.s,b=tmp.b; a[1][i]=s; if(b<k)q.push(node(s-a[j][b]+a[j][b+1],b+1)); } } signed main(){ //freopen(\"UVA11997.txt\",\"r\",stdin); while(scanf(\"%lld\",&k)!=EOF){ memset(a,0,sizeof a); for(int i=1;i<=k;++i){ for(int j=1;j<=k;++j)scanf(\"%lld\",&a[i][j]); sort(a[i]+1,a[i]+k+1,cmp); } for(int i=2;i<=k;++i)merge(i); printf(\"%lld\",a[1][1]); for(int i=2;i<=k;++i)printf(\" %lld\",a[1][i]); printf(\"\\n\"); } return 0; } P8179 16pts: \u76f4\u63a5\u66b4\u529b$dp$. \u8bbe$g[i]$\u8868\u793a\u8003\u8651\u4e86\u524d$i$\u5708\u662f\u7684\u6700\u5c0f\u8d21\u732e\u3002\u5c06\u6362\u53f0\u7684\u65f6\u95f4\u52a0\u5728\u7b2c\u4e00\u5708\u7684\u8d21\u732e\u4e0a\u9762\uff0c\u76f8\u5f53\u4e8e\u53bb\u6389\u4e86\u6362\u80ce\u7684\u64cd\u4f5c\u3002 \u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a $f[i]=\\min_{j=0}^i(f[i],f[i-j]+c(o,j))$,$o$\u8868\u793a\u5f53\u524d\u8003\u8651\u7684\u662f\u54ea\u4e00\u4e2a\u8f6e\u5b50\u3002 \u590d\u6742\u5ea6$O(nm^2)$. 13pts: \u5bf9\u4e8e$t=0$\u7684\u60c5\u51b5\u5176\u5b9e\u5c31\u76f8\u5f53\u4e8e\u7ed9\u4f60$n$\u4e2a\u957f\u5ea6\u4e3a$m$\u7684\u4e0d\u7b49\u5f0f\uff0c\u8ba9\u4f60\u5408\u5e76\u51fa\u524d$m$\u4e2a\u6700\u5c0f\u7684\u503c\u3002\u76f4\u63a5\u7528\u5806+\u8d2a\u5fc3\u7ef4\u62a4\u5373\u53ef\u3002 \u6b63\u89e3: \u6211\u4eec\u4e0d\u80fd\u7528\u5806\u7ef4\u62a4\u7684\u539f\u56e0\u5728\u4e8e\u5e8f\u5217\u4e0d\u5355\u8c03\uff0c\u8fd9\u662f\u7531\u6362\u80ce\u65f6\u95f4\u5f15\u8d77\u7684\uff0c\u800c$dp$\u4e0d\u4f1a\u53d7\u5f71\u54cd\u3002 \u6ce8\u610f\u5230\u4e00\u4e2a\u8f6e\u80ce\u6700\u591a\u5728\u4f7f\u7528$25$\u5708\u540e\uff0c\u4f7f\u7528\u5f53\u524d\u8f6e\u80ce\u7684\u65f6\u95f4\u5c31\u4f1a\u5927\u4e8e\u6362\u80ce\u7684\u65f6\u95f4\u52a0\u7b2c\u4e00\u5708\u6240\u7528\u65f6\u95f4\uff0c\u5e8f\u5217\u53c8\u4e00\u6b21\u53d8\u5f97\u5355\u8c03\u3002 \u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5c06\u6bcf\u4e2a\u8f6e\u80ce\u524d$25$\u5708\u505a$dp$\uff0c\u540e\u9762\u7528\u5806\u7ef4\u62a4\u3002 \u5e76\u4e0d\u4f1a\u51fa\u73b0\"\u65ad\u5c42\"\uff0c\u5373\u524d\u9762$dp$\u6ca1\u53d6\u5230\u7684\u5708\u6570\uff0c\u8be5\u8f6e\u80ce\u5728\u540e\u9762\u5806\u4e2d\u53d6\u5230\u4e86\uff0c\u56e0\u4e3a\u524d\u9762\u7684\u4e00\u5b9a\u6bd4\u540e\u9762\u7684\u66f4\u4f18\uff0c\u53d6\u6700\u4f18\u89e3\u65f6\u4f1a\u81ea\u52a8\u6dd8\u6c70\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=510,M=2e5+10,INF=2e18,T=25; int n,m,t,s; int a[N],b[N],c[N]; int g[M],h[M],f[N][T+T]; inline int d(int i,int j){return a[i]+(j-1)*(j-1)*b[i];} struct node{ int n,m,val; bool operator <(const node &x)const{ return x.val<val; } node(int _n,int _m,int _val){ n=_n,m=_m,val=_val; } }; void init(){ for(int i=1;i<=n;++i){ f[i][0]=t; for(int j=1;j<=T;++j) f[i][j]=f[i][j-1]+d(i,j); } } void heap_greedy(){ priority_queue<node> q; for(int i=1;i<=n;++i)q.push(node(i,T+1,d(i,T+1))); for(int i=1;i<=m;++i){ node tmp=q.top();q.pop(); h[i]=h[i-1]+tmp.val; q.push(node(tmp.n,tmp.m+1,d(tmp.n,tmp.m+1))); } } void dp(){ memset(g,0x3f,sizeof g); g[0]=0; for(int o=1;o<=n;++o){ s=min(s+T,m); for(int j=s;j>=0;--j) for(int k=min(j,T);k>=0;--k) g[j]=min(g[j],g[j-k]+f[o][k]); } } signed main(){ scanf(\"%lld%lld%lld\",&n,&m,&t); for(int i=1;i<=n;++i)scanf(\"%lld%lld\",&a[i],&b[i]); init(); dp(); heap_greedy(); int ans=INF; for(int i=1;i<=min(m,s);++i) ans=min(ans,g[i]+h[m-i]); printf(\"%lld\",ans-t); return 0; }","title":"\u4f18\u5148\u961f\u5217/\u4e8c\u53c9\u5806"},{"location":"my%20past/OI/%E4%BC%98%E5%8C%96dp/","text":"\u659c\u7387\u4f18\u5316dp 1) \u8f6c\u79fb\u65b9\u7a0b\u7c7b\u4f3c$f[i]=a[i]+b j $\u7684\u53ef\u4ee5\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4$i$\u524d\u9762\u7684\u4e00\u6bb5\u5408\u6cd5\u533a\u95f4\u7684\u6700\u503c\uff0c\u4ece\u800c\u5c06$O(n^2)$\u7684\u8f6c\u79fb\u4f18\u5316\u5230$O(n)$ 2) \u8f6c\u79fb\u65b9\u7a0b\u7c7b\u4f3c$f[i]=a[i]* b[j]+c[i]+d[j]$\u5c31\u4e0d\u80fd\u53ea\u662f\u5355\u8c03\u961f\u5217\u4f18\u5316\u4e86\uff0c\u6211\u4eec\u9700\u8981\u5355\u8c03\u961f\u5217+\u659c\u7387\u4f18\u5316 \u5148\u6765\u4e00\u9053\u4f8b\u9898\u4f1a\u6bd4\u8f83\u597d\u7406\u89e3 P3195 \u7ecf\u5178\u659c\u7387\u4f18\u5316\u3002 $$ \u8f6c\u79fb\u65b9\u7a0b\u4e3af[i]=f[j]+(i-j-1+s[i]-s[j]-L)\\s[i]\u8868\u793a\u524d\u7f00\u548c\u3002\\ \u8bbea(i)=s[i]+i,b(i)=a(i)+L+1\\\u90a3\u4e48\u539f\u5f0f\u53d8\u4e3af[i]=f[j]+(a(i)-b(j))^2\\ \u79fb\u9879\u5f97\\ 2a(i)* b(j) +f[i]-a(i)^2=f[j]+b(j)^2\\ \u90a3\u4e48\u53ef\u4ee5\u770b\u6210k=2a(i),x=b(j),y=(f[j]+b(j)^2),b=f[i]-a(i)^2\u7684\u76f4\u7ebfy=kx+b $$ \u5bf9\u4e8e\u6bcf\u4e2a\u76f4\u7ebf\uff081~n\uff09,\u90fd\u6709\u659c\u7387$2a(i)$\u5355\u8c03\u9012\u589e\uff0c\u800c\u6211\u4eec\u8981\u6c42\u622a\u8ddd$f[i]-a(i)^2$\u7684\u6700\u5c0f\u503c\uff0c\u4e5f\u5c31\u662f\u5f53\u6211\u4eec\u7ef4\u62a4\u4e00\u4e2a\u4e0b\u51f8\u5305\u65f6\uff0c\u76f4\u7ebf\u7684\u659c\u7387\u521a\u597d\u6ee1\u8db3$slope(P_{j},P_{j+1})>k$\u65f6\u7684\u70b9$j$\u5373\u4e3a\u6211\u4eec\u8981\u7684$f[j]$\uff08\u53ef\u4ee5\u7406\u89e3\u4e3a\u76f8\u5207\uff09 \u56e0\u6b64\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u4e0b\u51f8\u5305\u4e0a\u7684\u70b9\u3002 1) $slope(P_{head},P_{head+1}\\leq k):++head$,\u5f39\u51fa\u524d\u7aef\u7684\u70b9\uff0c\u56e0\u4e3a\u4e0d\"\u76f8\u5207\" 2) $slope(P_{tail-1},P_i)<slope(P_{tail-1},P_{tail}):--tail$,\u8bf4\u660e$P_{tail}$\u4e0d\u518d\u662f\u51f8\u5305\u4e0a\u7684\u70b9\uff0c\u4e0d\u9700\u8981\u5c31\u5f39\u51fa #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; typedef double db; const int N=5e4+10; int C[N],s[N],q[N]; int n,L,head,tail; db f[N]; db a(int i){ return (db)(s[i]+i); } db b(int i){ return (db)(s[i]+i+L+1); } db slope(int u,int v){ db yu=f[u]+b(u)*b(u),yv=f[v]+b(v)*b(v),xu=b(u),xv=b(v); return (yu-yv)/(xu-xv); } void dp(){ head=tail=1; q[head]=0; for(int i=1;i<=n;++i){ while(head<tail && slope(q[head],q[head+1])< 2*a(i)) ++head; f[i]=f[q[head]]+(a(i)-b(q[head]))*(a(i)-b(q[head])); while(head<tail && slope(q[tail-1],q[tail])>slope(q[tail-1],i)) --tail; q[++tail]=i; } printf(\"%lld\",(long long)(f[n])); } signed main(){ scanf(\"%lld%lld\",&n,&L); for(int i=1;i<=n;++i) scanf(\"%lld\",&C[i]),s[i]=s[i-1]+C[i]; dp(); return 0; } \u7ebf\u6bb5\u6811\u4f18\u5316dp P1295 & P1848 \u76f8\u540c\u7c7b\u578b\u7684\u9898,\u5c31\u53ea\u8bb2P1295\u5427\uff0c\u8fd8\u7b80\u5355\u4e00\u70b9\u3002 \u66b4\u529b$O(n^2)$\u8f6c\u79fb\uff1a$f[i]=f[j]+(\\max_{k=j+1}^ih_k)(\\sum_{k=j+1}^ih_k\\leq m)$ \u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u53ef\u4ee5\u9996\u5148$O(n\\log n)$\u4e8c\u5206\u6c42\u51fa\u5b83\u6700\u9760\u5de6\u4e14\u6ee1\u8db3\u957f\u5ea6$\\leq m$\u7684\u7aef\u70b9\u4f4d\u7f6e$prelen[i]$,\u8fd8\u6709$O(n)$\u5355\u8c03\u6808\u6c42\u51fa\u524d\u4e00\u4e2a\u6bd4\u4ed6\u5927\u7684\u6570\u7684\u4f4d\u7f6e $premax[i]$. \u7136\u540e\uff0c\u5bf9\u4e8e\u5f53\u524d\u70b9$i$\uff0c\u6211\u4eec\u9700\u8981\u5c06\u524d$i-1$\u4e2a\u70b9\u7684$f[i]$\u52a0\u4e0a$i$\u4ea7\u751f\u7684\"\u8d21\u732e\"\u540e\u53d6\u6700\u5c0f\uff0c\u6c42\u51fa$f[i]$. \u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u5728\u6c42$f[k]$\u4e4b\u524d\u5728$k$\u7684\u4f4d\u7f6e\u5355\u70b9\u4fee\u6539$f[k-1]$,\u8868\u793a\u5982\u679c\u53d6$[k,i]$\u8fd9\u6bb5\u533a\u95f4\u7684\u8bdd\u8981\u52a0\u4e0a$f[k-1]$. \u7136\u540e\u5c31\u662f\u5e38\u89c1\u7684\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u6240\u6709\u5927\u4e8e$h[i]$\u7684\u70b9\u662f\u6ca1\u6709\u5f71\u54cd\u7684\uff0c\u6240\u4ee5\u5c06$[premax[i],i]$\u4fee\u6539\u4e3a$h[i]$. \u6700\u540e\uff0c\u67e5\u8be2$[prelen[i],i]$\u8fd9\u6bb5\u533a\u95f4\u7684\u6700\u5c0f\u503c\u5373\u53ef\u3002 \u663e\u7136\u8fd9\u4e2a\u8fc7\u7a0b\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 \u6ce8\u610f$f$\u662f\u5355\u70b9\u4fee\u6539\uff0c\u4e0d\u9700\u8981$tag$,\u800c$ans$\u9700\u8981\u7528$tag+f$\u5f97\u5230\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<stack> #define int long long #define ls i<<1 #define rs i<<1|1 #define mid (l+r>>1) using namespace std; typedef pair<int,int> PI; const int N=1e5+10,INF=1e18; int n,m; int a[N],premax[N],prelen[N],s[N],f[N]; struct tree{ int tag,l,r,f,ans; }tre[N<<2]; void init(){ stack<PI> q; for(int i=1;i<=n;++i){ int pos=lower_bound(s,s+n+1,s[i]-m)-s+1;prelen[i]=pos; } for(int i=1;i<=n;++i){ while(!q.empty() && q.top().first<a[i])q.pop(); premax[i]=q.empty()?1:q.top().second+1;q.push(make_pair(a[i],i)); } } void pushup(int i){ tre[i].f=min(tre[ls].f,tre[rs].f); tre[i].ans=min(tre[ls].ans,tre[rs].ans); } void build(int i,int l,int r){ tre[i].l=l,tre[i].r=r,tre[i].tag=0,tre[i].f=INF,tre[i].ans=INF; if(l==r)return; build(ls,l,mid); build(rs,mid+1,r); pushup(i); } void pushdown(int i){ int k=tre[i].tag; if(!k)return; tre[ls].tag=k,tre[ls].ans=tre[ls].f+k; tre[rs].tag=k,tre[rs].ans=tre[rs].f+k; tre[i].tag=0; } void add(int i,int pos,int k){ int l=tre[i].l,r=tre[i].r; if(l==r){ tre[i].f=k;return; } pushdown(i); if(pos<=mid)add(ls,pos,k); else add(rs,pos,k); pushup(i); } void change(int i,int el,int er,int k){ int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er){ tre[i].ans=tre[i].f+k,tre[i].tag=k; return; } pushdown(i); if(el<=mid)change(ls,el,er,k); if(er>mid)change(rs,el,er,k); pushup(i); } int query(int i,int el,int er){ int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) return tre[i].ans; pushdown(i); int ans=INF; if(el<=mid)ans=min(ans,query(ls,el,er)); if(er>mid)ans=min(ans,query(rs,el,er)); return ans; } signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),s[i]=s[i-1]+a[i]; build(1,1,n); init(); for(int i=1;i<=n;++i){ add(1,i,f[i-1]); if(premax[i]<=i)change(1,premax[i],i,a[i]); if(prelen[i]<=i)f[i]=query(1,prelen[i],i); } printf(\"%lld\",f[n]); return 0; } /* 4 9 1 6 3 5 1 */ \u7ed3\u8bba\uff1a\u7ebf\u6bb5\u6811\u4f18\u5316\u7684\u9898\u4e00\u822c\u7279\u70b9\u662f\u8fde\u7eed\u53d6\u4e00\u70b9\u533a\u95f4\uff0c\u518d\u52a0\u4e0a\u4e4b\u524d\u7684\u8d21\u732e\u66f4\u65b0$f[i]$ CF833B \u5e38\u89c1\u79bb\u7ebf\u64cd\u4f5c\uff0c\u5bf9\u4e8e$a[i]$\u53ea\u5bf9\u5b83\u524d\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u4e4b\u540e\u6709\u5f71\u54cd\u3002 \u800c\u5bf9\u4e8e\u90a3\u4e2a$k$\u6bb5\uff0c\u53ef\u4ee5\u6bcf\u6b21\u5efa\u4e00\u6b21\u6811\uff0c\u6811\u4e2d\u521d\u59cb\u4e3a$f[l-1][k-1]$\u3002 \u7136\u540e\u5c31\u662f\u6807\u51c6\u7ebf\u6bb5\u6811\u4f18\u5316\u3002 #include<iostream> #include<cstdio> #include<cstring> #define ls i<<1 #define rs i<<1|1 #define int long long using namespace std; const int N=4e4+10,K=55; int f[K][N],pos[N],pre[N],tre[N<<2],tag[N<<2]; int n,k,t; void pushup(int i){ tre[i]=max(tre[ls],tre[rs]); } void pushdown(int i,int l,int r){ int k=tag[i]; if(!k)return; tag[ls]+=k;tag[rs]+=k;tre[ls]+=k;tre[rs]+=k; tag[i]=0; } void build(int i,int l,int r,int now){ tag[i]=0; if(l==r){ tre[i]=f[now][l-1]; return; } int mid=(l+r)>>1; build(ls,l,mid,now); build(rs,mid+1,r,now); pushup(i); } void change(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tag[i]+=k;tre[i]+=k; return; } pushdown(i,l,r); int mid=(l+r)>>1; if(el<=mid) change(ls,l,mid,el,er,k); if(er>mid) change(rs,mid+1,r,el,er,k); pushup(i); } int query(int i,int l,int r,int el,int er){ if(el<=l && r<=er) return tre[i]; pushdown(i,l,r); int mid=(l+r)>>1,ans=0; if(el<=mid)ans=max(ans,query(ls,l,mid,el,er)); if(er>mid)ans=max(ans,query(rs,mid+1,r,el,er)); return ans; } signed main(){ scanf(\"%lld%lld\",&n,&k); for(int i=1;i<=n;++i)scanf(\"%lld\",&t),pre[i]=pos[t]+1,pos[t]=i; for(int i=1;i<=k;++i){ build(1,1,n,i-1); for(int j=1;j<=n;++j){ change(1,1,n,pre[j],j,1); f[i][j]=query(1,1,n,1,j); } } printf(\"%lld\",f[k][n]); }","title":"\u659c\u7387\u4f18\u5316dp"},{"location":"my%20past/OI/%E4%BC%98%E5%8C%96dp/#dp","text":"1) \u8f6c\u79fb\u65b9\u7a0b\u7c7b\u4f3c$f[i]=a[i]+b j $\u7684\u53ef\u4ee5\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4$i$\u524d\u9762\u7684\u4e00\u6bb5\u5408\u6cd5\u533a\u95f4\u7684\u6700\u503c\uff0c\u4ece\u800c\u5c06$O(n^2)$\u7684\u8f6c\u79fb\u4f18\u5316\u5230$O(n)$ 2) \u8f6c\u79fb\u65b9\u7a0b\u7c7b\u4f3c$f[i]=a[i]* b[j]+c[i]+d[j]$\u5c31\u4e0d\u80fd\u53ea\u662f\u5355\u8c03\u961f\u5217\u4f18\u5316\u4e86\uff0c\u6211\u4eec\u9700\u8981\u5355\u8c03\u961f\u5217+\u659c\u7387\u4f18\u5316 \u5148\u6765\u4e00\u9053\u4f8b\u9898\u4f1a\u6bd4\u8f83\u597d\u7406\u89e3 P3195 \u7ecf\u5178\u659c\u7387\u4f18\u5316\u3002 $$ \u8f6c\u79fb\u65b9\u7a0b\u4e3af[i]=f[j]+(i-j-1+s[i]-s[j]-L)\\s[i]\u8868\u793a\u524d\u7f00\u548c\u3002\\ \u8bbea(i)=s[i]+i,b(i)=a(i)+L+1\\\u90a3\u4e48\u539f\u5f0f\u53d8\u4e3af[i]=f[j]+(a(i)-b(j))^2\\ \u79fb\u9879\u5f97\\ 2a(i)* b(j) +f[i]-a(i)^2=f[j]+b(j)^2\\ \u90a3\u4e48\u53ef\u4ee5\u770b\u6210k=2a(i),x=b(j),y=(f[j]+b(j)^2),b=f[i]-a(i)^2\u7684\u76f4\u7ebfy=kx+b $$ \u5bf9\u4e8e\u6bcf\u4e2a\u76f4\u7ebf\uff081~n\uff09,\u90fd\u6709\u659c\u7387$2a(i)$\u5355\u8c03\u9012\u589e\uff0c\u800c\u6211\u4eec\u8981\u6c42\u622a\u8ddd$f[i]-a(i)^2$\u7684\u6700\u5c0f\u503c\uff0c\u4e5f\u5c31\u662f\u5f53\u6211\u4eec\u7ef4\u62a4\u4e00\u4e2a\u4e0b\u51f8\u5305\u65f6\uff0c\u76f4\u7ebf\u7684\u659c\u7387\u521a\u597d\u6ee1\u8db3$slope(P_{j},P_{j+1})>k$\u65f6\u7684\u70b9$j$\u5373\u4e3a\u6211\u4eec\u8981\u7684$f[j]$\uff08\u53ef\u4ee5\u7406\u89e3\u4e3a\u76f8\u5207\uff09 \u56e0\u6b64\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u4e0b\u51f8\u5305\u4e0a\u7684\u70b9\u3002 1) $slope(P_{head},P_{head+1}\\leq k):++head$,\u5f39\u51fa\u524d\u7aef\u7684\u70b9\uff0c\u56e0\u4e3a\u4e0d\"\u76f8\u5207\" 2) $slope(P_{tail-1},P_i)<slope(P_{tail-1},P_{tail}):--tail$,\u8bf4\u660e$P_{tail}$\u4e0d\u518d\u662f\u51f8\u5305\u4e0a\u7684\u70b9\uff0c\u4e0d\u9700\u8981\u5c31\u5f39\u51fa #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; typedef double db; const int N=5e4+10; int C[N],s[N],q[N]; int n,L,head,tail; db f[N]; db a(int i){ return (db)(s[i]+i); } db b(int i){ return (db)(s[i]+i+L+1); } db slope(int u,int v){ db yu=f[u]+b(u)*b(u),yv=f[v]+b(v)*b(v),xu=b(u),xv=b(v); return (yu-yv)/(xu-xv); } void dp(){ head=tail=1; q[head]=0; for(int i=1;i<=n;++i){ while(head<tail && slope(q[head],q[head+1])< 2*a(i)) ++head; f[i]=f[q[head]]+(a(i)-b(q[head]))*(a(i)-b(q[head])); while(head<tail && slope(q[tail-1],q[tail])>slope(q[tail-1],i)) --tail; q[++tail]=i; } printf(\"%lld\",(long long)(f[n])); } signed main(){ scanf(\"%lld%lld\",&n,&L); for(int i=1;i<=n;++i) scanf(\"%lld\",&C[i]),s[i]=s[i-1]+C[i]; dp(); return 0; }","title":"\u659c\u7387\u4f18\u5316dp"},{"location":"my%20past/OI/%E4%BC%98%E5%8C%96dp/#dp_1","text":"P1295 & P1848 \u76f8\u540c\u7c7b\u578b\u7684\u9898,\u5c31\u53ea\u8bb2P1295\u5427\uff0c\u8fd8\u7b80\u5355\u4e00\u70b9\u3002 \u66b4\u529b$O(n^2)$\u8f6c\u79fb\uff1a$f[i]=f[j]+(\\max_{k=j+1}^ih_k)(\\sum_{k=j+1}^ih_k\\leq m)$ \u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u53ef\u4ee5\u9996\u5148$O(n\\log n)$\u4e8c\u5206\u6c42\u51fa\u5b83\u6700\u9760\u5de6\u4e14\u6ee1\u8db3\u957f\u5ea6$\\leq m$\u7684\u7aef\u70b9\u4f4d\u7f6e$prelen[i]$,\u8fd8\u6709$O(n)$\u5355\u8c03\u6808\u6c42\u51fa\u524d\u4e00\u4e2a\u6bd4\u4ed6\u5927\u7684\u6570\u7684\u4f4d\u7f6e $premax[i]$. \u7136\u540e\uff0c\u5bf9\u4e8e\u5f53\u524d\u70b9$i$\uff0c\u6211\u4eec\u9700\u8981\u5c06\u524d$i-1$\u4e2a\u70b9\u7684$f[i]$\u52a0\u4e0a$i$\u4ea7\u751f\u7684\"\u8d21\u732e\"\u540e\u53d6\u6700\u5c0f\uff0c\u6c42\u51fa$f[i]$. \u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u5728\u6c42$f[k]$\u4e4b\u524d\u5728$k$\u7684\u4f4d\u7f6e\u5355\u70b9\u4fee\u6539$f[k-1]$,\u8868\u793a\u5982\u679c\u53d6$[k,i]$\u8fd9\u6bb5\u533a\u95f4\u7684\u8bdd\u8981\u52a0\u4e0a$f[k-1]$. \u7136\u540e\u5c31\u662f\u5e38\u89c1\u7684\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u6240\u6709\u5927\u4e8e$h[i]$\u7684\u70b9\u662f\u6ca1\u6709\u5f71\u54cd\u7684\uff0c\u6240\u4ee5\u5c06$[premax[i],i]$\u4fee\u6539\u4e3a$h[i]$. \u6700\u540e\uff0c\u67e5\u8be2$[prelen[i],i]$\u8fd9\u6bb5\u533a\u95f4\u7684\u6700\u5c0f\u503c\u5373\u53ef\u3002 \u663e\u7136\u8fd9\u4e2a\u8fc7\u7a0b\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 \u6ce8\u610f$f$\u662f\u5355\u70b9\u4fee\u6539\uff0c\u4e0d\u9700\u8981$tag$,\u800c$ans$\u9700\u8981\u7528$tag+f$\u5f97\u5230\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<stack> #define int long long #define ls i<<1 #define rs i<<1|1 #define mid (l+r>>1) using namespace std; typedef pair<int,int> PI; const int N=1e5+10,INF=1e18; int n,m; int a[N],premax[N],prelen[N],s[N],f[N]; struct tree{ int tag,l,r,f,ans; }tre[N<<2]; void init(){ stack<PI> q; for(int i=1;i<=n;++i){ int pos=lower_bound(s,s+n+1,s[i]-m)-s+1;prelen[i]=pos; } for(int i=1;i<=n;++i){ while(!q.empty() && q.top().first<a[i])q.pop(); premax[i]=q.empty()?1:q.top().second+1;q.push(make_pair(a[i],i)); } } void pushup(int i){ tre[i].f=min(tre[ls].f,tre[rs].f); tre[i].ans=min(tre[ls].ans,tre[rs].ans); } void build(int i,int l,int r){ tre[i].l=l,tre[i].r=r,tre[i].tag=0,tre[i].f=INF,tre[i].ans=INF; if(l==r)return; build(ls,l,mid); build(rs,mid+1,r); pushup(i); } void pushdown(int i){ int k=tre[i].tag; if(!k)return; tre[ls].tag=k,tre[ls].ans=tre[ls].f+k; tre[rs].tag=k,tre[rs].ans=tre[rs].f+k; tre[i].tag=0; } void add(int i,int pos,int k){ int l=tre[i].l,r=tre[i].r; if(l==r){ tre[i].f=k;return; } pushdown(i); if(pos<=mid)add(ls,pos,k); else add(rs,pos,k); pushup(i); } void change(int i,int el,int er,int k){ int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er){ tre[i].ans=tre[i].f+k,tre[i].tag=k; return; } pushdown(i); if(el<=mid)change(ls,el,er,k); if(er>mid)change(rs,el,er,k); pushup(i); } int query(int i,int el,int er){ int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) return tre[i].ans; pushdown(i); int ans=INF; if(el<=mid)ans=min(ans,query(ls,el,er)); if(er>mid)ans=min(ans,query(rs,el,er)); return ans; } signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),s[i]=s[i-1]+a[i]; build(1,1,n); init(); for(int i=1;i<=n;++i){ add(1,i,f[i-1]); if(premax[i]<=i)change(1,premax[i],i,a[i]); if(prelen[i]<=i)f[i]=query(1,prelen[i],i); } printf(\"%lld\",f[n]); return 0; } /* 4 9 1 6 3 5 1 */ \u7ed3\u8bba\uff1a\u7ebf\u6bb5\u6811\u4f18\u5316\u7684\u9898\u4e00\u822c\u7279\u70b9\u662f\u8fde\u7eed\u53d6\u4e00\u70b9\u533a\u95f4\uff0c\u518d\u52a0\u4e0a\u4e4b\u524d\u7684\u8d21\u732e\u66f4\u65b0$f[i]$ CF833B \u5e38\u89c1\u79bb\u7ebf\u64cd\u4f5c\uff0c\u5bf9\u4e8e$a[i]$\u53ea\u5bf9\u5b83\u524d\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u4e4b\u540e\u6709\u5f71\u54cd\u3002 \u800c\u5bf9\u4e8e\u90a3\u4e2a$k$\u6bb5\uff0c\u53ef\u4ee5\u6bcf\u6b21\u5efa\u4e00\u6b21\u6811\uff0c\u6811\u4e2d\u521d\u59cb\u4e3a$f[l-1][k-1]$\u3002 \u7136\u540e\u5c31\u662f\u6807\u51c6\u7ebf\u6bb5\u6811\u4f18\u5316\u3002 #include<iostream> #include<cstdio> #include<cstring> #define ls i<<1 #define rs i<<1|1 #define int long long using namespace std; const int N=4e4+10,K=55; int f[K][N],pos[N],pre[N],tre[N<<2],tag[N<<2]; int n,k,t; void pushup(int i){ tre[i]=max(tre[ls],tre[rs]); } void pushdown(int i,int l,int r){ int k=tag[i]; if(!k)return; tag[ls]+=k;tag[rs]+=k;tre[ls]+=k;tre[rs]+=k; tag[i]=0; } void build(int i,int l,int r,int now){ tag[i]=0; if(l==r){ tre[i]=f[now][l-1]; return; } int mid=(l+r)>>1; build(ls,l,mid,now); build(rs,mid+1,r,now); pushup(i); } void change(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tag[i]+=k;tre[i]+=k; return; } pushdown(i,l,r); int mid=(l+r)>>1; if(el<=mid) change(ls,l,mid,el,er,k); if(er>mid) change(rs,mid+1,r,el,er,k); pushup(i); } int query(int i,int l,int r,int el,int er){ if(el<=l && r<=er) return tre[i]; pushdown(i,l,r); int mid=(l+r)>>1,ans=0; if(el<=mid)ans=max(ans,query(ls,l,mid,el,er)); if(er>mid)ans=max(ans,query(rs,mid+1,r,el,er)); return ans; } signed main(){ scanf(\"%lld%lld\",&n,&k); for(int i=1;i<=n;++i)scanf(\"%lld\",&t),pre[i]=pos[t]+1,pos[t]=i; for(int i=1;i<=k;++i){ build(1,1,n,i-1); for(int j=1;j<=n;++j){ change(1,1,n,pre[j],j,1); f[i][j]=query(1,1,n,1,j); } } printf(\"%lld\",f[k][n]); }","title":"\u7ebf\u6bb5\u6811\u4f18\u5316dp"},{"location":"my%20past/OI/%E4%BD%8D%E8%BF%90%E7%AE%97/","text":"\u8fdb\u5236 & \u4f4d\u8fd0\u7b97 P7442 ~~\u4f17\u6240\u5468\u77e5\uff0c\u4e8c\u8fdb\u5236\u6709\u4e00\u7c7b\u63d0\u9700\u8981\u4f60\u627e\u89c4\u5f8b~~ \u6bcf\u6b21\u76841\u64cd\u4f5c\u76f8\u5f53\u4e8e\u5c06$x$\u8fd9\u4e2a\u4e8c\u8fdb\u5236\u6570\u770b\u6210\u4e00\u4e2a\u73af\uff0c\u5e76\u4e14\u5c06\u5b83\u65cb\u8f6c$cnt \\mod n$\u6b21\uff0c$cnt$\u4e3a\u603b\u7684\u64cd\u4f5c\u6b21\u6570\u3002 \u800c2\u64cd\u4f5c\u5c31\u662f\u57282\u64cd\u4f5c\u524d\u7684$cnt\\mod n$\u4f4d\u4e0a\u5f02\u6216\u4e0a\u4e00\u4e2a1\u3002 #include<iostream> #include<cstdio> #define int long long using namespace std; int cnt,n,m,op,x,tmp; signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&op,&x); if(op==1){ tmp^=(x)*(long long)(1ll<<cnt);cnt=(cnt+1ll)%n; }else{ int tot=x>>(n-cnt); x=x^(tot<<(n-cnt)); printf(\"%lld\\n\",(long long)(x<<cnt)^tot^tmp); } } return 0; } P1582 \u901a\u8fc7\u4e0d\u65ad\u6c42\u5f97\u5f53\u524d\u7684n\u6709\u591a\u5c11\u4e2a1\uff0c\u5e76\u4e0ek\u5224\u65ad\uff0c\u82e5\u5c0f\u4e8ek\u5219\u7b26\u5408\u9898\u610f\uff0c\u5426\u5219\u5c31\u5c06\u6700\u540e\u4e00\u4f4d1\u52a0\u5230\u8d21\u732e\u91cc\u53bb\u3002 //\u6c42\u6700\u540e\u4e00\u4f4d1 int lowbit(int x){ return x&-x; } \u5b8c\u6574code\uff1a #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int K=1e3+10; int n,k; int lowbit(int x){ return x&-x; } signed main(){ scanf(\"%lld%lld\",&n,&k); int m=n,t=0; while(m){ m-=lowbit(m); ++t; } if(t<=k){ printf(\"0\"); return 0; }else{ int ans=0; while(t>k){ int tmp=lowbit(n); ans+=tmp; n+=tmp; int m=n; t=0; while(m){ m-=lowbit(m); t++; } } printf(\"%lld\",ans); } return 0; } P1015 \u6a21\u62df\u9898. #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=1e4+10; int n; struct HP{ int p[N],len; void clear1(){ memset(p,0,sizeof p); len=1; } void read1(){ memset(p,0,sizeof p); len=0; p[0]=1; char ch=getchar(); int x=0,f=1; while(!(ch<='9' && ch>='0' || ch<='F' && ch>='A' || ch<='f' && ch>='a')){ ch=getchar(); } while((ch<='9' && ch>='0' || ch<='F' && ch>='A' || ch<='f' && ch>='a')){ ++len; if(n==16){ if(ch<='F' && ch>='A'){ p[len]=ch-'A'+10; }else if(ch<='f' && ch>='a'){ p[len]=ch-'a'+10; }else p[len]=ch-'0'; }else p[len]=ch-'0'; ch=getchar(); } for(int i=1;i<=len/2;++i){ swap(p[i],p[len-i+1]); } } void write1(){ for(int i=len;i>=1;--i){ printf(\"%d\",p[i]); } putchar('\\n'); } }; HP operator +(const HP &a,const HP &b){ HP c; c.clear1(); int la=a.len,lb=b.len,lc=max(la,lb),x=0; for(int i=1;i<=lc;++i){ c.p[i]=a.p[i]+b.p[i]+x; x=c.p[i]/n; c.p[i]%=n; } if(x)c.p[++lc]=x; c.len=lc; return c; } HP new1(HP a){ HP b; b.clear1(); int la=a.len; b.len=la; for(int i=1;i<=la;++i){ b.p[la-i+1]=a.p[i]; } a=a+b; return a; } bool check(HP a){ bool flag=true; for(int i=1;i<=a.len/2;++i){ if(a.p[i]!=a.p[a.len-i+1])flag=false; } return flag; } int main(){ scanf(\"%d\",&n); HP a; a.read1(); int cnt=0; while(!check(a) && cnt<=31){ a=new1(a); cnt++; } if(cnt>=31)printf(\"Impossible!\"); else printf(\"STEP=%d\",cnt); return 0; } P2852 \u8fd9\u9053\u9898\u65f6$hash$\u4f18\u5316\u7684\u5b57\u7b26\u4e32\u8868\u793a\u6cd5\uff0c\u5c06\u6bcf\u4e2a\u5b57\u7b26\u4e32\u770b\u6210\u4e00\u4e2a$C$\u8fdb\u5236\u6570\u5373\u53ef\uff0c\u5e76\u5c06\u5b83$mod$\u4e0a\u4e00\u4e2a\u5927\u8d28\u6570$P$,\u56e0\u4e3a\u6211\u4eec\u7528\u524d\u7f00\u548c\u7684\u601d\u60f3\u8868\u793a\u6bcf\u4e00\u4e2a\u5b50\u4e32\uff0c\u6240\u4ee5\u5bf9\u4e8e$n$\u4e2a\u6570\u7684\u5e8f\u5217\u603b\u5171\u53ea\u6709$n$\u4e2a\u5b57\u7b26\u4e32\uff0c\u5982\u679c$P$\u8db3\u591f\u5927\u5e76\u4e14\u662f\u8d28\u6570\u5c31\u4e0d\u4f1a\u51fa\u73b0\u72b6\u6001\u91cd\u590d\u7684\u60c5\u51b5\u3002~~\u5982\u679c\u6709\uff0c\u5c31\u6362\u4e00\u4e2a\u66f4\u2642\u5927\u2642\u7684~~ \u4ee3\u7801\u5728$hash$\u4f18\u5316\u91cc\u6709\u3002 P3760 ~~\u4f4d\u8fd0\u7b97\u597d\u9898~~ \u5bf9\u4e8e\u6240\u6709\u590d\u6742\u7684\u4f4d\u8fd0\u7b97\uff0c\u6211\u4eec\u6709\u4e2a\u5e38\u7528\u7684$Trick$\uff0c\u5c31\u662f\u5c06\u6bcf\u4e2a\u6570\u62c6\u4f4d\uff0c\u6bcf\u4e2a\u6570\u53ea\u7528\u8bb0\u5f55$O(\\log n)$\u4e2a\u4f4d. \u5bf9\u4e8e\u679a\u4e3e\u7684\u4f4d\u6570$v$\uff0c\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1\u6709\u591a\u5c11\u4e2a$s$\u6ee1\u8db3\uff1a $(s[j]-s[i]>>v)&1==1$\u5373\u53ef\u3002 \u90a3\u4e48\u53ef\u4ee5\u5f00\u4e24\u4e2a\u6811\u72b6\u6570\u7ec4\uff0c\u8bb0\u5f55\u7b2c$v$\u4f4d\u5206\u522b\u4e3a0\u62161\u7684\u72b6\u6001\u3002 \u5bf9\u4e8e\u5f53\u524d\u679a\u4e3e\u5230\u7684$s[i]$\uff1a 1) \u7b2c$v$\u4f4d\u4e3a1\uff0c\u90a3\u53ea\u9700\u8981\u627e\u5230\u7b2c$v$\u4f4d\u4e4b\u524d\u6bd4\u4ed6\u5c0f\u4e140\u7684\u4e2a\u6570\u6216\u6bd4\u4ed6\u5927\u4e141\u7684\u4e2a\u6570\u3002 2) \u7b2c$v$\u4f4d\u4e3a0\uff0c\u90a3\u53ea\u9700\u8981\u627e\u5230\u7b2c$v$\u4f4d\u4e4b\u524d\u6bd4\u4ed6\u5927\u4e140\u7684\u4e2a\u6570\u6216\u6bd4\u4ed6\u5c0f\u4e141\u7684\u4e2a\u6570\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long #define lowbit(x) (x&-x) using namespace std; const int N=1e5+10,C=1e6+10; int s[N],a[N],f[C][2]; int n,maxn,ans; void change(int i,int x,int d){ while(x<C)f[x][i]+=d,x+=lowbit(x); } int sum(int i,int x){ int ans=0; while(x>0)ans+=f[x][i],x-=lowbit(x); return ans; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),s[i]=s[i-1]+a[i],maxn=max(maxn,s[i]); for(int v=0;v<=20;++v){ if((1<<v)>maxn)break; int cnt=0; memset(f,0,sizeof f); change(0,1,1); for(int i=1;i<=n;++i){ int tmp=s[i]&((1<<v)-1),type=(s[i]>>v)&1; if(type)cnt+=sum(1,C-1)-sum(1,tmp+1)+sum(0,tmp+1); else cnt+=sum(0,C-1)-sum(0,tmp+1)+sum(1,tmp+1); change(type,tmp+1,1); } if(cnt%2)ans|=(1<<v); } printf(\"%lld\",ans); return 0; }","title":"\u8fdb\u5236 &amp; \u4f4d\u8fd0\u7b97"},{"location":"my%20past/OI/%E4%BD%8D%E8%BF%90%E7%AE%97/#_1","text":"P7442 ~~\u4f17\u6240\u5468\u77e5\uff0c\u4e8c\u8fdb\u5236\u6709\u4e00\u7c7b\u63d0\u9700\u8981\u4f60\u627e\u89c4\u5f8b~~ \u6bcf\u6b21\u76841\u64cd\u4f5c\u76f8\u5f53\u4e8e\u5c06$x$\u8fd9\u4e2a\u4e8c\u8fdb\u5236\u6570\u770b\u6210\u4e00\u4e2a\u73af\uff0c\u5e76\u4e14\u5c06\u5b83\u65cb\u8f6c$cnt \\mod n$\u6b21\uff0c$cnt$\u4e3a\u603b\u7684\u64cd\u4f5c\u6b21\u6570\u3002 \u800c2\u64cd\u4f5c\u5c31\u662f\u57282\u64cd\u4f5c\u524d\u7684$cnt\\mod n$\u4f4d\u4e0a\u5f02\u6216\u4e0a\u4e00\u4e2a1\u3002 #include<iostream> #include<cstdio> #define int long long using namespace std; int cnt,n,m,op,x,tmp; signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&op,&x); if(op==1){ tmp^=(x)*(long long)(1ll<<cnt);cnt=(cnt+1ll)%n; }else{ int tot=x>>(n-cnt); x=x^(tot<<(n-cnt)); printf(\"%lld\\n\",(long long)(x<<cnt)^tot^tmp); } } return 0; } P1582 \u901a\u8fc7\u4e0d\u65ad\u6c42\u5f97\u5f53\u524d\u7684n\u6709\u591a\u5c11\u4e2a1\uff0c\u5e76\u4e0ek\u5224\u65ad\uff0c\u82e5\u5c0f\u4e8ek\u5219\u7b26\u5408\u9898\u610f\uff0c\u5426\u5219\u5c31\u5c06\u6700\u540e\u4e00\u4f4d1\u52a0\u5230\u8d21\u732e\u91cc\u53bb\u3002 //\u6c42\u6700\u540e\u4e00\u4f4d1 int lowbit(int x){ return x&-x; } \u5b8c\u6574code\uff1a #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int K=1e3+10; int n,k; int lowbit(int x){ return x&-x; } signed main(){ scanf(\"%lld%lld\",&n,&k); int m=n,t=0; while(m){ m-=lowbit(m); ++t; } if(t<=k){ printf(\"0\"); return 0; }else{ int ans=0; while(t>k){ int tmp=lowbit(n); ans+=tmp; n+=tmp; int m=n; t=0; while(m){ m-=lowbit(m); t++; } } printf(\"%lld\",ans); } return 0; } P1015 \u6a21\u62df\u9898. #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=1e4+10; int n; struct HP{ int p[N],len; void clear1(){ memset(p,0,sizeof p); len=1; } void read1(){ memset(p,0,sizeof p); len=0; p[0]=1; char ch=getchar(); int x=0,f=1; while(!(ch<='9' && ch>='0' || ch<='F' && ch>='A' || ch<='f' && ch>='a')){ ch=getchar(); } while((ch<='9' && ch>='0' || ch<='F' && ch>='A' || ch<='f' && ch>='a')){ ++len; if(n==16){ if(ch<='F' && ch>='A'){ p[len]=ch-'A'+10; }else if(ch<='f' && ch>='a'){ p[len]=ch-'a'+10; }else p[len]=ch-'0'; }else p[len]=ch-'0'; ch=getchar(); } for(int i=1;i<=len/2;++i){ swap(p[i],p[len-i+1]); } } void write1(){ for(int i=len;i>=1;--i){ printf(\"%d\",p[i]); } putchar('\\n'); } }; HP operator +(const HP &a,const HP &b){ HP c; c.clear1(); int la=a.len,lb=b.len,lc=max(la,lb),x=0; for(int i=1;i<=lc;++i){ c.p[i]=a.p[i]+b.p[i]+x; x=c.p[i]/n; c.p[i]%=n; } if(x)c.p[++lc]=x; c.len=lc; return c; } HP new1(HP a){ HP b; b.clear1(); int la=a.len; b.len=la; for(int i=1;i<=la;++i){ b.p[la-i+1]=a.p[i]; } a=a+b; return a; } bool check(HP a){ bool flag=true; for(int i=1;i<=a.len/2;++i){ if(a.p[i]!=a.p[a.len-i+1])flag=false; } return flag; } int main(){ scanf(\"%d\",&n); HP a; a.read1(); int cnt=0; while(!check(a) && cnt<=31){ a=new1(a); cnt++; } if(cnt>=31)printf(\"Impossible!\"); else printf(\"STEP=%d\",cnt); return 0; } P2852 \u8fd9\u9053\u9898\u65f6$hash$\u4f18\u5316\u7684\u5b57\u7b26\u4e32\u8868\u793a\u6cd5\uff0c\u5c06\u6bcf\u4e2a\u5b57\u7b26\u4e32\u770b\u6210\u4e00\u4e2a$C$\u8fdb\u5236\u6570\u5373\u53ef\uff0c\u5e76\u5c06\u5b83$mod$\u4e0a\u4e00\u4e2a\u5927\u8d28\u6570$P$,\u56e0\u4e3a\u6211\u4eec\u7528\u524d\u7f00\u548c\u7684\u601d\u60f3\u8868\u793a\u6bcf\u4e00\u4e2a\u5b50\u4e32\uff0c\u6240\u4ee5\u5bf9\u4e8e$n$\u4e2a\u6570\u7684\u5e8f\u5217\u603b\u5171\u53ea\u6709$n$\u4e2a\u5b57\u7b26\u4e32\uff0c\u5982\u679c$P$\u8db3\u591f\u5927\u5e76\u4e14\u662f\u8d28\u6570\u5c31\u4e0d\u4f1a\u51fa\u73b0\u72b6\u6001\u91cd\u590d\u7684\u60c5\u51b5\u3002~~\u5982\u679c\u6709\uff0c\u5c31\u6362\u4e00\u4e2a\u66f4\u2642\u5927\u2642\u7684~~ \u4ee3\u7801\u5728$hash$\u4f18\u5316\u91cc\u6709\u3002 P3760 ~~\u4f4d\u8fd0\u7b97\u597d\u9898~~ \u5bf9\u4e8e\u6240\u6709\u590d\u6742\u7684\u4f4d\u8fd0\u7b97\uff0c\u6211\u4eec\u6709\u4e2a\u5e38\u7528\u7684$Trick$\uff0c\u5c31\u662f\u5c06\u6bcf\u4e2a\u6570\u62c6\u4f4d\uff0c\u6bcf\u4e2a\u6570\u53ea\u7528\u8bb0\u5f55$O(\\log n)$\u4e2a\u4f4d. \u5bf9\u4e8e\u679a\u4e3e\u7684\u4f4d\u6570$v$\uff0c\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1\u6709\u591a\u5c11\u4e2a$s$\u6ee1\u8db3\uff1a $(s[j]-s[i]>>v)&1==1$\u5373\u53ef\u3002 \u90a3\u4e48\u53ef\u4ee5\u5f00\u4e24\u4e2a\u6811\u72b6\u6570\u7ec4\uff0c\u8bb0\u5f55\u7b2c$v$\u4f4d\u5206\u522b\u4e3a0\u62161\u7684\u72b6\u6001\u3002 \u5bf9\u4e8e\u5f53\u524d\u679a\u4e3e\u5230\u7684$s[i]$\uff1a 1) \u7b2c$v$\u4f4d\u4e3a1\uff0c\u90a3\u53ea\u9700\u8981\u627e\u5230\u7b2c$v$\u4f4d\u4e4b\u524d\u6bd4\u4ed6\u5c0f\u4e140\u7684\u4e2a\u6570\u6216\u6bd4\u4ed6\u5927\u4e141\u7684\u4e2a\u6570\u3002 2) \u7b2c$v$\u4f4d\u4e3a0\uff0c\u90a3\u53ea\u9700\u8981\u627e\u5230\u7b2c$v$\u4f4d\u4e4b\u524d\u6bd4\u4ed6\u5927\u4e140\u7684\u4e2a\u6570\u6216\u6bd4\u4ed6\u5c0f\u4e141\u7684\u4e2a\u6570\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long #define lowbit(x) (x&-x) using namespace std; const int N=1e5+10,C=1e6+10; int s[N],a[N],f[C][2]; int n,maxn,ans; void change(int i,int x,int d){ while(x<C)f[x][i]+=d,x+=lowbit(x); } int sum(int i,int x){ int ans=0; while(x>0)ans+=f[x][i],x-=lowbit(x); return ans; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),s[i]=s[i-1]+a[i],maxn=max(maxn,s[i]); for(int v=0;v<=20;++v){ if((1<<v)>maxn)break; int cnt=0; memset(f,0,sizeof f); change(0,1,1); for(int i=1;i<=n;++i){ int tmp=s[i]&((1<<v)-1),type=(s[i]>>v)&1; if(type)cnt+=sum(1,C-1)-sum(1,tmp+1)+sum(0,tmp+1); else cnt+=sum(0,C-1)-sum(0,tmp+1)+sum(1,tmp+1); change(type,tmp+1,1); } if(cnt%2)ans|=(1<<v); } printf(\"%lld\",ans); return 0; }","title":"\u8fdb\u5236 &amp; \u4f4d\u8fd0\u7b97"},{"location":"my%20past/OI/%E5%80%8D%E5%A2%9E/","text":"\u500d\u589e \u666e\u901a\u500d\u589e P7167 \u8fd9\u9053\u9898\u975e\u5e38\u5751 \u8981\u6ce8\u610f\u500d\u589e\u5230\u6700\u540e\u53ef\u80fd\u6709\u5269\u4f59\uff0c\u8fd9\u65f6\u5019\u8981\u7279\u5224\u4e00\u4e0b\uff0c\u5982\u679c\u6709\u5269\u4f59\u5219\u5e94\u8be5\u6d41\u5411\u4e0b\u4e00\u4e2a\u76d8\u5b50(\u55b7\u6cc9)\u4e2d \u6811\u4e0a\u500d\u589e \u7ecf\u5178\u5e94\u7528\uff1a\u500d\u589e$lca$\uff0c\u7ef4\u62a4\u6811\u4e0a\u4e00\u6bb5\u533a\u95f4(\u94fe)\u4fe1\u606f\uff0c\u5bfb\u627e\u6811\u4e0a\u8282\u70b9\u3002 P1084 \u5047\u8bbe\u5f53\u524d\u6709\u4e00\u4e2a\u65f6\u95f4\u9650\u5236\uff0c\u53ef\u4ee5\u53d1\u73b0\u5bf9\u4e8e\u6bcf\u4e2a\u519b\u961f\uff0c\u4e00\u5b9a\u65f6\u8d8a\u9760\u8fd1\u6839\u8282\u70b9\u8d8a\u4f18\u3002\u5e76\u4e14\u4e00\u4e2a\u65f6\u95f4\u9650\u5236\u5982\u679c\u80fd\u6ee1\u8db3\uff0c\u90a3\u4e48\u6bd4\u4ed6\u5927\u7684\u65f6\u95f4\u9650\u5236\u5c31\u90fd\u80fd\u6ee1\u8db3\u3002 \u6709\u8fd9\u4e24\u4e2a\u5355\u8c03\u6027\uff0c\u5c31\u53ef\u4ee5\u6811\u4e0a\u500d\u589e+\u4e8c\u5206\u3002\u6bcf\u6b21\u4e8c\u5206\u4e00\u4e2a\u65f6\u95f4\u9650\u5236\uff0c\u5e76\u5c06\u6240\u6709\u519b\u961f\u7528\u6811\u4e0a\u500d\u589e\u7684\u65b9\u5f0f\u63a8\u5230\u5b83\u80fd\u5230\u7684\u6df1\u5ea6\u6700\u5c0f\u7684\u8282\u70b9\u3002\u5e76\u627e\u51fa\u6240\u6709\u80fd\u81ea\u7531\u6d3b\u52a8\u7684\u519b\u961f\u53bb\u6ee1\u8db3\u90a3\u4e9b\u6ca1\u6709\u519b\u961f\u9a7b\u5b88\u7684\u6839\u7684\u5b50\u8282\u70b9\u3002 \u6309\u7167\u5269\u4f59\u65f6\u95f4\u7684\u6392\u5e8f\u987a\u5e8f\u8d2a\u5fc3\u7684\u53bb\u4e00\u4e00\u89e3\u51b3\u5c31\u884c\u4e86\u3002 \u6700\u540e\u8fd4\u56de\u662f\u5426\u6ee1\u8db3\u8fd9\u4e2a\u65f6\u95f4\u9650\u5236\u3002 update.2022.4.5 \u6628\u5929\u5199\u4e86\u8fd9\u4e2a\u9898\uff0c\u53d1\u73b0\u6bd4\u6211\u60f3\u8c61\u5730\u6076\u5fc3\u5f97\u591a\u554a\uff0c\u518d\u6765\u5410\u69fd\u4e00\u4e0b\u3002 \u9884\u5904\u7406 \u9996\u5148\uff0c\u6811\u4e0a\u500d\u589e\u6c42\u51fa$dis[u][j]$,\u8868\u793a\u4e00\u6bb5\u8ddd\u79bb\u3002 \u4e0a\u79fb\u519b\u961f \u7136\u540e\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u519b\u961f\uff0c\u6211\u4eec\u5c06\u4ed6\u5411\u4e0a\u63a8\u5230\u6df1\u5ea6\u6700\u5c0f(\u4e0d\u662f\u6839)\u7684\u5730\u65b9\u3002\u5982\u679c\u8be5\u8282\u70b9\u4e0d\u5728\u6839\u8282\u70b9\u4e0b\u9762\uff0c\u6216\u5b83\u5269\u4f59\u65f6\u95f4\u65e0\u6cd5\u5230\u8fbe\u6839\uff0c\u5c31\u5728\u5f53\u524d\u8282\u70b9\u9a7b\u624e($vis[u]=1$) \u5426\u5219\u5c06\u519b\u961f\u52a0\u5165\u4e00\u4e2a\u4e8c\u5143\u7ec4$h$\u4e2d\u5907\u7528\uff0c\u4e8c\u5143\u7ec4\u7b2c\u4e00\u7ef4\u662f\u5b83\u5230\u8fbe\u6839\u8282\u70b9\u65f6\u7684\u5269\u4f59\u65f6\u95f4\uff0c\u7b2c\u4e8c\u7ef4\u65f6\u5b83\u6765\u81ea\u6839\u7684\u54ea\u4e2a\u5b50\u8282\u70b9\u3002 \u7edf\u8ba1\u7b54\u6848 \u5148\u5bf9\u4e8e\u6839\u7684\u5b50\u8282\u70b9\u505a\u6df1\u641c\uff0c\u5f97\u51fa\u90a3\u4e9b\u8282\u70b9\u4e0d\u7528\u519b\u961f\u9a7b\u624e\uff0c\u5269\u4f59\u90a3\u4e9b\u8282\u70b9\u9700\u8981\u519b\u961f\u9a7b\u624e\u3002 \u4e4b\u540e\uff0c\u5bf9\u4e8e\u4e8c\u5143\u7ec4\u6309\u7b2c\u4e00\u7ef4\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u3002\u5982\u679c\u6ee1\u8db3\uff1a !vis[h[i].n] && h[i].d<dis[h[i].n][0] ,\u5c31\u5c06\u519b\u961f\u9a7b\u624e\u5728$h[i].n$. \uff08\u8fd9\u4e2a\u8d2a\u5fc3\u540e\u9762\u4f1a\u8bf4\u660e\uff09 \u6700\u540e\uff0c\u5c06\u90a3\u4e9b\u4ecd\u7136\u9700\u8981\u9a7b\u624e\u7684\u5b50\u8282\u70b9\u62ff\u51fa\u6765\uff0c\u6309\u7167\u5230\u6839\u7684\u8ddd\u79bb\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u4e0e\u7a7a\u95f2\u519b\u961f\u5339\u914d(\u53cc\u6307\u9488)\u3002\u8fd9\u91cc\u4e5f\u7528\u5230\u4e86\u5f88\u663e\u7136\u7684\u8d2a\u5fc3\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<queue> #define int long long using namespace std; const int N=1e5+10,K=21,INF=1e15; struct edge{ int v,w,nxt; }e[N<<1]; struct node{ int d,n; node(int dd=0,int nn=0){ d=dd,n=nn; } }h[N],s[N]; int n,m,u,v,w,cnt; int head[N],fa[N][K],dis[N][K],vis[N],t[N],a[N]; void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void dfs(int u,int p){ for(int i=1;i<K;++i) fa[u][i]=fa[fa[u][i-1]][i-1],dis[u][i]=dis[u][i-1]+dis[fa[u][i-1]][i-1]; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p) continue; fa[v][0]=u,dis[v][0]=w; dfs(v,u); } } bool _dfs(int u,int p){ if(vis[u]) return 1; int o=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; if(!_dfs(v,u)) return 0; o=1; } if(!o) return 0; return 1; } bool cmp(node a,node b){ if(a.d==b.d) return a.n<b.n; return a.d<b.d; } bool Cmp(int a,int b){ return a<b; } bool _cmp(int a,int b){ return dis[a][0]<dis[b][0]; } bool check(int x){ memset(vis,0,sizeof vis); memset(h,0,sizeof h); memset(s,0,sizeof s); memset(t,0,sizeof t); int tot=0,top=0,cur=0,atot=0,btot=0; for(int i=1;i<=m;++i){ int u=a[i],tmp=0; for(int j=K-1;j>=0;--j) if(fa[u][j]>1 && tmp+dis[u][j]<=x) tmp+=dis[u][j],u=fa[u][j]; if(fa[u][0]==1 && tmp+dis[u][0]<=x){ h[++tot]=node(x-tmp-dis[u][0],u); }else vis[u]=1; } for(int i=head[1];~i;i=e[i].nxt){ int v=e[i].v; vis[v]=_dfs(v,1); } sort(h+1,h+tot+1,cmp); for(int i=1;i<=tot;++i){ if(!vis[h[i].n] && h[i].d<dis[h[i].n][0]) vis[h[i].n]=1; else s[++top]=h[i]; } for(int i=head[1];~i;i=e[i].nxt){ int v=e[i].v; if(!vis[v]) t[++cur]=v; } sort(s+1,s+top+1,cmp); sort(t+1,t+cur+1,_cmp); int l=1; for(int i=1;i<=cur;++i){ while(l<=top && s[l].d<dis[t[i]][0]) ++l; if(l<=top) vis[t[i]]=1,++l; else return 0; } return 1; } signed main(){ //freopen(\"P1084_2.in\",\"r\",stdin); memset(head,-1,sizeof head),cnt=-1; scanf(\"%lld\",&n); for(int i=1;i<n;++i) scanf(\"%lld%lld%lld\",&u,&v,&w),add(u,v,w),add(v,u,w); dfs(1,0); scanf(\"%lld\",&m); for(int i=1;i<=m;++i) scanf(\"%lld\",&a[i]); int l=0,r=INF,ans=-1; while(l<=r){ int mid=l+r>>1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; } printf(\"%lld\",ans); return 0; } /* 10 2 1 3 2 3 4 1 4 7 5 1 9 6 1 2 4 7 9 7 8 8 9 8 8 1 10 2 5 2 8 5 4 2 */ \u4e0b\u9762\u8bf4\u8bf4\u5751\u70b9\uff1a \u6811\u4e0a\u500d\u589e \u6811\u4e0a\u500d\u589e\u4e00\u5b9a\u8981\u5728\u9012\u5f52\u5230\u4e0b\u4e00\u5c42\u524d\u5c31\u9012\u63a8\u51fa\u8fd9\u4e00\u5c42\u5f97$dis[u][j],fa[u][j]$,\u4e0d\u7136\uff0c\u76f8\u5f53\u4e8e\u9012\u5f52\u5230\u5e95\uff0c\u524d\u9762\u7684$dis[u][j]$\u8fd8\u90fd\u662f\u7a7a\u7684\uff0c\u5c31\u4f1a\u51fa\u9519\u4e86 \u8d2a\u5fc3\u90e8\u5206 \u5148\u8003\u8651\u4e00\u4e2a\u53cd\u4f8b\uff1a \u8fd9\u91cc\u5c31\u4e0d\u7528\u4e8c\u5143\u7ec4\u8868\u793a\u4e86\uff0c\u76f4\u63a5\u5c55\u793a\u539f\u59cb\u72b6\u6001\uff0c\u7ea2\u8272\u8868\u793a\u5269\u4f59\u65f6\u95f4\uff0c\u84dd\u8272\u8868\u793a\u8fb9\u6743\u3002 \u53ef\u4ee5\u53d1\u73b0\uff0c\u5982\u679c\u8ba9$9$\u9a7b\u624e\u5728$2$\u53f7\u8282\u70b9\uff0c\u6700\u7ec8\u5c31\u53ea\u80fd\u9a7b\u624e$3$\u4e2a\uff0c\u800c\u6b63\u786e\u7b54\u6848\u4e3a$4$. \u7136\u540e\u5c1d\u8bd5~~\u8bc1\u660e~~\u8bf4\u660e\u4e00\u4e0b\u539f\u7406\u3002 \u56e0\u4e3a\u519b\u961f$i$\u6ee1\u8db3 h[i].d<dis[h[i].n][0] ,\u90a3\u8fd9\u4e2a\u519b\u961f\u65e0\u6cd5\u518d\u56de\u5230\u5b83\u6240\u5c5e\u7684\u5b50\u8282\u70b9\uff0c\u6240\u4ee5\u8be5\u5b50\u8282\u70b9\u4e00\u5b9a\u7531\u53e6\u4e00\u4e2a \u5269\u4f59\u65f6\u95f4\u5927\u4e8e\u5b83 \u7684\u519b\u961f$j$\u63a7\u5236\u3002\u800c\u663e\u7136$j$\u53ef\u4ee5\u5230\u8fbe\u7684\u8282\u70b9\u6570\u591a\u4e8e$i$\uff0c\u6240\u4ee5\u76f4\u63a5\u8ba9$i$\u7ba1\u63a7\u8fd9\u4e2a\u5b50\u8282\u70b9\u66f4\u4f18\u3002 \u800c\u5982\u679c$i$\u4e0d\u6ee1\u8db3\uff0c\u8bf4\u660e\u5b83\u80fd\u56de\u53bb\uff0c\u90a3\u5c31\u5c06\u4ed6\u52a0\u5165\u6700\u540e\u7684\u6570\u7ec4\u4e0e\u540e\u9762\u7684\u519b\u961f\u4e00\u8d77\u8003\u8651\u3002\u867d\u7136\u8ba9\u4ed6\u6298\u8fd4\u4f1a\u6d6a\u8d39\u65f6\u95f4\uff0c\u4f46\u662f \u7ed3\u679c\u4e0d\u4f1a\u66f4\u5dee \uff0c\u8fd9\u6837\u7b80\u5316\u4e86\u51b3\u7b56\u590d\u6742\u5ea6\u3002 P3233 ~~\u5173\u4e8e\u865a\u6811\u6a21\u677f\u5199\u5047\u4e86\u8c03\u4e86\u4e00\u4e0a\u5348\u8fd9\u4ef6\u4e8b~~ \u8fd9\u9053\u9898\u53ca\u5176~~\u6076\u5fc3~~\u590d\u6742,\u9700\u8981$6$\u6b21$dfs$\u3002 \u9884\u5904\u7406$lca,dep,size$ \u500d\u589e\u5904\u7406$fa$\uff0c\u56e0\u4e3a\u540e\u9762\u9664\u4e86\u6c42$lca$\u8fd8\u4f1a\u7528\u5230\u3002 \u6c42\u51fa\u865a\u6811\u4e2d\u6bcf\u4e2a\u865a\u6811\u8282\u70b9\u5b50\u6811\u4e2d\u8ddd\u79bb\u6b64\u8282\u70b9\u6700\u8fd1\u7684\"\u5173\u952e\u8282\u70b9\" \u6240\u6709\u5173\u952e\u8282\u70b9\u90fd\u5728\u865a\u6811\u4e0a\uff0c\u6240\u4ee5\u7b2c\u4e00\u904d\u4ece\u4e0b\u800c\u4e0a$dfs$\uff0c\u53ef\u4ee5\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u5728\u5b83\u5b50\u6811\u4e2d\u8ddd\u79bb\u5b83\u6700\u8fd1\u7684\u5173\u952e\u8282\u70b9(\u53ef\u4ee5\u662f\u81ea\u5df1)\u3002 \u6c42\u51fa\u865a\u6811\u4e2d\u8ddd\u79bb\u6bcf\u4e2a\u865a\u6811\u8282\u70b9\u6700\u8fd1\u7684\"\u5173\u952e\u8282\u70b9\" \u7b2c\u4e8c\u904d\u4ece\u4e0a\u800c\u4e0b\u6c42\u51fa\u5b50\u6811\u5916\u8d21\u732e\u3002 \u6ce8\u610f\uff0c\u6211\u4eec\u7ef4\u62a4\u7684\u662f\u4e00\u4e2a\u4e8c\u5143\u7ec4$g[u]$\uff0c\u7b2c\u4e00\u5173\u952e\u5b57\u4e3a\u8ddd\u79bb\uff0c\u7b2c\u4e8c\u5173\u952e\u5b57\u4e3a\u7f16\u53f7\u3002 \u6c42\u51fa\u865a\u6811\u4e0a\u6bcf\u4e2a\u8282\u70b9\u8ddd\u79bb\u6700\u8fd1\u7684\u70b9\u7f16\u53f7\uff0c\u4ee5\u53ca\u8282\u70b9\u4e0a\u7684\u8d21\u732e\u3002 \u6700\u8fd1\u8282\u70b9\u5c31\u662f$num[u]=g[u].second$,\u800c\u8282\u70b9\u4e0a\u7684\u8d21\u732e\u662f\u6307\uff1a\u5bf9\u4e8e\u865a\u6811\u8282\u70b9$u$\uff0c\u5176\u6240\u6709 \u6ca1\u6709\u5173\u952e\u70b9 \u7684\u5b50\u6811\uff0c\u90fd\u5c06\u5f52$num[u]$\u7ba1\u7406\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u904d\u5386\u865a\u6811\u65f6\uff0c\u53ef\u4ee5\u7528$u$\u6240\u5728\u7684\u5b50\u6811\u603b\u7ed3\u70b9\u6570\u51cf\u53bb\u6709\u5173\u952e\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u3002 \u6709\u5173\u952e\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u9700\u8981\u5728\u539f\u6811\u4e0a\u500d\u589e\u6c42\u51fa\u5bf9\u4e8e$v$\u6240\u5728\u5b50\u6811\u7684\u6839$up[v]$\uff0c\u8fd9\u65f6$up[v]$\u5728$u$\u4e0b\u9762\uff0c\u51cf\u6389$sz[up[v]]$\u5373\u53ef\u3002 \u6c42\u51fa\u865a\u6811\u4e0a\u6bcf\u6761\u8fb9\u7684\u8d21\u732e \u5bf9\u4e8e\u6bcf\u6761\u8fb9\u4e24\u7aef\u70b9$u,v$\uff0c\u6709\u4e24\u79cd\u60c5\u51b5\uff1a \u4e00\u662f$num[u]=num[v]$,\u8fd9\u79cd\u60c5\u51b5\u8fd9\u6761\u8fb9\u4e0a\u6240\u6709\u8282\u70b9\u90fd\u5f52$num[u]$\u7ba1\u5373\u53ef\u3002 \u4e8c\u662f$num[u]\\not =num[v]$,\u8fd9\u79cd\u60c5\u51b5\u5148\u6c42\u51fa\u4e2d\u95f4\u70b9\u7684\u6df1\u5ea6\uff0c\u518d\u4ece$v$\u500d\u589e\u627e\u51fa\u4e2d\u95f4\u70b9\u6807\u53f7\u5373\u53ef\u3002 \u5177\u4f53\u5730\uff0c\u4ece$num[u]$\u5230$num[v]$\u7684\u94fe\u957f\u5ea6$L$=$dep[num[v]]-dep[u]+g[u].first$. \u90a3\u4e48\u4e2d\u95f4\u70b9\u7684\u6df1\u5ea6=$\\frac{dep[num[v]]-L} 2$. \u6e05\u7a7a\u865a\u6811\u53ca\u70b9\u6807\u8bb0 \u9700\u8981\u6e05\u7a7a$vis[i],ans[i],up[i],num[i]$. \u81f3\u6b64\uff0c\u8fd9\u9053\u9898\u624d\u7b97\u505a\u5b8c\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<utility> using namespace std; typedef pair<int,int> PI; const int N=3e5+10,K=20,INF=0x3f3f3f3f; int fa[N][K],dep[N],head[2][N],vis[N],a[N],b[N],sz[N],stk[N],ans[N],id[N],num[N],up[N]; int n,q,u,v,cnt[2],tmp,m,top,tot,rt; PI g[N]; struct edge { int v,nxt; } e[2][N<<1]; void add(int u,int v,int i) { e[i][++cnt[i]].v=v,e[i][cnt[i]].nxt=head[i][u],head[i][u]=cnt[i]; } bool cmp(int a,int b) { return id[a]<id[b]; } int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x){ if(x>9) write1(x/10); putchar(x%10+'0'); } void dfs0(int u,int p) { id[u]=++tot;fa[u][0]=p;sz[u]=1; for(int i=1; i<K; ++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[0][u]; ~i; i=e[0][i].nxt) { int v=e[0][i].v; if(v==p) continue; dep[v]=dep[u]+1; dfs0(v,u); sz[u]+=sz[v]; } } void dfs1(int u,int p) { if(vis[u]) g[u]=make_pair(0,u); else g[u]=make_pair(INF,0); for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs1(v,u); g[u]=min(g[u],make_pair(g[v].first+dep[v]-dep[u],g[v].second)); } } void dfs2(int u,int p,int d,int x) { PI tmp=make_pair(d,x); if(tmp<g[u]) g[u]=tmp; else d=g[u].first,x=g[u].second; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs2(v,u,d+dep[v]-dep[u],x); } } void dfs3(int u,int p) { num[u]=g[u].second; ans[num[u]]+=sz[u]; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; int k=v; for(int j=K-1;j>=0;--j) if(fa[k][j] && dep[fa[k][j]]>dep[u]) k=fa[k][j]; ans[num[u]]-=sz[up[v]=k]; dfs3(v,u); } } void dfs4(int u,int p){ for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; if(num[v]==num[u]) ans[num[u]]+=(sz[up[v]]-sz[v]); else{ int dis=dep[num[v]]+dep[u]-g[u].first; dis=dis&1?dis+1>>1:(num[v]<num[u]?dis>>1:(dis>>1)+1); int k=v; for(int j=K-1;j>=0;--j) if(fa[k][j] && dep[fa[k][j]]>=dis) k=fa[k][j]; ans[num[u]]+=sz[up[v]]-sz[k]; ans[num[v]]+=sz[k]-sz[v]; } dfs4(v,u); } } void dfs5(int u,int p){//clear up[u]=num[u]=0; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs5(v,u); } head[1][u]=-1; } int getlca(int u,int v) { if(dep[u]<dep[v]) swap(u,v); int k=dep[u]-dep[v]; for(int i=K-1; i>=0; --i) if(k&(1<<i)) u=fa[u][i]; if(v==u) return u; for(int i=K-1; i>=0; --i) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0]; } void insert(int u) { int lca=getlca(u,stk[top]); while(top>1 && id[stk[top-1]]>=id[lca]) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top; if(lca!=stk[top]) add(stk[top],lca,1),add(lca,stk[top],1),stk[top]=lca; stk[++top]=u; } void build() { cnt[1]=-1; sort(a+1,a+m+1,cmp); stk[top=1]=a[1]; for(int i=2; i<=m; ++i) insert(a[i]); while(top>1) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top; rt=stk[1]; } int main() { memset(head,-1,sizeof head); cnt[0]=-1; scanf(\"%d\",&n); for(int i=1; i<n; ++i) scanf(\"%d%d\",&u,&v),add(u,v,0),add(v,u,0); dfs0(1,0); scanf(\"%d\",&q); for(int i=1; i<=q; ++i) { scanf(\"%d\",&m); for(int j=1; j<=m; ++j) scanf(\"%d\",&a[j]),b[j]=a[j],vis[b[j]]=1; build(); dfs1(rt,0); dfs2(rt,0,g[rt].first,g[rt].second); dfs3(rt,0); dfs4(rt,0); ans[num[rt]]+=sz[1]-sz[rt]; for(int j=1; j<=m; ++j) printf(\"%d \",ans[b[j]]),ans[b[j]]=vis[b[j]]=0;printf(\"\\n\"); dfs5(rt,0); } return 0; } P7518 ~~\u505a\u4e86\u6574\u6574\u4e24\u5929\u624d\u8fc7\u7684\u6076\u5fc3\u9898~~ ~~100\u7d2b\u9898\u796d\uff01~~ ~~\u601d\u8def\u5f88\u7b80\u5355\uff0c\u4ee3\u7801100\u884c\uff0c\u4f46\u7ec6\u8282\u771f\u7684\u591a~~ \u9996\u5148\u53ef\u4ee5\u5c06\u8def\u5f84$s\\to t$\u62c6\u5206\u4e3a\u4e0a\u884c$s\\to lca$\u548c\u4e0b\u884c$lca\\to t$ \u5bf9\u4e8e\u6bcf\u4e2a\u6811\u4e0a\u7684\u8282\u70b9\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u901a\u8fc7\u500d\u589e\u6765\u6c42\u51fa$f[u][j]$\uff0c\u8868\u793a\u5b83\u7ecf\u8fc7\u539f\u5e8f\u5217$2^j$\u4e2a\u5b9d\u77f3\u540e\u5411\u4e0a\u8df3\u5230\u4e86\u54ea\u4e2a\u8282\u70b9\u3002 \u6bcf\u6b21\u4e8c\u5206\u627e\u5230\u4e0a\u884c\u8def\u5f84\u4e2d\u7684\u7b2c\u4e00\u4e2a\u4e8e\u539f\u5e8f\u5217\u5bf9\u5e94\u7684\u8282\u70b9(\u8d77\u70b9)\uff0c\u4ece\u5b83\u5f00\u59cb\u500d\u589e\uff0c\u4fbf\u53ef\u4ee5\u89e3\u51b3\u4e0a\u884c\u7684\u60c5\u51b5\u3002\u4e0b\u884c\u4e5f\u540c\u7406\u3002 \u63a5\u4e0b\u6765\u5c31\u662f\u4e00\u5806\u7ec6\u8282\u4e86\u3002 \u6c42\u89e3$f[u][j]$. \u6211\u4eec\u53d1\u73b0\uff0c\u53ea\u8981\u6709\u4e86$f[u][0]$,\u5269\u4f59\u5c31\u53ef\u4ee5\u9012\u63a8\u89e3\u51b3\u3002 \u800c$f[u][0]$\u53ef\u4ee5\u7528$c$\u4e2a\u6808$h$\u7ef4\u62a4\u4e00\u4e0b\uff0c\u5373\u5bf9\u4e8e\u6bcf\u4e2a\u5b9d\u77f3\u5f00\u4e00\u4e2a\u6808\u3002 \u800c\u56e0\u4e3a\u6211\u4eec\u8981\u77e5\u9053\u6bcf\u4e2a\u5b9d\u77f3\u4e0b\u4e00\u4e2a\u5b9d\u77f3\u7684\u7f16\u53f7\uff0c\u6240\u4ee5\u53ef\u4ee5\u63d0\u524d\u6c42\u4e00\u4e2a$nxt[i]$\u8868\u793a\u5b9d\u77f3$i$\u7684\u4e0b\u4e00\u4e2a\uff0c\u4e5f\u53ef\u4ee5\u6c42\u51fa$rk[i]$,\u8868\u793a\u5b9d\u77f3$i$\u7684\u76f8\u5bf9\u6392\u540d\u3002 $dfs$\u6bcf\u7ecf\u8fc7\u4e00\u4e2a\u8282\u70b9\uff0c\u5c31\u5c06\u8fd9\u4e2a\u8282\u70b9\u7684\u7f16\u53f7\u52a0\u5165$rk[a[u]]$\u8fd9\u4e2a\u6808\u91cc\u3002(\u6808\u7684\u4e0b\u6807\u4e3a\u5b9d\u77f3\u76f8\u5bf9\u6392\u540d\u3002) \u6bcf\u6b21\u5bf9\u4e8e\u8282\u70b9$u$\uff0c\u8bbf\u95ee$h[rk[a[u]]+1]$\u7684\u6808\u9876(\u6ce8\u610f\u7279\u5224\u6808\u4e3a\u7a7a\uff0c\u4e0d\u7136\u4f1a$RE$)\uff0c\u5c31\u662f\u6df1\u5ea6\u6700\u6df1\u7684$f[u][0]$\u4e86\u3002 \u4e8c\u5206\u8d77\u70b9 \u4e8c\u5206\u4e00\u5b9a\u8981\u5229\u7528\u5355\u8c03\u6027\uff0c\u7136\u800c\u53ea\u770b\u5b9d\u77f3\u79cd\u7c7b\u65e0\u6cd5\u5f97\u51fa\u5355\u8c03\u6027\u3002 \u6240\u4ee5\u6211\u4eec\u8981\u7528\u5230$dfs$\u5e8f\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u5b9d\u77f3$i$\uff0c\u6c42\u51fa\u5b83\u5728\u90a3\u4e9b$dfs$\u5e8f\u5bf9\u5e94\u7684\u8282\u70b9\u51fa\u73b0\u8fc7\uff0c\u8bb0\u4e3a$d[i]$\u3002$dfs$\u5e8f\u4ece\u5c0f\u5230\u5927\u3002 \u90a3\u4e48\uff0c\u6211\u4e48\u5c31\u53ef\u4ee5\u6839\u636e$dfs$\u5e8f\u7684\u6027\u8d28\uff0c\u7528\u6811\u5256\u5c06\u6811\u5206\u6210\u51e0\u6761\u91cd\u94fe\u3002\u91cd\u94fe\u4e0a$dfs$\u5e8f\u8fde\u7eed\uff0c\u6240\u4ee5\u53ef\u4ee5\u5728$d[i]$\u4e2d\u4e8c\u5206\u6700\u540e\u4e00\u4e2a$\\leq$\u6811\u94fe\u4e0b\u7aef\u70b9$dfs$\u5e8f\u7684$dfs$\u5e8f\u503c$tmp$\u3002\u5982\u679c$tmp$\u5728$id[top[t]],id[t]$\u4e4b\u95f4\uff0c\u5c31\u8bf4\u660e\u627e\u5230\u4e86\uff0c\u5426\u5219\u7ee7\u7eed\u5411\u4e0a\u627e\u3002 \u590d\u6742\u5ea6$O(\\log^2n)$,\u4e00\u5171$O(\\log n)$\u6761\u94fe\u3002 \u500d\u589e \u5982\u679c\u627e\u5230\u8d77\u70b9\u518d\u8fdb\u884c\u500d\u589e\uff0c\u4e0d\u7136\u500d\u589e\u5c31\u6ca1\u610f\u4e49\u4e86\u3002 \u4e0b\u884c ~~\u300a\u4e0b\u884c\u4e5f\u540c\u7406\u300b\uff0c\u5f53\u65f6\u6211\u662f\u8fd9\u4e48\u60f3\u7684~~ \u9996\u5148\uff0c\u6211\u4eec\u6ce8\u610f\u5230\u4e00\u4e2a\u4e8b\uff1a\u500d\u589e\u6570\u7ec4\u53ea\u80fd\u5411\u4e0a\uff0c\u4e0d\u80fd\u5411\u4e0b\uff0c\u56e0\u4e3a\u4e00\u4e2a\u7236\u4eb2\u5bf9\u5e94\u591a\u4e2a\u513f\u5b50\u3002 \u6240\u4ee5\u8fd9\u91cc\u6211\u4eec\u4ecd\u7136\u8981\u6c42\u4e00\u4e2a\u5411\u4e0a\u7684\u500d\u589e\u6570\u7ec4$g[u][j]$,\u53ea\u4e0d\u8fc7\u8981\u6c42$h[rk[a[u]-1]$,\u9006\u7740\u5411\u4e0a\u5373\u987a\u7740\u5411\u4e0b\u3002 \u6c42\u51fa\u8fd9\u4e2a\u540e\u53d1\u73b0\uff0c\u6211\u4eec\u9700\u8981\u77e5\u9053\u6700\u7ec8\u7b54\u6848\u624d\u80fd\u4ece$t$\u5f00\u59cb\u4e8c\u5206\u8d77\u70b9+\u500d\u589e\uff0c\u4e0d\u7136\u8d77\u70b9\u4e0d\u786e\u5b9a\uff0c\u6ca1\u6cd5\u500d\u589e\u3002 \u8fd8\u597d\u8fd9\u4e2a\u7b54\u6848\u5177\u6709\u5355\u8c03\u6027\uff0c\u5373\u5982\u679c\u8f83\u5927\u7684\u7b54\u6848\u5df2\u7ecf\u6ee1\u8db3\uff0c\u90a3\u4e48\u8f83\u5c0f\u7684\u7b54\u6848\u4e00\u5b9a\u6ee1\u8db3\u3002(\u76f8\u5f53\u4e8e\u6c42\u51fa\u7684\u5e8f\u5217\u548c\u524d\u9762\u5e8f\u5217\u53ef\u4ee5\u6709\u91cd\u5408\uff0c\u4f46\u4e0d\u80fd\u6709\u7a7a\u9699\u3002) \u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u4e8c\u5206\u4e00\u4e2a\u6700\u7ec8\u7b54\u6848\uff0c\u7136\u540e\u4ece\u627e\u5230\u7684\u8d77\u70b9\u5411\u4e0a\u500d\u589e\uff0c\u6ce8\u610f\u8981\u51cf\u6389\u6240\u6709\u8d21\u732e\uff0c\u4e4b\u540e\u5224\u65ad\u4e00\u4e0b\u4e24\u6bb5\u662f\u5426\u6709\u91cd\u53e0\u5373\u53ef\u3002(\u8fd9\u91cc\u7684\u4e24\u6bb5\u5c31\u662f\u505a\u591a\u5411\u524d/\u5411\u540e\u500d\u589e\u4e86\u591a\u5c11\u4e2a\u5b9d\u77f3\u3002) \u5e76\u4e14\uff0c\u8fd9\u4e2a\u4e8c\u5206\u8981\u5224\u65ad\u5982\u679c$mid$\u5c0f\u4e8e\u4e0a\u884c\u7684\u7b54\u6848\uff0c\u90a3\u4e48\u660e\u663e\u6210\u7acb\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u89e3\u51b3\u4e86\u8fd9\u9053\u9898\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<vector> #include<stack> using namespace std; const int N=2e5+10,M=5e4+10,K=23; int b[N],a[N],head[N],sz[N],top[N],son[N],fa[N],dep[N],id[N],dfn[N],f[N][K],g[N][K],rk[N]; int n,m,c,q,cnt,tot,u,v,lca,num; vector<int> d[N]; stack<int> h[N]; struct edge{ int v,nxt; }e[N<<1]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x){ if(x>9) write1(x/10); putchar(x%10+'0'); } void dfs1(int u,int p){ sz[u]=1; h[rk[a[u]]].push(u); f[u][0]=h[rk[a[u]]+1].empty()?0:h[rk[a[u]]+1].top(),g[u][0]=h[rk[a[u]]-1].empty()?0:h[rk[a[u]]-1].top(); for(int i=1;i<K;++i) f[u][i]=f[f[u][i-1]][i-1],g[u][i]=g[g[u][i-1]][i-1]; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; fa[v]=u,dep[v]=dep[u]+1; dfs1(v,u); sz[u]+=sz[v]; if(sz[son[u]]<sz[v]) son[u]=v; } h[rk[a[u]]].pop(); } void dfs2(int u,int t){ top[u]=t,id[u]=++tot,dfn[tot]=u; if(son[u]) dfs2(son[u],t); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==fa[u] || v==son[u]) continue; dfs2(v,v); } } int getlca(int u,int v){ while(top[u]!=top[v]){ if(dep[top[u]]<dep[top[v]]) swap(v,u); u=fa[top[u]]; } return dep[u]<dep[v]?u:v; } void Get(int &u,int &now,int x,int t){ u=0,now=0; while(id[t]>=id[lca]){ int idx=upper_bound(d[b[x]].begin(),d[b[x]].end(),id[t])-d[b[x]].begin()-1; if(idx>=0 && d[b[x]][idx]>=max(id[lca],id[top[t]])) { u=dfn[d[b[x]][idx]];now=x; break; } t=fa[top[t]]; } } bool check(int ans,int x,int t){ if(x<ans) return true; int u=0,now=0; Get(u,now,x,t); if(!now) return false; for(int j=K-1;j>=0;--j) if(g[u][j] && id[g[u][j]]>id[lca]) u=g[u][j],now-=(1<<j); return now<=ans; } void work(int s,int t){ lca=getlca(s,t);int u=0,now=0; Get(u,now,1,s); if(now) for(int j=K-1;j>=0;--j) if(f[u][j] && id[f[u][j]]>=id[lca]) u=f[u][j],now+=(1<<j); int l=1,r=c,ans=0; while(l<=r){ int mid=l+r>>1; if(check(now+1,mid,t)) ans=mid,l=mid+1; else r=mid-1; } write1(ans),putchar('\\n'); } int main(){ memset(head,-1,sizeof head),cnt=-1; n=read1(),m=read1(),c=read1(); for(int i=1;i<=c;++i) b[i]=read1(); for(int i=1;i<=n;++i) a[i]=read1(); for(int i=1;i<=c;++i) rk[b[i]]=i; for(int i=1;i<n;++i) u=read1(),v=read1(),add(u,v),add(v,u); dfs1(1,0); dfs2(1,1); for(int i=1;i<=tot;++i) d[a[dfn[i]]].push_back(i); q=read1(); for(int i=1;i<=q;++i) u=read1(),v=read1(),work(u,v); return 0; } P2597 \u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u4f1a\u706d\u7edd\uff0c\u5f53\u4e14\u4ec5\u5f53\u5b83\u7684\u6240\u6709\u98df\u7269\u90fd\u706d\u7edd\u4e86\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u8fd9\u4e9b\u98df\u7269\u7684\u5171\u540clca\u4e00\u5b9a\u706d\u7edd\u3002\u6240\u4ee5\u53ef\u4ee5\u5728\u62d3\u6251\u6392\u5e8f\u8fc7\u7a0b\u4e2d\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u7ef4\u62a4\u4e00\u4e2a$dad$\u6570\u7ec4\uff0c\u5b58\u6240\u6709\u98df\u7269\u7684\u5171\u540clca\u3002\u6c42\u51fa\u6570\u7ec4\u540e\uff0c\u5c06$dad[i]$\u4e0ei\u8fde\u8fb9\uff0c\u6784\u6210\u65b0\u7684\u706d\u7edd\u6811\u3002\u7b54\u6848\u4e3a$sz[u]-1$\u3002\u5728\u6bcf\u6b21\u62d3\u6251\u65f6\uff0c\u7531\u4e8e\u62d3\u6251\u5e8f\u51b3\u5b9a\u5f53\u524d\u70b9\u4e4b\u524d\u6240\u6709\u70b9\u5df2\u7ecf\u641c\u7d22\u8fc7\uff0c\u6240\u4ee5\u5b83\u5728\u65b0\u7684\u706d\u7edd\u6811\u7684\u500d\u589e\u6570\u7ec4\u53ef\u4ee5\u552f\u4e00\u786e\u5b9a\u3002\u6240\u4ee5\u76f4\u63a5\u66f4\u65b0\u500d\u589e\u6570\u7ec4\u3002$dad$\u9ed8\u8ba4\u4e3a-1\u3002\u904d\u5386$u$\u7684\u98df\u7269$v$,\u82e5\u5f53\u524d\u70b9$dad$\u5df2\u7ecf\u6709\u503c\uff0c\u5219\u66f4\u65b0$dad[i]=lca(dad[i],v)$\u3002 #include<iostream> #include<cstring> #include<vector> #include<queue> using namespace std; const int N=1e5+10,M=2e5+10,K=20; struct edge{ int v,nxt; }e[M<<1]; int head[N],dad[N],ind[N],dep[N],fa[N][K],sz[N]; int cnt,n,u; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } vector<int> g[N]; queue<int> q; int getlca(int u,int v){ if(u==v) return u; if(dep[u]<dep[v]) swap(u,v); int k=dep[u]-dep[v]; for(int i=0;i<K;++i){ if((k>>i)&1) u=fa[u][i]; } if(u==v) return u; for(int i=K-1;i>=0;--i){ if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; } return fa[u][0]; } void dfs(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; dfs(v,u); sz[u]+=sz[v]; } } int main(){ memset(head,-1,sizeof head); memset(dad,-1,sizeof dad); cnt=-1; scanf(\"%d\",&n); for(int v=1;v<=n;++v){ while(1){ scanf(\"%d\",&u); if(u==0) break; ++ind[v]; g[u].push_back(v); } } for(int i=1;i<=n;++i){ if(!ind[i]){ q.push(i); dad[i]=0; } } while(!q.empty()){ int u=q.front();q.pop(); add(u,dad[u]),add(dad[u],u); fa[u][0]=dad[u],dep[u]=dep[dad[u]]+1; for(int i=1;i<K;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=0;i<g[u].size();++i){ int v=g[u][i]; if(dad[v]==-1){ dad[v]=u; }else{ dad[v]=getlca(u,dad[v]); } if(!(--ind[v])){ q.push(v); } } } dfs(0,0); for(int i=1;i<=n;++i){ printf(\"%d\\n\",sz[i]-1); } return 0; }","title":"\u500d\u589e"},{"location":"my%20past/OI/%E5%80%8D%E5%A2%9E/#_1","text":"","title":"\u500d\u589e"},{"location":"my%20past/OI/%E5%80%8D%E5%A2%9E/#_2","text":"P7167 \u8fd9\u9053\u9898\u975e\u5e38\u5751 \u8981\u6ce8\u610f\u500d\u589e\u5230\u6700\u540e\u53ef\u80fd\u6709\u5269\u4f59\uff0c\u8fd9\u65f6\u5019\u8981\u7279\u5224\u4e00\u4e0b\uff0c\u5982\u679c\u6709\u5269\u4f59\u5219\u5e94\u8be5\u6d41\u5411\u4e0b\u4e00\u4e2a\u76d8\u5b50(\u55b7\u6cc9)\u4e2d","title":"\u666e\u901a\u500d\u589e"},{"location":"my%20past/OI/%E5%80%8D%E5%A2%9E/#_3","text":"\u7ecf\u5178\u5e94\u7528\uff1a\u500d\u589e$lca$\uff0c\u7ef4\u62a4\u6811\u4e0a\u4e00\u6bb5\u533a\u95f4(\u94fe)\u4fe1\u606f\uff0c\u5bfb\u627e\u6811\u4e0a\u8282\u70b9\u3002 P1084 \u5047\u8bbe\u5f53\u524d\u6709\u4e00\u4e2a\u65f6\u95f4\u9650\u5236\uff0c\u53ef\u4ee5\u53d1\u73b0\u5bf9\u4e8e\u6bcf\u4e2a\u519b\u961f\uff0c\u4e00\u5b9a\u65f6\u8d8a\u9760\u8fd1\u6839\u8282\u70b9\u8d8a\u4f18\u3002\u5e76\u4e14\u4e00\u4e2a\u65f6\u95f4\u9650\u5236\u5982\u679c\u80fd\u6ee1\u8db3\uff0c\u90a3\u4e48\u6bd4\u4ed6\u5927\u7684\u65f6\u95f4\u9650\u5236\u5c31\u90fd\u80fd\u6ee1\u8db3\u3002 \u6709\u8fd9\u4e24\u4e2a\u5355\u8c03\u6027\uff0c\u5c31\u53ef\u4ee5\u6811\u4e0a\u500d\u589e+\u4e8c\u5206\u3002\u6bcf\u6b21\u4e8c\u5206\u4e00\u4e2a\u65f6\u95f4\u9650\u5236\uff0c\u5e76\u5c06\u6240\u6709\u519b\u961f\u7528\u6811\u4e0a\u500d\u589e\u7684\u65b9\u5f0f\u63a8\u5230\u5b83\u80fd\u5230\u7684\u6df1\u5ea6\u6700\u5c0f\u7684\u8282\u70b9\u3002\u5e76\u627e\u51fa\u6240\u6709\u80fd\u81ea\u7531\u6d3b\u52a8\u7684\u519b\u961f\u53bb\u6ee1\u8db3\u90a3\u4e9b\u6ca1\u6709\u519b\u961f\u9a7b\u5b88\u7684\u6839\u7684\u5b50\u8282\u70b9\u3002 \u6309\u7167\u5269\u4f59\u65f6\u95f4\u7684\u6392\u5e8f\u987a\u5e8f\u8d2a\u5fc3\u7684\u53bb\u4e00\u4e00\u89e3\u51b3\u5c31\u884c\u4e86\u3002 \u6700\u540e\u8fd4\u56de\u662f\u5426\u6ee1\u8db3\u8fd9\u4e2a\u65f6\u95f4\u9650\u5236\u3002 update.2022.4.5 \u6628\u5929\u5199\u4e86\u8fd9\u4e2a\u9898\uff0c\u53d1\u73b0\u6bd4\u6211\u60f3\u8c61\u5730\u6076\u5fc3\u5f97\u591a\u554a\uff0c\u518d\u6765\u5410\u69fd\u4e00\u4e0b\u3002 \u9884\u5904\u7406 \u9996\u5148\uff0c\u6811\u4e0a\u500d\u589e\u6c42\u51fa$dis[u][j]$,\u8868\u793a\u4e00\u6bb5\u8ddd\u79bb\u3002 \u4e0a\u79fb\u519b\u961f \u7136\u540e\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u519b\u961f\uff0c\u6211\u4eec\u5c06\u4ed6\u5411\u4e0a\u63a8\u5230\u6df1\u5ea6\u6700\u5c0f(\u4e0d\u662f\u6839)\u7684\u5730\u65b9\u3002\u5982\u679c\u8be5\u8282\u70b9\u4e0d\u5728\u6839\u8282\u70b9\u4e0b\u9762\uff0c\u6216\u5b83\u5269\u4f59\u65f6\u95f4\u65e0\u6cd5\u5230\u8fbe\u6839\uff0c\u5c31\u5728\u5f53\u524d\u8282\u70b9\u9a7b\u624e($vis[u]=1$) \u5426\u5219\u5c06\u519b\u961f\u52a0\u5165\u4e00\u4e2a\u4e8c\u5143\u7ec4$h$\u4e2d\u5907\u7528\uff0c\u4e8c\u5143\u7ec4\u7b2c\u4e00\u7ef4\u662f\u5b83\u5230\u8fbe\u6839\u8282\u70b9\u65f6\u7684\u5269\u4f59\u65f6\u95f4\uff0c\u7b2c\u4e8c\u7ef4\u65f6\u5b83\u6765\u81ea\u6839\u7684\u54ea\u4e2a\u5b50\u8282\u70b9\u3002 \u7edf\u8ba1\u7b54\u6848 \u5148\u5bf9\u4e8e\u6839\u7684\u5b50\u8282\u70b9\u505a\u6df1\u641c\uff0c\u5f97\u51fa\u90a3\u4e9b\u8282\u70b9\u4e0d\u7528\u519b\u961f\u9a7b\u624e\uff0c\u5269\u4f59\u90a3\u4e9b\u8282\u70b9\u9700\u8981\u519b\u961f\u9a7b\u624e\u3002 \u4e4b\u540e\uff0c\u5bf9\u4e8e\u4e8c\u5143\u7ec4\u6309\u7b2c\u4e00\u7ef4\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u3002\u5982\u679c\u6ee1\u8db3\uff1a !vis[h[i].n] && h[i].d<dis[h[i].n][0] ,\u5c31\u5c06\u519b\u961f\u9a7b\u624e\u5728$h[i].n$. \uff08\u8fd9\u4e2a\u8d2a\u5fc3\u540e\u9762\u4f1a\u8bf4\u660e\uff09 \u6700\u540e\uff0c\u5c06\u90a3\u4e9b\u4ecd\u7136\u9700\u8981\u9a7b\u624e\u7684\u5b50\u8282\u70b9\u62ff\u51fa\u6765\uff0c\u6309\u7167\u5230\u6839\u7684\u8ddd\u79bb\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u4e0e\u7a7a\u95f2\u519b\u961f\u5339\u914d(\u53cc\u6307\u9488)\u3002\u8fd9\u91cc\u4e5f\u7528\u5230\u4e86\u5f88\u663e\u7136\u7684\u8d2a\u5fc3\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<queue> #define int long long using namespace std; const int N=1e5+10,K=21,INF=1e15; struct edge{ int v,w,nxt; }e[N<<1]; struct node{ int d,n; node(int dd=0,int nn=0){ d=dd,n=nn; } }h[N],s[N]; int n,m,u,v,w,cnt; int head[N],fa[N][K],dis[N][K],vis[N],t[N],a[N]; void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void dfs(int u,int p){ for(int i=1;i<K;++i) fa[u][i]=fa[fa[u][i-1]][i-1],dis[u][i]=dis[u][i-1]+dis[fa[u][i-1]][i-1]; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p) continue; fa[v][0]=u,dis[v][0]=w; dfs(v,u); } } bool _dfs(int u,int p){ if(vis[u]) return 1; int o=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; if(!_dfs(v,u)) return 0; o=1; } if(!o) return 0; return 1; } bool cmp(node a,node b){ if(a.d==b.d) return a.n<b.n; return a.d<b.d; } bool Cmp(int a,int b){ return a<b; } bool _cmp(int a,int b){ return dis[a][0]<dis[b][0]; } bool check(int x){ memset(vis,0,sizeof vis); memset(h,0,sizeof h); memset(s,0,sizeof s); memset(t,0,sizeof t); int tot=0,top=0,cur=0,atot=0,btot=0; for(int i=1;i<=m;++i){ int u=a[i],tmp=0; for(int j=K-1;j>=0;--j) if(fa[u][j]>1 && tmp+dis[u][j]<=x) tmp+=dis[u][j],u=fa[u][j]; if(fa[u][0]==1 && tmp+dis[u][0]<=x){ h[++tot]=node(x-tmp-dis[u][0],u); }else vis[u]=1; } for(int i=head[1];~i;i=e[i].nxt){ int v=e[i].v; vis[v]=_dfs(v,1); } sort(h+1,h+tot+1,cmp); for(int i=1;i<=tot;++i){ if(!vis[h[i].n] && h[i].d<dis[h[i].n][0]) vis[h[i].n]=1; else s[++top]=h[i]; } for(int i=head[1];~i;i=e[i].nxt){ int v=e[i].v; if(!vis[v]) t[++cur]=v; } sort(s+1,s+top+1,cmp); sort(t+1,t+cur+1,_cmp); int l=1; for(int i=1;i<=cur;++i){ while(l<=top && s[l].d<dis[t[i]][0]) ++l; if(l<=top) vis[t[i]]=1,++l; else return 0; } return 1; } signed main(){ //freopen(\"P1084_2.in\",\"r\",stdin); memset(head,-1,sizeof head),cnt=-1; scanf(\"%lld\",&n); for(int i=1;i<n;++i) scanf(\"%lld%lld%lld\",&u,&v,&w),add(u,v,w),add(v,u,w); dfs(1,0); scanf(\"%lld\",&m); for(int i=1;i<=m;++i) scanf(\"%lld\",&a[i]); int l=0,r=INF,ans=-1; while(l<=r){ int mid=l+r>>1; if(check(mid)) ans=mid,r=mid-1; else l=mid+1; } printf(\"%lld\",ans); return 0; } /* 10 2 1 3 2 3 4 1 4 7 5 1 9 6 1 2 4 7 9 7 8 8 9 8 8 1 10 2 5 2 8 5 4 2 */ \u4e0b\u9762\u8bf4\u8bf4\u5751\u70b9\uff1a \u6811\u4e0a\u500d\u589e \u6811\u4e0a\u500d\u589e\u4e00\u5b9a\u8981\u5728\u9012\u5f52\u5230\u4e0b\u4e00\u5c42\u524d\u5c31\u9012\u63a8\u51fa\u8fd9\u4e00\u5c42\u5f97$dis[u][j],fa[u][j]$,\u4e0d\u7136\uff0c\u76f8\u5f53\u4e8e\u9012\u5f52\u5230\u5e95\uff0c\u524d\u9762\u7684$dis[u][j]$\u8fd8\u90fd\u662f\u7a7a\u7684\uff0c\u5c31\u4f1a\u51fa\u9519\u4e86 \u8d2a\u5fc3\u90e8\u5206 \u5148\u8003\u8651\u4e00\u4e2a\u53cd\u4f8b\uff1a \u8fd9\u91cc\u5c31\u4e0d\u7528\u4e8c\u5143\u7ec4\u8868\u793a\u4e86\uff0c\u76f4\u63a5\u5c55\u793a\u539f\u59cb\u72b6\u6001\uff0c\u7ea2\u8272\u8868\u793a\u5269\u4f59\u65f6\u95f4\uff0c\u84dd\u8272\u8868\u793a\u8fb9\u6743\u3002 \u53ef\u4ee5\u53d1\u73b0\uff0c\u5982\u679c\u8ba9$9$\u9a7b\u624e\u5728$2$\u53f7\u8282\u70b9\uff0c\u6700\u7ec8\u5c31\u53ea\u80fd\u9a7b\u624e$3$\u4e2a\uff0c\u800c\u6b63\u786e\u7b54\u6848\u4e3a$4$. \u7136\u540e\u5c1d\u8bd5~~\u8bc1\u660e~~\u8bf4\u660e\u4e00\u4e0b\u539f\u7406\u3002 \u56e0\u4e3a\u519b\u961f$i$\u6ee1\u8db3 h[i].d<dis[h[i].n][0] ,\u90a3\u8fd9\u4e2a\u519b\u961f\u65e0\u6cd5\u518d\u56de\u5230\u5b83\u6240\u5c5e\u7684\u5b50\u8282\u70b9\uff0c\u6240\u4ee5\u8be5\u5b50\u8282\u70b9\u4e00\u5b9a\u7531\u53e6\u4e00\u4e2a \u5269\u4f59\u65f6\u95f4\u5927\u4e8e\u5b83 \u7684\u519b\u961f$j$\u63a7\u5236\u3002\u800c\u663e\u7136$j$\u53ef\u4ee5\u5230\u8fbe\u7684\u8282\u70b9\u6570\u591a\u4e8e$i$\uff0c\u6240\u4ee5\u76f4\u63a5\u8ba9$i$\u7ba1\u63a7\u8fd9\u4e2a\u5b50\u8282\u70b9\u66f4\u4f18\u3002 \u800c\u5982\u679c$i$\u4e0d\u6ee1\u8db3\uff0c\u8bf4\u660e\u5b83\u80fd\u56de\u53bb\uff0c\u90a3\u5c31\u5c06\u4ed6\u52a0\u5165\u6700\u540e\u7684\u6570\u7ec4\u4e0e\u540e\u9762\u7684\u519b\u961f\u4e00\u8d77\u8003\u8651\u3002\u867d\u7136\u8ba9\u4ed6\u6298\u8fd4\u4f1a\u6d6a\u8d39\u65f6\u95f4\uff0c\u4f46\u662f \u7ed3\u679c\u4e0d\u4f1a\u66f4\u5dee \uff0c\u8fd9\u6837\u7b80\u5316\u4e86\u51b3\u7b56\u590d\u6742\u5ea6\u3002 P3233 ~~\u5173\u4e8e\u865a\u6811\u6a21\u677f\u5199\u5047\u4e86\u8c03\u4e86\u4e00\u4e0a\u5348\u8fd9\u4ef6\u4e8b~~ \u8fd9\u9053\u9898\u53ca\u5176~~\u6076\u5fc3~~\u590d\u6742,\u9700\u8981$6$\u6b21$dfs$\u3002 \u9884\u5904\u7406$lca,dep,size$ \u500d\u589e\u5904\u7406$fa$\uff0c\u56e0\u4e3a\u540e\u9762\u9664\u4e86\u6c42$lca$\u8fd8\u4f1a\u7528\u5230\u3002 \u6c42\u51fa\u865a\u6811\u4e2d\u6bcf\u4e2a\u865a\u6811\u8282\u70b9\u5b50\u6811\u4e2d\u8ddd\u79bb\u6b64\u8282\u70b9\u6700\u8fd1\u7684\"\u5173\u952e\u8282\u70b9\" \u6240\u6709\u5173\u952e\u8282\u70b9\u90fd\u5728\u865a\u6811\u4e0a\uff0c\u6240\u4ee5\u7b2c\u4e00\u904d\u4ece\u4e0b\u800c\u4e0a$dfs$\uff0c\u53ef\u4ee5\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u5728\u5b83\u5b50\u6811\u4e2d\u8ddd\u79bb\u5b83\u6700\u8fd1\u7684\u5173\u952e\u8282\u70b9(\u53ef\u4ee5\u662f\u81ea\u5df1)\u3002 \u6c42\u51fa\u865a\u6811\u4e2d\u8ddd\u79bb\u6bcf\u4e2a\u865a\u6811\u8282\u70b9\u6700\u8fd1\u7684\"\u5173\u952e\u8282\u70b9\" \u7b2c\u4e8c\u904d\u4ece\u4e0a\u800c\u4e0b\u6c42\u51fa\u5b50\u6811\u5916\u8d21\u732e\u3002 \u6ce8\u610f\uff0c\u6211\u4eec\u7ef4\u62a4\u7684\u662f\u4e00\u4e2a\u4e8c\u5143\u7ec4$g[u]$\uff0c\u7b2c\u4e00\u5173\u952e\u5b57\u4e3a\u8ddd\u79bb\uff0c\u7b2c\u4e8c\u5173\u952e\u5b57\u4e3a\u7f16\u53f7\u3002 \u6c42\u51fa\u865a\u6811\u4e0a\u6bcf\u4e2a\u8282\u70b9\u8ddd\u79bb\u6700\u8fd1\u7684\u70b9\u7f16\u53f7\uff0c\u4ee5\u53ca\u8282\u70b9\u4e0a\u7684\u8d21\u732e\u3002 \u6700\u8fd1\u8282\u70b9\u5c31\u662f$num[u]=g[u].second$,\u800c\u8282\u70b9\u4e0a\u7684\u8d21\u732e\u662f\u6307\uff1a\u5bf9\u4e8e\u865a\u6811\u8282\u70b9$u$\uff0c\u5176\u6240\u6709 \u6ca1\u6709\u5173\u952e\u70b9 \u7684\u5b50\u6811\uff0c\u90fd\u5c06\u5f52$num[u]$\u7ba1\u7406\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u904d\u5386\u865a\u6811\u65f6\uff0c\u53ef\u4ee5\u7528$u$\u6240\u5728\u7684\u5b50\u6811\u603b\u7ed3\u70b9\u6570\u51cf\u53bb\u6709\u5173\u952e\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u3002 \u6709\u5173\u952e\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u9700\u8981\u5728\u539f\u6811\u4e0a\u500d\u589e\u6c42\u51fa\u5bf9\u4e8e$v$\u6240\u5728\u5b50\u6811\u7684\u6839$up[v]$\uff0c\u8fd9\u65f6$up[v]$\u5728$u$\u4e0b\u9762\uff0c\u51cf\u6389$sz[up[v]]$\u5373\u53ef\u3002 \u6c42\u51fa\u865a\u6811\u4e0a\u6bcf\u6761\u8fb9\u7684\u8d21\u732e \u5bf9\u4e8e\u6bcf\u6761\u8fb9\u4e24\u7aef\u70b9$u,v$\uff0c\u6709\u4e24\u79cd\u60c5\u51b5\uff1a \u4e00\u662f$num[u]=num[v]$,\u8fd9\u79cd\u60c5\u51b5\u8fd9\u6761\u8fb9\u4e0a\u6240\u6709\u8282\u70b9\u90fd\u5f52$num[u]$\u7ba1\u5373\u53ef\u3002 \u4e8c\u662f$num[u]\\not =num[v]$,\u8fd9\u79cd\u60c5\u51b5\u5148\u6c42\u51fa\u4e2d\u95f4\u70b9\u7684\u6df1\u5ea6\uff0c\u518d\u4ece$v$\u500d\u589e\u627e\u51fa\u4e2d\u95f4\u70b9\u6807\u53f7\u5373\u53ef\u3002 \u5177\u4f53\u5730\uff0c\u4ece$num[u]$\u5230$num[v]$\u7684\u94fe\u957f\u5ea6$L$=$dep[num[v]]-dep[u]+g[u].first$. \u90a3\u4e48\u4e2d\u95f4\u70b9\u7684\u6df1\u5ea6=$\\frac{dep[num[v]]-L} 2$. \u6e05\u7a7a\u865a\u6811\u53ca\u70b9\u6807\u8bb0 \u9700\u8981\u6e05\u7a7a$vis[i],ans[i],up[i],num[i]$. \u81f3\u6b64\uff0c\u8fd9\u9053\u9898\u624d\u7b97\u505a\u5b8c\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<utility> using namespace std; typedef pair<int,int> PI; const int N=3e5+10,K=20,INF=0x3f3f3f3f; int fa[N][K],dep[N],head[2][N],vis[N],a[N],b[N],sz[N],stk[N],ans[N],id[N],num[N],up[N]; int n,q,u,v,cnt[2],tmp,m,top,tot,rt; PI g[N]; struct edge { int v,nxt; } e[2][N<<1]; void add(int u,int v,int i) { e[i][++cnt[i]].v=v,e[i][cnt[i]].nxt=head[i][u],head[i][u]=cnt[i]; } bool cmp(int a,int b) { return id[a]<id[b]; } int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x){ if(x>9) write1(x/10); putchar(x%10+'0'); } void dfs0(int u,int p) { id[u]=++tot;fa[u][0]=p;sz[u]=1; for(int i=1; i<K; ++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[0][u]; ~i; i=e[0][i].nxt) { int v=e[0][i].v; if(v==p) continue; dep[v]=dep[u]+1; dfs0(v,u); sz[u]+=sz[v]; } } void dfs1(int u,int p) { if(vis[u]) g[u]=make_pair(0,u); else g[u]=make_pair(INF,0); for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs1(v,u); g[u]=min(g[u],make_pair(g[v].first+dep[v]-dep[u],g[v].second)); } } void dfs2(int u,int p,int d,int x) { PI tmp=make_pair(d,x); if(tmp<g[u]) g[u]=tmp; else d=g[u].first,x=g[u].second; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs2(v,u,d+dep[v]-dep[u],x); } } void dfs3(int u,int p) { num[u]=g[u].second; ans[num[u]]+=sz[u]; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; int k=v; for(int j=K-1;j>=0;--j) if(fa[k][j] && dep[fa[k][j]]>dep[u]) k=fa[k][j]; ans[num[u]]-=sz[up[v]=k]; dfs3(v,u); } } void dfs4(int u,int p){ for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; if(num[v]==num[u]) ans[num[u]]+=(sz[up[v]]-sz[v]); else{ int dis=dep[num[v]]+dep[u]-g[u].first; dis=dis&1?dis+1>>1:(num[v]<num[u]?dis>>1:(dis>>1)+1); int k=v; for(int j=K-1;j>=0;--j) if(fa[k][j] && dep[fa[k][j]]>=dis) k=fa[k][j]; ans[num[u]]+=sz[up[v]]-sz[k]; ans[num[v]]+=sz[k]-sz[v]; } dfs4(v,u); } } void dfs5(int u,int p){//clear up[u]=num[u]=0; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs5(v,u); } head[1][u]=-1; } int getlca(int u,int v) { if(dep[u]<dep[v]) swap(u,v); int k=dep[u]-dep[v]; for(int i=K-1; i>=0; --i) if(k&(1<<i)) u=fa[u][i]; if(v==u) return u; for(int i=K-1; i>=0; --i) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0]; } void insert(int u) { int lca=getlca(u,stk[top]); while(top>1 && id[stk[top-1]]>=id[lca]) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top; if(lca!=stk[top]) add(stk[top],lca,1),add(lca,stk[top],1),stk[top]=lca; stk[++top]=u; } void build() { cnt[1]=-1; sort(a+1,a+m+1,cmp); stk[top=1]=a[1]; for(int i=2; i<=m; ++i) insert(a[i]); while(top>1) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top; rt=stk[1]; } int main() { memset(head,-1,sizeof head); cnt[0]=-1; scanf(\"%d\",&n); for(int i=1; i<n; ++i) scanf(\"%d%d\",&u,&v),add(u,v,0),add(v,u,0); dfs0(1,0); scanf(\"%d\",&q); for(int i=1; i<=q; ++i) { scanf(\"%d\",&m); for(int j=1; j<=m; ++j) scanf(\"%d\",&a[j]),b[j]=a[j],vis[b[j]]=1; build(); dfs1(rt,0); dfs2(rt,0,g[rt].first,g[rt].second); dfs3(rt,0); dfs4(rt,0); ans[num[rt]]+=sz[1]-sz[rt]; for(int j=1; j<=m; ++j) printf(\"%d \",ans[b[j]]),ans[b[j]]=vis[b[j]]=0;printf(\"\\n\"); dfs5(rt,0); } return 0; } P7518 ~~\u505a\u4e86\u6574\u6574\u4e24\u5929\u624d\u8fc7\u7684\u6076\u5fc3\u9898~~ ~~100\u7d2b\u9898\u796d\uff01~~ ~~\u601d\u8def\u5f88\u7b80\u5355\uff0c\u4ee3\u7801100\u884c\uff0c\u4f46\u7ec6\u8282\u771f\u7684\u591a~~ \u9996\u5148\u53ef\u4ee5\u5c06\u8def\u5f84$s\\to t$\u62c6\u5206\u4e3a\u4e0a\u884c$s\\to lca$\u548c\u4e0b\u884c$lca\\to t$ \u5bf9\u4e8e\u6bcf\u4e2a\u6811\u4e0a\u7684\u8282\u70b9\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u901a\u8fc7\u500d\u589e\u6765\u6c42\u51fa$f[u][j]$\uff0c\u8868\u793a\u5b83\u7ecf\u8fc7\u539f\u5e8f\u5217$2^j$\u4e2a\u5b9d\u77f3\u540e\u5411\u4e0a\u8df3\u5230\u4e86\u54ea\u4e2a\u8282\u70b9\u3002 \u6bcf\u6b21\u4e8c\u5206\u627e\u5230\u4e0a\u884c\u8def\u5f84\u4e2d\u7684\u7b2c\u4e00\u4e2a\u4e8e\u539f\u5e8f\u5217\u5bf9\u5e94\u7684\u8282\u70b9(\u8d77\u70b9)\uff0c\u4ece\u5b83\u5f00\u59cb\u500d\u589e\uff0c\u4fbf\u53ef\u4ee5\u89e3\u51b3\u4e0a\u884c\u7684\u60c5\u51b5\u3002\u4e0b\u884c\u4e5f\u540c\u7406\u3002 \u63a5\u4e0b\u6765\u5c31\u662f\u4e00\u5806\u7ec6\u8282\u4e86\u3002 \u6c42\u89e3$f[u][j]$. \u6211\u4eec\u53d1\u73b0\uff0c\u53ea\u8981\u6709\u4e86$f[u][0]$,\u5269\u4f59\u5c31\u53ef\u4ee5\u9012\u63a8\u89e3\u51b3\u3002 \u800c$f[u][0]$\u53ef\u4ee5\u7528$c$\u4e2a\u6808$h$\u7ef4\u62a4\u4e00\u4e0b\uff0c\u5373\u5bf9\u4e8e\u6bcf\u4e2a\u5b9d\u77f3\u5f00\u4e00\u4e2a\u6808\u3002 \u800c\u56e0\u4e3a\u6211\u4eec\u8981\u77e5\u9053\u6bcf\u4e2a\u5b9d\u77f3\u4e0b\u4e00\u4e2a\u5b9d\u77f3\u7684\u7f16\u53f7\uff0c\u6240\u4ee5\u53ef\u4ee5\u63d0\u524d\u6c42\u4e00\u4e2a$nxt[i]$\u8868\u793a\u5b9d\u77f3$i$\u7684\u4e0b\u4e00\u4e2a\uff0c\u4e5f\u53ef\u4ee5\u6c42\u51fa$rk[i]$,\u8868\u793a\u5b9d\u77f3$i$\u7684\u76f8\u5bf9\u6392\u540d\u3002 $dfs$\u6bcf\u7ecf\u8fc7\u4e00\u4e2a\u8282\u70b9\uff0c\u5c31\u5c06\u8fd9\u4e2a\u8282\u70b9\u7684\u7f16\u53f7\u52a0\u5165$rk[a[u]]$\u8fd9\u4e2a\u6808\u91cc\u3002(\u6808\u7684\u4e0b\u6807\u4e3a\u5b9d\u77f3\u76f8\u5bf9\u6392\u540d\u3002) \u6bcf\u6b21\u5bf9\u4e8e\u8282\u70b9$u$\uff0c\u8bbf\u95ee$h[rk[a[u]]+1]$\u7684\u6808\u9876(\u6ce8\u610f\u7279\u5224\u6808\u4e3a\u7a7a\uff0c\u4e0d\u7136\u4f1a$RE$)\uff0c\u5c31\u662f\u6df1\u5ea6\u6700\u6df1\u7684$f[u][0]$\u4e86\u3002 \u4e8c\u5206\u8d77\u70b9 \u4e8c\u5206\u4e00\u5b9a\u8981\u5229\u7528\u5355\u8c03\u6027\uff0c\u7136\u800c\u53ea\u770b\u5b9d\u77f3\u79cd\u7c7b\u65e0\u6cd5\u5f97\u51fa\u5355\u8c03\u6027\u3002 \u6240\u4ee5\u6211\u4eec\u8981\u7528\u5230$dfs$\u5e8f\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u5b9d\u77f3$i$\uff0c\u6c42\u51fa\u5b83\u5728\u90a3\u4e9b$dfs$\u5e8f\u5bf9\u5e94\u7684\u8282\u70b9\u51fa\u73b0\u8fc7\uff0c\u8bb0\u4e3a$d[i]$\u3002$dfs$\u5e8f\u4ece\u5c0f\u5230\u5927\u3002 \u90a3\u4e48\uff0c\u6211\u4e48\u5c31\u53ef\u4ee5\u6839\u636e$dfs$\u5e8f\u7684\u6027\u8d28\uff0c\u7528\u6811\u5256\u5c06\u6811\u5206\u6210\u51e0\u6761\u91cd\u94fe\u3002\u91cd\u94fe\u4e0a$dfs$\u5e8f\u8fde\u7eed\uff0c\u6240\u4ee5\u53ef\u4ee5\u5728$d[i]$\u4e2d\u4e8c\u5206\u6700\u540e\u4e00\u4e2a$\\leq$\u6811\u94fe\u4e0b\u7aef\u70b9$dfs$\u5e8f\u7684$dfs$\u5e8f\u503c$tmp$\u3002\u5982\u679c$tmp$\u5728$id[top[t]],id[t]$\u4e4b\u95f4\uff0c\u5c31\u8bf4\u660e\u627e\u5230\u4e86\uff0c\u5426\u5219\u7ee7\u7eed\u5411\u4e0a\u627e\u3002 \u590d\u6742\u5ea6$O(\\log^2n)$,\u4e00\u5171$O(\\log n)$\u6761\u94fe\u3002 \u500d\u589e \u5982\u679c\u627e\u5230\u8d77\u70b9\u518d\u8fdb\u884c\u500d\u589e\uff0c\u4e0d\u7136\u500d\u589e\u5c31\u6ca1\u610f\u4e49\u4e86\u3002 \u4e0b\u884c ~~\u300a\u4e0b\u884c\u4e5f\u540c\u7406\u300b\uff0c\u5f53\u65f6\u6211\u662f\u8fd9\u4e48\u60f3\u7684~~ \u9996\u5148\uff0c\u6211\u4eec\u6ce8\u610f\u5230\u4e00\u4e2a\u4e8b\uff1a\u500d\u589e\u6570\u7ec4\u53ea\u80fd\u5411\u4e0a\uff0c\u4e0d\u80fd\u5411\u4e0b\uff0c\u56e0\u4e3a\u4e00\u4e2a\u7236\u4eb2\u5bf9\u5e94\u591a\u4e2a\u513f\u5b50\u3002 \u6240\u4ee5\u8fd9\u91cc\u6211\u4eec\u4ecd\u7136\u8981\u6c42\u4e00\u4e2a\u5411\u4e0a\u7684\u500d\u589e\u6570\u7ec4$g[u][j]$,\u53ea\u4e0d\u8fc7\u8981\u6c42$h[rk[a[u]-1]$,\u9006\u7740\u5411\u4e0a\u5373\u987a\u7740\u5411\u4e0b\u3002 \u6c42\u51fa\u8fd9\u4e2a\u540e\u53d1\u73b0\uff0c\u6211\u4eec\u9700\u8981\u77e5\u9053\u6700\u7ec8\u7b54\u6848\u624d\u80fd\u4ece$t$\u5f00\u59cb\u4e8c\u5206\u8d77\u70b9+\u500d\u589e\uff0c\u4e0d\u7136\u8d77\u70b9\u4e0d\u786e\u5b9a\uff0c\u6ca1\u6cd5\u500d\u589e\u3002 \u8fd8\u597d\u8fd9\u4e2a\u7b54\u6848\u5177\u6709\u5355\u8c03\u6027\uff0c\u5373\u5982\u679c\u8f83\u5927\u7684\u7b54\u6848\u5df2\u7ecf\u6ee1\u8db3\uff0c\u90a3\u4e48\u8f83\u5c0f\u7684\u7b54\u6848\u4e00\u5b9a\u6ee1\u8db3\u3002(\u76f8\u5f53\u4e8e\u6c42\u51fa\u7684\u5e8f\u5217\u548c\u524d\u9762\u5e8f\u5217\u53ef\u4ee5\u6709\u91cd\u5408\uff0c\u4f46\u4e0d\u80fd\u6709\u7a7a\u9699\u3002) \u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u4e8c\u5206\u4e00\u4e2a\u6700\u7ec8\u7b54\u6848\uff0c\u7136\u540e\u4ece\u627e\u5230\u7684\u8d77\u70b9\u5411\u4e0a\u500d\u589e\uff0c\u6ce8\u610f\u8981\u51cf\u6389\u6240\u6709\u8d21\u732e\uff0c\u4e4b\u540e\u5224\u65ad\u4e00\u4e0b\u4e24\u6bb5\u662f\u5426\u6709\u91cd\u53e0\u5373\u53ef\u3002(\u8fd9\u91cc\u7684\u4e24\u6bb5\u5c31\u662f\u505a\u591a\u5411\u524d/\u5411\u540e\u500d\u589e\u4e86\u591a\u5c11\u4e2a\u5b9d\u77f3\u3002) \u5e76\u4e14\uff0c\u8fd9\u4e2a\u4e8c\u5206\u8981\u5224\u65ad\u5982\u679c$mid$\u5c0f\u4e8e\u4e0a\u884c\u7684\u7b54\u6848\uff0c\u90a3\u4e48\u660e\u663e\u6210\u7acb\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u89e3\u51b3\u4e86\u8fd9\u9053\u9898\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<vector> #include<stack> using namespace std; const int N=2e5+10,M=5e4+10,K=23; int b[N],a[N],head[N],sz[N],top[N],son[N],fa[N],dep[N],id[N],dfn[N],f[N][K],g[N][K],rk[N]; int n,m,c,q,cnt,tot,u,v,lca,num; vector<int> d[N]; stack<int> h[N]; struct edge{ int v,nxt; }e[N<<1]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x){ if(x>9) write1(x/10); putchar(x%10+'0'); } void dfs1(int u,int p){ sz[u]=1; h[rk[a[u]]].push(u); f[u][0]=h[rk[a[u]]+1].empty()?0:h[rk[a[u]]+1].top(),g[u][0]=h[rk[a[u]]-1].empty()?0:h[rk[a[u]]-1].top(); for(int i=1;i<K;++i) f[u][i]=f[f[u][i-1]][i-1],g[u][i]=g[g[u][i-1]][i-1]; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; fa[v]=u,dep[v]=dep[u]+1; dfs1(v,u); sz[u]+=sz[v]; if(sz[son[u]]<sz[v]) son[u]=v; } h[rk[a[u]]].pop(); } void dfs2(int u,int t){ top[u]=t,id[u]=++tot,dfn[tot]=u; if(son[u]) dfs2(son[u],t); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==fa[u] || v==son[u]) continue; dfs2(v,v); } } int getlca(int u,int v){ while(top[u]!=top[v]){ if(dep[top[u]]<dep[top[v]]) swap(v,u); u=fa[top[u]]; } return dep[u]<dep[v]?u:v; } void Get(int &u,int &now,int x,int t){ u=0,now=0; while(id[t]>=id[lca]){ int idx=upper_bound(d[b[x]].begin(),d[b[x]].end(),id[t])-d[b[x]].begin()-1; if(idx>=0 && d[b[x]][idx]>=max(id[lca],id[top[t]])) { u=dfn[d[b[x]][idx]];now=x; break; } t=fa[top[t]]; } } bool check(int ans,int x,int t){ if(x<ans) return true; int u=0,now=0; Get(u,now,x,t); if(!now) return false; for(int j=K-1;j>=0;--j) if(g[u][j] && id[g[u][j]]>id[lca]) u=g[u][j],now-=(1<<j); return now<=ans; } void work(int s,int t){ lca=getlca(s,t);int u=0,now=0; Get(u,now,1,s); if(now) for(int j=K-1;j>=0;--j) if(f[u][j] && id[f[u][j]]>=id[lca]) u=f[u][j],now+=(1<<j); int l=1,r=c,ans=0; while(l<=r){ int mid=l+r>>1; if(check(now+1,mid,t)) ans=mid,l=mid+1; else r=mid-1; } write1(ans),putchar('\\n'); } int main(){ memset(head,-1,sizeof head),cnt=-1; n=read1(),m=read1(),c=read1(); for(int i=1;i<=c;++i) b[i]=read1(); for(int i=1;i<=n;++i) a[i]=read1(); for(int i=1;i<=c;++i) rk[b[i]]=i; for(int i=1;i<n;++i) u=read1(),v=read1(),add(u,v),add(v,u); dfs1(1,0); dfs2(1,1); for(int i=1;i<=tot;++i) d[a[dfn[i]]].push_back(i); q=read1(); for(int i=1;i<=q;++i) u=read1(),v=read1(),work(u,v); return 0; } P2597 \u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u4f1a\u706d\u7edd\uff0c\u5f53\u4e14\u4ec5\u5f53\u5b83\u7684\u6240\u6709\u98df\u7269\u90fd\u706d\u7edd\u4e86\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u8fd9\u4e9b\u98df\u7269\u7684\u5171\u540clca\u4e00\u5b9a\u706d\u7edd\u3002\u6240\u4ee5\u53ef\u4ee5\u5728\u62d3\u6251\u6392\u5e8f\u8fc7\u7a0b\u4e2d\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u7ef4\u62a4\u4e00\u4e2a$dad$\u6570\u7ec4\uff0c\u5b58\u6240\u6709\u98df\u7269\u7684\u5171\u540clca\u3002\u6c42\u51fa\u6570\u7ec4\u540e\uff0c\u5c06$dad[i]$\u4e0ei\u8fde\u8fb9\uff0c\u6784\u6210\u65b0\u7684\u706d\u7edd\u6811\u3002\u7b54\u6848\u4e3a$sz[u]-1$\u3002\u5728\u6bcf\u6b21\u62d3\u6251\u65f6\uff0c\u7531\u4e8e\u62d3\u6251\u5e8f\u51b3\u5b9a\u5f53\u524d\u70b9\u4e4b\u524d\u6240\u6709\u70b9\u5df2\u7ecf\u641c\u7d22\u8fc7\uff0c\u6240\u4ee5\u5b83\u5728\u65b0\u7684\u706d\u7edd\u6811\u7684\u500d\u589e\u6570\u7ec4\u53ef\u4ee5\u552f\u4e00\u786e\u5b9a\u3002\u6240\u4ee5\u76f4\u63a5\u66f4\u65b0\u500d\u589e\u6570\u7ec4\u3002$dad$\u9ed8\u8ba4\u4e3a-1\u3002\u904d\u5386$u$\u7684\u98df\u7269$v$,\u82e5\u5f53\u524d\u70b9$dad$\u5df2\u7ecf\u6709\u503c\uff0c\u5219\u66f4\u65b0$dad[i]=lca(dad[i],v)$\u3002 #include<iostream> #include<cstring> #include<vector> #include<queue> using namespace std; const int N=1e5+10,M=2e5+10,K=20; struct edge{ int v,nxt; }e[M<<1]; int head[N],dad[N],ind[N],dep[N],fa[N][K],sz[N]; int cnt,n,u; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } vector<int> g[N]; queue<int> q; int getlca(int u,int v){ if(u==v) return u; if(dep[u]<dep[v]) swap(u,v); int k=dep[u]-dep[v]; for(int i=0;i<K;++i){ if((k>>i)&1) u=fa[u][i]; } if(u==v) return u; for(int i=K-1;i>=0;--i){ if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; } return fa[u][0]; } void dfs(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; dfs(v,u); sz[u]+=sz[v]; } } int main(){ memset(head,-1,sizeof head); memset(dad,-1,sizeof dad); cnt=-1; scanf(\"%d\",&n); for(int v=1;v<=n;++v){ while(1){ scanf(\"%d\",&u); if(u==0) break; ++ind[v]; g[u].push_back(v); } } for(int i=1;i<=n;++i){ if(!ind[i]){ q.push(i); dad[i]=0; } } while(!q.empty()){ int u=q.front();q.pop(); add(u,dad[u]),add(dad[u],u); fa[u][0]=dad[u],dep[u]=dep[dad[u]]+1; for(int i=1;i<K;++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=0;i<g[u].size();++i){ int v=g[u][i]; if(dad[v]==-1){ dad[v]=u; }else{ dad[v]=getlca(u,dad[v]); } if(!(--ind[v])){ q.push(v); } } } dfs(0,0); for(int i=1;i<=n;++i){ printf(\"%d\\n\",sz[i]-1); } return 0; }","title":"\u6811\u4e0a\u500d\u589e"},{"location":"my%20past/OI/%E5%87%8F%E5%B0%91%E6%97%A0%E7%94%A8%E7%8A%B6%E6%80%81/","text":"\u51cf\u5c11\u65e0\u7528\u72b6\u6001 CF1766D \u7531\u4e8e\u6ee1\u8db3 x+k=a*d[i] \u7684\u6700\u5c0fk\u4e00\u5b9a\u6ee1\u8db3 x+k=a*t*d[j] ,\u5176\u4e2d d[j] \u4e3a\u8d28\u56e0\u5b50\uff0c d[i] \u4e3a\u56e0\u5b50 \u6240\u4ee5\u53ef\u4ee5\u53ea\u679a\u4e3e\u8d28\u56e0\u5b50\uff0c\u590d\u6742\u5ea6\u7531 $O(\\sqrt n)$ \u53d8\u4e3a $O(\\log n)$ CF1870E \u5b9a\u4e49\u597d\u7684MEX\u533a\u95f4\u4e3a\u6ee1\u8db3MEX\u4e3a\u67d0\u4e00\u4e2a\u503c$k$\u7684\u6700\u5c0f\u533a\u95f4\u3002\u8fd9\u6837\u7684\u533a\u95f4\u53ea\u6709 $O(n)$ \u4e2a\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u679a\u4e3e\u8fd9 $O(n)$ \u4e2a\u533a\u95f4\u5c31\u53ef\u4ee5\u3002","title":"\u51cf\u5c11\u65e0\u7528\u72b6\u6001"},{"location":"my%20past/OI/%E5%87%8F%E5%B0%91%E6%97%A0%E7%94%A8%E7%8A%B6%E6%80%81/#_1","text":"CF1766D \u7531\u4e8e\u6ee1\u8db3 x+k=a*d[i] \u7684\u6700\u5c0fk\u4e00\u5b9a\u6ee1\u8db3 x+k=a*t*d[j] ,\u5176\u4e2d d[j] \u4e3a\u8d28\u56e0\u5b50\uff0c d[i] \u4e3a\u56e0\u5b50 \u6240\u4ee5\u53ef\u4ee5\u53ea\u679a\u4e3e\u8d28\u56e0\u5b50\uff0c\u590d\u6742\u5ea6\u7531 $O(\\sqrt n)$ \u53d8\u4e3a $O(\\log n)$ CF1870E \u5b9a\u4e49\u597d\u7684MEX\u533a\u95f4\u4e3a\u6ee1\u8db3MEX\u4e3a\u67d0\u4e00\u4e2a\u503c$k$\u7684\u6700\u5c0f\u533a\u95f4\u3002\u8fd9\u6837\u7684\u533a\u95f4\u53ea\u6709 $O(n)$ \u4e2a\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u679a\u4e3e\u8fd9 $O(n)$ \u4e2a\u533a\u95f4\u5c31\u53ef\u4ee5\u3002","title":"\u51cf\u5c11\u65e0\u7528\u72b6\u6001"},{"location":"my%20past/OI/%E5%88%86%E6%B2%BB/","text":"\u5206\u6cbb P4755 \u4e00\u9053\u795e\u5947\u7684\u9898 \u672c\u6765\u60f3\u4e86\u4e2a$\\Theta(nlogn)$\u7684\u7b97\u6cd5\uff0c\u7ed3\u679c\u53ea\u5f97\u4e8620pts \u60f3\u6cd5\u662f\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u5355\u8c03\u9012\u589e\u7684\u5e8f\u5217\uff0c\u5bf9\u5185\u7684\u7b54\u6848\u8d21\u732e\u4e3a\u6240\u67091\u4e58\u4ee51\u540e\u9762\u7684\u90a3\u6bb5\u957f\u5ea6\uff1b\u5bf9\u5916\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4\uff0c\u6700\u5927\u503c\u6c38\u8fdc\u4e3a\u5e8f\u5217\u6700\u540e\u4e00\u4e2a\u6570 hack\uff1a 6 1 3 9 3 12 4 \u6ca1\u6709\u8003\u8651\u5230\u540e\u9762\u66f4\u5927\u7684\u6570\u5bf9\u7b54\u6848\u7684\u5f71\u54cd \u6b63\u89e3\uff1a \u542f\u53d1\u5f0f\u679a\u4e3e \u8003\u8651\u5206\u6cbb.\u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4[l,r],\u7528st\u8868$\\Theta(1)$\u627e\u51fa\u6700\u5927\u503c\u53ca\u5176\u4f4d\u7f6e\uff1b \u968f\u540e\u5206\u7c7b\u9012\u5f52(l,m),(m+1,r)\u6216(l,m-1),(m,r) \u6700\u540e\u7edf\u8ba1\u81ea\u5df1\u7684\u7b54\u6848. \u5bf9\u4e8e\u4e24\u6bb5\u5b50\u533a\u95f4\uff0c\u6c38\u8fdc\u542f\u53d1\u5f0f\u5730\u679a\u4e3e\u5c0f\u533a\u95f4\uff0c\u8fd9\u6837\u7684\u76ee\u7684\u662f\u5c06\u603b\u679a\u4e3e\u6b21\u6570\u5747\u644a\u4e3a$\\Theta(nlogn)$\uff0c\u52a0\u4e0a\u4e3b\u5e2d\u6811\u7684$\\Theta(logn)$\u5e94\u8be5\u4e3a$\\Theta(nlog^2n)$. \u6bcf\u6b21\u679a\u4e3e\u7684\u6811\u7684\u8d21\u732e\u4e3a\u5927\u533a\u95f4\u4e2d<=$\\frac {maxn}{a[i]}$\u7684\u6570\u7684\u4e2a\u6570\uff0c\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4. \u679a\u4e3e\u5c0f\u533a\u95f4\u7684\u6b63\u786e\u6027\uff1a \u56e0\u4e3a\u5927\u533a\u95f4\u6c38\u8fdc\u7528\u4e3b\u5e2d\u6811\uff0c\u6240\u4ee5\u590d\u6742\u5ea6\u4e3a$\\Theta(logn)$\uff1b\u5206\u6cbb\u5171\u6709$\\log n$\u5c42\uff0c\u6bcf\u5c42\u5c0f\u533a\u95f4\u52a0\u5728\u4e00\u8d77\u6700\u574f\u60c5\u51b5\u4e3a$\\frac{n}{2}$\u957f\u5ea6\uff0c\u56e0\u6b64\u603b\u590d\u6742\u5ea6\u4e3a$\\Theta(nlogn)$","title":"\u5206\u6cbb"},{"location":"my%20past/OI/%E5%88%86%E6%B2%BB/#_1","text":"P4755 \u4e00\u9053\u795e\u5947\u7684\u9898 \u672c\u6765\u60f3\u4e86\u4e2a$\\Theta(nlogn)$\u7684\u7b97\u6cd5\uff0c\u7ed3\u679c\u53ea\u5f97\u4e8620pts \u60f3\u6cd5\u662f\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u5355\u8c03\u9012\u589e\u7684\u5e8f\u5217\uff0c\u5bf9\u5185\u7684\u7b54\u6848\u8d21\u732e\u4e3a\u6240\u67091\u4e58\u4ee51\u540e\u9762\u7684\u90a3\u6bb5\u957f\u5ea6\uff1b\u5bf9\u5916\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4\uff0c\u6700\u5927\u503c\u6c38\u8fdc\u4e3a\u5e8f\u5217\u6700\u540e\u4e00\u4e2a\u6570 hack\uff1a 6 1 3 9 3 12 4 \u6ca1\u6709\u8003\u8651\u5230\u540e\u9762\u66f4\u5927\u7684\u6570\u5bf9\u7b54\u6848\u7684\u5f71\u54cd \u6b63\u89e3\uff1a","title":"\u5206\u6cbb"},{"location":"my%20past/OI/%E5%88%86%E6%B2%BB/#_2","text":"\u8003\u8651\u5206\u6cbb.\u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4[l,r],\u7528st\u8868$\\Theta(1)$\u627e\u51fa\u6700\u5927\u503c\u53ca\u5176\u4f4d\u7f6e\uff1b \u968f\u540e\u5206\u7c7b\u9012\u5f52(l,m),(m+1,r)\u6216(l,m-1),(m,r) \u6700\u540e\u7edf\u8ba1\u81ea\u5df1\u7684\u7b54\u6848. \u5bf9\u4e8e\u4e24\u6bb5\u5b50\u533a\u95f4\uff0c\u6c38\u8fdc\u542f\u53d1\u5f0f\u5730\u679a\u4e3e\u5c0f\u533a\u95f4\uff0c\u8fd9\u6837\u7684\u76ee\u7684\u662f\u5c06\u603b\u679a\u4e3e\u6b21\u6570\u5747\u644a\u4e3a$\\Theta(nlogn)$\uff0c\u52a0\u4e0a\u4e3b\u5e2d\u6811\u7684$\\Theta(logn)$\u5e94\u8be5\u4e3a$\\Theta(nlog^2n)$. \u6bcf\u6b21\u679a\u4e3e\u7684\u6811\u7684\u8d21\u732e\u4e3a\u5927\u533a\u95f4\u4e2d<=$\\frac {maxn}{a[i]}$\u7684\u6570\u7684\u4e2a\u6570\uff0c\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4. \u679a\u4e3e\u5c0f\u533a\u95f4\u7684\u6b63\u786e\u6027\uff1a \u56e0\u4e3a\u5927\u533a\u95f4\u6c38\u8fdc\u7528\u4e3b\u5e2d\u6811\uff0c\u6240\u4ee5\u590d\u6742\u5ea6\u4e3a$\\Theta(logn)$\uff1b\u5206\u6cbb\u5171\u6709$\\log n$\u5c42\uff0c\u6bcf\u5c42\u5c0f\u533a\u95f4\u52a0\u5728\u4e00\u8d77\u6700\u574f\u60c5\u51b5\u4e3a$\\frac{n}{2}$\u957f\u5ea6\uff0c\u56e0\u6b64\u603b\u590d\u6742\u5ea6\u4e3a$\\Theta(nlogn)$","title":"\u542f\u53d1\u5f0f\u679a\u4e3e"},{"location":"my%20past/OI/%E5%8C%BA%E9%97%B4dp/","text":"\u533a\u95f4dp\u603b\u7ed3 1) \u4ec0\u4e48\u60c5\u51b5\u8981\u679a\u4e3e\u65ad\u70b9\u5408\u5e76\u4e24\u4e2a\u533a\u95f4$f[l][k]+f[k+1][r]$\uff1f \u4e3a\u4e86\u8003\u8651\u533a\u95f4\u4e0e\u533a\u95f4\u5408\u5e76\u5bfc\u81f4\u7684\u65b0\u8d21\u732e\u7684\u52a0\u5165,\u56e0\u4e3a\u4e00\u6b65\u4e00\u6b65\u8f6c\u79fb\u4f1a\u6f0f\u6389\u7ec6\u8282\uff0c\u5177\u4f53\u6765\u8bf4\u5c31\u662f\u533a\u95f4\u7684\u7b54\u6848\u5408\u5e76\u540e\u4f1a\u6539\u53d8\uff0c\u53d8\u5c11\u6216\u53d8\u591a(P4170)\u3002 2) \u4ec0\u4e48\u65f6\u5019\u53ef\u4ee5\u4e0d\u7528/\u4e0d\u80fd\u679a\u4e3e\u65ad\u70b9\uff1f \u5f53\u533a\u95f4\u4e0d\u5177\u5907\u53ef\u5408\u5e76\u6027(P5044/CF360B)\u6216\u9898\u76ee\u660e\u786e\u8f6c\u79fb\u662f\u4e00\u6b65\u4e00\u6b65\u7684(P1005)\u6216\u679a\u4e0d\u679a\u4e3e\u65ad\u70b9\u65e0\u6240\u8c13\uff0c\u4f46\u4e00\u6b65\u4e00\u6b65\u8f6c\u79fb\u53ef\u4ee5\u51cf\u5c11\u72b6\u6001\u6570\u7684(P4767) 3) \u50cfP4158\u548cP4767\u8fd9\u79cd\u5e26\u6709\u6570\u91cf\u9650\u5236\u7684\u5e8f\u5217\u95ee\u9898\u5c31\u4e0d\u7b97\u533a\u95f4dp\u4e86\uff0c\u7b97\u7ebf\u6027dp. ~~\u603b\u4e4b\u5177\u4f53\u60c5\u51b5\u9760\u76f4\u89c9~~ \u7edf\u8ba1\u6700\u503c\u7c7b P1880 \u6a21\u677f\u9898 \u6ce8\u610f\u73af\u5f62\u9700\u8981\u5f002\u500d\u7a7a\u95f4 P1063 \u4e0eP1880\u5341\u5206\u7c7b\u4f3c\uff0c\u6ce8\u610f\u6bcf\u6b21\u589e\u52a0\u7684\u6570\u503c\u4e3a$a[b] a[k+1] a[e+1]$ \u8f6c\u79fb\u65b9\u7a0b\uff1a for(int l=1;l<=n+n;++l){ for(int b=1;b+l-1<=n+n;++b){ int e=b+l-1; for(int k=b;k<e;++k){ dp[b][e]=max(dp[b][e],dp[b][k]+dp[k+1][e]+a[b]*a[k+1]*a[(e+1)]); } } } P1220 \u6ce8\u610f\u5230\u7279\u6b8a\u6027\u8d28\uff1a \u6700\u4f73\u65b9\u6848\u4e00\u5b9a\u53d6\u5f97\u662f\u8fde\u7eed\u7684\u533a\u95f4\u3002 \u5047\u5982\u6709: 5 3 2 10 3 20 5 20 6 30 8 10 \u5f00\u59cb\u65f6\u60f3\u8981\u53d61\u53f7\u548c2\u53f7\uff0c\u90a3\u4e48\u5148\u53d61\u518d\u53d62\u80af\u5b9a\u6ca1\u6709\u5148\u53d62\u518d\u53d61\u597d\uff0c\u56e0\u4e3a\u53d61\u65f6\u7ecf\u8fc72\uff0c\u800c\u5173\u706f\u4e0d\u9700\u8981\u65f6\u95f4 \u56e0\u6b64\uff0c\u6240\u6709\u72b6\u6001\u90fd\u662f\u8fde\u7eed\u533a\u95f4\uff0c\u4fbf\u6709\u8f6c\u79fb\u65b9\u7a0b\uff1a for(int l=c;l>=1;--l){ for(int r=c;r<=n;++r){ dp[l][r][l]=min(dp[l][r][l],min(dp[l+1][r][l+1]+(a[l+1]-a[l])*(sum-x[r]+x[l]),dp[l+1][r][r]+(a[r]-a[l])*(sum-x[r]+x[l]))); dp[l][r][r]=min(dp[l][r][r],min(dp[l][r-1][l]+(a[r]-a[l])*(sum-x[r-1]+x[l-1]),dp[l][r-1][r-1]+(a[r]-a[r-1])*(sum-x[r-1]+x[l-1]))); } } P2466 \u4e0e\u4e0a\u9762\u7684\u76f8\u4f3c\uff0c\u6bcf\u6b21\u79fb\u52a8\u540e\u5c0f\u7403\u90fd\u4f1a\u4e0b\u843d\uff0c\u76f8\u5f53\u4e8e\u6d88\u8017\u4e86\u6700\u7ec8\u7684\u4ef7\u503c\uff0c\u6240\u4ee5\u6700\u5c0f\u5316\u8fd9\u4e2a\u6d88\u8017\u5373\u53ef\uff0c\u8f6c\u79fb\u65b9\u7a0b\u540c\u4e0a\u9762\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define int long long using namespace std; typedef double db; const int N=1e3+10; const db INF=1e16; db f[N][N][2],res,ans; struct node{ int x,y,v; }a[N]; int s[N],sum,n,x; bool cmp(node a,node b); void init(); void dp(); int Abs(int x); db Min(db a,db b); signed main(){ scanf(\"%lld%lld\",&n,&x); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i].x); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i].y); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i].v); init(); dp(); return 0; } bool cmp(node a,node b){ return a.x<b.x; } int Abs(int x){ return x>=0?x:-x; } db Min(db a,db b){ return a<=b?a:b; } void init(){ sort(a+1,a+n+1,cmp); for(int i=1;i<=n;++i) s[i]=s[i-1]+a[i].v,sum+=a[i].v; for(int i=1;i<=n;++i) res+=(db)(a[i].y)/1000.0; for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) f[i][j][0]=f[i][j][1]=INF; for(int i=1;i<=n;++i) f[i][i][0]=f[i][i][1]=(db)(Abs(x-a[i].x)*sum)/1000.0; } void dp(){ for(int l=2;l<=n;++l){ for(int b=1;b+l-1<=n;++b){ int e=b+l-1; f[b][e][0]=Min(f[b][e][0],Min(f[b+1][e][0]+(db)(Abs(a[b+1].x-a[b].x)*(sum-s[e]+s[b]))/1000.0,f[b+1][e][1]+(db)(Abs(a[e].x-a[b].x)*(sum-s[e]+s[b]))/1000.0)); f[b][e][1]=Min(f[b][e][1],Min(f[b][e-1][0]+(db)(Abs(a[e].x-a[b].x)*(sum-s[e-1]+s[b-1]))/1000.0,f[b][e-1][1]+(db)(Abs(a[e].x-a[e-1].x)*(sum-s[e-1]+s[b-1]))/1000.0)); } } ans=Min(f[1][n][0],f[1][n][1]); printf(\"%.3lf\",res-ans); } /* 3 3 -4 -2 2 22 30 26 1 9 8 */ P1650 \u8fd9\u9053\u9898\u4e00\u4e2a\u91cd\u8981\u7684\u6027\u8d28\u5c31\u662f\uff1a\u5bf9\u4e8e\u7530\u5fcc\u5168\u4e0d\u8f93\u7684\u51fa\u9a6c\u5e8f\u5217\uff0c\u4e00\u5b9a\u6ee1\u8db3\u4ece\u5927\u5230\u5c0f: $$A_1 \\geq A_2 \\geq... \\geq A_n\\ \u5047\u8bbe\u6709A_i<A_{i+1},\u4e14A_i\\geq B_i,A_{i+1}\\geq B_{i+1},B_i\\geq B_{i+1},\\\u90a3\u4e48\u5c31\u53ef\u4ee5\u4ea4\u6362A_i \u548cA_{i+1}\u3002 $$ \u540c\u6837\u80fd\u8bc1\u660e\u5bf9\u4e8e\u7530\u5fcc\u5168\u8f93\u7684\u5e8f\u5217\u6ee1\u8db3\u4ece\u5c0f\u5230\u5927\u3002 \u4e8e\u662f\uff0c\u4efb\u610f\u7684\u72b6\u6001\u90fd\u662f\u4eceA\u5e8f\u5217\u5934\u548c\u4e3a\u53bb\u9664\u4e00\u4e9b\u5143\u7d20\u540e\u5f62\u6210\u7684\u8fde\u7eed\u5e8f\u5217\u3002\u8fd9\u6837\u7684\u8bdd\uff0c\u533a\u95f4DP\u548c\u8d2a\u5fc3\u90fd\u53ef\u4ee5\u505a\u4e86\u3002 \u8bbef[i][j]\u8868\u793aA\u5e8f\u5217\u8fd8\u5269i\u5230j\u5339\u9a6c\u65f6\u7684\u6700\u4f18\u89e3\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=2010; int n; int a[N],b[N],f[N][N]; bool cmp(int a,int b){ return a>b; } int main(){ memset(f,-0x3f,sizeof f); scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=1;i<=n;++i)scanf(\"%d\",&b[i]); sort(a+1,a+n+1,cmp); sort(b+1,b+n+1,cmp); f[1][n]=0; for(int num=0,l=n-1;l>=1;--l){ num=n-l; for(int i=1,j=0;i+l-1<=n;++i){ j=i+l-1; int g1=a[i-1]>b[num]?200:(a[i-1]==b[num]?0:-200); int g2=a[j+1]>b[num]?200:(a[j+1]==b[num]?0:-200); f[i][j]=max(f[i][j],f[i-1][j]+g1); f[i][j]=max(f[i][j],f[i][j+1]+g2); } } int ans=-0x3f3f3f3f; for(int i=1,tmp=0;i<=n;++i){ tmp=f[i][i]+(a[i]>b[n]?200:(a[i]==b[n]?0:-200)); ans=max(ans,tmp); } printf(\"%d\",ans); return 0; } /* 3 92 83 71 95 87 74 4 87 84 83 82 90 87 86 85 4 87 85 84 83 90 87 86 82 */ P2587 ~~\u627f\u63a5\u4e0a\u6587~~ \u8fd9\u9053\u9898\u6570\u636e\u8303\u56f4\u5c31\u6ca1\u90a3\u4e48\u53cb\u597d\u4e86\uff0c\u8d39\u7528\u6d41\u548cdp\u90fd\u884c\u4e0d\u901a\uff0c\u6b64\u65f6\u6211\u4eec\u8003\u8651\u8d2a\u5fc3\u3002 \u56e0\u4e3a\u6709\u4e86\u8fde\u7eed\u6027\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u6bd4\u8f83a\uff0cb\u5e8f\u5217\u7684\u5934\u548c\u5c3e\u5c31\u884c\u4e86\uff0c\u6240\u4ee5\u6709\u56db\u4e2a\u6307\u9488\u3002 \u4e0b\u9762\u5206\u60c5\u51b5\u8ba8\u8bba\u53d6\u6700\u5927\u503c\uff1a 0.\u5148\u4ece\u5927\u5230\u5c0f\u6392\u5e8f 1.a[la]>b[lb],\u56e0\u4e3a\u8d62\u7684\u5e8f\u5217\u90fd\u662f\u5355\u8c03\u9012\u51cf\u7684\uff0c\u6240\u4ee5\u4e0d\u7528\u72b9\u8c6b\u76f4\u63a5\u603c\uff0c\u8d62\u4e0b\u4e00\u5c40\uff1b 2.a[la]<b[lb],\u6b64\u65f6b[lb]\u5c31\u662f\u6240\u6709\u6570\u4e2d\u6700\u5927\u7684\uff0ca\u4e0d\u7ba1\u51fa\u4ec0\u4e48\u90fd\u4e00\u5b9a\u8f93\uff0c\u6240\u4ee5\u7834\u7f50\u7834\u6454\uff0c\u8d2a\u5fc3\u7684\u53d6a\u7684\u6700\u5c0f\u503c\u603c\u5b83\u3002 3.a[la]==b[lb]. \u56e0\u4e3aa[la]\u5df2\u7ecf\u4e0eb[lb]\u76f8\u7b49\uff0c\u90a3\u4e48a[la]\u4e00\u5b9a\u5927\u4e8e\u7b49\u4e8eb[lb+1],\u6b64\u65f6\u5982\u679ca\u6700\u5c0f\u603cb\u6700\u5927\u8f93\uff0ca\u6700\u5927\u603cb\u6b21\u5927\u8d62\uff0c\u83b7\u5f97\u7684\u7ed3\u679c\u4e00\u5b9a\u4e0d\u5dee\u4e8ea\u6700\u5927\u4e0eb\u6700\u5927\u603c\u6210\u5e73\u5c40\uff08\u56e0\u4e3a\u6d88\u8017\u4e86b\u4e24\u5458\u5927\u5c06\uff0c\u800c\u4e00\u80dc\u4e00\u8d1f\u4e0e\u4e00\u5e73\u5c40\u7ed3\u679c\u4e00\u6837\uff09,\u6240\u4ee5\u9047\u5230\u5e73\u5c40\u5c31\u518d\u5206\u7c7b\uff1a 1) a[ra]>b[rb],\u65e2\u7136\u80fd\u8d62\uff0c\u90a3\u5c31\u603c 2) a[ra]<=b[rb],\u6b64\u65f6a[ra]\u65f6\u6700\u5c0f\u7684\uff0c\u4e00\u5b9a\u4f1a\u8f93\uff0c\u4e0e\u5176\u8ba9\u5b83\u4e0eb\u5c0f\u7684\u8f93\uff0c\u4e0d\u5982\u8ba9\u4ed6\u6d88\u8017\u6389b\u6700\u5927\u7684\u3002\u6ce8\u610f\u5f53\u5e8f\u5217\u53ea\u6709\u4e00\u4e2a\u6570\u65f6\uff0ca[ra]==b[lb]\u8981\u7279\u5224\u3002 \u90a3\u4e48\u6700\u5c0f\u503c\u540c\u7406\u3002 code time: #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e5+10; int a[N],b[N],n; bool cmp(int a,int b){ return a>b; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=1;i<=n;++i)scanf(\"%d\",&b[i]); sort(a+1,a+n+1,cmp); sort(b+1,b+n+1,cmp); int la=1,lb=1,ra=n,rb=n,ans=0; for(int i=1;i<=n;++i){ if(a[la]>b[lb]){ ans+=2; la++; lb++; }else if(a[la]<b[lb]){//b[lb] biggest ra--; lb++; }else{ if(a[ra]>b[rb]){ ans+=2; ra--; rb--; }else{//a[ra] smallest if(a[ra]==b[lb])ans+=1; ra--; lb++; } } } printf(\"%d \",ans); la=1,lb=1,ra=n,rb=n,ans=0; for(int i=1;i<=n;++i){ if(a[ra]<b[rb]){ ra--; rb--; }else if(a[ra]>b[rb]){//b[rb] smallest ans+=2; la++; rb--; }else{ if(a[la]<b[lb]){ la++; lb++; }else{//a[la] biggest ans+=2; if(a[la]==b[rb])ans-=1; la++; rb--; } } } printf(\"%d\",ans); return 0; } P3205 \u6ce8\u610f\u5230\u6bcf\u79cd\u961f\u5f62\u53ea\u6709\u4e24\u79cd\u72b6\u6001\uff0c\u4e00\u79cd\u662f\u5de6\u8fb9\u7684\u6700\u540e\u8fdb\u961f\uff0c\u4e00\u79cd\u65f6\u53f3\u8fb9\u7684\u6700\u540e\u8fdb\u961f\uff0c\u56e0\u6b64\u5b9a\u4e49\u72b6\u6001\uff1a f[i][j][0/1]\u8868\u793ai\u5230j\u533a\u95f4\u7684\u5de6/\u53f3\u6700\u540e\u8fdb\u961f\u7684\u961f\u5f62 \u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a memset(dp,0,sizeof dp); for(int i=1;i<=n;++i)dp[i][i][0]=1,dp[i][i][1]=0;//\u6ce8\u610f\uff0c\u662f\u5751 for(int l=1;l<=n;++l){ for(int b=1;b+l-1<=n;++b){ int e=b+l-1; if(a[b]<a[b+1])dp[b][e][0]=(dp[b][e][0]+dp[b+1][e][0])%P; if(a[b]<a[e])dp[b][e][0]=(dp[b][e][0]+dp[b+1][e][1])%P; if(a[e]>a[b])dp[b][e][1]=(dp[b][e][1]+dp[b][e-1][0])%P; if(a[e]>a[e-1])dp[b][e][1]=(dp[b][e][1]+dp[b][e-1][1])%P;//%P } } \u6ce8\u610f\u5f53(b+1==e)\u548c(b==e-1)\u65f6\uff0c\u5c06\u540c\u4e00\u79cd\u521d\u59cb\u72b6\u6001\u7b97\u4e86\u4e24\u904d\uff0c\u56e0\u6b64\u521d\u59cb\u5316\u65f6,\u5b9a\u4e49\u4e00\u4e2a\u4e3a0\uff0c\u53e6\u4e00\u4e2a\u4e3a1\u5373\u53ef\uff0c\u987a\u5e8f\u65e0\u6240\u8c13 P1005 \u4e0e3205\u5f88\u50cf\uff0c~~\u5c31\u662f\u9ad8\u7cbe\u5ea6\u592a\u70e6\u4eba\u4e86~~ \u8bbef[i][j]\u8868\u793ai\u5230j\u90fd\u53d6\u5b8c\u7684\u6700\u5927\u503c.\u8f6c\u79fb\u65b9\u7a0b\uff1a for(int i=1;i<=m;++i){ f[i][i]=tmp[i]<<1; } for(int l=2;l<=m;++l){ for(int b=1;b+l-1<=m;++b){ int e=b+l-1; f[b][e]=max(f[b][e],2*f[b][e-1]+2*tmp[e]); f[b][e]=max(f[b][e],2*f[b+1][e]+2*tmp[b]); } } P3147 \u5de7\u5999\u5730\u5c06\u5927\u7684\u4e8c\u7ef4\u72b6\u6001\u53d8\u4e3a\u5c0f\u7684 \u8bbef[k][i]\u8868\u793a\u4ece\u5de6\u7aef\u70b9i\u4f4d\u7f6e\u80fd\u5408\u6210k\u7684\u53f3\u7aef\u70b9\u4f4d\u7f6e\u4fe1\u606f \u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a f[k][i]=f[k-1][f[k-1][i]] \u590d\u6742\u5ea6$\\Theta(NK)$ for(int i=1;i<=n;++i){ f[a[i]][i]=i+1; maxn=max(maxn,a[i]); } for(int k=1;k<=58;++k){ for(int i=1;i<=n;++i){ f[k][i]=f[k-1][f[k-1][i]]==0?f[k][i]:f[k-1][f[k-1][i]]; if(f[k][i])maxn=max(k,maxn); } } P4170 \u82e5a[b]==a[e],\u5219\u5728\u4e00\u5f00\u59cb\u53ef\u4ee5\u90fd\u67d3\u4e86\uff0c\u6240\u4ee5\u7ee7\u627ff[b+1][e]\u548cf[b][e-1] \u82e5a[b]!=a[e],\u90a3\u5c31\u666e\u901a\u5730\u65ad\u6210\u4e24\u6bb5\u3002 for(int l=1;l<=n;++l){ for(int b=1;b+l-1<=n;++b){ int e=b+l-1; if(a[b]==a[e])f[b][e]=min(f[b][e],f[b+1][e]); if(a[b]==a[e])f[b][e]=min(f[b][e],f[b][e-1]); for(int k=b;k<e;++k){ f[b][e]=min(f[b][e],f[b][k]+f[k+1][e]); } } } \u4e3a\u4ec0\u4e48\u533a\u95f4dp\u4e0d\u80fd\u6bcf\u6b21\u53ea\u8f6c\u79fb\u4e00\u6b65\uff0c\u800c\u8981\u679a\u4e3e\u65ad\u70b9\u5462\uff1f \u56e0\u4e3a\u679a\u4e3e\u65ad\u70b9\u53ef\u4ee5\u628a\u5927\u533a\u95f4\u4e2d\u7684\u5c0f\u533a\u95f4\u679a\u4e3e\u51fa\u6765\uff0c\u4ece\u800c\u4e0d\u4f1a\u6f0f\u6389\u7ec6\u8282\u3002 \u4ee5P4170\u4e3e\u4f8b\uff0c\u9762\u5bf9ABCBAABA\u8fd9\u4e2a\u4e32\u65f6\uff0c\u5982\u679c\u4e00\u6b65\u4e00\u6b65\u679a\u4e3e\uff0c\u5c31\u4e0d\u80fd\u770b\u5230BCB\u53ef\u4ee5\u4e24\u6b65\u89e3\u51b3\uff0c\u800c\u662f\u4f1a\u5224\u5b9a\u4e3a3\u6b65: AABA 2 BAABA 3 CBAABA 4 BCBAABA 5 (X) \u8fd9\u662f\u56e0\u4e3a CB \u8fd9\u4e2a\u4e32\u4e2d\u7684B\u88ab\u5305\u5728\u4e86\u5927\u533a\u95f4\u91cc\u9762\uff0c\u6240\u4ee5\u6ca1\u6709\u679a\u4e3e\u5230\u3002 P1622 \u8bbef[i][j]\u8868\u793a\u7b2ci\u53f7\u5230\u7b2cj\u53f7\u72af\u4eba\u5168\u90e8\u91ca\u653e\u7684\u6700\u5c0f\u503c\uff0c\u5e76\u4e14\u5305\u542ba[i-1]\u5230a[j+1]\u4e4b\u95f4\u7684\u6240\u6709\u623f\u95f4\u3002 \u4f8b\uff1a0---3---6---14---21 \u5219f[1][2]\u8868\u793a---3---6--- \u6ce8\u610fa\u7684\u4e24\u7aef\u5e94\u8be5\u8bbe\u4e3a0\u548cn+1\uff0c\u4e0d\u7136\u6574\u4e2a\u533a\u95f4\u5c31\u77ed\u4e862\u4e2a\u5355\u4f4d #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e3+10,M=110; int f[N][N]; int a[N]; int n,m; bool cmp(int a,int b){ return a<b; } int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=m;++i)scanf(\"%d\",&a[i]); sort(a+1,a+m+1,cmp); a[0]=0; a[m+1]=n+1; for(int l=1;l<=m;++l){ for(int b=1;b+l-1<=m;++b){ int e=b+l-1; f[b][e]=999999999; for(int k=b;k<=e;++k){ f[b][e]=min(f[b][e],f[b][k-1]+f[k+1][e]+a[e+1]-a[b-1]-1-1); } } } printf(\"%d\",f[1][m]); return 0; } P7914 ~~$O(n^3)$\u80fd\u8fc7\u662f\u6211\u6ca1\u60f3\u5230\u7684~~ \u8fd9\u9053\u9898\u6700\u9ebb\u70e6\u7684\u5730\u65b9\u662f\u5224\u91cd\u3002 \u5047\u8bbe\u6709\u4e00\u4e2aAB\u4e32\u662f\u8fd9\u6837\u7684\uff1a ()()() \u90a3\u4e48\uff0c\u5408\u5e76\u533a\u95f4\u65f6\u80af\u5b9a\u8981\u679a\u4e3e\u65ad\u70b9\uff0c\u800c\u5982\u679c\u4e0d\u52a0\u9650\u5236\u7684\u8bdd\uff0c\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\uff1a 1.()+()() 2.()()+() \u8fd9\u6837\uff0c\u540c\u4e00\u4e2a\u4e32\u5c31\u4f1a\u7b97\u4e24\u904d\uff0c\u5c31\u9519\u4e86\u3002 \u540c\u6837\u7684\uff0cASB\u4e32\u4e5f\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u7c7b\u4f3c\u7ebf\u6027\u7b5b\u7684\u601d\u60f3\u53d6\u5224\u91cd\u3002 \u7ebf\u6027\u7b5b\u662f\u8ba9\u6bcf\u4e2a\u6570\u90fd\u7531\u6700\u5c0f\u7684\u8d28\u6570\u7b5b\u6389\uff0c\u598212\u53ea\u75312 6\u7b5b\uff0c\u800c\u4e0d\u80fd\u75313 4\u7b5b\u6389\u3002 \u540c\u7406\uff0c()()()\u53ea\u80fd\u7531()+()()\u66f4\u65b0\uff0c\u800c\u4e0d\u80fd\u7531()()+()\u66f4\u65b0\u3002 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u8fd9\u6837\u8bbe\u72b6\u6001\uff1a struct node{ int A,S,AS,SA,AA,AAS,SAA; }f[N][N]; \u5176\u4e2dAS,SA\u6307\u7531\"\u6700\u5c0f\"\u7684A\u4e32\u5f97\u51fa\u7684\u6784\u578b\uff0cAAS,SAA\u6307\u975e\"\u6700\u5c0f\"\u7684AA\u4e32\u5f97\u51fa\u7684\u6784\u578b\u3002 \"\u6700\u5c0f\"\u662f\u6307\u4e25\u683c\u7531\u62ec\u53f7\u5305\u7740\uff0c\u5982(),(S),(A),(AS),(SA)\u90fd\u5c5e\u4e8e\u6700\u5c0f,\u5373A; \u800cAB,ASB\u5c5e\u4e8e\u975e\u6700\u5c0f,\u5373AA\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c\u5c31\u662f\u4e0d\u53ef\u518d\u62c6\u5206\u7684A\u4e32\u3002 \u90a3\u4e48\u8f6c\u79fb\u65b9\u7a0b\u5c31\u597d\u63a8\u4e86\u3002 1) *\u548c()\u76f4\u63a5\u521d\u59cb\u5316\u5f97\u5230\u3002 2) S\u53ef\u4ee5\u7531\u66f4\u5c0f\u7684S\u63a8\u51fa\u6765\uff0c\u53ea\u8981\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8ek\u5e76\u4e14\u4e0d\u8986\u76d6\u56fa\u5b9a\u62ec\u53f7\u5c31\u884c\u3002 3) A\u53ef\u4ee5\u7531\u6240\u6709(),(S),(AS),(SA),(A),(AAS),(SAA)\u5f97\u6765\u3002 4) SA,AS,AAS,SAA\u53ef\u4ee5\u679a\u4e3e\u65ad\u70b9\uff1aAS=A S,SAA=S AA\u7b49\u3002 5) AA\u540c\u6837\u679a\u4e3e\u65ad\u70b9\uff0c\u53ef\u4ee5\u7531\u6700\u5c0f\u5f97A\u548cAS\u4e0eA\u548cAA\u62fc\u63a5\u5f97\u6765\uff1aAA=(A+AS)* (A+AA); code time: #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=550,P=1e9+7; struct node{ int A,S,AS,SA,AA,AAS,SAA; }f[N][N]; int n,k,a[N]; char ch[N]; bool ok(int i,int j){//(...) if(a[i]!=1 && a[i]!=-2 && a[j]!=1 && a[j]!=-1)return true; else return false; } bool getS(int l,int i,int j){ if(l>k)return false; if((f[i][j-1].S==1 && a[j]!=-1 && a[j]!=-2) || (f[i+1][j].S==1 && a[i]!=-1 && a[i]!=-2))return true; else return false; } void init(){ memset(f,0,sizeof f); for(int i=1;i<=n;++i){ if(a[i]==0 || a[i]==1){ f[i][i].S=1;//* }else f[i][i].S=0; } for(int i=1;i+1<=n;++i){ if(ok(i,i+1)){ f[i][i+1].A=1;//() }else f[i][i+1].A=0; } } void dp(){ init(); for(int l=1;l<=n;++l){ for(int i=1,j=0;i+l-1<=n;++i){ j=i+l-1; if(ok(i,j)){ f[i][j].A=(f[i][j].A+f[i+1][j-1].AA+f[i+1][j-1].A+f[i+1][j-1].S+f[i+1][j-1].SA+f[i+1][j-1].AS+f[i+1][j-1].SAA+f[i+1][j-1].AAS)%P; //(AA) (S) (A) (AS) (SA) (AAS) (SSA) } for(int p=i;p<j;++p){ f[i][j].AS=(f[i][j].AS+f[i][p].A*f[p+1][j].S)%P; //AS f[i][j].SA=(f[i][j].SA+f[i][p].S*f[p+1][j].A)%P; //SA f[i][j].AAS=(f[i][j].AAS+f[i][p].AA*f[p+1][j].S)%P; //AAS f[i][j].SAA=(f[i][j].SAA+f[i][p].S*f[p+1][j].AA)%P; //SAA } for(int p=i;p<j;++p){ f[i][j].AA=(f[i][j].AA+(f[i][p].A+f[i][p].AS)*(f[p+1][j].A+f[p+1][j].AA))%P; //AB //ASB } if(getS(l,i,j)) f[i][j].S=1;//S } } printf(\"%lld\",(f[1][n].A+f[1][n].AA)%P); } signed main(){ //freopen(\"bracket4.in\",\"r\",stdin); scanf(\"%lld%lld\",&n,&k); scanf(\"%s\",ch); for(int i=0;i<n;++i){ if(ch[i]=='*'){ a[i+1]=1; }else if(ch[i]=='('){ a[i+1]=-1; }else if(ch[i]==')'){ a[i+1]=-2; }else{//? a[i+1]=0; } } dp(); return 0; } /* 4 2 ()() 6 2 ()()() 7 3 (*??*?? (**)*() (**(*)) (*(**)) (*)**() (*)(**) 10 2 ???(*??(?) (**(*))(*) (()(*))(*) ()((*))(*) ()*(**)(*) (*)(**)(*) ()*(*)*(*)V (*)(*)*(*) ()*(*()()) //() (*)(*()()) (*)(*)(()) //)( ()*(*)(()) (()(**)()) //*) ()((**)()) (**(**)()) (**(*)*())V //)* ()((*)*()) (()(*)*()) (*((*))()) //)) ((*(*))()) */ \u590d\u6742\u5ea6\u8ba1\u7b97\uff1a \u5176\u5b9e\u4f20\u7edf\u7684\u533a\u95f4dp\u4e0d\u662f$\\Theta(N^3)$,\u800c\u662f$O(n^3)$,\u5e76\u4e14\u8981\u5c0f\u5f88\u591a\u3002 \u5f53\u679a\u4e3e\u7684\u533a\u95f4\u957f\u5ea6\u4e3al\u65f6\uff0cl\u662f\u4ece1\u5230n\u53d8\u5316\u7684\uff0c\u8fd9\u4f7f\u5f97\u6bcf\u6b21\u518d\u679a\u4e3e\u533a\u95f4\u5de6\u7aef\u70b9\u7684\u6b21\u6570\u65f6\u4ecen\u52301\u53d8\u5316\u7684\uff0c\u800c\u6bcf\u6b21\u679a\u4e3e\u65ad\u70b9\u90fd\u8981\u679a\u4e3el\u6b21\uff0c\u6240\u4ee5\u603b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662f $$\\sum_{i=1}^n(n-i+1)* i=\\sum_{i=1}^nf(i)\\ \u5373\u5bf9f(i)\u79ef\u5206\uff1a\\ \\int_1^nf(i)di=F(n)-F(1) \\ \\because f(i)= -i^2+(n+1)i \\ \\therefore F(i)=-\\frac13i^3+\\frac{n+1}{2}i^2\\ \\therefore \u539f\u5f0f=-\\frac13n^3+\\frac12n^3+\\frac12n^2+\\frac13-\\frac12-\\frac n2\\ =\\frac16n^3+\\frac12n^2-\\frac12n-\\frac16\\ =O(\\frac16 n^3) $$ ~~\u8fd9\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u4e0d\u7528\u56db\u8fb9\u5f62\u4f18\u5316\u76f4\u63a5\u6c34\u8fc7~~ P2470 \u597d\u9898\u3002 \u4e3a\u4e86\u65b9\u4fbf\u8868\u793a\uff0c\u5047\u8bbe\u6bcf\u4e2a\u4e32\u7684\u5f00\u5934\u90fd\u6709$M$\uff0c\u6700\u540e\u7b54\u6848$-1$\u5373\u53ef\u3002 \u6211\u4eec\u53d1\u73b0\uff0c\u80fd\u591f\u538b\u7f29\u7684\u4e32\u53ea\u6709\u4e00\u79cd\uff0c\u5c31\u662f\u4e2d\u95f4\u6ca1\u6709$M$\u7684\uff0c\u524d\u540e\u76f8\u540c\u7684\u4e32\u3002 \u4f8b\u5982,$abcbcabcbc$\u524d\u540e\u76f8\u7b49\uff0c\u53ef\u4ee5\u538b\u7f29\u6210$abcbcR$. \u867d\u7136$aMbcR$\u662f$abcbc$\u7684\u4e00\u4e2a\u538b\u7f29\uff0c\u4f46\u56e0\u4e3a$aMbcRaMbcR$\u4e2d\u95f4\u542b\u6709$M$\u4e14$M$\u524d\u6709\u4e1c\u897f$(a)$\uff0c\u6240\u4ee5\u4e0d\u80fd\u53d8\u6210$aMbcRR(abcbcbcbc)$\u3002 \u7531\u6b64\u53ef\u4ee5\u8bbe\u4e24\u79cd\u72b6\u6001\uff0c$f[i][j][0]$\u548c$f[i][j][1]$. $f[i][j][0]$\u8868\u793a\u53ea\u6709\u5f00\u5934\u6709\u4e00\u4e2a$M$\uff0c\u5e76\u4e14\u4e2d\u95f4\u4e0d\u5305\u542b$M$\u7684\u72b6\u6001\u3002 $f[i][j][1]$\u8868\u793a\u5f00\u5934\u6709$M$,\u5e76\u4e14\u4e2d\u95f4\u6709\u4e00\u4e2a\u53ca\u4ee5\u4e0a$M$\u7684\u72b6\u6001\u3002 \u90a3\u4e48\u5bf9\u4e8e\u957f\u5ea6\u4e3a\u5076\u6570\u4e14\u524d\u540e\u76f8\u7b49\u7684\u4e32\uff0c\u53ef\u4ee5\u52a0\u4e00\u4e2a$R$\u538b\u7f29\u3002 \u5bf9\u4e8e\u53ea\u6709\u4e00\u4e2a$M$\u7684\u72b6\u6001\uff0c\u53ef\u4ee5\u7531\u5c0f\u7684\u533a\u95f4\u52a0\u4e0a\u672a\u538b\u7f29\u7684\u539f\u4e32\u7684\u6765\u3002 \u5bf9\u4e8e\u591a\u4e2a$M$\u7684\u72b6\u6001\u5219\u53ef\u4ee5\u679a\u4e3e\u65ad\u70b9\u3002 code time: #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=55; int f[N][N][2]; int n; int a[N]; char ch[N]; bool check(int l,int r){ int len=r-l+1; if(len&1)return 0; int mid=l+r>>1; for(int i=l;i<=mid;++i) if(a[i]!=a[i-l+mid+1])return 0; return 1; } void init(){ scanf(\"%s\",ch); n=strlen(ch); for(int i=0;i<n;++i)a[i+1]=ch[i]-'a'+1; for(int i=1;i<=n;++i) for(int j=i;j<=n;++j)f[i][j][0]=f[i][j][1]=j-i+1+1; } void dp(){ for(int l=1;l<=n;++l){ for(int i=1,j,mid;i+l-1<=n;++i){ j=i+l-1; mid=i+j>>1; if(check(i,j))f[i][j][0]=min(f[i][j][0],f[i][mid][0]+1); for(int k=i;k<j;++k){ f[i][j][0]=min(f[i][j][0],f[i][k][0]+j-k); f[i][j][1]=min(f[i][j][1],min(f[i][k][0],f[i][k][1])+min(f[k+1][j][0],f[k+1][j][1])); } } } } int main(){ init(); dp(); printf(\"%d\",min(f[1][n][0],f[1][n][1])-1); return 0; } \u8bb0\u5fc6\u5316\u641c\u7d22 UVA10559 \u770b\u5230\u8fd9\u9898\u5f88\u5bb9\u6613\u60f3\u5230$f[i][j]$\u8868\u793a\u5c06$i$\u5230$j$\u5168\u90e8\u6d88\u9664\u80fd\u4ea7\u751f\u7684\u6700\u5927\u8d21\u732e\u3002 \u7136\u800c\uff0c\u95ee\u9898\u5728\u4e8e\uff0c\u4e0d\u4e00\u5b9a\u5c06\u8fd9\u4e2a\u533a\u95f4\u6240\u6709\u90fd\u6d88\u9664\u7684\u51b3\u7b56\u5c31\u662f\u6700\u4f18\u51b3\u7b56\uff0c\u4ed6\u4e0d\u6ee1\u8db3\u6700\u4f18\u5b50\u7ed3\u6784\uff0c\u5373\u6700\u4f18\u89e3\u4e0d\u4e00\u5b9a\u6709\u5b50\u95ee\u9898\u6700\u4f18\u89e3\u5f97\u6765\u3002 \u6bd4\u5982\uff1a\u53ef\u4ee5\u5c06\u533a\u95f4\u4e2d\u95f4\u638f\u7a7a\uff0c\u7559\u4e0b\u67d0\u4e9b\u989c\u8272\u7684\u65b9\u5757\u4e0e\u533a\u95f4\u5916\u7684\u540c\u8272\u5757\u4e00\u8d77\u6d88\u9664\u3002 \u8fd9\u662f\u8bf4\u660e\uff0c\u72b6\u6001\u63cf\u8ff0\u4e0d\u591f\u6e05\u6670\u3002\u6211\u4eec\u8981\u52a0\u7ef4\u3002 \u8bbe$f[i][j][k]$\u8868\u793a\u6d88\u9664\u533a\u95f4$i$\u5230$j$\u4ee5\u53ca\u4e0e$a[j]$\u540c\u8272\u7684\uff0c\u53f3\u8fb9\u7684$k$\u4e2a\u5757\u4ea7\u751f\u7684\u6700\u5927\u8d21\u732e\u3002 \u6b64\u65f6\u5bf9\u4e8e$j$\u548c\u5b83\u53f3\u8fb9\u7684$k$\u4e2a\u540c\u8272\u5757\u6709\u6d88\u9664\u548c\u4fdd\u7559\u4e24\u79cd\u51b3\u7b56\u3002 1) \u6d88\u9664 \u8fd9\u65f6\u53ea\u8981\u5c06$a[j]$\u4e0e\u53f3\u8fb9$k$\u4e2a\u5757\u4e00\u8d77\u6d88\u9664\u5c31\u884c\u3002\u8d21\u732e$(k+1)^2$\u3002\u5269\u4e0b\u7684\u53e6\u4f5c\u8003\u8651\u3002 $$ f[i][j][k]=max(f[i][j][k],dfs(i,j-1,0)+(k+1)* (k+1)); $$ \u81f3\u4e8e\u5c06\u8fde\u7eed$x$\u4e2a$j$\u5de6\u8fb9\u7684\u540c\u8272\u5757\u4e5f\u4e00\u540c\u6d88\u9664\u8fd9\u4e2a\u51b3\u7b56\uff0c\u4f1a\u88ab\u5305\u542b\u5728\u4fdd\u7559\u4e2d\u3002 2) \u4fdd\u7559 \u4fdd\u7559\u6307\u4fdd\u7559\u7740$j$\u548c\u5b83\u53f3\u8fb9\u7684$k$\u4e2a\u540c\u8272\u5757\uff0c\u4e0e\u533a\u95f4\u5de6\u8fb9\u7684\u4e00\u4e9b\u5757\u4e00\u8d77\u6d88\u53bb\uff0c\u5373\u7d2f\u79ef$k+1+p$\u4e2a\u540c\u8272\u5757\u4e00\u8d77\u6d88\u53bb\u3002 \u5f53\u7136\uff0c\u4e0d\u4e00\u5b9a\u8981\u5c06\u6240\u6709\u540c\u8272\u5757\u90fd\u4e00\u6b21\u6027\u6d88\u53bb\uff0c\u53ef\u80fd\u53f3\u8fb9\u4e00\u90e8\u5206\u8fde\u7eed\u6d88\u9664\uff0c\u5de6\u8fb9\u7684\u6240\u6709\u540c\u8272\u5757\u90fd\u5355\u72ec\u6d88\u9664\uff0c\u8ba9\u4ed6\u4eec\u4e2d\u95f4\u7684\u5176\u4ed6\u989c\u8272\u5757\u8fde\u7eed\u6d88\u9664\u624d\u662f\u6700\u4f73\u7b54\u6848\u3002 \u6240\u4ee5\u8981\u679a\u4e3e\u65ad\u70b9\uff0c\u800c\u8fd9\u4e2a\u65ad\u70b9\u4e0e$a[j]$\u540c\u8272\u3002\u8fd9\u4e2a\u53ef\u4ee5\u9884\u5904\u7406\u51fa$pre[j]$. $$ f[i][j][k]=max(f[i][j][k],dfs(i,p,k+1)+dfs(p+1,j-1,0)); $$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=220; int f[N][N][N]; int pre[N],vis[N],a[N]; int T,n; void init() { memset(pre,0,sizeof pre); memset(vis,0,sizeof vis); memset(f,0,sizeof f); scanf(\"%lld\",&n); for(int i=1; i<=n; ++i) { scanf(\"%lld\",&a[i]); if(vis[a[i]])pre[i]=vis[a[i]]; vis[a[i]]=i; } } int dfs(int i,int j,int k) { if(i>j)return 0; if(f[i][j][k])return f[i][j][k]; f[i][j][k]=max(f[i][j][k],dfs(i,j-1,0)+(k+1)*(k+1)); for(int p=pre[j]; p>=i; p=pre[p]) { f[i][j][k]=max(f[i][j][k],dfs(i,p,k+1)+dfs(p+1,j-1,0)); } return f[i][j][k]; } signed main() { scanf(\"%lld\",&T); for(int t=1; t<=T; ++t) { init(); printf(\"Case %lld: %lld\\n\",t,dfs(1,n,0)); } return 0; } ~~dp\u771f\u662f\u77ed\u5c0f\u7cbe\u608d\u7684\u4e1c\u897f~~ P5044 naive\u7248 \u5982\u679c\u8003\u8651$19pts$\u53ef\u4ee5\u533a\u95f4dp,$O(n^2)$. \u8bbe$f[i][j]$\u8868\u793a\u4ece$i$\u5230$j$\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002 \u9996\u5148\u8bbe$x$\u4e3a\u533a\u95f4\u6700\u5927\u503c\u7684\u4f4d\u7f6e\u3002 \u6211\u4eec\u8003\u8651\u5f53\u9009\u53d6\u7684\u70b9\u5728$x$\u5de6\u8fb9\u65f6\uff0c\u53f3\u8fb9\u7684\u70b9\u8d21\u732e\u5168\u90e8\u4e3a$a_x$,\u5de6\u8fb9\u7684\u70b9\u8d21\u732e\u5219\u4e3a$f[i][x-1]$,\u53f3\u8fb9\u540c\u7406\uff0c\u6240\u4ee5\u8f6c\u79fb\u65b9\u7a0b\uff1a $$ f[l][r]=\\min(f[l][x-1]+(r-x+1) a[x],f[x+1][r]+(x-l+1) a[x]) $$ \u7ed3\u8bba\uff1a \u8be5\u9898\u5177\u6709\u5355\u8c03\u6027\uff0c\u5373\u6bcf\u4e2a\u70b9\u7684\u8d21\u732e\u53ea\u7531\u533a\u95f4\u6700\u5927\u503c\u53ca\u5176\u4f4d\u7f6e\u51b3\u5b9a\uff0c\u8fd9\u6837\u8f6c\u79fb\u65f6\u5c31\u53ef\u4ee5\u53ea\u8003\u8651\u6700\u5927\u503c\uff0c\u964d\u4f4e\u8f6c\u79fb\u96be\u5ea6\u3002 \u627e\u5355\u8c03\u6027\u65f6\u5c31\u8981\u8003\u8651\u54ea\u4e9b\u6761\u4ef6\u4f1a\u4f7f\u8d21\u732e\u5355\u4e00\u5316\uff0c\u6bd4\u5982\u6700\u5927\u503c\u4f1a\u4f7f\u5b83\u5de6/\u53f3\u7684\u533a\u95f4\u8d21\u732e\u5168\u90e8\u53d8\u4e3a\u81ea\u5df1\u3002 P4767 naive\u7248 \u8bbe$f[i][j]$\u8868\u793a\u524d$i$\u4e2a\u6751\u5e84\u653e\u4e86$j$\u4e2a\u90ae\u5c40\u3002 \u4e00\u4e2a\u4e00\u4e2a\u8f6c\u79fb\uff0c\u65b9\u7a0b\u4e3a $$ f[i][j]=\\min_{k=0}^{i-1}(f[i][j],f[k][j-1]+w(k+1,i)) $$ \u5176\u4e2d$w(k+1,i)$\u4e3a\u8ba1\u7b97$k+1$\u5230$i$\u7684\u6700\u5c0f\u8ddd\u79bb\u548c\u3002 \u56e0\u4e3a\u6570\u5b66\u4e0a\u8ddd\u79bb\u548c\u4e00\u5b9a\u662f\u4e2d\u4f4d\u6570\u6700\u5c0f\uff0c\u6240\u4ee5\u76f4\u63a5\u66b4\u529b\u6c42\u89e3\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=1e3+10; int f[N][N]; int p,v; int a[N]; int w(int l,int r){ int mid=l+r>>1,ans=0; for(int i=l;i<=mid-1;++i)ans+=a[mid]-a[i]; for(int i=mid+1;i<=r;++i)ans+=a[i]-a[mid]; return ans; } int main(){ scanf(\"%d%d\",&v,&p); for(int i=1;i<=v;++i)scanf(\"%d\",&a[i]); memset(f,0x3f,sizeof f); f[0][0]=0; for(int i=1;i<=v;++i){ for(int j=1;j<=p;++j){ for(int k=0;k<i;++k){ f[i][j]=min(f[i][j],f[k][j-1]+w(k+1,i)); } } } printf(\"%d\",f[v][p]); return 0; } \u7ed3\u8bba\uff1a $w$\u7684\u6c42\u89e3\u5177\u6709\u5355\u8c03\u6027\uff0c\u53ef\u4ee5\u5e2e\u52a9\u7b80\u5316\u8f6c\u79fb\u3002 \u5982\u679c\u679a\u4e3e\u65ad\u70b9\u5408\u5e76\u4e24\u4e2a\u533a\u95f4\u7684\u8bdd\uff0c\u65e2\u8981\u5c06\u90ae\u5c40\u4e2a\u6570$p$\u5408\u5e76\uff0c\u53c8\u8981\u5c06\u5de6\u53f3\u7aef\u70b9$l,r$\u5408\u5e76\uff0c\u8981\u4e24\u4e2a\u65ad\u70b9\uff0c\u80af\u5b9a\u4e0d\u884c\u3002\u4e8b\u5b9e\u4e0a\uff0c\u679a\u4e3e\u65ad\u70b9\u5408\u5e76\u533a\u95f4\u53ea\u6709\u5728\u5408\u5e76\u4e24\u4e2a\u533a\u95f4\u65f6\uff0c\u4e24\u4e2a\u533a\u95f4\u4e4b\u95f4\u4f1a\u6709\u65b0\u8d21\u732e\u65f6\uff0c\u624d\u9700\u8981\u3002\u50cf\u8fd9\u9898\uff0c\u5de6\u53f3\u533a\u95f4\u5408\u5e76\u5c31\u662f\u5408\u5e76\u4e86\uff0c\u4e4b\u95f4\u6ca1\u6709\u65b0\u8d21\u732e\uff0c\u90ae\u5c40\u4e2a\u6570\u7684\u589e\u52a0\u4e5f\u6ca1\u6709\u65b0\u8d21\u732e\uff0c\u5c31\u53ef\u4ee5\u4e00\u4e2a\u4e00\u4e2a\u5730\uff0c\u4e0d\u7528\u53f3\u533a\u95f4\u503c\u5730\u8f6c\u79fb\u3002 \u8003\u8651$[1\\ 2\\ 5]\\ [6\\ 7\\ 8]$,\u8fd9\u6837\u7684\u6570\u636e\u4f1a\u51fa\u9519\uff1f\u4e0d\uff0c\u56e0\u4e3a$[1\\ 2]\\ [5\\ 6\\ 7\\ 8]$\u5373\u53ef\u6c42\u51fa\u6b63\u786e\u7b54\u6848\u3002 P4676 \u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u8bbe$f[i][j]$\u8868\u793a\u5c06 \u5b8c\u5168\u5c5e\u4e8e \u8fd9\u4e2a\u533a\u95f4\u7684\u6240\u6709\u5916\u661f\u4eba\u5168\u90e8\u6d88\u9664\u7684\u6700\u5c0f\u503c\u3002 \u90a3\u4e48\u6211\u4eec\u5148$O(n)$\u627e\u51fa\u8fd9\u4e2a\u533a\u95f4\u5185\u8ddd\u79bb\u6700\u5927\u7684\u5916\u661f\u4eba$p$\u3002\u56e0\u4e3a\u5b83\u6700\u5927\uff0c\u4e0d\u4f1a\u88ab\u522b\u4eba\u987a\u5e26\u6d88\u9664\uff0c\u6240\u4ee5\u5fc5\u6709\u4e00\u4e2a\u64cd\u4f5c\u662f\u9488\u5bf9\u8fd9\u4e2a\u6700\u5927\u5916\u661f\u4eba\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u679a\u4e3e$[a[p].l,a[p].r]$\u8fd9\u4e2a\u533a\u95f4\u7684\u65ad\u70b9\u5373\u53ef\uff0c\u90a3\u4e48\u4e1c\u7ebf\u81ea\u7136\u662f$a[p].d$,\u8f6c\u79fb\u65b9\u7a0b: $$ f[i][j]=\\min(f[i][j],f[i][k-1]+f[k+1][j]+a[p].d) $$ \u4e3a\u4ec0\u4e48\u8981\u5b8c\u5168\u5c5e\u4e8e\uff1f\u56e0\u4e3a\u5982\u679c\u8de8\u8d8a\u5f53\u524d\u533a\u95f4\u5230\u522b\u7684\u5730\u65b9\uff0c\u90a3\u4e48\u8fd9\u4e2a\u6700\u5927\u5c31\u53ef\u80fd\u88ab\u591a\u4e2a\u65ad\u70b9\u679a\u4e3e\u5230\uff0c\u76f8\u5f53\u4e8e\u7b97\u91cd\u4e86\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=660,INF=1e18; struct node{ int l,r,d; }a[N]; int f[N][N]; int b[N]; int T,n,cnt,tot; bool cmp(int a,int b){return a<b;} void lsh(){ sort(b+1,b+cnt+1,cmp); tot=unique(b+1,b+cnt+1)-b-1; for(int i=1;i<=n;++i) a[i].l=lower_bound(b+1,b+tot+1,a[i].l)-b,a[i].r=lower_bound(b+1,b+tot+1,a[i].r)-b; } void dp(){ for(int i=1;i<=tot;++i) for(int j=i;j<=tot;++j) f[i][j]=INF; for(int l=1;l<=tot;++l){ for(int i=1;i+l-1<=tot;++i){ int j=i+l-1,pos=-1,maxn=-1; for(int k=1;k<=n;++k) if(i<=a[k].l && a[k].r<=j && a[k].d>maxn) maxn=a[k].d,pos=k; if(pos==-1){f[i][j]=0;continue;} for(int k=a[pos].l;k<=a[pos].r;++k) f[i][j]=min(f[i][j],f[i][k-1]+f[k+1][j]+a[pos].d); } } printf(\"%lld\\n\",f[1][tot]); } signed main(){ scanf(\"%lld\",&T); while(T--){ scanf(\"%lld\",&n);cnt=0;tot=0; for(int i=1;i<=n;++i) scanf(\"%lld%lld%lld\",&a[i].l,&a[i].r,&a[i].d),b[++cnt]=a[i].l,b[++cnt]=a[i].r; lsh(); dp(); } return 0; } P5851 \u4e0e\u4e0a\u9762\u7c7b\u4f3c\uff0c\u53ea\u662f\u6bcf\u6b21$dp$\u662f\u518d\u679a\u4e3e\u533a\u95f4\u5c31\u4f1a\u53d8\u6210$O(n^2m)=O(n^4)$\u7684\u590d\u6742\u5ea6\uff0c\u6240\u4ee5\u6211\u4eec\u9884\u5904\u7406\u4e00\u4e0b$g[k][i][j]$,\u8868\u793a\u5bf9\u4e8e$[i,j]$\u8fd9\u4e2a\u533a\u95f4\u4e2d\u5305\u542b$k$\u70b9\u7684\uff0c\u6240\u6709\u5b50\u533a\u95f4\u7684\u6700\u5927\u503c\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=330; int a[N][N][N]; int f[N][N]; int n,m,l,r,w; void init(){ for(int k=1;k<=n;++k) for(int i=k;i>=1;--i) for(int j=k;j<=n;++j) a[k][i][j+1]=max(a[k][i][j+1],a[k][i][j]),a[k][i-1][j]=max(a[k][i-1][j],a[k][i][j]); } void dp(){ for(int l=1;l<=n;++l) for(int i=1;i+l-1<=n;++i){ int j=i+l-1; //for(int k=i;k<j;++k) f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]); for(int k=i;k<=j;++k) f[i][j]=max(f[i][j],f[i][k-1]+f[k+1][j]+a[k][i][j]); } printf(\"%lld\",f[1][n]); } signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld%lld\",&w,&l,&r); for(int k=l;k<=r;++k) a[k][l][r]=max(a[k][l][r],w); } init(); dp(); return 0; }","title":"\u533a\u95f4dp\u603b\u7ed3"},{"location":"my%20past/OI/%E5%8C%BA%E9%97%B4dp/#dp","text":"1) \u4ec0\u4e48\u60c5\u51b5\u8981\u679a\u4e3e\u65ad\u70b9\u5408\u5e76\u4e24\u4e2a\u533a\u95f4$f[l][k]+f[k+1][r]$\uff1f \u4e3a\u4e86\u8003\u8651\u533a\u95f4\u4e0e\u533a\u95f4\u5408\u5e76\u5bfc\u81f4\u7684\u65b0\u8d21\u732e\u7684\u52a0\u5165,\u56e0\u4e3a\u4e00\u6b65\u4e00\u6b65\u8f6c\u79fb\u4f1a\u6f0f\u6389\u7ec6\u8282\uff0c\u5177\u4f53\u6765\u8bf4\u5c31\u662f\u533a\u95f4\u7684\u7b54\u6848\u5408\u5e76\u540e\u4f1a\u6539\u53d8\uff0c\u53d8\u5c11\u6216\u53d8\u591a(P4170)\u3002 2) \u4ec0\u4e48\u65f6\u5019\u53ef\u4ee5\u4e0d\u7528/\u4e0d\u80fd\u679a\u4e3e\u65ad\u70b9\uff1f \u5f53\u533a\u95f4\u4e0d\u5177\u5907\u53ef\u5408\u5e76\u6027(P5044/CF360B)\u6216\u9898\u76ee\u660e\u786e\u8f6c\u79fb\u662f\u4e00\u6b65\u4e00\u6b65\u7684(P1005)\u6216\u679a\u4e0d\u679a\u4e3e\u65ad\u70b9\u65e0\u6240\u8c13\uff0c\u4f46\u4e00\u6b65\u4e00\u6b65\u8f6c\u79fb\u53ef\u4ee5\u51cf\u5c11\u72b6\u6001\u6570\u7684(P4767) 3) \u50cfP4158\u548cP4767\u8fd9\u79cd\u5e26\u6709\u6570\u91cf\u9650\u5236\u7684\u5e8f\u5217\u95ee\u9898\u5c31\u4e0d\u7b97\u533a\u95f4dp\u4e86\uff0c\u7b97\u7ebf\u6027dp. ~~\u603b\u4e4b\u5177\u4f53\u60c5\u51b5\u9760\u76f4\u89c9~~","title":"\u533a\u95f4dp\u603b\u7ed3"},{"location":"my%20past/OI/%E5%8C%BA%E9%97%B4dp/#_1","text":"P1880 \u6a21\u677f\u9898 \u6ce8\u610f\u73af\u5f62\u9700\u8981\u5f002\u500d\u7a7a\u95f4 P1063 \u4e0eP1880\u5341\u5206\u7c7b\u4f3c\uff0c\u6ce8\u610f\u6bcf\u6b21\u589e\u52a0\u7684\u6570\u503c\u4e3a$a[b] a[k+1] a[e+1]$ \u8f6c\u79fb\u65b9\u7a0b\uff1a for(int l=1;l<=n+n;++l){ for(int b=1;b+l-1<=n+n;++b){ int e=b+l-1; for(int k=b;k<e;++k){ dp[b][e]=max(dp[b][e],dp[b][k]+dp[k+1][e]+a[b]*a[k+1]*a[(e+1)]); } } } P1220 \u6ce8\u610f\u5230\u7279\u6b8a\u6027\u8d28\uff1a \u6700\u4f73\u65b9\u6848\u4e00\u5b9a\u53d6\u5f97\u662f\u8fde\u7eed\u7684\u533a\u95f4\u3002 \u5047\u5982\u6709: 5 3 2 10 3 20 5 20 6 30 8 10 \u5f00\u59cb\u65f6\u60f3\u8981\u53d61\u53f7\u548c2\u53f7\uff0c\u90a3\u4e48\u5148\u53d61\u518d\u53d62\u80af\u5b9a\u6ca1\u6709\u5148\u53d62\u518d\u53d61\u597d\uff0c\u56e0\u4e3a\u53d61\u65f6\u7ecf\u8fc72\uff0c\u800c\u5173\u706f\u4e0d\u9700\u8981\u65f6\u95f4 \u56e0\u6b64\uff0c\u6240\u6709\u72b6\u6001\u90fd\u662f\u8fde\u7eed\u533a\u95f4\uff0c\u4fbf\u6709\u8f6c\u79fb\u65b9\u7a0b\uff1a for(int l=c;l>=1;--l){ for(int r=c;r<=n;++r){ dp[l][r][l]=min(dp[l][r][l],min(dp[l+1][r][l+1]+(a[l+1]-a[l])*(sum-x[r]+x[l]),dp[l+1][r][r]+(a[r]-a[l])*(sum-x[r]+x[l]))); dp[l][r][r]=min(dp[l][r][r],min(dp[l][r-1][l]+(a[r]-a[l])*(sum-x[r-1]+x[l-1]),dp[l][r-1][r-1]+(a[r]-a[r-1])*(sum-x[r-1]+x[l-1]))); } } P2466 \u4e0e\u4e0a\u9762\u7684\u76f8\u4f3c\uff0c\u6bcf\u6b21\u79fb\u52a8\u540e\u5c0f\u7403\u90fd\u4f1a\u4e0b\u843d\uff0c\u76f8\u5f53\u4e8e\u6d88\u8017\u4e86\u6700\u7ec8\u7684\u4ef7\u503c\uff0c\u6240\u4ee5\u6700\u5c0f\u5316\u8fd9\u4e2a\u6d88\u8017\u5373\u53ef\uff0c\u8f6c\u79fb\u65b9\u7a0b\u540c\u4e0a\u9762\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define int long long using namespace std; typedef double db; const int N=1e3+10; const db INF=1e16; db f[N][N][2],res,ans; struct node{ int x,y,v; }a[N]; int s[N],sum,n,x; bool cmp(node a,node b); void init(); void dp(); int Abs(int x); db Min(db a,db b); signed main(){ scanf(\"%lld%lld\",&n,&x); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i].x); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i].y); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i].v); init(); dp(); return 0; } bool cmp(node a,node b){ return a.x<b.x; } int Abs(int x){ return x>=0?x:-x; } db Min(db a,db b){ return a<=b?a:b; } void init(){ sort(a+1,a+n+1,cmp); for(int i=1;i<=n;++i) s[i]=s[i-1]+a[i].v,sum+=a[i].v; for(int i=1;i<=n;++i) res+=(db)(a[i].y)/1000.0; for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) f[i][j][0]=f[i][j][1]=INF; for(int i=1;i<=n;++i) f[i][i][0]=f[i][i][1]=(db)(Abs(x-a[i].x)*sum)/1000.0; } void dp(){ for(int l=2;l<=n;++l){ for(int b=1;b+l-1<=n;++b){ int e=b+l-1; f[b][e][0]=Min(f[b][e][0],Min(f[b+1][e][0]+(db)(Abs(a[b+1].x-a[b].x)*(sum-s[e]+s[b]))/1000.0,f[b+1][e][1]+(db)(Abs(a[e].x-a[b].x)*(sum-s[e]+s[b]))/1000.0)); f[b][e][1]=Min(f[b][e][1],Min(f[b][e-1][0]+(db)(Abs(a[e].x-a[b].x)*(sum-s[e-1]+s[b-1]))/1000.0,f[b][e-1][1]+(db)(Abs(a[e].x-a[e-1].x)*(sum-s[e-1]+s[b-1]))/1000.0)); } } ans=Min(f[1][n][0],f[1][n][1]); printf(\"%.3lf\",res-ans); } /* 3 3 -4 -2 2 22 30 26 1 9 8 */ P1650 \u8fd9\u9053\u9898\u4e00\u4e2a\u91cd\u8981\u7684\u6027\u8d28\u5c31\u662f\uff1a\u5bf9\u4e8e\u7530\u5fcc\u5168\u4e0d\u8f93\u7684\u51fa\u9a6c\u5e8f\u5217\uff0c\u4e00\u5b9a\u6ee1\u8db3\u4ece\u5927\u5230\u5c0f: $$A_1 \\geq A_2 \\geq... \\geq A_n\\ \u5047\u8bbe\u6709A_i<A_{i+1},\u4e14A_i\\geq B_i,A_{i+1}\\geq B_{i+1},B_i\\geq B_{i+1},\\\u90a3\u4e48\u5c31\u53ef\u4ee5\u4ea4\u6362A_i \u548cA_{i+1}\u3002 $$ \u540c\u6837\u80fd\u8bc1\u660e\u5bf9\u4e8e\u7530\u5fcc\u5168\u8f93\u7684\u5e8f\u5217\u6ee1\u8db3\u4ece\u5c0f\u5230\u5927\u3002 \u4e8e\u662f\uff0c\u4efb\u610f\u7684\u72b6\u6001\u90fd\u662f\u4eceA\u5e8f\u5217\u5934\u548c\u4e3a\u53bb\u9664\u4e00\u4e9b\u5143\u7d20\u540e\u5f62\u6210\u7684\u8fde\u7eed\u5e8f\u5217\u3002\u8fd9\u6837\u7684\u8bdd\uff0c\u533a\u95f4DP\u548c\u8d2a\u5fc3\u90fd\u53ef\u4ee5\u505a\u4e86\u3002 \u8bbef[i][j]\u8868\u793aA\u5e8f\u5217\u8fd8\u5269i\u5230j\u5339\u9a6c\u65f6\u7684\u6700\u4f18\u89e3\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=2010; int n; int a[N],b[N],f[N][N]; bool cmp(int a,int b){ return a>b; } int main(){ memset(f,-0x3f,sizeof f); scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=1;i<=n;++i)scanf(\"%d\",&b[i]); sort(a+1,a+n+1,cmp); sort(b+1,b+n+1,cmp); f[1][n]=0; for(int num=0,l=n-1;l>=1;--l){ num=n-l; for(int i=1,j=0;i+l-1<=n;++i){ j=i+l-1; int g1=a[i-1]>b[num]?200:(a[i-1]==b[num]?0:-200); int g2=a[j+1]>b[num]?200:(a[j+1]==b[num]?0:-200); f[i][j]=max(f[i][j],f[i-1][j]+g1); f[i][j]=max(f[i][j],f[i][j+1]+g2); } } int ans=-0x3f3f3f3f; for(int i=1,tmp=0;i<=n;++i){ tmp=f[i][i]+(a[i]>b[n]?200:(a[i]==b[n]?0:-200)); ans=max(ans,tmp); } printf(\"%d\",ans); return 0; } /* 3 92 83 71 95 87 74 4 87 84 83 82 90 87 86 85 4 87 85 84 83 90 87 86 82 */ P2587 ~~\u627f\u63a5\u4e0a\u6587~~ \u8fd9\u9053\u9898\u6570\u636e\u8303\u56f4\u5c31\u6ca1\u90a3\u4e48\u53cb\u597d\u4e86\uff0c\u8d39\u7528\u6d41\u548cdp\u90fd\u884c\u4e0d\u901a\uff0c\u6b64\u65f6\u6211\u4eec\u8003\u8651\u8d2a\u5fc3\u3002 \u56e0\u4e3a\u6709\u4e86\u8fde\u7eed\u6027\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u6bd4\u8f83a\uff0cb\u5e8f\u5217\u7684\u5934\u548c\u5c3e\u5c31\u884c\u4e86\uff0c\u6240\u4ee5\u6709\u56db\u4e2a\u6307\u9488\u3002 \u4e0b\u9762\u5206\u60c5\u51b5\u8ba8\u8bba\u53d6\u6700\u5927\u503c\uff1a 0.\u5148\u4ece\u5927\u5230\u5c0f\u6392\u5e8f 1.a[la]>b[lb],\u56e0\u4e3a\u8d62\u7684\u5e8f\u5217\u90fd\u662f\u5355\u8c03\u9012\u51cf\u7684\uff0c\u6240\u4ee5\u4e0d\u7528\u72b9\u8c6b\u76f4\u63a5\u603c\uff0c\u8d62\u4e0b\u4e00\u5c40\uff1b 2.a[la]<b[lb],\u6b64\u65f6b[lb]\u5c31\u662f\u6240\u6709\u6570\u4e2d\u6700\u5927\u7684\uff0ca\u4e0d\u7ba1\u51fa\u4ec0\u4e48\u90fd\u4e00\u5b9a\u8f93\uff0c\u6240\u4ee5\u7834\u7f50\u7834\u6454\uff0c\u8d2a\u5fc3\u7684\u53d6a\u7684\u6700\u5c0f\u503c\u603c\u5b83\u3002 3.a[la]==b[lb]. \u56e0\u4e3aa[la]\u5df2\u7ecf\u4e0eb[lb]\u76f8\u7b49\uff0c\u90a3\u4e48a[la]\u4e00\u5b9a\u5927\u4e8e\u7b49\u4e8eb[lb+1],\u6b64\u65f6\u5982\u679ca\u6700\u5c0f\u603cb\u6700\u5927\u8f93\uff0ca\u6700\u5927\u603cb\u6b21\u5927\u8d62\uff0c\u83b7\u5f97\u7684\u7ed3\u679c\u4e00\u5b9a\u4e0d\u5dee\u4e8ea\u6700\u5927\u4e0eb\u6700\u5927\u603c\u6210\u5e73\u5c40\uff08\u56e0\u4e3a\u6d88\u8017\u4e86b\u4e24\u5458\u5927\u5c06\uff0c\u800c\u4e00\u80dc\u4e00\u8d1f\u4e0e\u4e00\u5e73\u5c40\u7ed3\u679c\u4e00\u6837\uff09,\u6240\u4ee5\u9047\u5230\u5e73\u5c40\u5c31\u518d\u5206\u7c7b\uff1a 1) a[ra]>b[rb],\u65e2\u7136\u80fd\u8d62\uff0c\u90a3\u5c31\u603c 2) a[ra]<=b[rb],\u6b64\u65f6a[ra]\u65f6\u6700\u5c0f\u7684\uff0c\u4e00\u5b9a\u4f1a\u8f93\uff0c\u4e0e\u5176\u8ba9\u5b83\u4e0eb\u5c0f\u7684\u8f93\uff0c\u4e0d\u5982\u8ba9\u4ed6\u6d88\u8017\u6389b\u6700\u5927\u7684\u3002\u6ce8\u610f\u5f53\u5e8f\u5217\u53ea\u6709\u4e00\u4e2a\u6570\u65f6\uff0ca[ra]==b[lb]\u8981\u7279\u5224\u3002 \u90a3\u4e48\u6700\u5c0f\u503c\u540c\u7406\u3002 code time: #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e5+10; int a[N],b[N],n; bool cmp(int a,int b){ return a>b; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=1;i<=n;++i)scanf(\"%d\",&b[i]); sort(a+1,a+n+1,cmp); sort(b+1,b+n+1,cmp); int la=1,lb=1,ra=n,rb=n,ans=0; for(int i=1;i<=n;++i){ if(a[la]>b[lb]){ ans+=2; la++; lb++; }else if(a[la]<b[lb]){//b[lb] biggest ra--; lb++; }else{ if(a[ra]>b[rb]){ ans+=2; ra--; rb--; }else{//a[ra] smallest if(a[ra]==b[lb])ans+=1; ra--; lb++; } } } printf(\"%d \",ans); la=1,lb=1,ra=n,rb=n,ans=0; for(int i=1;i<=n;++i){ if(a[ra]<b[rb]){ ra--; rb--; }else if(a[ra]>b[rb]){//b[rb] smallest ans+=2; la++; rb--; }else{ if(a[la]<b[lb]){ la++; lb++; }else{//a[la] biggest ans+=2; if(a[la]==b[rb])ans-=1; la++; rb--; } } } printf(\"%d\",ans); return 0; } P3205 \u6ce8\u610f\u5230\u6bcf\u79cd\u961f\u5f62\u53ea\u6709\u4e24\u79cd\u72b6\u6001\uff0c\u4e00\u79cd\u662f\u5de6\u8fb9\u7684\u6700\u540e\u8fdb\u961f\uff0c\u4e00\u79cd\u65f6\u53f3\u8fb9\u7684\u6700\u540e\u8fdb\u961f\uff0c\u56e0\u6b64\u5b9a\u4e49\u72b6\u6001\uff1a f[i][j][0/1]\u8868\u793ai\u5230j\u533a\u95f4\u7684\u5de6/\u53f3\u6700\u540e\u8fdb\u961f\u7684\u961f\u5f62 \u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a memset(dp,0,sizeof dp); for(int i=1;i<=n;++i)dp[i][i][0]=1,dp[i][i][1]=0;//\u6ce8\u610f\uff0c\u662f\u5751 for(int l=1;l<=n;++l){ for(int b=1;b+l-1<=n;++b){ int e=b+l-1; if(a[b]<a[b+1])dp[b][e][0]=(dp[b][e][0]+dp[b+1][e][0])%P; if(a[b]<a[e])dp[b][e][0]=(dp[b][e][0]+dp[b+1][e][1])%P; if(a[e]>a[b])dp[b][e][1]=(dp[b][e][1]+dp[b][e-1][0])%P; if(a[e]>a[e-1])dp[b][e][1]=(dp[b][e][1]+dp[b][e-1][1])%P;//%P } } \u6ce8\u610f\u5f53(b+1==e)\u548c(b==e-1)\u65f6\uff0c\u5c06\u540c\u4e00\u79cd\u521d\u59cb\u72b6\u6001\u7b97\u4e86\u4e24\u904d\uff0c\u56e0\u6b64\u521d\u59cb\u5316\u65f6,\u5b9a\u4e49\u4e00\u4e2a\u4e3a0\uff0c\u53e6\u4e00\u4e2a\u4e3a1\u5373\u53ef\uff0c\u987a\u5e8f\u65e0\u6240\u8c13 P1005 \u4e0e3205\u5f88\u50cf\uff0c~~\u5c31\u662f\u9ad8\u7cbe\u5ea6\u592a\u70e6\u4eba\u4e86~~ \u8bbef[i][j]\u8868\u793ai\u5230j\u90fd\u53d6\u5b8c\u7684\u6700\u5927\u503c.\u8f6c\u79fb\u65b9\u7a0b\uff1a for(int i=1;i<=m;++i){ f[i][i]=tmp[i]<<1; } for(int l=2;l<=m;++l){ for(int b=1;b+l-1<=m;++b){ int e=b+l-1; f[b][e]=max(f[b][e],2*f[b][e-1]+2*tmp[e]); f[b][e]=max(f[b][e],2*f[b+1][e]+2*tmp[b]); } } P3147 \u5de7\u5999\u5730\u5c06\u5927\u7684\u4e8c\u7ef4\u72b6\u6001\u53d8\u4e3a\u5c0f\u7684 \u8bbef[k][i]\u8868\u793a\u4ece\u5de6\u7aef\u70b9i\u4f4d\u7f6e\u80fd\u5408\u6210k\u7684\u53f3\u7aef\u70b9\u4f4d\u7f6e\u4fe1\u606f \u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a f[k][i]=f[k-1][f[k-1][i]] \u590d\u6742\u5ea6$\\Theta(NK)$ for(int i=1;i<=n;++i){ f[a[i]][i]=i+1; maxn=max(maxn,a[i]); } for(int k=1;k<=58;++k){ for(int i=1;i<=n;++i){ f[k][i]=f[k-1][f[k-1][i]]==0?f[k][i]:f[k-1][f[k-1][i]]; if(f[k][i])maxn=max(k,maxn); } } P4170 \u82e5a[b]==a[e],\u5219\u5728\u4e00\u5f00\u59cb\u53ef\u4ee5\u90fd\u67d3\u4e86\uff0c\u6240\u4ee5\u7ee7\u627ff[b+1][e]\u548cf[b][e-1] \u82e5a[b]!=a[e],\u90a3\u5c31\u666e\u901a\u5730\u65ad\u6210\u4e24\u6bb5\u3002 for(int l=1;l<=n;++l){ for(int b=1;b+l-1<=n;++b){ int e=b+l-1; if(a[b]==a[e])f[b][e]=min(f[b][e],f[b+1][e]); if(a[b]==a[e])f[b][e]=min(f[b][e],f[b][e-1]); for(int k=b;k<e;++k){ f[b][e]=min(f[b][e],f[b][k]+f[k+1][e]); } } } \u4e3a\u4ec0\u4e48\u533a\u95f4dp\u4e0d\u80fd\u6bcf\u6b21\u53ea\u8f6c\u79fb\u4e00\u6b65\uff0c\u800c\u8981\u679a\u4e3e\u65ad\u70b9\u5462\uff1f \u56e0\u4e3a\u679a\u4e3e\u65ad\u70b9\u53ef\u4ee5\u628a\u5927\u533a\u95f4\u4e2d\u7684\u5c0f\u533a\u95f4\u679a\u4e3e\u51fa\u6765\uff0c\u4ece\u800c\u4e0d\u4f1a\u6f0f\u6389\u7ec6\u8282\u3002 \u4ee5P4170\u4e3e\u4f8b\uff0c\u9762\u5bf9ABCBAABA\u8fd9\u4e2a\u4e32\u65f6\uff0c\u5982\u679c\u4e00\u6b65\u4e00\u6b65\u679a\u4e3e\uff0c\u5c31\u4e0d\u80fd\u770b\u5230BCB\u53ef\u4ee5\u4e24\u6b65\u89e3\u51b3\uff0c\u800c\u662f\u4f1a\u5224\u5b9a\u4e3a3\u6b65: AABA 2 BAABA 3 CBAABA 4 BCBAABA 5 (X) \u8fd9\u662f\u56e0\u4e3a CB \u8fd9\u4e2a\u4e32\u4e2d\u7684B\u88ab\u5305\u5728\u4e86\u5927\u533a\u95f4\u91cc\u9762\uff0c\u6240\u4ee5\u6ca1\u6709\u679a\u4e3e\u5230\u3002 P1622 \u8bbef[i][j]\u8868\u793a\u7b2ci\u53f7\u5230\u7b2cj\u53f7\u72af\u4eba\u5168\u90e8\u91ca\u653e\u7684\u6700\u5c0f\u503c\uff0c\u5e76\u4e14\u5305\u542ba[i-1]\u5230a[j+1]\u4e4b\u95f4\u7684\u6240\u6709\u623f\u95f4\u3002 \u4f8b\uff1a0---3---6---14---21 \u5219f[1][2]\u8868\u793a---3---6--- \u6ce8\u610fa\u7684\u4e24\u7aef\u5e94\u8be5\u8bbe\u4e3a0\u548cn+1\uff0c\u4e0d\u7136\u6574\u4e2a\u533a\u95f4\u5c31\u77ed\u4e862\u4e2a\u5355\u4f4d #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e3+10,M=110; int f[N][N]; int a[N]; int n,m; bool cmp(int a,int b){ return a<b; } int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=m;++i)scanf(\"%d\",&a[i]); sort(a+1,a+m+1,cmp); a[0]=0; a[m+1]=n+1; for(int l=1;l<=m;++l){ for(int b=1;b+l-1<=m;++b){ int e=b+l-1; f[b][e]=999999999; for(int k=b;k<=e;++k){ f[b][e]=min(f[b][e],f[b][k-1]+f[k+1][e]+a[e+1]-a[b-1]-1-1); } } } printf(\"%d\",f[1][m]); return 0; } P7914 ~~$O(n^3)$\u80fd\u8fc7\u662f\u6211\u6ca1\u60f3\u5230\u7684~~ \u8fd9\u9053\u9898\u6700\u9ebb\u70e6\u7684\u5730\u65b9\u662f\u5224\u91cd\u3002 \u5047\u8bbe\u6709\u4e00\u4e2aAB\u4e32\u662f\u8fd9\u6837\u7684\uff1a ()()() \u90a3\u4e48\uff0c\u5408\u5e76\u533a\u95f4\u65f6\u80af\u5b9a\u8981\u679a\u4e3e\u65ad\u70b9\uff0c\u800c\u5982\u679c\u4e0d\u52a0\u9650\u5236\u7684\u8bdd\uff0c\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\uff1a 1.()+()() 2.()()+() \u8fd9\u6837\uff0c\u540c\u4e00\u4e2a\u4e32\u5c31\u4f1a\u7b97\u4e24\u904d\uff0c\u5c31\u9519\u4e86\u3002 \u540c\u6837\u7684\uff0cASB\u4e32\u4e5f\u4f1a\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u7c7b\u4f3c\u7ebf\u6027\u7b5b\u7684\u601d\u60f3\u53d6\u5224\u91cd\u3002 \u7ebf\u6027\u7b5b\u662f\u8ba9\u6bcf\u4e2a\u6570\u90fd\u7531\u6700\u5c0f\u7684\u8d28\u6570\u7b5b\u6389\uff0c\u598212\u53ea\u75312 6\u7b5b\uff0c\u800c\u4e0d\u80fd\u75313 4\u7b5b\u6389\u3002 \u540c\u7406\uff0c()()()\u53ea\u80fd\u7531()+()()\u66f4\u65b0\uff0c\u800c\u4e0d\u80fd\u7531()()+()\u66f4\u65b0\u3002 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u8fd9\u6837\u8bbe\u72b6\u6001\uff1a struct node{ int A,S,AS,SA,AA,AAS,SAA; }f[N][N]; \u5176\u4e2dAS,SA\u6307\u7531\"\u6700\u5c0f\"\u7684A\u4e32\u5f97\u51fa\u7684\u6784\u578b\uff0cAAS,SAA\u6307\u975e\"\u6700\u5c0f\"\u7684AA\u4e32\u5f97\u51fa\u7684\u6784\u578b\u3002 \"\u6700\u5c0f\"\u662f\u6307\u4e25\u683c\u7531\u62ec\u53f7\u5305\u7740\uff0c\u5982(),(S),(A),(AS),(SA)\u90fd\u5c5e\u4e8e\u6700\u5c0f,\u5373A; \u800cAB,ASB\u5c5e\u4e8e\u975e\u6700\u5c0f,\u5373AA\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c\u5c31\u662f\u4e0d\u53ef\u518d\u62c6\u5206\u7684A\u4e32\u3002 \u90a3\u4e48\u8f6c\u79fb\u65b9\u7a0b\u5c31\u597d\u63a8\u4e86\u3002 1) *\u548c()\u76f4\u63a5\u521d\u59cb\u5316\u5f97\u5230\u3002 2) S\u53ef\u4ee5\u7531\u66f4\u5c0f\u7684S\u63a8\u51fa\u6765\uff0c\u53ea\u8981\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8ek\u5e76\u4e14\u4e0d\u8986\u76d6\u56fa\u5b9a\u62ec\u53f7\u5c31\u884c\u3002 3) A\u53ef\u4ee5\u7531\u6240\u6709(),(S),(AS),(SA),(A),(AAS),(SAA)\u5f97\u6765\u3002 4) SA,AS,AAS,SAA\u53ef\u4ee5\u679a\u4e3e\u65ad\u70b9\uff1aAS=A S,SAA=S AA\u7b49\u3002 5) AA\u540c\u6837\u679a\u4e3e\u65ad\u70b9\uff0c\u53ef\u4ee5\u7531\u6700\u5c0f\u5f97A\u548cAS\u4e0eA\u548cAA\u62fc\u63a5\u5f97\u6765\uff1aAA=(A+AS)* (A+AA); code time: #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=550,P=1e9+7; struct node{ int A,S,AS,SA,AA,AAS,SAA; }f[N][N]; int n,k,a[N]; char ch[N]; bool ok(int i,int j){//(...) if(a[i]!=1 && a[i]!=-2 && a[j]!=1 && a[j]!=-1)return true; else return false; } bool getS(int l,int i,int j){ if(l>k)return false; if((f[i][j-1].S==1 && a[j]!=-1 && a[j]!=-2) || (f[i+1][j].S==1 && a[i]!=-1 && a[i]!=-2))return true; else return false; } void init(){ memset(f,0,sizeof f); for(int i=1;i<=n;++i){ if(a[i]==0 || a[i]==1){ f[i][i].S=1;//* }else f[i][i].S=0; } for(int i=1;i+1<=n;++i){ if(ok(i,i+1)){ f[i][i+1].A=1;//() }else f[i][i+1].A=0; } } void dp(){ init(); for(int l=1;l<=n;++l){ for(int i=1,j=0;i+l-1<=n;++i){ j=i+l-1; if(ok(i,j)){ f[i][j].A=(f[i][j].A+f[i+1][j-1].AA+f[i+1][j-1].A+f[i+1][j-1].S+f[i+1][j-1].SA+f[i+1][j-1].AS+f[i+1][j-1].SAA+f[i+1][j-1].AAS)%P; //(AA) (S) (A) (AS) (SA) (AAS) (SSA) } for(int p=i;p<j;++p){ f[i][j].AS=(f[i][j].AS+f[i][p].A*f[p+1][j].S)%P; //AS f[i][j].SA=(f[i][j].SA+f[i][p].S*f[p+1][j].A)%P; //SA f[i][j].AAS=(f[i][j].AAS+f[i][p].AA*f[p+1][j].S)%P; //AAS f[i][j].SAA=(f[i][j].SAA+f[i][p].S*f[p+1][j].AA)%P; //SAA } for(int p=i;p<j;++p){ f[i][j].AA=(f[i][j].AA+(f[i][p].A+f[i][p].AS)*(f[p+1][j].A+f[p+1][j].AA))%P; //AB //ASB } if(getS(l,i,j)) f[i][j].S=1;//S } } printf(\"%lld\",(f[1][n].A+f[1][n].AA)%P); } signed main(){ //freopen(\"bracket4.in\",\"r\",stdin); scanf(\"%lld%lld\",&n,&k); scanf(\"%s\",ch); for(int i=0;i<n;++i){ if(ch[i]=='*'){ a[i+1]=1; }else if(ch[i]=='('){ a[i+1]=-1; }else if(ch[i]==')'){ a[i+1]=-2; }else{//? a[i+1]=0; } } dp(); return 0; } /* 4 2 ()() 6 2 ()()() 7 3 (*??*?? (**)*() (**(*)) (*(**)) (*)**() (*)(**) 10 2 ???(*??(?) (**(*))(*) (()(*))(*) ()((*))(*) ()*(**)(*) (*)(**)(*) ()*(*)*(*)V (*)(*)*(*) ()*(*()()) //() (*)(*()()) (*)(*)(()) //)( ()*(*)(()) (()(**)()) //*) ()((**)()) (**(**)()) (**(*)*())V //)* ()((*)*()) (()(*)*()) (*((*))()) //)) ((*(*))()) */ \u590d\u6742\u5ea6\u8ba1\u7b97\uff1a \u5176\u5b9e\u4f20\u7edf\u7684\u533a\u95f4dp\u4e0d\u662f$\\Theta(N^3)$,\u800c\u662f$O(n^3)$,\u5e76\u4e14\u8981\u5c0f\u5f88\u591a\u3002 \u5f53\u679a\u4e3e\u7684\u533a\u95f4\u957f\u5ea6\u4e3al\u65f6\uff0cl\u662f\u4ece1\u5230n\u53d8\u5316\u7684\uff0c\u8fd9\u4f7f\u5f97\u6bcf\u6b21\u518d\u679a\u4e3e\u533a\u95f4\u5de6\u7aef\u70b9\u7684\u6b21\u6570\u65f6\u4ecen\u52301\u53d8\u5316\u7684\uff0c\u800c\u6bcf\u6b21\u679a\u4e3e\u65ad\u70b9\u90fd\u8981\u679a\u4e3el\u6b21\uff0c\u6240\u4ee5\u603b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662f $$\\sum_{i=1}^n(n-i+1)* i=\\sum_{i=1}^nf(i)\\ \u5373\u5bf9f(i)\u79ef\u5206\uff1a\\ \\int_1^nf(i)di=F(n)-F(1) \\ \\because f(i)= -i^2+(n+1)i \\ \\therefore F(i)=-\\frac13i^3+\\frac{n+1}{2}i^2\\ \\therefore \u539f\u5f0f=-\\frac13n^3+\\frac12n^3+\\frac12n^2+\\frac13-\\frac12-\\frac n2\\ =\\frac16n^3+\\frac12n^2-\\frac12n-\\frac16\\ =O(\\frac16 n^3) $$ ~~\u8fd9\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u4e0d\u7528\u56db\u8fb9\u5f62\u4f18\u5316\u76f4\u63a5\u6c34\u8fc7~~ P2470 \u597d\u9898\u3002 \u4e3a\u4e86\u65b9\u4fbf\u8868\u793a\uff0c\u5047\u8bbe\u6bcf\u4e2a\u4e32\u7684\u5f00\u5934\u90fd\u6709$M$\uff0c\u6700\u540e\u7b54\u6848$-1$\u5373\u53ef\u3002 \u6211\u4eec\u53d1\u73b0\uff0c\u80fd\u591f\u538b\u7f29\u7684\u4e32\u53ea\u6709\u4e00\u79cd\uff0c\u5c31\u662f\u4e2d\u95f4\u6ca1\u6709$M$\u7684\uff0c\u524d\u540e\u76f8\u540c\u7684\u4e32\u3002 \u4f8b\u5982,$abcbcabcbc$\u524d\u540e\u76f8\u7b49\uff0c\u53ef\u4ee5\u538b\u7f29\u6210$abcbcR$. \u867d\u7136$aMbcR$\u662f$abcbc$\u7684\u4e00\u4e2a\u538b\u7f29\uff0c\u4f46\u56e0\u4e3a$aMbcRaMbcR$\u4e2d\u95f4\u542b\u6709$M$\u4e14$M$\u524d\u6709\u4e1c\u897f$(a)$\uff0c\u6240\u4ee5\u4e0d\u80fd\u53d8\u6210$aMbcRR(abcbcbcbc)$\u3002 \u7531\u6b64\u53ef\u4ee5\u8bbe\u4e24\u79cd\u72b6\u6001\uff0c$f[i][j][0]$\u548c$f[i][j][1]$. $f[i][j][0]$\u8868\u793a\u53ea\u6709\u5f00\u5934\u6709\u4e00\u4e2a$M$\uff0c\u5e76\u4e14\u4e2d\u95f4\u4e0d\u5305\u542b$M$\u7684\u72b6\u6001\u3002 $f[i][j][1]$\u8868\u793a\u5f00\u5934\u6709$M$,\u5e76\u4e14\u4e2d\u95f4\u6709\u4e00\u4e2a\u53ca\u4ee5\u4e0a$M$\u7684\u72b6\u6001\u3002 \u90a3\u4e48\u5bf9\u4e8e\u957f\u5ea6\u4e3a\u5076\u6570\u4e14\u524d\u540e\u76f8\u7b49\u7684\u4e32\uff0c\u53ef\u4ee5\u52a0\u4e00\u4e2a$R$\u538b\u7f29\u3002 \u5bf9\u4e8e\u53ea\u6709\u4e00\u4e2a$M$\u7684\u72b6\u6001\uff0c\u53ef\u4ee5\u7531\u5c0f\u7684\u533a\u95f4\u52a0\u4e0a\u672a\u538b\u7f29\u7684\u539f\u4e32\u7684\u6765\u3002 \u5bf9\u4e8e\u591a\u4e2a$M$\u7684\u72b6\u6001\u5219\u53ef\u4ee5\u679a\u4e3e\u65ad\u70b9\u3002 code time: #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=55; int f[N][N][2]; int n; int a[N]; char ch[N]; bool check(int l,int r){ int len=r-l+1; if(len&1)return 0; int mid=l+r>>1; for(int i=l;i<=mid;++i) if(a[i]!=a[i-l+mid+1])return 0; return 1; } void init(){ scanf(\"%s\",ch); n=strlen(ch); for(int i=0;i<n;++i)a[i+1]=ch[i]-'a'+1; for(int i=1;i<=n;++i) for(int j=i;j<=n;++j)f[i][j][0]=f[i][j][1]=j-i+1+1; } void dp(){ for(int l=1;l<=n;++l){ for(int i=1,j,mid;i+l-1<=n;++i){ j=i+l-1; mid=i+j>>1; if(check(i,j))f[i][j][0]=min(f[i][j][0],f[i][mid][0]+1); for(int k=i;k<j;++k){ f[i][j][0]=min(f[i][j][0],f[i][k][0]+j-k); f[i][j][1]=min(f[i][j][1],min(f[i][k][0],f[i][k][1])+min(f[k+1][j][0],f[k+1][j][1])); } } } } int main(){ init(); dp(); printf(\"%d\",min(f[1][n][0],f[1][n][1])-1); return 0; }","title":"\u7edf\u8ba1\u6700\u503c\u7c7b"},{"location":"my%20past/OI/%E5%8C%BA%E9%97%B4dp/#_2","text":"UVA10559 \u770b\u5230\u8fd9\u9898\u5f88\u5bb9\u6613\u60f3\u5230$f[i][j]$\u8868\u793a\u5c06$i$\u5230$j$\u5168\u90e8\u6d88\u9664\u80fd\u4ea7\u751f\u7684\u6700\u5927\u8d21\u732e\u3002 \u7136\u800c\uff0c\u95ee\u9898\u5728\u4e8e\uff0c\u4e0d\u4e00\u5b9a\u5c06\u8fd9\u4e2a\u533a\u95f4\u6240\u6709\u90fd\u6d88\u9664\u7684\u51b3\u7b56\u5c31\u662f\u6700\u4f18\u51b3\u7b56\uff0c\u4ed6\u4e0d\u6ee1\u8db3\u6700\u4f18\u5b50\u7ed3\u6784\uff0c\u5373\u6700\u4f18\u89e3\u4e0d\u4e00\u5b9a\u6709\u5b50\u95ee\u9898\u6700\u4f18\u89e3\u5f97\u6765\u3002 \u6bd4\u5982\uff1a\u53ef\u4ee5\u5c06\u533a\u95f4\u4e2d\u95f4\u638f\u7a7a\uff0c\u7559\u4e0b\u67d0\u4e9b\u989c\u8272\u7684\u65b9\u5757\u4e0e\u533a\u95f4\u5916\u7684\u540c\u8272\u5757\u4e00\u8d77\u6d88\u9664\u3002 \u8fd9\u662f\u8bf4\u660e\uff0c\u72b6\u6001\u63cf\u8ff0\u4e0d\u591f\u6e05\u6670\u3002\u6211\u4eec\u8981\u52a0\u7ef4\u3002 \u8bbe$f[i][j][k]$\u8868\u793a\u6d88\u9664\u533a\u95f4$i$\u5230$j$\u4ee5\u53ca\u4e0e$a[j]$\u540c\u8272\u7684\uff0c\u53f3\u8fb9\u7684$k$\u4e2a\u5757\u4ea7\u751f\u7684\u6700\u5927\u8d21\u732e\u3002 \u6b64\u65f6\u5bf9\u4e8e$j$\u548c\u5b83\u53f3\u8fb9\u7684$k$\u4e2a\u540c\u8272\u5757\u6709\u6d88\u9664\u548c\u4fdd\u7559\u4e24\u79cd\u51b3\u7b56\u3002 1) \u6d88\u9664 \u8fd9\u65f6\u53ea\u8981\u5c06$a[j]$\u4e0e\u53f3\u8fb9$k$\u4e2a\u5757\u4e00\u8d77\u6d88\u9664\u5c31\u884c\u3002\u8d21\u732e$(k+1)^2$\u3002\u5269\u4e0b\u7684\u53e6\u4f5c\u8003\u8651\u3002 $$ f[i][j][k]=max(f[i][j][k],dfs(i,j-1,0)+(k+1)* (k+1)); $$ \u81f3\u4e8e\u5c06\u8fde\u7eed$x$\u4e2a$j$\u5de6\u8fb9\u7684\u540c\u8272\u5757\u4e5f\u4e00\u540c\u6d88\u9664\u8fd9\u4e2a\u51b3\u7b56\uff0c\u4f1a\u88ab\u5305\u542b\u5728\u4fdd\u7559\u4e2d\u3002 2) \u4fdd\u7559 \u4fdd\u7559\u6307\u4fdd\u7559\u7740$j$\u548c\u5b83\u53f3\u8fb9\u7684$k$\u4e2a\u540c\u8272\u5757\uff0c\u4e0e\u533a\u95f4\u5de6\u8fb9\u7684\u4e00\u4e9b\u5757\u4e00\u8d77\u6d88\u53bb\uff0c\u5373\u7d2f\u79ef$k+1+p$\u4e2a\u540c\u8272\u5757\u4e00\u8d77\u6d88\u53bb\u3002 \u5f53\u7136\uff0c\u4e0d\u4e00\u5b9a\u8981\u5c06\u6240\u6709\u540c\u8272\u5757\u90fd\u4e00\u6b21\u6027\u6d88\u53bb\uff0c\u53ef\u80fd\u53f3\u8fb9\u4e00\u90e8\u5206\u8fde\u7eed\u6d88\u9664\uff0c\u5de6\u8fb9\u7684\u6240\u6709\u540c\u8272\u5757\u90fd\u5355\u72ec\u6d88\u9664\uff0c\u8ba9\u4ed6\u4eec\u4e2d\u95f4\u7684\u5176\u4ed6\u989c\u8272\u5757\u8fde\u7eed\u6d88\u9664\u624d\u662f\u6700\u4f73\u7b54\u6848\u3002 \u6240\u4ee5\u8981\u679a\u4e3e\u65ad\u70b9\uff0c\u800c\u8fd9\u4e2a\u65ad\u70b9\u4e0e$a[j]$\u540c\u8272\u3002\u8fd9\u4e2a\u53ef\u4ee5\u9884\u5904\u7406\u51fa$pre[j]$. $$ f[i][j][k]=max(f[i][j][k],dfs(i,p,k+1)+dfs(p+1,j-1,0)); $$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=220; int f[N][N][N]; int pre[N],vis[N],a[N]; int T,n; void init() { memset(pre,0,sizeof pre); memset(vis,0,sizeof vis); memset(f,0,sizeof f); scanf(\"%lld\",&n); for(int i=1; i<=n; ++i) { scanf(\"%lld\",&a[i]); if(vis[a[i]])pre[i]=vis[a[i]]; vis[a[i]]=i; } } int dfs(int i,int j,int k) { if(i>j)return 0; if(f[i][j][k])return f[i][j][k]; f[i][j][k]=max(f[i][j][k],dfs(i,j-1,0)+(k+1)*(k+1)); for(int p=pre[j]; p>=i; p=pre[p]) { f[i][j][k]=max(f[i][j][k],dfs(i,p,k+1)+dfs(p+1,j-1,0)); } return f[i][j][k]; } signed main() { scanf(\"%lld\",&T); for(int t=1; t<=T; ++t) { init(); printf(\"Case %lld: %lld\\n\",t,dfs(1,n,0)); } return 0; } ~~dp\u771f\u662f\u77ed\u5c0f\u7cbe\u608d\u7684\u4e1c\u897f~~ P5044 naive\u7248 \u5982\u679c\u8003\u8651$19pts$\u53ef\u4ee5\u533a\u95f4dp,$O(n^2)$. \u8bbe$f[i][j]$\u8868\u793a\u4ece$i$\u5230$j$\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002 \u9996\u5148\u8bbe$x$\u4e3a\u533a\u95f4\u6700\u5927\u503c\u7684\u4f4d\u7f6e\u3002 \u6211\u4eec\u8003\u8651\u5f53\u9009\u53d6\u7684\u70b9\u5728$x$\u5de6\u8fb9\u65f6\uff0c\u53f3\u8fb9\u7684\u70b9\u8d21\u732e\u5168\u90e8\u4e3a$a_x$,\u5de6\u8fb9\u7684\u70b9\u8d21\u732e\u5219\u4e3a$f[i][x-1]$,\u53f3\u8fb9\u540c\u7406\uff0c\u6240\u4ee5\u8f6c\u79fb\u65b9\u7a0b\uff1a $$ f[l][r]=\\min(f[l][x-1]+(r-x+1) a[x],f[x+1][r]+(x-l+1) a[x]) $$ \u7ed3\u8bba\uff1a \u8be5\u9898\u5177\u6709\u5355\u8c03\u6027\uff0c\u5373\u6bcf\u4e2a\u70b9\u7684\u8d21\u732e\u53ea\u7531\u533a\u95f4\u6700\u5927\u503c\u53ca\u5176\u4f4d\u7f6e\u51b3\u5b9a\uff0c\u8fd9\u6837\u8f6c\u79fb\u65f6\u5c31\u53ef\u4ee5\u53ea\u8003\u8651\u6700\u5927\u503c\uff0c\u964d\u4f4e\u8f6c\u79fb\u96be\u5ea6\u3002 \u627e\u5355\u8c03\u6027\u65f6\u5c31\u8981\u8003\u8651\u54ea\u4e9b\u6761\u4ef6\u4f1a\u4f7f\u8d21\u732e\u5355\u4e00\u5316\uff0c\u6bd4\u5982\u6700\u5927\u503c\u4f1a\u4f7f\u5b83\u5de6/\u53f3\u7684\u533a\u95f4\u8d21\u732e\u5168\u90e8\u53d8\u4e3a\u81ea\u5df1\u3002 P4767 naive\u7248 \u8bbe$f[i][j]$\u8868\u793a\u524d$i$\u4e2a\u6751\u5e84\u653e\u4e86$j$\u4e2a\u90ae\u5c40\u3002 \u4e00\u4e2a\u4e00\u4e2a\u8f6c\u79fb\uff0c\u65b9\u7a0b\u4e3a $$ f[i][j]=\\min_{k=0}^{i-1}(f[i][j],f[k][j-1]+w(k+1,i)) $$ \u5176\u4e2d$w(k+1,i)$\u4e3a\u8ba1\u7b97$k+1$\u5230$i$\u7684\u6700\u5c0f\u8ddd\u79bb\u548c\u3002 \u56e0\u4e3a\u6570\u5b66\u4e0a\u8ddd\u79bb\u548c\u4e00\u5b9a\u662f\u4e2d\u4f4d\u6570\u6700\u5c0f\uff0c\u6240\u4ee5\u76f4\u63a5\u66b4\u529b\u6c42\u89e3\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=1e3+10; int f[N][N]; int p,v; int a[N]; int w(int l,int r){ int mid=l+r>>1,ans=0; for(int i=l;i<=mid-1;++i)ans+=a[mid]-a[i]; for(int i=mid+1;i<=r;++i)ans+=a[i]-a[mid]; return ans; } int main(){ scanf(\"%d%d\",&v,&p); for(int i=1;i<=v;++i)scanf(\"%d\",&a[i]); memset(f,0x3f,sizeof f); f[0][0]=0; for(int i=1;i<=v;++i){ for(int j=1;j<=p;++j){ for(int k=0;k<i;++k){ f[i][j]=min(f[i][j],f[k][j-1]+w(k+1,i)); } } } printf(\"%d\",f[v][p]); return 0; } \u7ed3\u8bba\uff1a $w$\u7684\u6c42\u89e3\u5177\u6709\u5355\u8c03\u6027\uff0c\u53ef\u4ee5\u5e2e\u52a9\u7b80\u5316\u8f6c\u79fb\u3002 \u5982\u679c\u679a\u4e3e\u65ad\u70b9\u5408\u5e76\u4e24\u4e2a\u533a\u95f4\u7684\u8bdd\uff0c\u65e2\u8981\u5c06\u90ae\u5c40\u4e2a\u6570$p$\u5408\u5e76\uff0c\u53c8\u8981\u5c06\u5de6\u53f3\u7aef\u70b9$l,r$\u5408\u5e76\uff0c\u8981\u4e24\u4e2a\u65ad\u70b9\uff0c\u80af\u5b9a\u4e0d\u884c\u3002\u4e8b\u5b9e\u4e0a\uff0c\u679a\u4e3e\u65ad\u70b9\u5408\u5e76\u533a\u95f4\u53ea\u6709\u5728\u5408\u5e76\u4e24\u4e2a\u533a\u95f4\u65f6\uff0c\u4e24\u4e2a\u533a\u95f4\u4e4b\u95f4\u4f1a\u6709\u65b0\u8d21\u732e\u65f6\uff0c\u624d\u9700\u8981\u3002\u50cf\u8fd9\u9898\uff0c\u5de6\u53f3\u533a\u95f4\u5408\u5e76\u5c31\u662f\u5408\u5e76\u4e86\uff0c\u4e4b\u95f4\u6ca1\u6709\u65b0\u8d21\u732e\uff0c\u90ae\u5c40\u4e2a\u6570\u7684\u589e\u52a0\u4e5f\u6ca1\u6709\u65b0\u8d21\u732e\uff0c\u5c31\u53ef\u4ee5\u4e00\u4e2a\u4e00\u4e2a\u5730\uff0c\u4e0d\u7528\u53f3\u533a\u95f4\u503c\u5730\u8f6c\u79fb\u3002 \u8003\u8651$[1\\ 2\\ 5]\\ [6\\ 7\\ 8]$,\u8fd9\u6837\u7684\u6570\u636e\u4f1a\u51fa\u9519\uff1f\u4e0d\uff0c\u56e0\u4e3a$[1\\ 2]\\ [5\\ 6\\ 7\\ 8]$\u5373\u53ef\u6c42\u51fa\u6b63\u786e\u7b54\u6848\u3002 P4676 \u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u8bbe$f[i][j]$\u8868\u793a\u5c06 \u5b8c\u5168\u5c5e\u4e8e \u8fd9\u4e2a\u533a\u95f4\u7684\u6240\u6709\u5916\u661f\u4eba\u5168\u90e8\u6d88\u9664\u7684\u6700\u5c0f\u503c\u3002 \u90a3\u4e48\u6211\u4eec\u5148$O(n)$\u627e\u51fa\u8fd9\u4e2a\u533a\u95f4\u5185\u8ddd\u79bb\u6700\u5927\u7684\u5916\u661f\u4eba$p$\u3002\u56e0\u4e3a\u5b83\u6700\u5927\uff0c\u4e0d\u4f1a\u88ab\u522b\u4eba\u987a\u5e26\u6d88\u9664\uff0c\u6240\u4ee5\u5fc5\u6709\u4e00\u4e2a\u64cd\u4f5c\u662f\u9488\u5bf9\u8fd9\u4e2a\u6700\u5927\u5916\u661f\u4eba\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u679a\u4e3e$[a[p].l,a[p].r]$\u8fd9\u4e2a\u533a\u95f4\u7684\u65ad\u70b9\u5373\u53ef\uff0c\u90a3\u4e48\u4e1c\u7ebf\u81ea\u7136\u662f$a[p].d$,\u8f6c\u79fb\u65b9\u7a0b: $$ f[i][j]=\\min(f[i][j],f[i][k-1]+f[k+1][j]+a[p].d) $$ \u4e3a\u4ec0\u4e48\u8981\u5b8c\u5168\u5c5e\u4e8e\uff1f\u56e0\u4e3a\u5982\u679c\u8de8\u8d8a\u5f53\u524d\u533a\u95f4\u5230\u522b\u7684\u5730\u65b9\uff0c\u90a3\u4e48\u8fd9\u4e2a\u6700\u5927\u5c31\u53ef\u80fd\u88ab\u591a\u4e2a\u65ad\u70b9\u679a\u4e3e\u5230\uff0c\u76f8\u5f53\u4e8e\u7b97\u91cd\u4e86\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=660,INF=1e18; struct node{ int l,r,d; }a[N]; int f[N][N]; int b[N]; int T,n,cnt,tot; bool cmp(int a,int b){return a<b;} void lsh(){ sort(b+1,b+cnt+1,cmp); tot=unique(b+1,b+cnt+1)-b-1; for(int i=1;i<=n;++i) a[i].l=lower_bound(b+1,b+tot+1,a[i].l)-b,a[i].r=lower_bound(b+1,b+tot+1,a[i].r)-b; } void dp(){ for(int i=1;i<=tot;++i) for(int j=i;j<=tot;++j) f[i][j]=INF; for(int l=1;l<=tot;++l){ for(int i=1;i+l-1<=tot;++i){ int j=i+l-1,pos=-1,maxn=-1; for(int k=1;k<=n;++k) if(i<=a[k].l && a[k].r<=j && a[k].d>maxn) maxn=a[k].d,pos=k; if(pos==-1){f[i][j]=0;continue;} for(int k=a[pos].l;k<=a[pos].r;++k) f[i][j]=min(f[i][j],f[i][k-1]+f[k+1][j]+a[pos].d); } } printf(\"%lld\\n\",f[1][tot]); } signed main(){ scanf(\"%lld\",&T); while(T--){ scanf(\"%lld\",&n);cnt=0;tot=0; for(int i=1;i<=n;++i) scanf(\"%lld%lld%lld\",&a[i].l,&a[i].r,&a[i].d),b[++cnt]=a[i].l,b[++cnt]=a[i].r; lsh(); dp(); } return 0; } P5851 \u4e0e\u4e0a\u9762\u7c7b\u4f3c\uff0c\u53ea\u662f\u6bcf\u6b21$dp$\u662f\u518d\u679a\u4e3e\u533a\u95f4\u5c31\u4f1a\u53d8\u6210$O(n^2m)=O(n^4)$\u7684\u590d\u6742\u5ea6\uff0c\u6240\u4ee5\u6211\u4eec\u9884\u5904\u7406\u4e00\u4e0b$g[k][i][j]$,\u8868\u793a\u5bf9\u4e8e$[i,j]$\u8fd9\u4e2a\u533a\u95f4\u4e2d\u5305\u542b$k$\u70b9\u7684\uff0c\u6240\u6709\u5b50\u533a\u95f4\u7684\u6700\u5927\u503c\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=330; int a[N][N][N]; int f[N][N]; int n,m,l,r,w; void init(){ for(int k=1;k<=n;++k) for(int i=k;i>=1;--i) for(int j=k;j<=n;++j) a[k][i][j+1]=max(a[k][i][j+1],a[k][i][j]),a[k][i-1][j]=max(a[k][i-1][j],a[k][i][j]); } void dp(){ for(int l=1;l<=n;++l) for(int i=1;i+l-1<=n;++i){ int j=i+l-1; //for(int k=i;k<j;++k) f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]); for(int k=i;k<=j;++k) f[i][j]=max(f[i][j],f[i][k-1]+f[k+1][j]+a[k][i][j]); } printf(\"%lld\",f[1][n]); } signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld%lld\",&w,&l,&r); for(int k=l;k<=r;++k) a[k][l][r]=max(a[k][l][r],w); } init(); dp(); return 0; }","title":"\u8bb0\u5fc6\u5316\u641c\u7d22"},{"location":"my%20past/OI/%E5%8F%8C%E6%8C%87%E9%92%88/","text":"\u5c3a\u53d6\u6cd5 two-pointers \u7528\u9014 \u7528\u6765\u5904\u7406\u4e00\u4e9b\u5177\u6709\u5355\u8c03\u6027\u7684\u533a\u95f4\u95ee\u9898\u3002 \u4e3b\u8981\u6d41\u7a0b\u5c31\u662f\u679a\u4e3e\u4e00\u4e2a\u5de6\u7aef\u70b9$l$\uff0c\u6c42\u51fa\u5408\u6cd5\u5e8f\u5217\u5bf9\u5e94\u7684\u53f3\u7aef\u70b9$r$. \u5355\u8c03\u6027\u53ef\u80fd\u6307\u5bf9\u4e8e\u4e00\u4e2a\u5de6\u7aef\u70b9$l$\uff0c\u4e00\u4e2a\u5408\u6cd5\u7684\u5e8f\u5217\u4e3a$[l,r]$\uff0c\u90a3\u4e48$[l,r-1]$\u548c$[l+1,r]$\u4e00\u5b9a\u4e0d\u5408\u6cd5,\u7b49\u7b49\u3002\u8fd9\u5206\u522b\u4fdd\u8bc1\u4e86\u53f3\u7aef\u70b9\u4e0d\u4f1a\u5de6\u79fb\u548c\u5de6\u7aef\u70b9\u53f3\u79fb\u4e0d\u4f1a\u6f0f\u89e3\u3002 \u5c3a\u53d6\u6cd5\u7684\u590d\u6742\u5ea6\u4e00\u822c\u4e3a$O(n)$\uff0c\u56e0\u4e3a\u5355\u8c03\u6027\u4fdd\u8bc1\u5411\u53f3\u987a\u5e8f\u679a\u4e3e$l$\u65f6\uff0c$r$\u4e0d\u4f1a\u5411\u5de6\u79fb\u52a8\u3002 \"\u5c3a\u53d6\u6cd5\u5c31\u662f\u5728\u5bf9\u4e8e\u679a\u4e3e\u6bcf\u4e00\u4e2a l \u7684\u65f6\u5019,\u53e6\u4e00\u4e2a\u5750\u6807 r \u7ef4\u62a4\u7684\u7b54\u6848\u4e5f\u662f\u5355\u8c03\u7684\u65f6\u5019\u53ef\u4ee5\u4f7f\u7528,\u80fd\u591f\u5747\u644a\u679a\u4e3e\u7684\u65f6\u95f4\u4ece\u800c\u628a\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u5230 O(n) . \" \u4f8b\u9898 P1638 \u679a\u4e3e$l$\u5e76\u6c42\u51fa\u6bcf\u4e2a\u5408\u6cd5\u7684\u53f3\u7aef\u70b9$r$,\u5e76\u7edf\u8ba1\u6700\u5c0f\u503c\u5373\u53ef\u3002 #include<iostream> #include<cstdio> using namespace std; const int N=1e6+10; int n,m,el,er; int a[N],cnt[N]; int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); int l=1,r=0,now=0,ans=n+1; for(;l<=n;){ while(now<m && r<n)now+=!cnt[a[++r]]++?1:0; if(now<m)break; if(ans>r-l+1)el=l,er=r,ans=r-l+1; now-=!--cnt[a[l++]]?1:0; } printf(\"%d %d\",el,er); return 0; } UVA11572 \u5982\u679c$[l,r]$\u4e0d\u5408\u6cd5\uff0c\u5219$[l,r+1]$\u4e00\u5b9a\u4e0d\u5408\u6cd5\uff0c\u8fd9\u5c31\u4fdd\u8bc1\u5355\u8c03\u6027\uff1a\u5982\u679c$[l,r]$\u4e0d\u5408\u6cd5\uff0c\u5c31\u4e0d\u7528\u679a\u4e3e\u540e\u9762\u7684$r$\u4e86\uff0c\u76f4\u63a5\u53f3\u79fb$l$. \u6240\u6709\u7684\u5c3a\u53d6\u90fd\u662f\u53ea\u8981\u6ee1\u8db3/\u4e0d\u6ee1\u8db3\u67d0\u4e00\u6761\u4ef6\u5c31\u53ef\u4ee5\u53f3\u79fb$l$\u5e76\u4e14$r$\u4e0d\u4f1a\u5de6\u79fb\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e6+10; int T,n; int a[N],cnt[N],b[N]; bool cmp(int a,int b){ return a<b; } void init(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]),b[i]=a[i]; sort(b+1,b+n+1,cmp); int tot=unique(b+1,b+n+1)-b-1; for(int i=1;i<=n;++i)a[i]=lower_bound(b+1,b+tot+1,a[i])-b; } int main(){ scanf(\"%d\",&T); while(T--){ init(); int l=1,r=0,ans=0; memset(cnt,0,sizeof cnt); for(;l<=n;){ while(r<n){ if(cnt[a[r+1]])break; else cnt[a[++r]]++; } ans=max(ans,r-l+1); --cnt[a[l++]]; } printf(\"%d\\n\",ans); } return 0; } AT4142 \u8fd9\u9898\u4e5f\u6ee1\u8db3\u5355\u8c03\u6027\u3002 \u8bbe$a_l+...+a_r=sum_a,a_lxor...xora_r=sum_b$,\u5219\u6ee1\u8db3$sum_a\\geq sum_b$,\u6240\u4ee5\u5982\u679c$sum_a>sum_b$\uff0c\u540e\u9762\u7684$r$\u90fd\u4e0d\u7528\u679a\u4e3e\u4e86\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=2e5+10; int n; int a[N]; signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]); int l=1,r=0,sum=0,nowa=0,nowb=0; for(;l<=n;){ while(r<n){ if((nowa+a[r+1])>(nowb^a[r+1]))break; ++r; nowa+=a[r]; nowb^=a[r]; } sum+=r-l+1; nowa-=a[l]; nowb^=a[l]; l++; } printf(\"%lld\",sum); return 0; } \u4e5f\u53ef\u4ee5\u4e8c\u5206\uff0c\u5bf9\u4e8e\u6bcf\u4e2a$l$\u4e8c\u5206\u51fa\u6700\u540e\u6ee1\u8db3$sum_a=sum_b$\u7684\u53f3\u7aef\u70b9$r$,\u65f6\u95f4\u590d\u6742\u5ea6$O(nlogn)$ \u7ed3\u8bba\uff1a\u4e8c\u5206\u4e0d\u4e00\u5b9a\u8981\u4e8c\u5206\u7b54\u6848\uff0c\u4e5f\u53ef\u4ee5\u5bf9\u5de6\u7aef\u70b9\u6bcf\u6b21\u90fd\u4e8c\u5206\u53f3\u7aef\u70b9\u3002 CF47E ~~\u5c5e\u4e8e\u6709\u601d\u8def\u4f46\u5199\u4e0d\u5bf9\u4ee3\u7801\u7684\u9898\u4e86~~ \u4e00\u5f00\u59cb\u770b\u9898\u5c31\u6ce8\u610f\u5230$0<\\alpha<\\frac\\pi4$,\u8fd9\u610f\u5473\u7740\u629b\u7269\u7ebf\u7684\u9ad8\u5ea6\u548c\u8ddd\u79bb\u65f6\u5355\u8c03\u9012\u589e\u7684\u3002 $$x=\\frac{v^2\\sin2\\alpha}{g}\\y=\\frac{v\\sin\\alpha}{g}$$ \u8fd9\u6837\u5c31\u53ef\u4ee5\u7528\u5c3a\u53d6\u6cd5\u4e86,\u56e0\u4e3a\u5982\u679c\u70ae\u5f39\u6253\u5728\u5899\u4e0a\uff0c\u90a3\u4e48\u6bd4\u4ed6\u89d2\u5ea6\u5c0f\u7684\u70ae\u5f39\u4e5f\u4e00\u5b9a\u6253\u5728\u5899\u4e0a\u3002 \u5bf9\u4e8e\u6240\u6709\u70ae\u5f39\u7684\u89d2\u5ea6\u6392\u4e2a\u5e8f\uff0c\u5bf9\u5899\u7684\u6a2a\u5750\u6807\u4e5f\u6392\u4e2a\u5e8f\u3002 \u5982\u679c\u8ba1\u7b97\u51fa$y\\leq 0$\u8bf4\u660e\u6253\u5728\u5730\u4e0a\uff0c\u76f4\u63a5\u8ba1\u7b97\u5730\u4e0a\u6a2a\u5750\u6807\u3002 \u5982\u679c\u8ba1\u7b97$0<y\\leq s[l].y$,\u8bf4\u660e\u6253\u5728\u5899\u4e0a\u3002 \u6700\u540e\u76f4\u63a5\u8f93\u51fa$ans[i]$\u5373\u53ef\u3002 CF430B \u8fd9\u9898\u63d0\u9192\u6211\u4eec\u53cc\u6307\u9488\u4e0d\u4e00\u5b9a\u8981\u50cf\"\u5c3a\"\u4e00\u6837\u4ece\u5de6\u5230\u53f3\u626b\u533a\u95f4\uff0c\u8fd8\u53ef\u4ee5\u4ece\u4e2d\u95f4\u5411\u4e24\u8fb9\u6269\u6563\u3002 \u6ce8\u610f\u7b2c\u4e00\u6b21\u7684\u8ba1\u6570$cnt-1$. #include<iostream> #include<cstdio> using namespace std; const int N=220; int n,k,x,maxn; int a[N]; int main(){ scanf(\"%d%d%d\",&n,&k,&x); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=0;i<=n;++i){ int l=i,r=i+1,now=x,cnt=1,ans=0,flag=-1; for(int time=1;;time++){ while(l>=1 && now==a[l])--l,++cnt; while(r<=n && now==a[r])++r,++cnt; if(cnt<=2)break; ans+=cnt+flag; if(a[l]!=a[r] || l==0 && r==n+1)break; now=a[l]; cnt=0; flag=0; } maxn=max(maxn,ans); } printf(\"%d\",maxn); return 0; } /* 50 2 1 1 1 2 2 1 2 1 1 2 2 1 2 1 2 1 1 2 2 1 2 1 2 2 1 2 1 2 1 2 2 1 1 2 2 1 1 2 2 1 2 1 1 2 1 1 2 2 1 1 2 */ CF939E \u8d2a\u5fc3\u5c3a\u53d6\u6cd5\u3002 \u6709\u4e24\u6761\u91cd\u8981\u6027\u8d28\u3002 1) \u5bf9\u4e8e\u4e00\u4e2a\u52a0\u5165\u7684\u65b0\u6570\u4e00\u5b9a\u8981\u9009\u3002 $$ \u539f\u5f0f ans=Max-\\frac{sum}{n}\\ \u8003\u8651\u7528\u65b0\u7684\u6700\u5927\u66ff\u6362\u6389\u539f\u6765\u7684\u6700\u5927\uff0c\u8bbe\u65b0\u7684\u6700\u5927\u6bd4\u539f\u6765\u6700\u5927\u5927 \\Delta(x)\\ ans=\\frac{(Max+\\Delta(x))\\times n-(sum+\\Delta(x))}{n}\\ \u56e0\u4e3a n\\geq 1\uff0cans\u4e00\u5b9a\u53d8\u5927\uff08\u4f18\u79c0\uff09 $$ 2) \u5bf9\u4e8e\u96c6\u5408 s \u5269\u4e0b\u7684\u6570\uff0c\u4e00\u5b9a\u662f\u9009\u524d\u9762\u51e0\u4e2a\u5c0f\u7684\u6570\uff0c\u5e76\u4e14\u9009\u7684\u6570\u7684\u4e2a\u6570\u662f\u5355\u8c03\u4e0d\u51cf\u7684\u3002 \u53ef\u4ee5\u610f\u4f1a\u4e00\u4e0b\u8bc1\u660e\uff0c\u4e00\u5b9a\u662f\u9009\u6bd4\u5f53\u524d\u96c6\u5408\u5e73\u5747\u6570\u5c0f\u7684\u6570\u52a0\u8fdb\u6765\uff0c\u4f7f\u5e73\u5747\u6570\u66f4\u5c0f\uff0c\u7b54\u6848\u624d\u4f1a\u53d8\u5f97\u66f4\u5927\u3002 $$ \u539f\u5f0f ans=Max-\\frac{sum}{n}\\ \u8003\u8651\u65b0\u52a0\u4e00\u4e2a\u6570 \\Delta(x)\\ \u65b0\u7684\u5f0f\u5b50 ans=Max-\\frac{sum+\\Delta(x)}{n+1}\\ \u82e5\u65b0\u5f0f\u51cf\u53bb\u539f\u5f0f>0\uff0c\u5219\u65b0\u5f0f\u66f4\u4f18\u79c0\\ \u65b0\u5f0f\u51cf\u539f\u5f0f\u5f97\\ -\\frac{sum+\\Delta(x)}{n+1}+\\frac{sum}{n}\\ \u7b49\u4e8e\\ \\frac{sum-n\\times \\Delta(x)}{n\\times(n+1)}>0\\ \u5f97\u51fa\u66f4\u4f18\u79c0\u6761\u4ef6\u4e3a\uff1asum-n\\times \\Delta(x)>0\uff0c\u5373 \\Delta(x) <\\frac{sum}{n}\\ $$ \u8bc1\u6bd5\uff0c\u53ef\u4ee5\u7528\u5c3a\u53d6\u6cd5\u3002 #include<iostream> #include<cstdio> #include<cstring> #define db double #define int long long using namespace std; const int N=5e5+10; int n,cnt,tot; int vis[N],q[N]; db res[N],a[N],sum[N]; int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void work(){ int l=1,r=0; db ans=-1.0; for(int i=1;i<=cnt;++i)sum[i]=sum[i-1]+a[i]; for(int i=1;i<=cnt;++i){ if(!vis[i])continue; ans=-1.0; while(l<=i){ db tmp=(double)(a[i]-(double)(sum[l]+a[i])/(l+1)); if(tmp>ans)ans=tmp,++l; else{ --l; break; } } if(l==i+1)--l; res[i]=ans; } for(int i=1;i<=tot;++i)printf(\"%.10lf\\n\",res[q[i]]); } signed main(){ cnt=0,tot=0; n=read1(); for(int i=1,op;i<=n;++i){ op=read1(); if(op==1){ a[++cnt]=(double)read1(); }else{ vis[cnt]=1; q[++tot]=cnt; } } work(); return 0; }","title":"\u5c3a\u53d6\u6cd5 two-pointers"},{"location":"my%20past/OI/%E5%8F%8C%E6%8C%87%E9%92%88/#two-pointers","text":"","title":"\u5c3a\u53d6\u6cd5 two-pointers"},{"location":"my%20past/OI/%E5%8F%8C%E6%8C%87%E9%92%88/#_1","text":"\u7528\u6765\u5904\u7406\u4e00\u4e9b\u5177\u6709\u5355\u8c03\u6027\u7684\u533a\u95f4\u95ee\u9898\u3002 \u4e3b\u8981\u6d41\u7a0b\u5c31\u662f\u679a\u4e3e\u4e00\u4e2a\u5de6\u7aef\u70b9$l$\uff0c\u6c42\u51fa\u5408\u6cd5\u5e8f\u5217\u5bf9\u5e94\u7684\u53f3\u7aef\u70b9$r$. \u5355\u8c03\u6027\u53ef\u80fd\u6307\u5bf9\u4e8e\u4e00\u4e2a\u5de6\u7aef\u70b9$l$\uff0c\u4e00\u4e2a\u5408\u6cd5\u7684\u5e8f\u5217\u4e3a$[l,r]$\uff0c\u90a3\u4e48$[l,r-1]$\u548c$[l+1,r]$\u4e00\u5b9a\u4e0d\u5408\u6cd5,\u7b49\u7b49\u3002\u8fd9\u5206\u522b\u4fdd\u8bc1\u4e86\u53f3\u7aef\u70b9\u4e0d\u4f1a\u5de6\u79fb\u548c\u5de6\u7aef\u70b9\u53f3\u79fb\u4e0d\u4f1a\u6f0f\u89e3\u3002 \u5c3a\u53d6\u6cd5\u7684\u590d\u6742\u5ea6\u4e00\u822c\u4e3a$O(n)$\uff0c\u56e0\u4e3a\u5355\u8c03\u6027\u4fdd\u8bc1\u5411\u53f3\u987a\u5e8f\u679a\u4e3e$l$\u65f6\uff0c$r$\u4e0d\u4f1a\u5411\u5de6\u79fb\u52a8\u3002 \"\u5c3a\u53d6\u6cd5\u5c31\u662f\u5728\u5bf9\u4e8e\u679a\u4e3e\u6bcf\u4e00\u4e2a l \u7684\u65f6\u5019,\u53e6\u4e00\u4e2a\u5750\u6807 r \u7ef4\u62a4\u7684\u7b54\u6848\u4e5f\u662f\u5355\u8c03\u7684\u65f6\u5019\u53ef\u4ee5\u4f7f\u7528,\u80fd\u591f\u5747\u644a\u679a\u4e3e\u7684\u65f6\u95f4\u4ece\u800c\u628a\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u5230 O(n) . \"","title":"\u7528\u9014"},{"location":"my%20past/OI/%E5%8F%8C%E6%8C%87%E9%92%88/#_2","text":"P1638 \u679a\u4e3e$l$\u5e76\u6c42\u51fa\u6bcf\u4e2a\u5408\u6cd5\u7684\u53f3\u7aef\u70b9$r$,\u5e76\u7edf\u8ba1\u6700\u5c0f\u503c\u5373\u53ef\u3002 #include<iostream> #include<cstdio> using namespace std; const int N=1e6+10; int n,m,el,er; int a[N],cnt[N]; int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); int l=1,r=0,now=0,ans=n+1; for(;l<=n;){ while(now<m && r<n)now+=!cnt[a[++r]]++?1:0; if(now<m)break; if(ans>r-l+1)el=l,er=r,ans=r-l+1; now-=!--cnt[a[l++]]?1:0; } printf(\"%d %d\",el,er); return 0; } UVA11572 \u5982\u679c$[l,r]$\u4e0d\u5408\u6cd5\uff0c\u5219$[l,r+1]$\u4e00\u5b9a\u4e0d\u5408\u6cd5\uff0c\u8fd9\u5c31\u4fdd\u8bc1\u5355\u8c03\u6027\uff1a\u5982\u679c$[l,r]$\u4e0d\u5408\u6cd5\uff0c\u5c31\u4e0d\u7528\u679a\u4e3e\u540e\u9762\u7684$r$\u4e86\uff0c\u76f4\u63a5\u53f3\u79fb$l$. \u6240\u6709\u7684\u5c3a\u53d6\u90fd\u662f\u53ea\u8981\u6ee1\u8db3/\u4e0d\u6ee1\u8db3\u67d0\u4e00\u6761\u4ef6\u5c31\u53ef\u4ee5\u53f3\u79fb$l$\u5e76\u4e14$r$\u4e0d\u4f1a\u5de6\u79fb\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e6+10; int T,n; int a[N],cnt[N],b[N]; bool cmp(int a,int b){ return a<b; } void init(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]),b[i]=a[i]; sort(b+1,b+n+1,cmp); int tot=unique(b+1,b+n+1)-b-1; for(int i=1;i<=n;++i)a[i]=lower_bound(b+1,b+tot+1,a[i])-b; } int main(){ scanf(\"%d\",&T); while(T--){ init(); int l=1,r=0,ans=0; memset(cnt,0,sizeof cnt); for(;l<=n;){ while(r<n){ if(cnt[a[r+1]])break; else cnt[a[++r]]++; } ans=max(ans,r-l+1); --cnt[a[l++]]; } printf(\"%d\\n\",ans); } return 0; } AT4142 \u8fd9\u9898\u4e5f\u6ee1\u8db3\u5355\u8c03\u6027\u3002 \u8bbe$a_l+...+a_r=sum_a,a_lxor...xora_r=sum_b$,\u5219\u6ee1\u8db3$sum_a\\geq sum_b$,\u6240\u4ee5\u5982\u679c$sum_a>sum_b$\uff0c\u540e\u9762\u7684$r$\u90fd\u4e0d\u7528\u679a\u4e3e\u4e86\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=2e5+10; int n; int a[N]; signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]); int l=1,r=0,sum=0,nowa=0,nowb=0; for(;l<=n;){ while(r<n){ if((nowa+a[r+1])>(nowb^a[r+1]))break; ++r; nowa+=a[r]; nowb^=a[r]; } sum+=r-l+1; nowa-=a[l]; nowb^=a[l]; l++; } printf(\"%lld\",sum); return 0; } \u4e5f\u53ef\u4ee5\u4e8c\u5206\uff0c\u5bf9\u4e8e\u6bcf\u4e2a$l$\u4e8c\u5206\u51fa\u6700\u540e\u6ee1\u8db3$sum_a=sum_b$\u7684\u53f3\u7aef\u70b9$r$,\u65f6\u95f4\u590d\u6742\u5ea6$O(nlogn)$ \u7ed3\u8bba\uff1a\u4e8c\u5206\u4e0d\u4e00\u5b9a\u8981\u4e8c\u5206\u7b54\u6848\uff0c\u4e5f\u53ef\u4ee5\u5bf9\u5de6\u7aef\u70b9\u6bcf\u6b21\u90fd\u4e8c\u5206\u53f3\u7aef\u70b9\u3002 CF47E ~~\u5c5e\u4e8e\u6709\u601d\u8def\u4f46\u5199\u4e0d\u5bf9\u4ee3\u7801\u7684\u9898\u4e86~~ \u4e00\u5f00\u59cb\u770b\u9898\u5c31\u6ce8\u610f\u5230$0<\\alpha<\\frac\\pi4$,\u8fd9\u610f\u5473\u7740\u629b\u7269\u7ebf\u7684\u9ad8\u5ea6\u548c\u8ddd\u79bb\u65f6\u5355\u8c03\u9012\u589e\u7684\u3002 $$x=\\frac{v^2\\sin2\\alpha}{g}\\y=\\frac{v\\sin\\alpha}{g}$$ \u8fd9\u6837\u5c31\u53ef\u4ee5\u7528\u5c3a\u53d6\u6cd5\u4e86,\u56e0\u4e3a\u5982\u679c\u70ae\u5f39\u6253\u5728\u5899\u4e0a\uff0c\u90a3\u4e48\u6bd4\u4ed6\u89d2\u5ea6\u5c0f\u7684\u70ae\u5f39\u4e5f\u4e00\u5b9a\u6253\u5728\u5899\u4e0a\u3002 \u5bf9\u4e8e\u6240\u6709\u70ae\u5f39\u7684\u89d2\u5ea6\u6392\u4e2a\u5e8f\uff0c\u5bf9\u5899\u7684\u6a2a\u5750\u6807\u4e5f\u6392\u4e2a\u5e8f\u3002 \u5982\u679c\u8ba1\u7b97\u51fa$y\\leq 0$\u8bf4\u660e\u6253\u5728\u5730\u4e0a\uff0c\u76f4\u63a5\u8ba1\u7b97\u5730\u4e0a\u6a2a\u5750\u6807\u3002 \u5982\u679c\u8ba1\u7b97$0<y\\leq s[l].y$,\u8bf4\u660e\u6253\u5728\u5899\u4e0a\u3002 \u6700\u540e\u76f4\u63a5\u8f93\u51fa$ans[i]$\u5373\u53ef\u3002 CF430B \u8fd9\u9898\u63d0\u9192\u6211\u4eec\u53cc\u6307\u9488\u4e0d\u4e00\u5b9a\u8981\u50cf\"\u5c3a\"\u4e00\u6837\u4ece\u5de6\u5230\u53f3\u626b\u533a\u95f4\uff0c\u8fd8\u53ef\u4ee5\u4ece\u4e2d\u95f4\u5411\u4e24\u8fb9\u6269\u6563\u3002 \u6ce8\u610f\u7b2c\u4e00\u6b21\u7684\u8ba1\u6570$cnt-1$. #include<iostream> #include<cstdio> using namespace std; const int N=220; int n,k,x,maxn; int a[N]; int main(){ scanf(\"%d%d%d\",&n,&k,&x); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=0;i<=n;++i){ int l=i,r=i+1,now=x,cnt=1,ans=0,flag=-1; for(int time=1;;time++){ while(l>=1 && now==a[l])--l,++cnt; while(r<=n && now==a[r])++r,++cnt; if(cnt<=2)break; ans+=cnt+flag; if(a[l]!=a[r] || l==0 && r==n+1)break; now=a[l]; cnt=0; flag=0; } maxn=max(maxn,ans); } printf(\"%d\",maxn); return 0; } /* 50 2 1 1 1 2 2 1 2 1 1 2 2 1 2 1 2 1 1 2 2 1 2 1 2 2 1 2 1 2 1 2 2 1 1 2 2 1 1 2 2 1 2 1 1 2 1 1 2 2 1 1 2 */ CF939E \u8d2a\u5fc3\u5c3a\u53d6\u6cd5\u3002 \u6709\u4e24\u6761\u91cd\u8981\u6027\u8d28\u3002 1) \u5bf9\u4e8e\u4e00\u4e2a\u52a0\u5165\u7684\u65b0\u6570\u4e00\u5b9a\u8981\u9009\u3002 $$ \u539f\u5f0f ans=Max-\\frac{sum}{n}\\ \u8003\u8651\u7528\u65b0\u7684\u6700\u5927\u66ff\u6362\u6389\u539f\u6765\u7684\u6700\u5927\uff0c\u8bbe\u65b0\u7684\u6700\u5927\u6bd4\u539f\u6765\u6700\u5927\u5927 \\Delta(x)\\ ans=\\frac{(Max+\\Delta(x))\\times n-(sum+\\Delta(x))}{n}\\ \u56e0\u4e3a n\\geq 1\uff0cans\u4e00\u5b9a\u53d8\u5927\uff08\u4f18\u79c0\uff09 $$ 2) \u5bf9\u4e8e\u96c6\u5408 s \u5269\u4e0b\u7684\u6570\uff0c\u4e00\u5b9a\u662f\u9009\u524d\u9762\u51e0\u4e2a\u5c0f\u7684\u6570\uff0c\u5e76\u4e14\u9009\u7684\u6570\u7684\u4e2a\u6570\u662f\u5355\u8c03\u4e0d\u51cf\u7684\u3002 \u53ef\u4ee5\u610f\u4f1a\u4e00\u4e0b\u8bc1\u660e\uff0c\u4e00\u5b9a\u662f\u9009\u6bd4\u5f53\u524d\u96c6\u5408\u5e73\u5747\u6570\u5c0f\u7684\u6570\u52a0\u8fdb\u6765\uff0c\u4f7f\u5e73\u5747\u6570\u66f4\u5c0f\uff0c\u7b54\u6848\u624d\u4f1a\u53d8\u5f97\u66f4\u5927\u3002 $$ \u539f\u5f0f ans=Max-\\frac{sum}{n}\\ \u8003\u8651\u65b0\u52a0\u4e00\u4e2a\u6570 \\Delta(x)\\ \u65b0\u7684\u5f0f\u5b50 ans=Max-\\frac{sum+\\Delta(x)}{n+1}\\ \u82e5\u65b0\u5f0f\u51cf\u53bb\u539f\u5f0f>0\uff0c\u5219\u65b0\u5f0f\u66f4\u4f18\u79c0\\ \u65b0\u5f0f\u51cf\u539f\u5f0f\u5f97\\ -\\frac{sum+\\Delta(x)}{n+1}+\\frac{sum}{n}\\ \u7b49\u4e8e\\ \\frac{sum-n\\times \\Delta(x)}{n\\times(n+1)}>0\\ \u5f97\u51fa\u66f4\u4f18\u79c0\u6761\u4ef6\u4e3a\uff1asum-n\\times \\Delta(x)>0\uff0c\u5373 \\Delta(x) <\\frac{sum}{n}\\ $$ \u8bc1\u6bd5\uff0c\u53ef\u4ee5\u7528\u5c3a\u53d6\u6cd5\u3002 #include<iostream> #include<cstdio> #include<cstring> #define db double #define int long long using namespace std; const int N=5e5+10; int n,cnt,tot; int vis[N],q[N]; db res[N],a[N],sum[N]; int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void work(){ int l=1,r=0; db ans=-1.0; for(int i=1;i<=cnt;++i)sum[i]=sum[i-1]+a[i]; for(int i=1;i<=cnt;++i){ if(!vis[i])continue; ans=-1.0; while(l<=i){ db tmp=(double)(a[i]-(double)(sum[l]+a[i])/(l+1)); if(tmp>ans)ans=tmp,++l; else{ --l; break; } } if(l==i+1)--l; res[i]=ans; } for(int i=1;i<=tot;++i)printf(\"%.10lf\\n\",res[q[i]]); } signed main(){ cnt=0,tot=0; n=read1(); for(int i=1,op;i<=n;++i){ op=read1(); if(op==1){ a[++cnt]=(double)read1(); }else{ vis[cnt]=1; q[++tot]=cnt; } } work(); return 0; }","title":"\u4f8b\u9898"},{"location":"my%20past/OI/%E5%9B%BE%E8%AE%BA/","text":"\u56fe\u8bba P5881 \u8bbe\u5bf9\u4e8e\u6bcf\u4e2a\u6570$i$\u7684\u6574\u6570\u56e0\u5f0f\u90e8\u5206\u4e3a$h(i)$,\u5219$gcsd(x,y)=h(gcd(x,y))^2=gcd(h(x),h(y))^2$ \u539f\u95ee\u9898\u662f\u5bf9\u4e8e\u6240\u6709$gcsd(x,y)>x$\u7684\u6570\u8fde\u8fb9\uff0c\u6c42\u51fa\u6240\u6709\u8fde\u901a\u5757\u4e2a\u6570\u4ee5\u53ca\u5757\u5185\u6700\u5927$c_i$\u7684\u548c\u3002 \u6240\u4ee5\u7528\u7ebf\u6027\u7b5b\u6c42\u51fa\u6bcf\u4e2a\u6570\u7684$h(i)$,\u5bf9\u4e8e$h(a_i) \\leq x$\u7684\u6570$a_i$\uff0c\u53ef\u4ee5\u76f4\u63a5\u629b\u5f03\uff0c\u56e0\u4e3a\u4ed6\u4eec\u81ea\u59cb\u81f3\u7ec8\u4e0d\u4f1a\u4ea7\u751f\u8fb9\u3002 \u5bf9\u4e8e$h(a_i)>x$,\u5b83\u4eec\u7684\u5927\u5c0f\u4e0d\u4f1a\u8d85\u8fc7$\\sqrt a$,\u6240\u4ee5\u53ea\u9700\u8981$\\sqrt a$\u4e2a\u70b9\u5c31\u53ef\u4ee5\u89e3\u51b3\uff0c$h(a_i)$\u76f8\u540c\u7684\u6570\u53ef\u4ee5\u770b\u6210\u4e00\u4e2a\u70b9\uff0c$c$\u5c31\u662f\u6700\u5927\u503c\u3002 \u8fd9\u6837\uff0c\u5bf9\u4e8e$x$\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\u540e\uff0c\u518d\u4e00\u6b21\u5411\u56fe\u4e2d\u52a0\u8fb9\uff0c\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u7b54\u6848\u5373\u53ef\u3002 \u7ed3\u8bba\uff1a 1) \u5bf9\u4e8e\u8fb9\u6570\u8f83\u591a\u7684\u60c5\u51b5\uff0c\u5982\u679c\u6240\u6709\u8fb9\u90fd\u662f\u4e00\u4e2a\u4e00\u4e2a\u533a\u95f4\u5730\u52a0\u5165\uff0c\u5c31\u53ef\u4ee5\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe\uff1b\u5426\u5219\uff0c\u5c31\u8981\u601d\u8003\u5220\u70b9\u5220\u8fb9\uff0c\u5c06\u4e0d\u4f1a\u6d89\u53ca\u5230\u7684\u70b9\u53bb\u9664\u3002 2) \u7ebf\u6027\u7b5b\u7684\u597d\u5904\u5c31\u662f\uff0c\u5bf9\u6bcf\u4e2a\u6570\u90fd\u53ea\u9700\u8981\u8003\u8651\u5b83\u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u56e0\u4e3a\u5728\u5b83\u4e4b\u524d\u7684\u6570\u5df2\u7ecf\u6c42\u597d\u4e86\uff0c\u800c\u8fd9\u4e00\u6b65\u4e00\u5b9a\u662f\u7531\u6700\u5c0f\u8d28\u56e0\u5b50\u7b5b\u51fa\u6765\u7684\u3002\u4e0d\u4ec5\u662f\u7b5b\u6cd5\uff0c\u8bb8\u591adp\u4e5f\u9075\u5faa\u8fd9\u6837\u7684\u5355\u8c03\u6027\u66f4\u65b0\u539f\u5219\u3002\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u7ef4\u62a4\u7684\u4e1c\u897f\uff0c\u5982\u8fd9\u9898\u4ece\u7ef4\u62a4\u6240\u6709\u7684\u8d28\u56e0\u5b50\u53d8\u6210\u53ea\u9700\u8981\u7ef4\u62a4\u6700\u5c0f\u8d28\u56e0\u5b50\u3002","title":"\u56fe\u8bba"},{"location":"my%20past/OI/%E5%9B%BE%E8%AE%BA/#_1","text":"P5881 \u8bbe\u5bf9\u4e8e\u6bcf\u4e2a\u6570$i$\u7684\u6574\u6570\u56e0\u5f0f\u90e8\u5206\u4e3a$h(i)$,\u5219$gcsd(x,y)=h(gcd(x,y))^2=gcd(h(x),h(y))^2$ \u539f\u95ee\u9898\u662f\u5bf9\u4e8e\u6240\u6709$gcsd(x,y)>x$\u7684\u6570\u8fde\u8fb9\uff0c\u6c42\u51fa\u6240\u6709\u8fde\u901a\u5757\u4e2a\u6570\u4ee5\u53ca\u5757\u5185\u6700\u5927$c_i$\u7684\u548c\u3002 \u6240\u4ee5\u7528\u7ebf\u6027\u7b5b\u6c42\u51fa\u6bcf\u4e2a\u6570\u7684$h(i)$,\u5bf9\u4e8e$h(a_i) \\leq x$\u7684\u6570$a_i$\uff0c\u53ef\u4ee5\u76f4\u63a5\u629b\u5f03\uff0c\u56e0\u4e3a\u4ed6\u4eec\u81ea\u59cb\u81f3\u7ec8\u4e0d\u4f1a\u4ea7\u751f\u8fb9\u3002 \u5bf9\u4e8e$h(a_i)>x$,\u5b83\u4eec\u7684\u5927\u5c0f\u4e0d\u4f1a\u8d85\u8fc7$\\sqrt a$,\u6240\u4ee5\u53ea\u9700\u8981$\\sqrt a$\u4e2a\u70b9\u5c31\u53ef\u4ee5\u89e3\u51b3\uff0c$h(a_i)$\u76f8\u540c\u7684\u6570\u53ef\u4ee5\u770b\u6210\u4e00\u4e2a\u70b9\uff0c$c$\u5c31\u662f\u6700\u5927\u503c\u3002 \u8fd9\u6837\uff0c\u5bf9\u4e8e$x$\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\u540e\uff0c\u518d\u4e00\u6b21\u5411\u56fe\u4e2d\u52a0\u8fb9\uff0c\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u7b54\u6848\u5373\u53ef\u3002 \u7ed3\u8bba\uff1a 1) \u5bf9\u4e8e\u8fb9\u6570\u8f83\u591a\u7684\u60c5\u51b5\uff0c\u5982\u679c\u6240\u6709\u8fb9\u90fd\u662f\u4e00\u4e2a\u4e00\u4e2a\u533a\u95f4\u5730\u52a0\u5165\uff0c\u5c31\u53ef\u4ee5\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe\uff1b\u5426\u5219\uff0c\u5c31\u8981\u601d\u8003\u5220\u70b9\u5220\u8fb9\uff0c\u5c06\u4e0d\u4f1a\u6d89\u53ca\u5230\u7684\u70b9\u53bb\u9664\u3002 2) \u7ebf\u6027\u7b5b\u7684\u597d\u5904\u5c31\u662f\uff0c\u5bf9\u6bcf\u4e2a\u6570\u90fd\u53ea\u9700\u8981\u8003\u8651\u5b83\u7684\u6700\u5c0f\u8d28\u56e0\u5b50\uff0c\u56e0\u4e3a\u5728\u5b83\u4e4b\u524d\u7684\u6570\u5df2\u7ecf\u6c42\u597d\u4e86\uff0c\u800c\u8fd9\u4e00\u6b65\u4e00\u5b9a\u662f\u7531\u6700\u5c0f\u8d28\u56e0\u5b50\u7b5b\u51fa\u6765\u7684\u3002\u4e0d\u4ec5\u662f\u7b5b\u6cd5\uff0c\u8bb8\u591adp\u4e5f\u9075\u5faa\u8fd9\u6837\u7684\u5355\u8c03\u6027\u66f4\u65b0\u539f\u5219\u3002\u8fd9\u6837\u53ef\u4ee5\u51cf\u5c11\u7ef4\u62a4\u7684\u4e1c\u897f\uff0c\u5982\u8fd9\u9898\u4ece\u7ef4\u62a4\u6240\u6709\u7684\u8d28\u56e0\u5b50\u53d8\u6210\u53ea\u9700\u8981\u7ef4\u62a4\u6700\u5c0f\u8d28\u56e0\u5b50\u3002","title":"\u56fe\u8bba"},{"location":"my%20past/OI/%E5%A4%8D%E6%9D%82%E5%BA%A6/","text":"\u770b\u4f3c\u9519\u8bef\u7684\u590d\u6742\u5ea6\u7684\u6e10\u8fd1\u5904\u7406 \u5806\u7684\u5efa\u7acb $\\Theta(nlogn)$ \u5f53\u6211\u4eec\u8bd5\u56fe\u5c06n\u4e2a\u6570\u7b80\u79f0\u5806\u65f6\uff0c\u4e00\u822c\u8ba4\u4e3a\u5c06\u6240\u6709\u6570\u66b4\u529b\u52a0\u5165\u5806\uff0c\u4e00\u6b21\u590d\u6742\u5ea6$\\Theta(logn)$\uff0c\u603b\u590d\u6742\u5ea6\u4e3a$\\Theta(nlogn)$\uff0c\u4e8b\u5b9e\u4e0a\uff0c\u5176\u6e10\u8fd1\u590d\u6742\u5ea6\u4e3a$\\Theta(n)$ \u8bbe$\\Theta(h)$\u8868\u793a\u9ad8\u5ea6\u4e3ah\u7684\u6570\u52a0\u5165\u5806\u7684\u590d\u6742\u5ea6 \u603b\u4ee3\u4ef7\u4e3a $$\\sum_{h=0}^{\\lfloor logn\\rfloor}\\lceil \\frac{n}{2^{h+1}} \\rceil\\Theta(h)=\\Theta(n\\sum_{h=0}^{\\lfloor logn\\rfloor}\\frac{h}{2^{h}}) \\ \u53c8\\because \u6839\u636e\u7b49\u6bd4\u6570\u5217\u6c42\u548c\uff0c\\sum_{h=0}^{n}\\frac{h}{2^{h}}=2-\\frac{1}{2^{n-1}}-n\\frac{1}{2^n}\\ \\therefore \\sum_{h=0}^{n}\\frac{h}{2^{h}}=2(n->+\\infty) \\therefore \\Theta(2n) $$ \u5f00\u5e73\u65b9 & \u53d6\u5bf9\u6570 \u8fd9\u4e24\u79cd\u64cd\u4f5c\u4e00\u822c\u4e0d\u8d85\u8fc710\uff0c\u4e3a\u5e38\u6570\u7ea7\u522b \u4f8b\uff1a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u6240\u6709\u6570\u5f00\u5e73\u65b9\uff0c\u56e0\u4e3a\u5f006\u6b21\u4ee5\u5185\u5c31\u80fd\u5f97\u52301\u62160\uff0c\u6240\u4ee5\u590d\u6742\u5ea6$\\Theta(6nlogn)$,\u800c\u4e0d\u662f$\\Theta(mnlogn)$ \u9636\u4e58 & \u8d28\u6570\u8fde\u4e58 \u8fd9\u4e24\u79cd\u64cd\u4f5c\u4e00\u822c\u4e0d\u8d85\u8fc710\uff0c\u4e3a\u5e38\u6570\u7ea7\u522b \u4f8b\uff1a\u5bf9\u4e8e\u4e24\u4e2a\u96c6\u5408\uff0c\u53ea\u8981\u5176\u4e2d\u4e24\u4e2a\u6570\u6709>=p\u7684\u8d28\u56e0\u6570\uff0c\u5219\u5408\u5e76\u4e24\u4e2a\u96c6\u5408\uff0c\u95ee[a,b]\u5185\u5171\u6709\u591a\u5c11\u96c6\u5408\u3002\u56e0\u4e3a\u4e00\u4e2a\u6570\u6700\u591a\u67096\u4e2a\u8d28\u56e0\u6570\uff0c\u6240\u4ee5\u590d\u6742\u5ea6$\\Theta(6n)$,\u800c\u4e0d\u662f$\\Theta(n^2)$","title":"\u770b\u4f3c\u9519\u8bef\u7684\u590d\u6742\u5ea6\u7684\u6e10\u8fd1\u5904\u7406"},{"location":"my%20past/OI/%E5%A4%8D%E6%9D%82%E5%BA%A6/#_1","text":"","title":"\u770b\u4f3c\u9519\u8bef\u7684\u590d\u6742\u5ea6\u7684\u6e10\u8fd1\u5904\u7406"},{"location":"my%20past/OI/%E5%A4%8D%E6%9D%82%E5%BA%A6/#thetanlogn","text":"\u5f53\u6211\u4eec\u8bd5\u56fe\u5c06n\u4e2a\u6570\u7b80\u79f0\u5806\u65f6\uff0c\u4e00\u822c\u8ba4\u4e3a\u5c06\u6240\u6709\u6570\u66b4\u529b\u52a0\u5165\u5806\uff0c\u4e00\u6b21\u590d\u6742\u5ea6$\\Theta(logn)$\uff0c\u603b\u590d\u6742\u5ea6\u4e3a$\\Theta(nlogn)$\uff0c\u4e8b\u5b9e\u4e0a\uff0c\u5176\u6e10\u8fd1\u590d\u6742\u5ea6\u4e3a$\\Theta(n)$ \u8bbe$\\Theta(h)$\u8868\u793a\u9ad8\u5ea6\u4e3ah\u7684\u6570\u52a0\u5165\u5806\u7684\u590d\u6742\u5ea6 \u603b\u4ee3\u4ef7\u4e3a $$\\sum_{h=0}^{\\lfloor logn\\rfloor}\\lceil \\frac{n}{2^{h+1}} \\rceil\\Theta(h)=\\Theta(n\\sum_{h=0}^{\\lfloor logn\\rfloor}\\frac{h}{2^{h}}) \\ \u53c8\\because \u6839\u636e\u7b49\u6bd4\u6570\u5217\u6c42\u548c\uff0c\\sum_{h=0}^{n}\\frac{h}{2^{h}}=2-\\frac{1}{2^{n-1}}-n\\frac{1}{2^n}\\ \\therefore \\sum_{h=0}^{n}\\frac{h}{2^{h}}=2(n->+\\infty) \\therefore \\Theta(2n) $$","title":"\u5806\u7684\u5efa\u7acb $\\Theta(nlogn)$"},{"location":"my%20past/OI/%E5%A4%8D%E6%9D%82%E5%BA%A6/#_2","text":"\u8fd9\u4e24\u79cd\u64cd\u4f5c\u4e00\u822c\u4e0d\u8d85\u8fc710\uff0c\u4e3a\u5e38\u6570\u7ea7\u522b \u4f8b\uff1a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u6240\u6709\u6570\u5f00\u5e73\u65b9\uff0c\u56e0\u4e3a\u5f006\u6b21\u4ee5\u5185\u5c31\u80fd\u5f97\u52301\u62160\uff0c\u6240\u4ee5\u590d\u6742\u5ea6$\\Theta(6nlogn)$,\u800c\u4e0d\u662f$\\Theta(mnlogn)$","title":"\u5f00\u5e73\u65b9 &amp; \u53d6\u5bf9\u6570"},{"location":"my%20past/OI/%E5%A4%8D%E6%9D%82%E5%BA%A6/#_3","text":"\u8fd9\u4e24\u79cd\u64cd\u4f5c\u4e00\u822c\u4e0d\u8d85\u8fc710\uff0c\u4e3a\u5e38\u6570\u7ea7\u522b \u4f8b\uff1a\u5bf9\u4e8e\u4e24\u4e2a\u96c6\u5408\uff0c\u53ea\u8981\u5176\u4e2d\u4e24\u4e2a\u6570\u6709>=p\u7684\u8d28\u56e0\u6570\uff0c\u5219\u5408\u5e76\u4e24\u4e2a\u96c6\u5408\uff0c\u95ee[a,b]\u5185\u5171\u6709\u591a\u5c11\u96c6\u5408\u3002\u56e0\u4e3a\u4e00\u4e2a\u6570\u6700\u591a\u67096\u4e2a\u8d28\u56e0\u6570\uff0c\u6240\u4ee5\u590d\u6742\u5ea6$\\Theta(6n)$,\u800c\u4e0d\u662f$\\Theta(n^2)$","title":"\u9636\u4e58 &amp; \u8d28\u6570\u8fde\u4e58"},{"location":"my%20past/OI/%E5%B9%B6%E6%9F%A5%E9%9B%86/","text":"\u5e76\u67e5\u96c6 P1653 \u6bcf\u4e2a\u7334\u5b50\u6389\u4e0b\u53d6\u5f97\u65f6\u5019\uff0c\u5c31\u662f\u5b83\u4e0e1\u65ad\u5f00\u8fde\u63a5\u5f97\u65f6\u5019\uff0c\u6240\u4ee5\u53ef\u4ee5\u5012\u7740\u641c\uff0c\u6bcf\u6b21\u7528\u5e76\u67e5\u96c6\u5c06\u4e24\u4e2a\u7334\u5b50\u8fde\u63a5\u4e0a\uff0c\u5c06\u6bcf\u4e2a\u7334\u5b50\u4e0e1\u8054\u901a\u5f97\u65f6\u95f4\u8bb0\u5f55\u4e0b\u6765\u5373\u53ef\u3002 P2661 \u5bf9\u4e8e\u6709\u5411\u73af\uff0c\u53ef\u4ee5\u7528\u5e76\u67e5\u96c6\u6c42\u89e3\u3002 \u8bbe$d[a]$\u8868\u793a\u8282\u70b9$a$\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\uff0c\u90a3\u4e48\u6bcf\u6b21\u8def\u5f84\u538b\u7f29\u65f6\u90fd\u8981\u66f4\u65b0$d[a]$. \u5047\u8bbe\u8282\u70b9$d[b]=0\uff0cd[a]=x$,\u90a3\u4e48\u5f53$d[b]=y$\u65f6\uff0c$d[a]=x+y$,\u5373$d[a]+=d[lst]$.\u4e0d\u7528\u5173\u5fc3$a$\u7684\u7236\u8282\u70b9\u600e\u6837\u53d8\u5316\uff0c\u56e0\u4e3a\u5df2\u7ecf\u8def\u5f84\u538b\u7f29\u8fc7\uff0c\u6240\u6709\u8282\u70b9\u90fd\u5df2\u7ecf\u5e76\u5728\u4e00\u4e2a\u6839\u8282\u70b9\u4e0a\uff0c\u800c\u8fd9\u4e2a\u6839\u8282\u70b9$d[b]=0$,\u6240\u4ee5\u53ea\u9700\u8981\u5173\u5fc3\u5b83\u7684\u503c\u7684\u53d8\u5316\u91cf\uff0c\u5373$d[lst]-0=d[lst]$. \u56e0\u4e3a\u6839\u636e\u9898\u610f\uff0c\u6bcf\u4e2a\u8282\u70b9\u53ea\u6709\u4e00\u4e2a\u7236\u4eb2\uff0c\u6240\u4ee5\u4e0d\u4f1a\u51fa\u73b0\u591a\u4e2a\u7236\u8282\u70b9\u5bfc\u81f4\u7684\u6df7\u4e71\uff0c\u6240\u4ee5\u53ef\u4ee5\u8bf4$d[b]=0$. \u800c\u5224\u65ad\u73af\u7684\u65f6\u5019\uff0c\u56e0\u4e3a\u4e0d\u77e5\u9053\u90a3\u4e2a\u8282\u70b9\u7684$d[ ]=0$,\u6240\u4ee5\u8fd4\u56de$da]+d[b]+1$\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=2e5+10; int n,minn,k; int fa[N],d[N]; int getfa(int u){ if(fa[u]!=u){ int lst=fa[u]; fa[u]=getfa(fa[u]); d[u]+=d[lst]; } return fa[u]; } void add(int a,int b){ int x=getfa(a),y=getfa(b); if(x!=y){ fa[x]=y;d[a]=d[b]+1; }else minn=min(minn,d[a]+d[b]+1); } int main(){ scanf(\"%d\",&n); minn=0x3f3f3f3f; for(int i=1;i<=n+1;++i)fa[i]=i; for(int i=1;i<=n;++i){ scanf(\"%d\",&k); add(i,k); } printf(\"%d\",minn); return 0; } \u7ed3\u8bba\uff1a\u5e76\u67e5\u96c6\u7684\u6838\u5fc3\u662f\u6839\u8282\u70b9\uff0c\u6240\u6709\u53f6\u5b50\u8282\u70b9\u53ea\u9700\u8981\u8003\u8651\u5b83\u7684\u6700\u9ad8\u7ea7\u6839\u8282\u70b9\u7684\u503c\u7684\u53d8\u5316\uff0c\u4e0d\u7528\u8003\u8651\u6b21\u7ea7\u6839\u8282\u70b9\u7684\u503c\u7684\u53d8\u5316\u3002","title":"\u5e76\u67e5\u96c6"},{"location":"my%20past/OI/%E5%B9%B6%E6%9F%A5%E9%9B%86/#_1","text":"P1653 \u6bcf\u4e2a\u7334\u5b50\u6389\u4e0b\u53d6\u5f97\u65f6\u5019\uff0c\u5c31\u662f\u5b83\u4e0e1\u65ad\u5f00\u8fde\u63a5\u5f97\u65f6\u5019\uff0c\u6240\u4ee5\u53ef\u4ee5\u5012\u7740\u641c\uff0c\u6bcf\u6b21\u7528\u5e76\u67e5\u96c6\u5c06\u4e24\u4e2a\u7334\u5b50\u8fde\u63a5\u4e0a\uff0c\u5c06\u6bcf\u4e2a\u7334\u5b50\u4e0e1\u8054\u901a\u5f97\u65f6\u95f4\u8bb0\u5f55\u4e0b\u6765\u5373\u53ef\u3002 P2661 \u5bf9\u4e8e\u6709\u5411\u73af\uff0c\u53ef\u4ee5\u7528\u5e76\u67e5\u96c6\u6c42\u89e3\u3002 \u8bbe$d[a]$\u8868\u793a\u8282\u70b9$a$\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb\uff0c\u90a3\u4e48\u6bcf\u6b21\u8def\u5f84\u538b\u7f29\u65f6\u90fd\u8981\u66f4\u65b0$d[a]$. \u5047\u8bbe\u8282\u70b9$d[b]=0\uff0cd[a]=x$,\u90a3\u4e48\u5f53$d[b]=y$\u65f6\uff0c$d[a]=x+y$,\u5373$d[a]+=d[lst]$.\u4e0d\u7528\u5173\u5fc3$a$\u7684\u7236\u8282\u70b9\u600e\u6837\u53d8\u5316\uff0c\u56e0\u4e3a\u5df2\u7ecf\u8def\u5f84\u538b\u7f29\u8fc7\uff0c\u6240\u6709\u8282\u70b9\u90fd\u5df2\u7ecf\u5e76\u5728\u4e00\u4e2a\u6839\u8282\u70b9\u4e0a\uff0c\u800c\u8fd9\u4e2a\u6839\u8282\u70b9$d[b]=0$,\u6240\u4ee5\u53ea\u9700\u8981\u5173\u5fc3\u5b83\u7684\u503c\u7684\u53d8\u5316\u91cf\uff0c\u5373$d[lst]-0=d[lst]$. \u56e0\u4e3a\u6839\u636e\u9898\u610f\uff0c\u6bcf\u4e2a\u8282\u70b9\u53ea\u6709\u4e00\u4e2a\u7236\u4eb2\uff0c\u6240\u4ee5\u4e0d\u4f1a\u51fa\u73b0\u591a\u4e2a\u7236\u8282\u70b9\u5bfc\u81f4\u7684\u6df7\u4e71\uff0c\u6240\u4ee5\u53ef\u4ee5\u8bf4$d[b]=0$. \u800c\u5224\u65ad\u73af\u7684\u65f6\u5019\uff0c\u56e0\u4e3a\u4e0d\u77e5\u9053\u90a3\u4e2a\u8282\u70b9\u7684$d[ ]=0$,\u6240\u4ee5\u8fd4\u56de$da]+d[b]+1$\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=2e5+10; int n,minn,k; int fa[N],d[N]; int getfa(int u){ if(fa[u]!=u){ int lst=fa[u]; fa[u]=getfa(fa[u]); d[u]+=d[lst]; } return fa[u]; } void add(int a,int b){ int x=getfa(a),y=getfa(b); if(x!=y){ fa[x]=y;d[a]=d[b]+1; }else minn=min(minn,d[a]+d[b]+1); } int main(){ scanf(\"%d\",&n); minn=0x3f3f3f3f; for(int i=1;i<=n+1;++i)fa[i]=i; for(int i=1;i<=n;++i){ scanf(\"%d\",&k); add(i,k); } printf(\"%d\",minn); return 0; } \u7ed3\u8bba\uff1a\u5e76\u67e5\u96c6\u7684\u6838\u5fc3\u662f\u6839\u8282\u70b9\uff0c\u6240\u6709\u53f6\u5b50\u8282\u70b9\u53ea\u9700\u8981\u8003\u8651\u5b83\u7684\u6700\u9ad8\u7ea7\u6839\u8282\u70b9\u7684\u503c\u7684\u53d8\u5316\uff0c\u4e0d\u7528\u8003\u8651\u6b21\u7ea7\u6839\u8282\u70b9\u7684\u503c\u7684\u53d8\u5316\u3002","title":"\u5e76\u67e5\u96c6"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/","text":"\u6cf0\u52d2\u7ea7\u6570 \u6cf0\u52d2\u591a\u9879\u5f0f \u7528\u6765\u6c42\u89e3f(x)\u67d0\u4e00\u70b9\u9644\u8fd1\u7684\u8fd1\u4f3c\u51fd\u6570g(x),f(x)\u662f\u4e00\u4e9b \u4e0d\u592a\u597d\u6c42\u503c \u7684\u51fd\u6570\uff0cg(x)\u5219\u662f\u6bd4\u8f83\u597d\u8ba1\u7b97\u7684\u51fd\u6570\u3002\u4f8b\u5982\uff1a $$ cos(x_0)\u5728x_0=0\u65f6\u7684\u6cf0\u52d2\u591a\u9879\u5f0f\u53ef\u4ee5\u662fg(x)=1-\\frac12 x^2,\u6216 g(x)=1-\\frac12 x^2+\\frac1{24}x^4 $$ \u8fd9\u6837\u53ef\u4ee5\u8ba1\u7b97\u51fd\u6570\u7684\u8fd1\u4f3c\u503c\uff0c\u4e00\u822c\u5e42\u6b21\u8d8a\u9ad8\uff0c\u7cbe\u786e\u5ea6\u8d8a\u9ad8\u3002 $1-\\frac12x^2$ $1-\\frac12x^2+\\frac1{24}x^4$ \u5728\u8fd9\u4e2a\u70b9$x_0$\u9644\u8fd1\u65f6\u7684g(x)\u65f6\u6bd4\u8f83\"\u8d34\u5408\"\u539f\u51fd\u6570\u7684\uff0c\u79f0\u4e3a\u6536\u655b\uff1b \u5982\u679c\u79bb\u5f97\u8fdc\u4e86\uff0c\u5c31\u4f1a\u8fdc\u79bb\u539f\u51fd\u6570\uff0c\u79f0\u4e3a\u53d1\u6563\u3002 \u6211\u4eec\u79f0\u6536\u655b\u7684\u6700\u5927\u8303\u56f4\u4e3a\u6536\u655b\u534a\u5f84\u3002 \u6cf0\u52d2\u7ea7\u6570 \u5c06g(x)\u7684\u51fd\u6570\u5e42\u6b21\u62d3\u5c55\u5230\u65e0\u7a77\u5927\uff0c\u90a3\u4e48g(x)\u7684\u503c\u5c31\u79f0\u4e3a \u6cf0\u52d2\u7ea7\u6570 $$G(x)=\\sum_{n=0}^\\infty g(x,n)= \\sum_{n=0}^{\\infty}\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n=f(x_0)+f'(x_0)(x-x_0)+\\frac {f''(x_0)}{2!}(x-x_0)^2+...+ \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+...$$ $$ \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \u5c31\u662fG(x)\u4e2d\u7684\u7b2cn\u9879g(x,n)$$ \u5e94\u7528 cmath pow \u7528\u8fd9\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5c06\u590d\u6742\u5ea6\u964d\u81f3O(1) \u901a\u8fc7\u4ee5\u4e0b\u4ee3\u7801 pow(b,n)=exp(n*log(b));//log(b)=lnb \u5c31\u662f$b^n=e^{n* lnb}$\u6765\u4f18\u5316\uff0c\u56e0\u4e3aexp\u548clog\u7684\u590d\u6742\u5ea6\u53ef\u4ee5\u901a\u8fc7\u6cf0\u52d2\u5c55\u5f00\u6c42\u51fa\u4ed6\u4eec\u5728\u6bcf\u4e2a\u70b9\u9644\u8fd1\u7684\u4f4e\u9636\u8fd1\u4f3c\u51fd\u6570\uff0c\u901a\u8fc7\u67e5\u8868\u7684\u65b9\u5f0fO(1)\u83b7\u53d6\u51fd\u6570\u503c\u3002 \u4f8b\u5982\uff1a $$1.e^x,\u5728x=0\u5904\u5c55\u5f00 \\f(x)=e^x ,\u5219\\g(0,n)=x^{n}\\ \\therefore G(x)=\\sum_{n=0}^\\infty x^{n}=1+x+x^2+x^3+...+x^n+...\\ 2.lnx \\f(x)=lnx,\u5728x=1\u5904\u5c55\u5f00\\ G(x)=(x-1)-\\frac12(x-1)^2+\\frac13(x-1)^3-\\frac14(x-1)^4+\\frac15(x-1)^5+...\\ $$ 0.999...=1 \u76f4\u63a5\u8ba1\u7b97 $$\\frac19=0.111... \\ 9 * \\frac19=0.999... \\ 9 * \\frac19=1 \\ \\therefore 0.999...=1 $$ \u8bbe\u6570 $$x=0.999...\\ 10 * x=9.999... \\10 * x-1 * x=9 * x=9 \\x=1 \\\\therefore 0.999...=1 $$ \u6781\u9650 $$ 0.999...=\\lim_{n\\to\\infty}1-\\frac1{10^n}\\ \\lim_{n\\to\\infty}\\frac1{10^n}=0 \\\\therefore0.999...=1 $$ \u7136\u800c\uff0c\u8fd9\u4e9b\u90fd\u4e0d\u591f\u4e25\u8c28 \u6234\u5fb7\u91d1\u5206\u5272\uff08Dedekind\uff09 $$ \u8bbe t=0.999......\uff0c\u4f5c\u4e24\u4e2a\u6709\u7406\u6570\u96c6\u7684\u5206\u5272 \\ A={ [x|x =t,x\u6709\u7406\u6570]} \\ C={[x|x<1,x\u6709\u7406\u6570]}\uff0cD={[x|x>=1,x\u6709\u7406\u6570]} \\ \u5206\u5272A/B\u786e\u5b9a\u4e86\u5b9e\u6570t=0.999......(\u6211\u4eec\u6682\u65f6\u4e0d\u77e5\u9053t=0.999...\u662f\u6709\u7406\u6570\u8fd8\u662f\u65e0\u7406\u6570) \\ \u5206\u5272C/D\u786e\u5b9a\u4e86\u6709\u7406\u65701 \\ \u4e3a\u8bc1\u660e t=1\uff0c\u6211\u4eec\u53ea\u9700\u8981\u8bc1\u660e\u8fd9\u4e24\u4e2a\u5206\u5272\u662f\u76f8\u540c\u7684\uff0c\u5373\u8bc1\u660e A=C \\ \u82e5\u6709\u7406\u6570 x\u2208A\uff0c\u5219\u663e\u7136\u6709 x<1\uff0c\u4e8e\u662f x\u2208C \\ \u82e5\u6709\u7406\u6570 x\u2208C\uff0c\u5219 x<1\uff0c\u4e0d\u59a8\u8bbe x>0 \\ \u6839\u636e\u6709\u7406\u6570\u7684\u5b9a\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u628ax\u7528\u5206\u6570\u7684\u5f62\u5f0f\u8868\u793a\u4e3a \\ x=\\frac pq\uff0c(p\uff0cq\u4e3a\u6b63\u6574\u6570) \\ \u65e2\u71360<x<1\uff0c\u5219\u5fc5\u6709p< q \\ \u4e8e\u662f\u75311-\\frac pq>=\\frac 1q>0\uff0c\u53ef\u5f97\u5b58\u5728\u6b63\u6574\u6570n(\\frac{p+1}q<=1 \u53ef\u4ee5\u8bc1\u660e\uff0c\u56e0\u4e3ap,q\u90fd\u662f\u6b63\u6574\u6570)\uff0c\u4f7f\u5f97 \\ \\frac 1q>\\frac1{10^n}>0(x\u662f\u786e\u5b9a\u7684\u6570\uff0c\u5219q\u5b58\u5728\uff0c\u5219\u6bd4\u5b83\u9ad8\u9636\u7684n\u4e00\u5b9a\u5b58\u5728\uff0c\u4e0d\u7528\u7ea0\u7ed3\u65e0\u7a77\u5927\u7684\u4e8b) \\ x=\\frac pq<=1-\\frac 1q<1-\\frac1{10^n}=0.99...9(n\u4e2a9)< t \\ \u65e2\u7136x<t\uff0c\u8fd9\u5c31\u8bf4\u660ex\u2208A \\ \u7531\u4e0a\uff0c\u6211\u4eec\u5c31\u5f97\u5230\u4e86A=C\uff0c\u4ece\u800c\uff0cA/B\u548cC/D\u662f\u4e24\u4e2a\u76f8\u540c\u7684\u5206\u5272\uff0c\u56e0\u6b64\uff0c 0.999...=t=1 $$ Orz","title":"\u6cf0\u52d2\u7ea7\u6570"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/#_1","text":"","title":"\u6cf0\u52d2\u7ea7\u6570"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/#_2","text":"\u7528\u6765\u6c42\u89e3f(x)\u67d0\u4e00\u70b9\u9644\u8fd1\u7684\u8fd1\u4f3c\u51fd\u6570g(x),f(x)\u662f\u4e00\u4e9b \u4e0d\u592a\u597d\u6c42\u503c \u7684\u51fd\u6570\uff0cg(x)\u5219\u662f\u6bd4\u8f83\u597d\u8ba1\u7b97\u7684\u51fd\u6570\u3002\u4f8b\u5982\uff1a $$ cos(x_0)\u5728x_0=0\u65f6\u7684\u6cf0\u52d2\u591a\u9879\u5f0f\u53ef\u4ee5\u662fg(x)=1-\\frac12 x^2,\u6216 g(x)=1-\\frac12 x^2+\\frac1{24}x^4 $$ \u8fd9\u6837\u53ef\u4ee5\u8ba1\u7b97\u51fd\u6570\u7684\u8fd1\u4f3c\u503c\uff0c\u4e00\u822c\u5e42\u6b21\u8d8a\u9ad8\uff0c\u7cbe\u786e\u5ea6\u8d8a\u9ad8\u3002 $1-\\frac12x^2$ $1-\\frac12x^2+\\frac1{24}x^4$ \u5728\u8fd9\u4e2a\u70b9$x_0$\u9644\u8fd1\u65f6\u7684g(x)\u65f6\u6bd4\u8f83\"\u8d34\u5408\"\u539f\u51fd\u6570\u7684\uff0c\u79f0\u4e3a\u6536\u655b\uff1b \u5982\u679c\u79bb\u5f97\u8fdc\u4e86\uff0c\u5c31\u4f1a\u8fdc\u79bb\u539f\u51fd\u6570\uff0c\u79f0\u4e3a\u53d1\u6563\u3002 \u6211\u4eec\u79f0\u6536\u655b\u7684\u6700\u5927\u8303\u56f4\u4e3a\u6536\u655b\u534a\u5f84\u3002","title":"\u6cf0\u52d2\u591a\u9879\u5f0f"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/#_3","text":"\u5c06g(x)\u7684\u51fd\u6570\u5e42\u6b21\u62d3\u5c55\u5230\u65e0\u7a77\u5927\uff0c\u90a3\u4e48g(x)\u7684\u503c\u5c31\u79f0\u4e3a \u6cf0\u52d2\u7ea7\u6570 $$G(x)=\\sum_{n=0}^\\infty g(x,n)= \\sum_{n=0}^{\\infty}\\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n=f(x_0)+f'(x_0)(x-x_0)+\\frac {f''(x_0)}{2!}(x-x_0)^2+...+ \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+...$$ $$ \\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n \u5c31\u662fG(x)\u4e2d\u7684\u7b2cn\u9879g(x,n)$$","title":"\u6cf0\u52d2\u7ea7\u6570"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/#_4","text":"","title":"\u5e94\u7528"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/#cmath-pow","text":"\u7528\u8fd9\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5c06\u590d\u6742\u5ea6\u964d\u81f3O(1) \u901a\u8fc7\u4ee5\u4e0b\u4ee3\u7801 pow(b,n)=exp(n*log(b));//log(b)=lnb \u5c31\u662f$b^n=e^{n* lnb}$\u6765\u4f18\u5316\uff0c\u56e0\u4e3aexp\u548clog\u7684\u590d\u6742\u5ea6\u53ef\u4ee5\u901a\u8fc7\u6cf0\u52d2\u5c55\u5f00\u6c42\u51fa\u4ed6\u4eec\u5728\u6bcf\u4e2a\u70b9\u9644\u8fd1\u7684\u4f4e\u9636\u8fd1\u4f3c\u51fd\u6570\uff0c\u901a\u8fc7\u67e5\u8868\u7684\u65b9\u5f0fO(1)\u83b7\u53d6\u51fd\u6570\u503c\u3002 \u4f8b\u5982\uff1a $$1.e^x,\u5728x=0\u5904\u5c55\u5f00 \\f(x)=e^x ,\u5219\\g(0,n)=x^{n}\\ \\therefore G(x)=\\sum_{n=0}^\\infty x^{n}=1+x+x^2+x^3+...+x^n+...\\ 2.lnx \\f(x)=lnx,\u5728x=1\u5904\u5c55\u5f00\\ G(x)=(x-1)-\\frac12(x-1)^2+\\frac13(x-1)^3-\\frac14(x-1)^4+\\frac15(x-1)^5+...\\ $$","title":"cmath pow"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/#09991","text":"","title":"0.999...=1"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/#_5","text":"$$\\frac19=0.111... \\ 9 * \\frac19=0.999... \\ 9 * \\frac19=1 \\ \\therefore 0.999...=1 $$","title":"\u76f4\u63a5\u8ba1\u7b97"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/#_6","text":"$$x=0.999...\\ 10 * x=9.999... \\10 * x-1 * x=9 * x=9 \\x=1 \\\\therefore 0.999...=1 $$","title":"\u8bbe\u6570"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/#_7","text":"$$ 0.999...=\\lim_{n\\to\\infty}1-\\frac1{10^n}\\ \\lim_{n\\to\\infty}\\frac1{10^n}=0 \\\\therefore0.999...=1 $$ \u7136\u800c\uff0c\u8fd9\u4e9b\u90fd\u4e0d\u591f\u4e25\u8c28","title":"\u6781\u9650"},{"location":"my%20past/OI/%E6%95%B0%E5%AD%A6/#dedekind","text":"$$ \u8bbe t=0.999......\uff0c\u4f5c\u4e24\u4e2a\u6709\u7406\u6570\u96c6\u7684\u5206\u5272 \\ A={ [x|x =t,x\u6709\u7406\u6570]} \\ C={[x|x<1,x\u6709\u7406\u6570]}\uff0cD={[x|x>=1,x\u6709\u7406\u6570]} \\ \u5206\u5272A/B\u786e\u5b9a\u4e86\u5b9e\u6570t=0.999......(\u6211\u4eec\u6682\u65f6\u4e0d\u77e5\u9053t=0.999...\u662f\u6709\u7406\u6570\u8fd8\u662f\u65e0\u7406\u6570) \\ \u5206\u5272C/D\u786e\u5b9a\u4e86\u6709\u7406\u65701 \\ \u4e3a\u8bc1\u660e t=1\uff0c\u6211\u4eec\u53ea\u9700\u8981\u8bc1\u660e\u8fd9\u4e24\u4e2a\u5206\u5272\u662f\u76f8\u540c\u7684\uff0c\u5373\u8bc1\u660e A=C \\ \u82e5\u6709\u7406\u6570 x\u2208A\uff0c\u5219\u663e\u7136\u6709 x<1\uff0c\u4e8e\u662f x\u2208C \\ \u82e5\u6709\u7406\u6570 x\u2208C\uff0c\u5219 x<1\uff0c\u4e0d\u59a8\u8bbe x>0 \\ \u6839\u636e\u6709\u7406\u6570\u7684\u5b9a\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u628ax\u7528\u5206\u6570\u7684\u5f62\u5f0f\u8868\u793a\u4e3a \\ x=\\frac pq\uff0c(p\uff0cq\u4e3a\u6b63\u6574\u6570) \\ \u65e2\u71360<x<1\uff0c\u5219\u5fc5\u6709p< q \\ \u4e8e\u662f\u75311-\\frac pq>=\\frac 1q>0\uff0c\u53ef\u5f97\u5b58\u5728\u6b63\u6574\u6570n(\\frac{p+1}q<=1 \u53ef\u4ee5\u8bc1\u660e\uff0c\u56e0\u4e3ap,q\u90fd\u662f\u6b63\u6574\u6570)\uff0c\u4f7f\u5f97 \\ \\frac 1q>\\frac1{10^n}>0(x\u662f\u786e\u5b9a\u7684\u6570\uff0c\u5219q\u5b58\u5728\uff0c\u5219\u6bd4\u5b83\u9ad8\u9636\u7684n\u4e00\u5b9a\u5b58\u5728\uff0c\u4e0d\u7528\u7ea0\u7ed3\u65e0\u7a77\u5927\u7684\u4e8b) \\ x=\\frac pq<=1-\\frac 1q<1-\\frac1{10^n}=0.99...9(n\u4e2a9)< t \\ \u65e2\u7136x<t\uff0c\u8fd9\u5c31\u8bf4\u660ex\u2208A \\ \u7531\u4e0a\uff0c\u6211\u4eec\u5c31\u5f97\u5230\u4e86A=C\uff0c\u4ece\u800c\uff0cA/B\u548cC/D\u662f\u4e24\u4e2a\u76f8\u540c\u7684\u5206\u5272\uff0c\u56e0\u6b64\uff0c 0.999...=t=1 $$ Orz","title":"\u6234\u5fb7\u91d1\u5206\u5272\uff08Dedekind\uff09"},{"location":"my%20past/OI/%E6%9C%80%E7%9F%AD%E8%B7%AF/","text":"\u6700\u77ed\u8def \u5168\u6e90\u7b97\u6cd5Floyd Q.\u4e3a\u4ec0\u4e48\u4e2d\u8f6c\u70b9k\u8981\u653e\u5728\u6700\u5916\u5c42\uff1f A.\u56e0\u4e3afloyd\u7684\u5b9e\u8d28\u662fdp. \u7528f[k][i][j]\u8868\u793a\u7ecf\u8fc7i\u5230j\u7684\u901a\u8fc71...k\u7684\u8def\u5f84 \u5219 f[k][i][j]=min(f[k-1][i][j],f[k-1][i][k]+f[k-1][k][j]); \u7531\u4e8e\u6700\u5916\u9762\u4e00\u5c42\u7701\u7565\u6389\uff0c\u6240\u4ee5\u5f97\u51fafloyd\u5e38\u89c1\u7684\u5f0f\u5b50\uff1b \u4f46\u662f\uff1a \u201c\u4f60\u8981\u77e5\u9053\u4ed6\u662f\u4ece\u4e0a\u4e00\u5c42k\u8f6c\u79fb\u8fc7\u6765\u7684\uff0c\u6240\u4ee5\u5f53\u524d\u7684f[i][j]\u90fd\u5e94\u8be5\u662f\u5b8c\u6210\u4e0a\u4e00\u5c42\u52a8\u6001\u89c4\u5212\u7684\uff0c\u5982\u679ck\u4e0d\u662f\u5728\u6700\u5916\u5c42\uff0c\u90a3\u4e48f[i][j]\u5c31\u4e0d\u662f\u5b8c\u6210\u4e0a\u4e00\u5c42\u52a8\u6001\u89c4\u5212\u7684\u540e\u7684\u72b6\u6001\uff0c\u6709\u53ef\u80fd\u6709\u7684\u70b9\u6ca1\u6709\u7ecf\u8fc7k-1\u8fd9\u4e2a\u70b9\u7684\u677e\u5f1b\u3002\u201d :) \u5168\u6e90\u4e4b\u8def\u5f84\u7edf\u8ba1 P2047 ($2^{11}-1$) \u8fd9\u9053\u9898\uff0c\u4e00\u5f00\u59cb\u601d\u8def\u662f\u5bf9\u7684\uff0c\u540e\u6765\u8d8a\u505a\u8d8a\u9519orz \u7528C[i][j]\u8868\u793ai\u5230j\u4e4b\u95f4\u7684\u6700\u77ed\u8def\u5f84\u6570\u76ee \u8f6c\u79fb\u65b9\u7a0b:(floyd==dp) void floyd() { for(int k=1; k<=n; ++k) { for(int i=1; i<=n; ++i) { for(int j=1; j<=n; ++j) { if(i==j || i==k || j==k)continue; if(dis[i][j]>dis[i][k]+dis[k][j]) { dis[i][j]=dis[i][k]+dis[k][j]; C[i][j]=C[i][k]*C[k][j]; continue; } if(dis[i][j]==dis[i][k]+dis[k][j]){ C[i][j]+=C[i][k]*C[k][j]; } } } } return; } \u7edf\u8ba1\u7b54\u6848:\u5f53dis[i][k]+dis[k][j]==dis[i][j]\u65f6\uff0c\u8fd9\u6761\u7ecf\u8fc7k\u7684\u8def\u5f84\u4e00\u5b9a\u662fi\u5230j\u7684\u6700\u77ed\u8def\uff0c\u5219: void sum() { for(int k=1; k<=n; ++k) { for(int i=1; i<=n; ++i) { for(int j=1; j<=n; ++j) { if(i==k || j==k || i==j)continue; if(dis[i][k]+dis[k][j]==dis[i][j]) { ans[k]+=(C[i][k]*C[k][j]*1.0)/(C[i][j]*1.0); } } } } } \u4e3a\u4ec0\u4e48floyd\u8fd9\u79cd\u66f4\u65b0\u6700\u77ed\u8def\u6761\u6570\u7684\u65b9\u5f0f\u662f\u5bf9\u7684\u5462\uff0c\u540c\u4e00\u6761\u8def\u4e0a\u7684\u4e0d\u540c\u70b9\u4f1a\u4e0d\u4f1a\u5bf9\u8fd9\u6761\u8def\u505a\u51fa\u91cd\u590d\u7684\u8d21\u732e\u5462\uff1f \u5176\u5b9e\u662f\u4e0d\u4f1a\u7684\uff0c\u8fd9\u662f\u7531\u4e8efloyd\u662f\u6309\u4e2d\u8f6c\u70b9k\u7684\u987a\u5e8f\u5b9e\u73b0\u7684\u7279\u6027\u3002 \u5047\u8bbe\u6309\u7167b,c,d\u7684\u987a\u5e8f(k)\u66f4\u65b0C[a][e]\uff0c\u5219\u7b2c\u4e00\u6b21C[a][e]=C[a][b]* C[b][e],\u56e0\u4e3aC[b][e]\u6ca1\u6709\u66f4\u65b0\u8fc7,\u5176\u503c\u4e3a0\uff0c\u6240\u4ee5C[a][e]\u6ca1\u6709\u53d8\u5316;c\u540cb;\u53ea\u6709d\u65f6\uff0cC[a][d]=C[d][e]=1,\u6240\u4ee5C[a][e]=1,\u7b26\u5408\u5b9e\u9645\u60c5\u51b5\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c$C[i][k]$\u662f\u73b0\u5728\uff0c$C[i][j]$\u662f\u672a\u6765\uff0c\u56e0\u4e3a$dp$\u7684\u65e0\u540e\u6548\u6027\uff0c\u6240\u4ee5\u672a\u6765\u4e0e\u8fc7\u53bb\u65e0\u5173\uff0c\u5373\u4e0e$C[i][k]$\u91cc\u9762\u7684\u5c0f\u533a\u95f4\u65e0\u5173\uff0c\u4e0d\u4f1a\u88ab\u66f4\u65b0\u5230\u3002 \u7efc\u4e0a\uff0c\u4e0d\u4f1a\u51fa\u73b0\u91cd\u590d\u8ba1\u7b97\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u53ea\u6709\u6700\u540e\u4e00\u6b21\u66f4\u65b0\u624d\u6709\u6548\u3002 \u5206\u5c42\u56fe \u4e0e\u7f51\u7edc\u6d41\u7684\u5efa\u56fe\u7c7b\u4f3c\uff0c\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u5efa\u6a21 P4568 \u8fd9\u9898\u6709\u4e24\u79cd\u601d\u8def\uff0c\u4e00\u79cd\u662fdp\uff0c\u53e6\u4e00\u79cd\u662f\u5206\u5c42\u56fe\uff0c\u6211\u7528\u7684\u7b2c\u4e00\u79cd 1.dp\u53ef\u4ee5\u8bbedis[n][k]\u8868\u793a\u7528k\u6b21\u514d\u8d39\u4f18\u60e0\u540e\u5230\u8fben\u7684\u6700\u77ed\u8def\uff0c\u5219\u8f6c\u79fb\uff1a if(dis[v][k1]>dis[u][k1]+w && k1<=k){ dis[v][k1]=dis[u][k1]+w; if(!vis[v][k1]){ q.push(node(dis[v][k1],v,k1)); } } if(dis[v][k1+1]>dis[u][k1] && k1+1<=k){ dis[v][k1+1]=dis[u][k1]; if(!vis[v][k1+1]){ q.push(node(dis[v][k1+1],v,k1+1)); } } } \u8fd9\u91cc\u53ef\u4ee5\u7528\u7ed3\u6784\u4f53\u6765\u4fdd\u5b58\u6bcf\u4e2a\u8282\u70b9\u7528\u7684k\uff0c\u5728\u5168\u90fd\u8fdb\u961f\uff1b \u4e5f\u53ef\u4ee5\u76f4\u63a5\u5728\u6700\u5916\u5c42\u679a\u4e3ek\uff0c\u505ak\u6b21\u6700\u77ed\u8def 2.\u5206\u5c42\u56fe\u677f\u5b50 \u76f4\u63a5\u5efa\u51fak\u5c420\u8fb9\uff0c\u8868\u793a\u6bcf\u4e2a\u822a\u73ed\u514d\u8d39\u642d\u4e58\u540e\u75280\u8d39\u7528\u8df3\u8f6c\u5230\u76ee\u7684\u5730\u3002 dijkstra 1.priority_queue\u5199\u6cd5\uff0c\u6700\u5e38\u7528\uff0c\u6ce8\u610f\u7ed3\u6784\u4f53\u6784\u9020\u51fd\u6570\u548c\u91cd\u8f7d\u8fd0\u7b97\u7b26\u7684\u5199\u6cd5\uff0c\u522b\u8bb0\u9519\u4e86\u3002 struct node{ int dis,pos; bool operator <(const node &x)const{ return x.dis<dis; } node(int d,int p){ dis=d,pos=p; } }e[N<<1]; void dijkstra() { for(int i=0;i<N;++i)dis[i]=INF; dis[s] = 0; q.push( node(0,s) ); while( !q.empty() ) { node u = q.top().pos; q.pop(); if( vis[u] )continue; vis[u] = 1; for( int i = head[u]; ~i; i = e[i].nxt ) { int v = e[i].v,w=e[i].w; if( dis[v] > dis[u] + w ) { dis[v] = dis[u] + w; if( !vis[v] ) { q.push( node (dis[v], v) ); } } } } } 2.\u624b\u5199\u5806\uff1a\u6bd4\u7b2c\u4e00\u79cd\u5feb\u4e86hin\u591a\uff0c\u8d39\u7528\u6d41\u7b49\u5f88\u591a\u7528\u5230\u6700\u77ed\u8def\u4e14\u6570\u636e\u91cf\u5f88\u5927\u7684\u9898\u5c31\u8981\u7528\u624b\u5199\u5806\u4e86\uff0c\u80fd\u5feb1\u500d\u5de6\u53f3\u3002 P1629 \u6a21\u677f\u9898 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e4+10,M=2e5+10,INF=1e14; struct hp{ int dis,pos; }heap[N]; struct node{ int v,w,nxt,t; }e[M<<1]; int head[N],dis[N],vis[N]; int cnt,n,m,u,v,w,tot; void add(int u,int v,int w,int t){ e[++cnt].v=v; e[cnt].w=w; e[cnt].t=t; e[cnt].nxt=head[u]; head[u]=cnt; return; } void push(int d,int p){ heap[++tot].dis=d,heap[tot].pos=p; int now=tot; while(now>1){ int nxt=now>>1; if(heap[nxt].dis<=heap[now].dis)break; swap(heap[nxt],heap[now]); now=nxt; } return; } int pop(){ int ans=heap[1].pos; swap(heap[1],heap[tot]); tot--; int now=1; while(now*2<=tot){ int nxt=now<<1; if(now*2+1<=tot && heap[nxt].dis>heap[nxt+1].dis)nxt++; if(heap[nxt].dis>=heap[now].dis)break; swap(heap[nxt],heap[now]); now=nxt; } return ans; } bool empty(){ return tot==0; } void dij(){ //memset(dis,0x3f,sizeof dis); for(int i=0;i<N;++i)dis[i]=INF; memset(vis,0,sizeof vis); dis[1]=0; tot=0; push(0,1); while(!empty()){ int u=pop(); if(vis[u])continue; vis[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w,t=e[i].t; if(t && dis[v]>dis[u]+w){ dis[v]=dis[u]+w; if(!vis[v]){ push(dis[v],v); } } } } return; } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld%lld\",&u,&v,&w); add(u,v,w,1); add(v,u,w,0); } dij(); int ans=0; for(int i=2;i<=n;++i){ ans+=dis[i]; } for(int i=0;i<=m*2-1;i+=2){ e[i].t=0; e[i^1].t=1; } dij(); for(int i=2;i<=n;++i){ ans+=dis[i]; } printf(\"%lld\",ans); return 0; } SPFA ~~\u636e\u8bf4\u5b83\u6b7b\u4e86~~ bellman-ford \u7684\u6c11\u95f4\u52a0\u5f3a\u7248\u3002 bool SPFA(){ int s=1; for(int i=0;i<N;++i)dis[i]=INF; memset(vis,0,sizeof vis); vis[s]=1; dis[s]=0; q.push(s); while(!q.empty()){ int u=q.front();q.pop(); vis[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(dis[v]>dis[u]+w){ dis[v]=dis[u]+w; if(!vis[v]){ vis[v]=1; q.push(v); } } } } } \u4e8c\u5206\u8282\u70b9 \u5728\u4e00\u4e9b\u9898\u4e2d\u4f1a\u7ed9\u4f60\u8282\u70b9\u7684\u6743\u503c\uff0c\u5e76\u8981\u6c42\u7ecf\u8fc7\u7684\u8282\u70b9\u7684\u6743\u503c\u6700\u5927\u503c\u4e0d\u8d85\u8fc7k\uff0c\u6c42\u6700\u77ed\u8def\u3002\u8fd9\u65f6\u5019\uff0c\u5c31\u53ef\u4ee5\u4e8c\u5206\u6743\u503c\u7684\u9650\u5236\uff0c\u5c06\u4e0d\u6ee1\u8db3\u7684\u8282\u70b9~~ban\u6389~~,\u7136\u540e\u8dd1\u6700\u77ed\u8def\u5373\u53ef\u3002 P1462 \u6a21\u677f\u9898 \u53cd\u5411\u5efa\u8fb9 \u7ecf\u5178\u7684\u6700\u77ed\u8def\u89e3\u9898\u65b9\u6cd5 P1629 \u6a21\u677f\u9898 P5663 ~~\u8003\u573a\u4e0a\u9001\u8d70\u6211\u7684\u9898\uff0c\u796d\u6211\u76842019~~ \u76f4\u63a5\u641c\u7d22\u76f4\u63a5\u7206\u70b8\uff0c\u66f4\u4f55\u51b5\u6211\u8003\u573a\u4e0a\u6839\u672c\u6ca1\u5199\u5bf9 \u6211\u4eec\u53d1\u73b0\uff0c\u5047\u8bbe\u4ece$u$\u51fa\u53d1\u53bb$v$,\u5982\u679c$u,v$\u4e4b\u95f4\u7684\u8ddd\u79bb\u7b49\u4e8e$L$,\u90a3\u4e48\u6240\u6709\u8ddd\u79bb$u$\u4e3a$L+2,L+4,...$\u7684\u70b9\u90fd\u53ef\u4ee5\u5230\u8fbe\uff1b \u800c\u5bf9\u4e8e$L+1$\uff0c\u5219\u4e0d\u4e00\u5b9a\u6709\uff0c\u9700\u8981\u4ece$L$\u8f6c\u79fb\u800c\u6765\u3002 \u6240\u4ee5\u8fd9\u9053\u9898\u53d8\u6210\u4e86\u4e00\u9053\u6c42\u5947\u5076\u8def\u5f84\u7684\u9898\u3002 \u5947\u5076\u8def\u5f84\u5c31\u662f\u6307\u5c06\u6574\u4e2a\u56fe\u5206\u6210\u957f\u5ea6\u4e3a\u5947\u6570\u7684\u8def\u5f84\u6838\u5076\u6570\u7684\u8def\u5f84\uff0c\u5e76\u5206\u522b\u4e92\u76f8\u66f4\u65b0\u3002 \u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8981$dijkstra$\u5373\u53ef\u6c42\u51fa\u6240\u6709\u8def\u5f84\u8ddd\u79bb\u3002 \u5982\u679c$dis[a][t]>L(L \\& 1= t)$,\u5219\u4e0d\u7528\u63d0\u4f9b\u96f6\u4ef6,\u5426\u5219\u5c31\u8981\u63d0\u4f9b\u96f6\u4ef6\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=1e5+10; int n,m,q,cnt,u,v,a,L; int head[N],dis[N][2],vis[N][2]; struct edge{ int v,nxt; }e[N<<1]; struct node{ int dis,pos,type; bool operator <(const node &x)const{ return x.dis<dis; } node(int d,int p,int t){ dis=d,pos=p,type=t; } }; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void dij(int s){ memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); priority_queue<node> q; q.push(node(0,s,0)); dis[s][0]=0; while(!q.empty()){ node tmp=q.top();q.pop(); int u=tmp.pos,t=tmp.type; if(vis[u][t])continue; vis[u][t]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(dis[v][1]>dis[u][0]+1){ dis[v][1]=dis[u][0]+1; if(!vis[v][1])q.push(node(dis[v][1],v,1)); } if(dis[v][0]>dis[u][1]+1){ dis[v][0]=dis[u][1]+1; if(!vis[v][0])q.push(node(dis[v][0],v,0)); } } } } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld%lld\",&n,&m,&q); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&u,&v); add(u,v),add(v,u); } dij(1); for(int i=1;i<=q;++i){ scanf(\"%lld%lld\",&a,&L); if(L&1){ if(dis[a][1]>L)printf(\"No\\n\"); else printf(\"Yes\\n\"); }else{ if(dis[a][0]>L)printf(\"No\\n\"); else printf(\"Yes\\n\"); } } return 0; } P7997 ~~\u53c8\u662f\u8003\u573a\u4e0a\u8650\u6211\u5343\u767e\u904d\u7684\u9898~~ \u8fd9\u9898\u4e5f\u662f\u5947\u5076\u8def\u5f84\u7684\u677f\u5b50\u9898\uff0c\u5982\u679c\u4e00\u4e2a\u6570$i$\u5c0f\u4e8e$a[j]$\uff0c\u5219\u4e00\u5b9a\u53ef\u4ee5\u53bb\u5230$i+a[j]$\u540e\u518d\u56de\u5230$i$;\u5e76\u4e14\u603b\u70b9\u6570\u53ea\u6709$2* MAXa=4000$\u4e2a\u70b9\uff0c\u6240\u4ee5\u76f4\u63a5\u6700\u77ed\u8def\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=1e4+10,M=4e6+10; int n,T,L,m,cnt,MAX; int a[N],head[N],vis[N][2],dis[N][2],ans[N]; struct node{ int dis,pos,type; bool operator <(const node &x)const{ return x.dis<dis; } node(int d,int p,int t){ dis=d,pos=p,type=t; } }; struct edge{ int v,nxt; }e[M<<1]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void init(){ for(int i=0;i<=MAX+MAX-1;++i) for(int j=1;j<=n;++j) add(i,i>=a[j]?i-a[j]:i+a[j]); } void dij(int s){ memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); priority_queue<node> q; q.push(node(0,s,0)); dis[s][0]=0; while(!q.empty()){ node tmp=q.top();q.pop(); int u=tmp.pos,t=tmp.type; if(vis[u][t])continue; vis[u][t]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(dis[v][1]>dis[u][0]+1){ dis[v][1]=dis[u][0]+1; if(!vis[v][1])q.push(node(dis[v][1],v,1)); } if(dis[v][0]>dis[u][1]+1){ dis[v][0]=dis[u][1]+1; if(!vis[v][0])q.push(node(dis[v][0],v,0)); } } } } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld\",&n,&T); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i]),MAX=max(MAX,a[i]); init(); dij(0); for(int i=1;i<=T;++i){ scanf(\"%lld\",&m); for(int i=MAX+MAX-1;i>=0;--i){ if(dis[i][m&1]<=m){ printf(\"%lld\\n\",i); break; } } } return 0; } P1027 ~~sb\u9898\u771f\u9ebb\u70e6\uff0c\u5199nm\u4e24\u5c0f\u65f6~~ \u5c31...\u76f4\u63a5\u6700\u77ed\u8def\u5c31\u884c\u4e86\uff0c\u4f46\u5efa\u56fe\u8d3c\u9ebb\u70e6\u3002SPFA\u8fd8\u6ca1\u6b7b\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<queue> using namespace std; typedef double db; const int N=1e3+10,INF=0x3f3f3f3f,M=1e6+10; int cnt,n,m,T,s,A,B; db tmp,t; int num[N]; int vis[N],head[N]; db dis[N]; struct edge{ int v,nxt; db w; }e[M]; struct city{ int x,y; db T; }c[N]; inline db Dis(int i,int j){int _x=c[i].x-c[j].x,_y=c[i].y-c[j].y;return (db)sqrt(_x*_x+_y*_y);} inline int _Dis(int i,int j){int _x=c[i].x-c[j].x,_y=c[i].y-c[j].y;return (_x*_x+_y*_y);} inline int g(int x,int y){return 4*(x-1)+y;} void add(int u,int v,db w){e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt;} void init(){for(int i=1;i<=4*s;++i)dis[i]=(db)INF;} void cal(int i){ int n1=g(i,1),n2=g(i,2),n3=g(i,3); int x1=c[n1].x, y1=c[n1].y, x2=c[n2].x, y2=c[n2].y, x3=c[n3].x, y3=c[n3].y; int ab=_Dis(n1,n2),bc=_Dis(n2,n3),ac=_Dis(n1,n3); int x4=0,y4=0; if(ab+ac==bc)x4=x2+x3-x1,y4=y2+y3-y1; if(ab+bc==ac)x4=x1+x3-x2,y4=y1+y3-y2; if(bc+ac==ab)x4=x1+x2-x3,y4=y1+y2-y3; c[g(i,4)].x=x4,c[g(i,4)].y=y4; } void SPFA(int S){ queue<int> q; init(); memset(vis,0,sizeof vis); dis[S]=0.0;vis[S]=1; q.push(S); while(!q.empty()){ int u=q.front();q.pop(); vis[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v;db w=e[i].w; if(dis[u]+w<dis[v]){ dis[v]=dis[u]+w; if(!vis[v]) vis[v]=1,q.push(v); } } } } db Min(db a,db b){ return a<b?a:b; } int main(){ scanf(\"%d\",&T); while(T--){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%d%lf%d%d\",&s,&t,&A,&B); for(int i=1;i<=s;++i){ for(int j=1;j<=3;++j) scanf(\"%d%d\",&c[g(i,j)].x,&c[g(i,j)].y),num[g(i,j)]=i; cal(i);num[g(i,4)]=i; scanf(\"%lf\",&tmp); for(int j=1;j<=4;++j) c[g(i,j)].T=tmp; } for(int i=1;i<=4*s;++i){ for(int j=1;j<=4*s;++j){ if(i==j)continue; if(num[i]==num[j]) add(i,j,c[i].T*Dis(i,j)); else add(i,j,t*Dis(i,j)); } } db ans=(db)INF; for(int i=0;i<=3;++i){ SPFA(4*A-i); for(int j=0;j<=3;++j) ans=Min(ans,dis[4*B-j]); } printf(\"%.1lf\\n\",ans); } return 0; }","title":"\u6700\u77ed\u8def"},{"location":"my%20past/OI/%E6%9C%80%E7%9F%AD%E8%B7%AF/#_1","text":"","title":"\u6700\u77ed\u8def"},{"location":"my%20past/OI/%E6%9C%80%E7%9F%AD%E8%B7%AF/#floyd","text":"Q.\u4e3a\u4ec0\u4e48\u4e2d\u8f6c\u70b9k\u8981\u653e\u5728\u6700\u5916\u5c42\uff1f A.\u56e0\u4e3afloyd\u7684\u5b9e\u8d28\u662fdp. \u7528f[k][i][j]\u8868\u793a\u7ecf\u8fc7i\u5230j\u7684\u901a\u8fc71...k\u7684\u8def\u5f84 \u5219 f[k][i][j]=min(f[k-1][i][j],f[k-1][i][k]+f[k-1][k][j]); \u7531\u4e8e\u6700\u5916\u9762\u4e00\u5c42\u7701\u7565\u6389\uff0c\u6240\u4ee5\u5f97\u51fafloyd\u5e38\u89c1\u7684\u5f0f\u5b50\uff1b \u4f46\u662f\uff1a \u201c\u4f60\u8981\u77e5\u9053\u4ed6\u662f\u4ece\u4e0a\u4e00\u5c42k\u8f6c\u79fb\u8fc7\u6765\u7684\uff0c\u6240\u4ee5\u5f53\u524d\u7684f[i][j]\u90fd\u5e94\u8be5\u662f\u5b8c\u6210\u4e0a\u4e00\u5c42\u52a8\u6001\u89c4\u5212\u7684\uff0c\u5982\u679ck\u4e0d\u662f\u5728\u6700\u5916\u5c42\uff0c\u90a3\u4e48f[i][j]\u5c31\u4e0d\u662f\u5b8c\u6210\u4e0a\u4e00\u5c42\u52a8\u6001\u89c4\u5212\u7684\u540e\u7684\u72b6\u6001\uff0c\u6709\u53ef\u80fd\u6709\u7684\u70b9\u6ca1\u6709\u7ecf\u8fc7k-1\u8fd9\u4e2a\u70b9\u7684\u677e\u5f1b\u3002\u201d :)","title":"\u5168\u6e90\u7b97\u6cd5Floyd"},{"location":"my%20past/OI/%E6%9C%80%E7%9F%AD%E8%B7%AF/#_2","text":"P2047 ($2^{11}-1$) \u8fd9\u9053\u9898\uff0c\u4e00\u5f00\u59cb\u601d\u8def\u662f\u5bf9\u7684\uff0c\u540e\u6765\u8d8a\u505a\u8d8a\u9519orz \u7528C[i][j]\u8868\u793ai\u5230j\u4e4b\u95f4\u7684\u6700\u77ed\u8def\u5f84\u6570\u76ee \u8f6c\u79fb\u65b9\u7a0b:(floyd==dp) void floyd() { for(int k=1; k<=n; ++k) { for(int i=1; i<=n; ++i) { for(int j=1; j<=n; ++j) { if(i==j || i==k || j==k)continue; if(dis[i][j]>dis[i][k]+dis[k][j]) { dis[i][j]=dis[i][k]+dis[k][j]; C[i][j]=C[i][k]*C[k][j]; continue; } if(dis[i][j]==dis[i][k]+dis[k][j]){ C[i][j]+=C[i][k]*C[k][j]; } } } } return; } \u7edf\u8ba1\u7b54\u6848:\u5f53dis[i][k]+dis[k][j]==dis[i][j]\u65f6\uff0c\u8fd9\u6761\u7ecf\u8fc7k\u7684\u8def\u5f84\u4e00\u5b9a\u662fi\u5230j\u7684\u6700\u77ed\u8def\uff0c\u5219: void sum() { for(int k=1; k<=n; ++k) { for(int i=1; i<=n; ++i) { for(int j=1; j<=n; ++j) { if(i==k || j==k || i==j)continue; if(dis[i][k]+dis[k][j]==dis[i][j]) { ans[k]+=(C[i][k]*C[k][j]*1.0)/(C[i][j]*1.0); } } } } } \u4e3a\u4ec0\u4e48floyd\u8fd9\u79cd\u66f4\u65b0\u6700\u77ed\u8def\u6761\u6570\u7684\u65b9\u5f0f\u662f\u5bf9\u7684\u5462\uff0c\u540c\u4e00\u6761\u8def\u4e0a\u7684\u4e0d\u540c\u70b9\u4f1a\u4e0d\u4f1a\u5bf9\u8fd9\u6761\u8def\u505a\u51fa\u91cd\u590d\u7684\u8d21\u732e\u5462\uff1f \u5176\u5b9e\u662f\u4e0d\u4f1a\u7684\uff0c\u8fd9\u662f\u7531\u4e8efloyd\u662f\u6309\u4e2d\u8f6c\u70b9k\u7684\u987a\u5e8f\u5b9e\u73b0\u7684\u7279\u6027\u3002 \u5047\u8bbe\u6309\u7167b,c,d\u7684\u987a\u5e8f(k)\u66f4\u65b0C[a][e]\uff0c\u5219\u7b2c\u4e00\u6b21C[a][e]=C[a][b]* C[b][e],\u56e0\u4e3aC[b][e]\u6ca1\u6709\u66f4\u65b0\u8fc7,\u5176\u503c\u4e3a0\uff0c\u6240\u4ee5C[a][e]\u6ca1\u6709\u53d8\u5316;c\u540cb;\u53ea\u6709d\u65f6\uff0cC[a][d]=C[d][e]=1,\u6240\u4ee5C[a][e]=1,\u7b26\u5408\u5b9e\u9645\u60c5\u51b5\u3002 \u6362\u53e5\u8bdd\u8bf4\uff0c$C[i][k]$\u662f\u73b0\u5728\uff0c$C[i][j]$\u662f\u672a\u6765\uff0c\u56e0\u4e3a$dp$\u7684\u65e0\u540e\u6548\u6027\uff0c\u6240\u4ee5\u672a\u6765\u4e0e\u8fc7\u53bb\u65e0\u5173\uff0c\u5373\u4e0e$C[i][k]$\u91cc\u9762\u7684\u5c0f\u533a\u95f4\u65e0\u5173\uff0c\u4e0d\u4f1a\u88ab\u66f4\u65b0\u5230\u3002 \u7efc\u4e0a\uff0c\u4e0d\u4f1a\u51fa\u73b0\u91cd\u590d\u8ba1\u7b97\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u53ea\u6709\u6700\u540e\u4e00\u6b21\u66f4\u65b0\u624d\u6709\u6548\u3002","title":"\u5168\u6e90\u4e4b\u8def\u5f84\u7edf\u8ba1"},{"location":"my%20past/OI/%E6%9C%80%E7%9F%AD%E8%B7%AF/#_3","text":"\u4e0e\u7f51\u7edc\u6d41\u7684\u5efa\u56fe\u7c7b\u4f3c\uff0c\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u5efa\u6a21 P4568 \u8fd9\u9898\u6709\u4e24\u79cd\u601d\u8def\uff0c\u4e00\u79cd\u662fdp\uff0c\u53e6\u4e00\u79cd\u662f\u5206\u5c42\u56fe\uff0c\u6211\u7528\u7684\u7b2c\u4e00\u79cd 1.dp\u53ef\u4ee5\u8bbedis[n][k]\u8868\u793a\u7528k\u6b21\u514d\u8d39\u4f18\u60e0\u540e\u5230\u8fben\u7684\u6700\u77ed\u8def\uff0c\u5219\u8f6c\u79fb\uff1a if(dis[v][k1]>dis[u][k1]+w && k1<=k){ dis[v][k1]=dis[u][k1]+w; if(!vis[v][k1]){ q.push(node(dis[v][k1],v,k1)); } } if(dis[v][k1+1]>dis[u][k1] && k1+1<=k){ dis[v][k1+1]=dis[u][k1]; if(!vis[v][k1+1]){ q.push(node(dis[v][k1+1],v,k1+1)); } } } \u8fd9\u91cc\u53ef\u4ee5\u7528\u7ed3\u6784\u4f53\u6765\u4fdd\u5b58\u6bcf\u4e2a\u8282\u70b9\u7528\u7684k\uff0c\u5728\u5168\u90fd\u8fdb\u961f\uff1b \u4e5f\u53ef\u4ee5\u76f4\u63a5\u5728\u6700\u5916\u5c42\u679a\u4e3ek\uff0c\u505ak\u6b21\u6700\u77ed\u8def 2.\u5206\u5c42\u56fe\u677f\u5b50 \u76f4\u63a5\u5efa\u51fak\u5c420\u8fb9\uff0c\u8868\u793a\u6bcf\u4e2a\u822a\u73ed\u514d\u8d39\u642d\u4e58\u540e\u75280\u8d39\u7528\u8df3\u8f6c\u5230\u76ee\u7684\u5730\u3002","title":"\u5206\u5c42\u56fe"},{"location":"my%20past/OI/%E6%9C%80%E7%9F%AD%E8%B7%AF/#dijkstra","text":"1.priority_queue\u5199\u6cd5\uff0c\u6700\u5e38\u7528\uff0c\u6ce8\u610f\u7ed3\u6784\u4f53\u6784\u9020\u51fd\u6570\u548c\u91cd\u8f7d\u8fd0\u7b97\u7b26\u7684\u5199\u6cd5\uff0c\u522b\u8bb0\u9519\u4e86\u3002 struct node{ int dis,pos; bool operator <(const node &x)const{ return x.dis<dis; } node(int d,int p){ dis=d,pos=p; } }e[N<<1]; void dijkstra() { for(int i=0;i<N;++i)dis[i]=INF; dis[s] = 0; q.push( node(0,s) ); while( !q.empty() ) { node u = q.top().pos; q.pop(); if( vis[u] )continue; vis[u] = 1; for( int i = head[u]; ~i; i = e[i].nxt ) { int v = e[i].v,w=e[i].w; if( dis[v] > dis[u] + w ) { dis[v] = dis[u] + w; if( !vis[v] ) { q.push( node (dis[v], v) ); } } } } } 2.\u624b\u5199\u5806\uff1a\u6bd4\u7b2c\u4e00\u79cd\u5feb\u4e86hin\u591a\uff0c\u8d39\u7528\u6d41\u7b49\u5f88\u591a\u7528\u5230\u6700\u77ed\u8def\u4e14\u6570\u636e\u91cf\u5f88\u5927\u7684\u9898\u5c31\u8981\u7528\u624b\u5199\u5806\u4e86\uff0c\u80fd\u5feb1\u500d\u5de6\u53f3\u3002 P1629 \u6a21\u677f\u9898 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e4+10,M=2e5+10,INF=1e14; struct hp{ int dis,pos; }heap[N]; struct node{ int v,w,nxt,t; }e[M<<1]; int head[N],dis[N],vis[N]; int cnt,n,m,u,v,w,tot; void add(int u,int v,int w,int t){ e[++cnt].v=v; e[cnt].w=w; e[cnt].t=t; e[cnt].nxt=head[u]; head[u]=cnt; return; } void push(int d,int p){ heap[++tot].dis=d,heap[tot].pos=p; int now=tot; while(now>1){ int nxt=now>>1; if(heap[nxt].dis<=heap[now].dis)break; swap(heap[nxt],heap[now]); now=nxt; } return; } int pop(){ int ans=heap[1].pos; swap(heap[1],heap[tot]); tot--; int now=1; while(now*2<=tot){ int nxt=now<<1; if(now*2+1<=tot && heap[nxt].dis>heap[nxt+1].dis)nxt++; if(heap[nxt].dis>=heap[now].dis)break; swap(heap[nxt],heap[now]); now=nxt; } return ans; } bool empty(){ return tot==0; } void dij(){ //memset(dis,0x3f,sizeof dis); for(int i=0;i<N;++i)dis[i]=INF; memset(vis,0,sizeof vis); dis[1]=0; tot=0; push(0,1); while(!empty()){ int u=pop(); if(vis[u])continue; vis[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w,t=e[i].t; if(t && dis[v]>dis[u]+w){ dis[v]=dis[u]+w; if(!vis[v]){ push(dis[v],v); } } } } return; } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld%lld\",&u,&v,&w); add(u,v,w,1); add(v,u,w,0); } dij(); int ans=0; for(int i=2;i<=n;++i){ ans+=dis[i]; } for(int i=0;i<=m*2-1;i+=2){ e[i].t=0; e[i^1].t=1; } dij(); for(int i=2;i<=n;++i){ ans+=dis[i]; } printf(\"%lld\",ans); return 0; }","title":"dijkstra"},{"location":"my%20past/OI/%E6%9C%80%E7%9F%AD%E8%B7%AF/#spfa","text":"~~\u636e\u8bf4\u5b83\u6b7b\u4e86~~ bellman-ford \u7684\u6c11\u95f4\u52a0\u5f3a\u7248\u3002 bool SPFA(){ int s=1; for(int i=0;i<N;++i)dis[i]=INF; memset(vis,0,sizeof vis); vis[s]=1; dis[s]=0; q.push(s); while(!q.empty()){ int u=q.front();q.pop(); vis[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(dis[v]>dis[u]+w){ dis[v]=dis[u]+w; if(!vis[v]){ vis[v]=1; q.push(v); } } } } }","title":"SPFA"},{"location":"my%20past/OI/%E6%9C%80%E7%9F%AD%E8%B7%AF/#_4","text":"\u5728\u4e00\u4e9b\u9898\u4e2d\u4f1a\u7ed9\u4f60\u8282\u70b9\u7684\u6743\u503c\uff0c\u5e76\u8981\u6c42\u7ecf\u8fc7\u7684\u8282\u70b9\u7684\u6743\u503c\u6700\u5927\u503c\u4e0d\u8d85\u8fc7k\uff0c\u6c42\u6700\u77ed\u8def\u3002\u8fd9\u65f6\u5019\uff0c\u5c31\u53ef\u4ee5\u4e8c\u5206\u6743\u503c\u7684\u9650\u5236\uff0c\u5c06\u4e0d\u6ee1\u8db3\u7684\u8282\u70b9~~ban\u6389~~,\u7136\u540e\u8dd1\u6700\u77ed\u8def\u5373\u53ef\u3002 P1462 \u6a21\u677f\u9898","title":"\u4e8c\u5206\u8282\u70b9"},{"location":"my%20past/OI/%E6%9C%80%E7%9F%AD%E8%B7%AF/#_5","text":"\u7ecf\u5178\u7684\u6700\u77ed\u8def\u89e3\u9898\u65b9\u6cd5 P1629 \u6a21\u677f\u9898 P5663 ~~\u8003\u573a\u4e0a\u9001\u8d70\u6211\u7684\u9898\uff0c\u796d\u6211\u76842019~~ \u76f4\u63a5\u641c\u7d22\u76f4\u63a5\u7206\u70b8\uff0c\u66f4\u4f55\u51b5\u6211\u8003\u573a\u4e0a\u6839\u672c\u6ca1\u5199\u5bf9 \u6211\u4eec\u53d1\u73b0\uff0c\u5047\u8bbe\u4ece$u$\u51fa\u53d1\u53bb$v$,\u5982\u679c$u,v$\u4e4b\u95f4\u7684\u8ddd\u79bb\u7b49\u4e8e$L$,\u90a3\u4e48\u6240\u6709\u8ddd\u79bb$u$\u4e3a$L+2,L+4,...$\u7684\u70b9\u90fd\u53ef\u4ee5\u5230\u8fbe\uff1b \u800c\u5bf9\u4e8e$L+1$\uff0c\u5219\u4e0d\u4e00\u5b9a\u6709\uff0c\u9700\u8981\u4ece$L$\u8f6c\u79fb\u800c\u6765\u3002 \u6240\u4ee5\u8fd9\u9053\u9898\u53d8\u6210\u4e86\u4e00\u9053\u6c42\u5947\u5076\u8def\u5f84\u7684\u9898\u3002 \u5947\u5076\u8def\u5f84\u5c31\u662f\u6307\u5c06\u6574\u4e2a\u56fe\u5206\u6210\u957f\u5ea6\u4e3a\u5947\u6570\u7684\u8def\u5f84\u6838\u5076\u6570\u7684\u8def\u5f84\uff0c\u5e76\u5206\u522b\u4e92\u76f8\u66f4\u65b0\u3002 \u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8981$dijkstra$\u5373\u53ef\u6c42\u51fa\u6240\u6709\u8def\u5f84\u8ddd\u79bb\u3002 \u5982\u679c$dis[a][t]>L(L \\& 1= t)$,\u5219\u4e0d\u7528\u63d0\u4f9b\u96f6\u4ef6,\u5426\u5219\u5c31\u8981\u63d0\u4f9b\u96f6\u4ef6\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=1e5+10; int n,m,q,cnt,u,v,a,L; int head[N],dis[N][2],vis[N][2]; struct edge{ int v,nxt; }e[N<<1]; struct node{ int dis,pos,type; bool operator <(const node &x)const{ return x.dis<dis; } node(int d,int p,int t){ dis=d,pos=p,type=t; } }; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void dij(int s){ memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); priority_queue<node> q; q.push(node(0,s,0)); dis[s][0]=0; while(!q.empty()){ node tmp=q.top();q.pop(); int u=tmp.pos,t=tmp.type; if(vis[u][t])continue; vis[u][t]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(dis[v][1]>dis[u][0]+1){ dis[v][1]=dis[u][0]+1; if(!vis[v][1])q.push(node(dis[v][1],v,1)); } if(dis[v][0]>dis[u][1]+1){ dis[v][0]=dis[u][1]+1; if(!vis[v][0])q.push(node(dis[v][0],v,0)); } } } } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld%lld\",&n,&m,&q); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&u,&v); add(u,v),add(v,u); } dij(1); for(int i=1;i<=q;++i){ scanf(\"%lld%lld\",&a,&L); if(L&1){ if(dis[a][1]>L)printf(\"No\\n\"); else printf(\"Yes\\n\"); }else{ if(dis[a][0]>L)printf(\"No\\n\"); else printf(\"Yes\\n\"); } } return 0; } P7997 ~~\u53c8\u662f\u8003\u573a\u4e0a\u8650\u6211\u5343\u767e\u904d\u7684\u9898~~ \u8fd9\u9898\u4e5f\u662f\u5947\u5076\u8def\u5f84\u7684\u677f\u5b50\u9898\uff0c\u5982\u679c\u4e00\u4e2a\u6570$i$\u5c0f\u4e8e$a[j]$\uff0c\u5219\u4e00\u5b9a\u53ef\u4ee5\u53bb\u5230$i+a[j]$\u540e\u518d\u56de\u5230$i$;\u5e76\u4e14\u603b\u70b9\u6570\u53ea\u6709$2* MAXa=4000$\u4e2a\u70b9\uff0c\u6240\u4ee5\u76f4\u63a5\u6700\u77ed\u8def\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=1e4+10,M=4e6+10; int n,T,L,m,cnt,MAX; int a[N],head[N],vis[N][2],dis[N][2],ans[N]; struct node{ int dis,pos,type; bool operator <(const node &x)const{ return x.dis<dis; } node(int d,int p,int t){ dis=d,pos=p,type=t; } }; struct edge{ int v,nxt; }e[M<<1]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void init(){ for(int i=0;i<=MAX+MAX-1;++i) for(int j=1;j<=n;++j) add(i,i>=a[j]?i-a[j]:i+a[j]); } void dij(int s){ memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); priority_queue<node> q; q.push(node(0,s,0)); dis[s][0]=0; while(!q.empty()){ node tmp=q.top();q.pop(); int u=tmp.pos,t=tmp.type; if(vis[u][t])continue; vis[u][t]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(dis[v][1]>dis[u][0]+1){ dis[v][1]=dis[u][0]+1; if(!vis[v][1])q.push(node(dis[v][1],v,1)); } if(dis[v][0]>dis[u][1]+1){ dis[v][0]=dis[u][1]+1; if(!vis[v][0])q.push(node(dis[v][0],v,0)); } } } } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld\",&n,&T); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i]),MAX=max(MAX,a[i]); init(); dij(0); for(int i=1;i<=T;++i){ scanf(\"%lld\",&m); for(int i=MAX+MAX-1;i>=0;--i){ if(dis[i][m&1]<=m){ printf(\"%lld\\n\",i); break; } } } return 0; } P1027 ~~sb\u9898\u771f\u9ebb\u70e6\uff0c\u5199nm\u4e24\u5c0f\u65f6~~ \u5c31...\u76f4\u63a5\u6700\u77ed\u8def\u5c31\u884c\u4e86\uff0c\u4f46\u5efa\u56fe\u8d3c\u9ebb\u70e6\u3002SPFA\u8fd8\u6ca1\u6b7b\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<queue> using namespace std; typedef double db; const int N=1e3+10,INF=0x3f3f3f3f,M=1e6+10; int cnt,n,m,T,s,A,B; db tmp,t; int num[N]; int vis[N],head[N]; db dis[N]; struct edge{ int v,nxt; db w; }e[M]; struct city{ int x,y; db T; }c[N]; inline db Dis(int i,int j){int _x=c[i].x-c[j].x,_y=c[i].y-c[j].y;return (db)sqrt(_x*_x+_y*_y);} inline int _Dis(int i,int j){int _x=c[i].x-c[j].x,_y=c[i].y-c[j].y;return (_x*_x+_y*_y);} inline int g(int x,int y){return 4*(x-1)+y;} void add(int u,int v,db w){e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt;} void init(){for(int i=1;i<=4*s;++i)dis[i]=(db)INF;} void cal(int i){ int n1=g(i,1),n2=g(i,2),n3=g(i,3); int x1=c[n1].x, y1=c[n1].y, x2=c[n2].x, y2=c[n2].y, x3=c[n3].x, y3=c[n3].y; int ab=_Dis(n1,n2),bc=_Dis(n2,n3),ac=_Dis(n1,n3); int x4=0,y4=0; if(ab+ac==bc)x4=x2+x3-x1,y4=y2+y3-y1; if(ab+bc==ac)x4=x1+x3-x2,y4=y1+y3-y2; if(bc+ac==ab)x4=x1+x2-x3,y4=y1+y2-y3; c[g(i,4)].x=x4,c[g(i,4)].y=y4; } void SPFA(int S){ queue<int> q; init(); memset(vis,0,sizeof vis); dis[S]=0.0;vis[S]=1; q.push(S); while(!q.empty()){ int u=q.front();q.pop(); vis[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v;db w=e[i].w; if(dis[u]+w<dis[v]){ dis[v]=dis[u]+w; if(!vis[v]) vis[v]=1,q.push(v); } } } } db Min(db a,db b){ return a<b?a:b; } int main(){ scanf(\"%d\",&T); while(T--){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%d%lf%d%d\",&s,&t,&A,&B); for(int i=1;i<=s;++i){ for(int j=1;j<=3;++j) scanf(\"%d%d\",&c[g(i,j)].x,&c[g(i,j)].y),num[g(i,j)]=i; cal(i);num[g(i,4)]=i; scanf(\"%lf\",&tmp); for(int j=1;j<=4;++j) c[g(i,j)].T=tmp; } for(int i=1;i<=4*s;++i){ for(int j=1;j<=4*s;++j){ if(i==j)continue; if(num[i]==num[j]) add(i,j,c[i].T*Dis(i,j)); else add(i,j,t*Dis(i,j)); } } db ans=(db)INF; for(int i=0;i<=3;++i){ SPFA(4*A-i); for(int j=0;j<=3;++j) ans=Min(ans,dis[4*B-j]); } printf(\"%.1lf\\n\",ans); } return 0; }","title":"\u53cd\u5411\u5efa\u8fb9"},{"location":"my%20past/OI/%E6%9E%84%E9%80%A0/","text":"\u6784\u9020 \u9012\u63a8\u6784\u9020+\u77e9\u9635\u52a0\u901f \u77e9\u9635\u4e58\u6cd5\u6709\u4ecb\u7ecd\u3002 P3990 \u6734\u7d20$dp$ $$ f[i][j]= \\left{ \\begin{array}{ll} f[i+1][j-1]+f[i+1][j-3]+...\\f[i][j-1]+f[i][j-3]+...\\f[i-1][j-1]+f[i-1][j-3]+... \\end{array} \\right . $$ \u590d\u6742\u5ea6$O(nm^2)$ 2.\u5c0f\u4f18\u5316$dp$ \u6ce8\u610f\u5230 $$ f[i][j-2]= \\left{ \\begin{array}{ll} f[i+1][j-3]+...\\f[i][j-3]+...\\f[i-1][j-3]+... \\end{array} \\right . $$ \u56e0\u6b64 $$ f[i][j]=f[i-1][j-1]+f[i][j-1]+f[i+1][j-1]+f[i][j-2]\\times [j\\geq 4] $$ \u6ce8\u610f\u7279\u5224\uff0c\u56e0\u4e3a\u53ea\u6709$j\\geq 4$\u65f6\u624d\u6709$f[i][j-3]...$\u8fd9\u4e9b\u9879\uff0c\u624d\u9700\u8981\u52a0\u4e0a$f[i][j-2]$,\u4e0d\u7136\u4f1a\u91cd\u590d\u3002\u5982$f[1][3]$\u53ea\u4f1a\u52a0\u4e0a$f[1][1]$\u8fd9\u4e2a\u521d\u59cb\u503c\uff0c\u800c$f[1][1]$\u4e0d\u662f\u9012\u63a8\u5f97\u6765\u7684\u3002 \u590d\u6742\u5ea6$O(nm)$ \u77e9\u9635\u52a0\u901f $$\\left[ \\begin{matrix} f_{1,j}\\f_{2,j}\\...\\f_{n,j}\\f_{1,j-1}\\f_{2,j-1}\\...\\f_{n,j-1} \\end{matrix} \\right]= S \\times \\left[ \\begin{matrix} f_{1,j-1}\\f_{2,j-1}\\...\\f_{n,j-1}\\f_{1,j-2}\\f_{2,j-2}\\...\\f_{n,j-2} \\end{matrix} \\right] \\ n=3\u65f6\uff0cS=\\ \\left[ \\begin{matrix}1&1&0&1&0&0\\1&1&1&0&1&0\\0&1&1&0&0&1\\1&0&0&0&0&0\\0&1&0&0&0&0\\0&0&1&0&0&0 \\end{matrix}\\right] $$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=110,P=30011; int n,m; int g[N][N]; struct ma{ int f[N][N],n,m; ma(){ memset(f,0,sizeof f),n=m=0; } }s,t,ans; ma operator *(ma a,ma b){ ma c=ma(); int x=a.n,y=a.m,z=b.m; c.n=x,c.m=z; for(int i=0;i<x;++i) for(int j=0;j<z;++j) for(int k=0;k<y;++k) c.f[i][j]=(c.f[i][j]+a.f[i][k]*b.f[k][j]%P)%P; return c; } ma kp(ma x,int p){ if(p<=1) return x; if(p&1) return x*kp(x*x,p>>1); else return kp(x*x,p>>1); } void init(){ t.n=t.m=n+n; for(int i=0;i<n;++i){ int l=max(0ll,i-1),r=min(n-1,i+1); for(int j=l;j<=r;++j) t.f[i][j]=1; t.f[i][n+i]=t.f[n+i][i]=1; } memset(g,0,sizeof g); g[1][1]=1; for(int j=2;j<=3;++j){ for(int i=1;i<=n;++i){ if(i+1<=n) g[i][j]+=g[i+1][j-1]; if(i-1>=1) g[i][j]+=g[i-1][j-1]; g[i][j]+=g[i][j-1]; if(j-3>=1) g[i][j]+=g[i][j-2]; } } s.n=n+n,s.m=1; for(int i=0;i<n;++i) s.f[i][0]=g[i+1][3]; for(int i=n;i<n+n;++i) s.f[i][0]=g[i-n+1][2]; } signed main(){ scanf(\"%lld%lld\",&n,&m); init(); if(m<=3){ printf(\"%lld\",g[n][m]%P); }else{ ans=kp(t,m-3)*s; printf(\"%lld\",ans.f[n-1][0]%P); } return 0; } \u65b9\u6848\u6784\u9020 P7854 \u5bf9\u4e8e\u4e00\u4e2a\u70b9\u60f3\u505a\u522b\u4eba\u7684\u513f\u5b50\uff0c\u5f53\u4e14\u4ec5\u5f53\u5b83\u7684\u6743\u503c$a_i$\u4e0e\u7236\u4eb2\u7684\u6743\u503c$a_j$\u6ee1\u8db3\uff1a$a_j|a_i$. \u6240\u4ee5\uff0c\u5bf9\u4e8e\u6240\u6709\u70b9\uff0c\u6211\u4eec\u5148\u6309\u7167\u6743\u503c\u5927\u5c0f\u4ece\u5927\u5230\u5c0f\u6392\u4e2a\u5e8f\u3002 \u7136\u540e\u5bf9\u4e8e\u5f53\u524d\u70b9$(u,a_u)$\u5c06\u6240\u6709 \u6ca1\u6709\u7236\u4eb2\u8282\u70b9 \u5e76\u4e14$a_u|a_v$\u7684\u70b9$v$\u8fde\u5728$u$\u7684\u4e0b\u9762\u3002 \u540c\u65f6\uff0c\u5982\u679c\u4e00\u4e2a\u70b9\u6709\u7236\u4eb2\u8282\u70b9$(p,a_p)$,$a_v$\u8fd8\u662f$a_u$\u7684\u500d\u6570\uff0c\u5e76\u4e14$\\gcd(a_p,a_u)=a_u$,\u8bf4\u660e$a_p$\u4e00\u5b9a\u53ef\u4ee5\u4f5c\u4e3a$a_u$\u7684\u5b50\u8282\u70b9(\u56e0\u4e3a\u4ece\u5927\u5230\u5c0f\u8003\u8651\uff0c\u6240\u4ee5$a_u$\u4e00\u5b9a\u6bd4$a_p$\u5c0f)\uff0c\u90a3\u4e48\u8df3\u8fc7\u4e0d\u7528\u5904\u7406\uff1b \u5426\u5219\uff0c\u8bf4\u660e$a_p$\u4e0d\u80fd\u4f5c\u4e3a$a_u$\u7684\u5b50\u8282\u70b9\uff0c\u90a3\u4e48$v$\u540c\u65f6\u6709\u4e24\u4e2a\u6839\u8282\u70b9$u,p$\uff0c\u4e0d\u6ee1\u8db3\uff0c\u8f93\u51fa$-1$. \u5efa\u5b8c\u6811\u540e\uff0c\u8fd9\u68f5\u6811\u6ee1\u8db3\u6240\u6709\u8282\u70b9\u6709\u552f\u4e00\u7236\u4eb2\u8282\u70b9\u5e76\u4e14\u6743\u503c\u90fd\u662f\u7236\u4eb2\u8282\u70b9\u7684\u500d\u6570\u3002 \u90a3\u4e48\u6211\u4eec\u8fd8\u9700\u8981\u5224\u65ad\u662f\u5426\u51fa\u73b0$\\gcd(i,j)=k$\u4e14$k$\u6ca1\u51fa\u73b0\u8fc7\u7684\u60c5\u51b5\u3002 \u5982\uff1a 3 1 4 6 \u8fd9\u79cd\u3002 \u9996\u5148\uff0c\u5c06\u6240\u6709\u51fa\u73b0\u8fc7\u7684\uff0c\u662f$k$\u500d\u6570\u7684\u8282\u70b9\u62ff\u51fa\u6765\u3002\u5982\u679c\u8fd9\u4e9b\u8282\u70b9\u5728\u539f\u6811\u79cd\u7ec4\u6210\u4e86\u591a\u9897\u5b50\u6811\uff0c\u90a3\u4e48\u8bf4\u660e\u8fd9\u4e9b\u5b50\u6811\u7684\u6839\u8282\u70b9\u6743\u503c\u4e24\u4e24\u6c42$\\gcd$\u4e00\u5b9a\u80fd\u6c42\u51fa$k$,\u800c$k$\u4e0d\u5b58\u5728\uff0c\u5219\u65e0\u89e3. \u5426\u5219\uff0c\u5982\u679c\u53ea\u6709\u4e00\u9897\u5b50\u6811\uff0c\u5c31\u53ea\u4f1a\u6c42\u51fa\u90a3\u4e2a\u6839\u8282\u70b9\uff0c\u4e0d\u4f1a\u6c42\u51fa$k$\u3002 \u90a3\u4e48\u600e\u4e48\u5224\u65ad\u5462\uff1f\u6211\u4eec\u76f4\u63a5\u5224\u65ad\u8fd9\u4e9b\u8282\u70b9\u662f\u5426\u6709\u7236\u4eb2\uff0c\u6216\u8005\u5176\u7236\u4eb2\u8282\u70b9\u662f\u4e0d\u662f$k$\u7684\u500d\u6570\u65f6\uff0c\u5982\u679c\u6ca1\u6709\u7236\u4eb2\u6216\u8005\u6ca1\u6709\u662f$k$\u500d\u6570\u7684\u7236\u4eb2\uff0c\u8bf4\u660e\u5b83\u662f\u67d0\u9897\u5b50\u6811\u7684\u6839\u8282\u70b9\uff0c\u8ba1\u6570\u5668\u52a0\u4e00\uff1b\u5f53\u8ba1\u6570\u5668$>1$\u65f6\uff0c\u5c31\u65e0\u89e3\u4e86\u3002 \u6240\u4ee5\u6700\u7ec8\u590d\u6742\u5ea6$O((n+m)\\log n)$ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<vector> using namespace std; const int N=1e5+10,M=1e6+10; int gcd(int a,int b){ return !b?a:gcd(b,a%b); } int n,cnt; int fa[N],b[N],f[M],head[N]; vector<int> vis[M]; struct node{ int id,val; }a[N]; bool cmp(node a,node b){ return a.val>b.val; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i) scanf(\"%d\",&a[i].val),a[i].id=i,b[i]=a[i].val,vis[a[i].val].push_back(a[i].id); sort(a+1,a+n+1,cmp); int lst=0,flag=1; for(int i=1;i<=n;++i){ int pre=a[i].id; if(lst==a[i].val) continue; for(int j=a[i].val;j<M;j+=a[i].val){ if(vis[j].size()){ for(int k=0;k<vis[j].size();++k){ int now=vis[j][k]; if(now==pre) continue; if(!fa[now]) fa[now]=pre; else{ int g=gcd(b[fa[now]],b[pre]); if(g!=b[pre]) flag=0; } } } } lst=a[i].val; } for(int i=1;i<M;++i){ int tmp=0; for(int j=i;j<M;j+=i){ if(vis[j].size()){ for(int k=0;k<vis[j].size();++k){ int now=vis[j][k]; if(fa[now]==0 || b[fa[now]]%i!=0) ++tmp; } } } if(tmp>1){ flag=0;break; } } if(!flag) printf(\"-1\"); else for(int i=1;i<=n;++i) printf(\"%d \",fa[i]); return 0; } P3557 \u6ce8\u610f\u5230\u8ddd\u79bb\u4e3a1\u7684\u60c5\u51b5\u7684 \u6700\u4f18\u89e3 \u5c31\u662f\u8ddd\u79bb\u4e3a2\u7684\u60c5\u51b5\u7684\u4e00\u4e2a \u53ef\u884c\u89e3 ,\u56e0\u4e3a\u8ddd\u79bb\u4e3a1\u65f6\uff0c\u4e24\u4e2a\u5854\u4e4b\u95f4\u6700\u591a\u53ea\u80fd\u95f4\u9694\u4e24\u4e2a\u8282\u70b9\uff0c\u8fd9\u6837\u624d\u80fd\u4fdd\u8bc1\u5854\u6570\u91cf\u6700\u5c11\u4e14\u8986\u76d6\u5168\u56fe,\u800c\u8fd9\u79cd\u6784\u9020\u65b9\u5f0f\u7b49\u4ef7\u4e8e\u8ddd\u79bb\u4e3a2\u7684\u60c5\u51b5\u4e0b\u5c06\u6240\u6709\u672a\u8986\u76d6\u7684\u8282\u70b9\u9009\u4f5c\u5854\uff0c\u5e76\u8986\u76d6\u4e0a\u5468\u56f4\u70b9\u7684\u6784\u9020\u65b9\u5f0f\u3002\u800c\u9898\u76ee\u4fdd\u8bc1\u4e00\u5b9a\u53ef\u4ee5\u6784\u9020\u51fa\u7b49\u4e8e$k$\u7684\u6700\u4f18\u89e3$1$\u3002\u56e0\u6b64\u8fd9\u79cd\u6784\u9020\u65b9\u5f0f\u4e00\u5b9a\u80fd\u6784\u9020\u51fa$\\leq k$\u7684\u53ef\u884c\u89e3$2$\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=5e5+10,M=1e6+10; int n,m,k,cnt,u,v; int head[N],ans[N],vis[N]; struct edge{ int v,nxt; }e[M<<1]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void dfs(int u,int p,int dep){ vis[u]=1; if(dep>=2) return; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; dfs(v,u,dep+1); } } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d%d%d\",&n,&m,&k); for(int i=1;i<=m;++i) scanf(\"%d%d\",&u,&v),add(u,v),add(v,u); for(int i=1;i<=n;++i) if(!vis[i]) ans[++ans[0]]=i,dfs(i,0,0); printf(\"%d\\n\",ans[0]); for(int i=1;i<=ans[0];++i) printf(\"%d \",ans[i]); return 0; } P5441 ~~\u540d\u526f\u5176\u5b9e\u7684MO\u9898~~ \u521d\u59cb\u7b54\u6848\u663e\u7136\uff0c\u4e3a$C_n^4$ \u5b9a\u4e49$S_k$\u8868\u793a$i\\to ((i+k-1)\\mod n+1)$\u7684\u6240\u6709\u8fb9\u7684\u96c6\u5408,\u5373\u8df3\u8fc7\u4e86$k-1$\u4e2a\u70b9\u3002$S_k=S_{n-k},|S_k|=\\frac n2$ \u6ce8\u610f\u5230\u6700\u5916\u5c42$S_1$/\u6b21\u5916\u5c42$S_2$\u7684\u8fb9\u90fd\u53ef\u4ee5\u6309\u7167\u4e00\u4e2a\u65b9\u5411\u653e\u7f6e\uff0c\u4e0d\u9700\u8981\u53cc\u5411\u8fb9\uff0c\u5bf9\u7b54\u6848\u6ca1\u6709\u5f71\u54cd\u3002 \u800c\u5bf9\u4e8e$k\\geq 3$\u7684\u60c5\u51b5\uff0c\u7531\u4e8e\u524d\u4e24\u5c42\u7684\u8fb9\u662f\u6309\u7167\u4e00\u4e2a\u65b9\u5411\u653e\u7f6e\u7684\uff0c\u6240\u4ee5\u4f1a\u51fa\u73b0\u4e24\u4e2a\u4e0d\u540c\u65b9\u5411\u7684\u73af\u5171\u7528\u8fd9\u4e00\u6761\u8fb9\uff0c\u5373\u9700\u8981\u53cc\u5411\u8fb9\u3002\u5982\u679c\u4e0d\u7528\u53cc\u5411\u8fb9\uff0c\u5c31\u4f1a\u4e22\u5931\u4e00\u90e8\u5206\u65b9\u6848\u6570\u3002 \u90a3\u4e48\u6211\u4eec\u8d2a\u5fc3\u5730\u53d6\u4e24\u73af\u4e2d\u6700\u5927\u73af\u7684\u65b9\u5411\u4f5c\u4e3a\u8fd9\u6761\u8fb9\u7684\u65b9\u5411\uff0c\u4e22\u5931\u4e00\u90e8\u5206\u6700\u5c0f\u73af\u4e0a\u7684\u65b9\u6848\u6570,\u8fd9\u79cd\u8fb9\u7684\u6570\u91cf\u4e3a$n$\u6761\u3002(\u4e24\u73af\u76f8\u7b49\u4efb\u53d6\u4e00\u4e2a\uff0c\u4f46\u6ce8\u610f\u8fb9\u6570\u53ea\u6709$\\frac n2$\u6761) \u53ef\u4ee5\u53d1\u73b0$S_k$\u7684\u6240\u6709\u8fb9\u53ef\u4ee5\u7ec4\u6210\u6240\u6709\u70b9\u6570\u4e3a$k$\u7684\u73af\u3002 \u5c0f\u73af\u65b9\u6848\u6570$=C_{k-2}^2$,\u56e0\u4e3a\u4e00\u4e2a\u8fb9\u7684\u4e24\u4e2a\u70b9\u4e00\u5b9a\u8981\u53d6\uff0c\u4e0d\u7136\u72b6\u6001\u6709\u91cd\u590d\u3002 \u90a3\u4e48\u6211\u4eec\u6309\u7167\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\uff0c\u51cf\u53bb\u8fd9\u4e9b\u8d21\u732e\uff0c\u6700\u540e\u5269\u4e0b\u7684\u5c31\u662f\u6700\u5927\u65b9\u6848\u6570\u3002 \u81f3\u4e8e\u65b9\u6848\uff0c\u53ea\u9700\u8981\u5728\u7edf\u8ba1$k\\geq 3$\u8fb9\u7684\u65f6\u5019\u8bb0\u5f55\u4e00\u4e0b\u4e24\u4e2a\u7aef\u70b9\uff0c\u5c06\u51cf\u53bb\u7684\u8bbe\u4e3a\u5355\u5411\uff0c\u5269\u4e0b\u7684\u8bbe\u4e3a\u53cc\u5411\u5373\u53ef\u3002\u518d\u52a0\u4e0a$k\\leq 2$\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=110,M=1e5+10; int C[N],c[N],f[N][N]; int n,cnt,sum,m; struct node{ int u,v,w; node(int uu=0,int vv=0,int ww=0){ u=uu,v=vv,w=ww; } }ans[M]; void work(){ C[4]=1;c[2]=1; for(int i=5;i<=n;++i) C[i]=C[i-1]*i/(i-4); for(int i=3;i<=n;++i) c[i]=c[i-1]*i/(i-2); cnt=0;sum=C[n]; for(int i=1;i<=n;++i) for(int j=1;j<=2;++j) f[i][(i+j-1)%n+1]=1,f[i][i]=0; for(int i=4;i<=n-i+2;++i){ int tmp=c[i-2]; if(i==n-i+2) for(int j=1;j<=n/2;++j) ans[++cnt]=node(j,(j+i-1-1)%n+1,tmp);//\u5bf9\u5e94\u4e24\u73af\u5927\u5c0f\u76f8\u7b49\u7684\u60c5\u51b5\u3002 else for(int j=1;j<=n;++j) ans[++cnt]=node(j,(j+i-1-1)%n+1,tmp); } m=max(0,n*(n-7)/2); for(int i=1;i<=m;++i){ int u=ans[i].u,v=ans[i].v,w=ans[i].w; sum-=w;f[u][v]=1; } for(int i=m+1;i<=cnt;++i){ int u=ans[i].u,v=ans[i].v; f[u][v]=f[v][u]=1; } } int main(){ scanf(\"%d\",&n); work(); printf(\"%d\\n\",sum); for(int i=1;i<=n;++i){ for(int j=1;j<=n;++j) printf(\"%d \",f[i][j]); printf(\"\\n\"); } return 0; }","title":"\u6784\u9020"},{"location":"my%20past/OI/%E6%9E%84%E9%80%A0/#_1","text":"","title":"\u6784\u9020"},{"location":"my%20past/OI/%E6%9E%84%E9%80%A0/#_2","text":"\u77e9\u9635\u4e58\u6cd5\u6709\u4ecb\u7ecd\u3002 P3990 \u6734\u7d20$dp$ $$ f[i][j]= \\left{ \\begin{array}{ll} f[i+1][j-1]+f[i+1][j-3]+...\\f[i][j-1]+f[i][j-3]+...\\f[i-1][j-1]+f[i-1][j-3]+... \\end{array} \\right . $$ \u590d\u6742\u5ea6$O(nm^2)$ 2.\u5c0f\u4f18\u5316$dp$ \u6ce8\u610f\u5230 $$ f[i][j-2]= \\left{ \\begin{array}{ll} f[i+1][j-3]+...\\f[i][j-3]+...\\f[i-1][j-3]+... \\end{array} \\right . $$ \u56e0\u6b64 $$ f[i][j]=f[i-1][j-1]+f[i][j-1]+f[i+1][j-1]+f[i][j-2]\\times [j\\geq 4] $$ \u6ce8\u610f\u7279\u5224\uff0c\u56e0\u4e3a\u53ea\u6709$j\\geq 4$\u65f6\u624d\u6709$f[i][j-3]...$\u8fd9\u4e9b\u9879\uff0c\u624d\u9700\u8981\u52a0\u4e0a$f[i][j-2]$,\u4e0d\u7136\u4f1a\u91cd\u590d\u3002\u5982$f[1][3]$\u53ea\u4f1a\u52a0\u4e0a$f[1][1]$\u8fd9\u4e2a\u521d\u59cb\u503c\uff0c\u800c$f[1][1]$\u4e0d\u662f\u9012\u63a8\u5f97\u6765\u7684\u3002 \u590d\u6742\u5ea6$O(nm)$ \u77e9\u9635\u52a0\u901f $$\\left[ \\begin{matrix} f_{1,j}\\f_{2,j}\\...\\f_{n,j}\\f_{1,j-1}\\f_{2,j-1}\\...\\f_{n,j-1} \\end{matrix} \\right]= S \\times \\left[ \\begin{matrix} f_{1,j-1}\\f_{2,j-1}\\...\\f_{n,j-1}\\f_{1,j-2}\\f_{2,j-2}\\...\\f_{n,j-2} \\end{matrix} \\right] \\ n=3\u65f6\uff0cS=\\ \\left[ \\begin{matrix}1&1&0&1&0&0\\1&1&1&0&1&0\\0&1&1&0&0&1\\1&0&0&0&0&0\\0&1&0&0&0&0\\0&0&1&0&0&0 \\end{matrix}\\right] $$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=110,P=30011; int n,m; int g[N][N]; struct ma{ int f[N][N],n,m; ma(){ memset(f,0,sizeof f),n=m=0; } }s,t,ans; ma operator *(ma a,ma b){ ma c=ma(); int x=a.n,y=a.m,z=b.m; c.n=x,c.m=z; for(int i=0;i<x;++i) for(int j=0;j<z;++j) for(int k=0;k<y;++k) c.f[i][j]=(c.f[i][j]+a.f[i][k]*b.f[k][j]%P)%P; return c; } ma kp(ma x,int p){ if(p<=1) return x; if(p&1) return x*kp(x*x,p>>1); else return kp(x*x,p>>1); } void init(){ t.n=t.m=n+n; for(int i=0;i<n;++i){ int l=max(0ll,i-1),r=min(n-1,i+1); for(int j=l;j<=r;++j) t.f[i][j]=1; t.f[i][n+i]=t.f[n+i][i]=1; } memset(g,0,sizeof g); g[1][1]=1; for(int j=2;j<=3;++j){ for(int i=1;i<=n;++i){ if(i+1<=n) g[i][j]+=g[i+1][j-1]; if(i-1>=1) g[i][j]+=g[i-1][j-1]; g[i][j]+=g[i][j-1]; if(j-3>=1) g[i][j]+=g[i][j-2]; } } s.n=n+n,s.m=1; for(int i=0;i<n;++i) s.f[i][0]=g[i+1][3]; for(int i=n;i<n+n;++i) s.f[i][0]=g[i-n+1][2]; } signed main(){ scanf(\"%lld%lld\",&n,&m); init(); if(m<=3){ printf(\"%lld\",g[n][m]%P); }else{ ans=kp(t,m-3)*s; printf(\"%lld\",ans.f[n-1][0]%P); } return 0; }","title":"\u9012\u63a8\u6784\u9020+\u77e9\u9635\u52a0\u901f"},{"location":"my%20past/OI/%E6%9E%84%E9%80%A0/#_3","text":"P7854 \u5bf9\u4e8e\u4e00\u4e2a\u70b9\u60f3\u505a\u522b\u4eba\u7684\u513f\u5b50\uff0c\u5f53\u4e14\u4ec5\u5f53\u5b83\u7684\u6743\u503c$a_i$\u4e0e\u7236\u4eb2\u7684\u6743\u503c$a_j$\u6ee1\u8db3\uff1a$a_j|a_i$. \u6240\u4ee5\uff0c\u5bf9\u4e8e\u6240\u6709\u70b9\uff0c\u6211\u4eec\u5148\u6309\u7167\u6743\u503c\u5927\u5c0f\u4ece\u5927\u5230\u5c0f\u6392\u4e2a\u5e8f\u3002 \u7136\u540e\u5bf9\u4e8e\u5f53\u524d\u70b9$(u,a_u)$\u5c06\u6240\u6709 \u6ca1\u6709\u7236\u4eb2\u8282\u70b9 \u5e76\u4e14$a_u|a_v$\u7684\u70b9$v$\u8fde\u5728$u$\u7684\u4e0b\u9762\u3002 \u540c\u65f6\uff0c\u5982\u679c\u4e00\u4e2a\u70b9\u6709\u7236\u4eb2\u8282\u70b9$(p,a_p)$,$a_v$\u8fd8\u662f$a_u$\u7684\u500d\u6570\uff0c\u5e76\u4e14$\\gcd(a_p,a_u)=a_u$,\u8bf4\u660e$a_p$\u4e00\u5b9a\u53ef\u4ee5\u4f5c\u4e3a$a_u$\u7684\u5b50\u8282\u70b9(\u56e0\u4e3a\u4ece\u5927\u5230\u5c0f\u8003\u8651\uff0c\u6240\u4ee5$a_u$\u4e00\u5b9a\u6bd4$a_p$\u5c0f)\uff0c\u90a3\u4e48\u8df3\u8fc7\u4e0d\u7528\u5904\u7406\uff1b \u5426\u5219\uff0c\u8bf4\u660e$a_p$\u4e0d\u80fd\u4f5c\u4e3a$a_u$\u7684\u5b50\u8282\u70b9\uff0c\u90a3\u4e48$v$\u540c\u65f6\u6709\u4e24\u4e2a\u6839\u8282\u70b9$u,p$\uff0c\u4e0d\u6ee1\u8db3\uff0c\u8f93\u51fa$-1$. \u5efa\u5b8c\u6811\u540e\uff0c\u8fd9\u68f5\u6811\u6ee1\u8db3\u6240\u6709\u8282\u70b9\u6709\u552f\u4e00\u7236\u4eb2\u8282\u70b9\u5e76\u4e14\u6743\u503c\u90fd\u662f\u7236\u4eb2\u8282\u70b9\u7684\u500d\u6570\u3002 \u90a3\u4e48\u6211\u4eec\u8fd8\u9700\u8981\u5224\u65ad\u662f\u5426\u51fa\u73b0$\\gcd(i,j)=k$\u4e14$k$\u6ca1\u51fa\u73b0\u8fc7\u7684\u60c5\u51b5\u3002 \u5982\uff1a 3 1 4 6 \u8fd9\u79cd\u3002 \u9996\u5148\uff0c\u5c06\u6240\u6709\u51fa\u73b0\u8fc7\u7684\uff0c\u662f$k$\u500d\u6570\u7684\u8282\u70b9\u62ff\u51fa\u6765\u3002\u5982\u679c\u8fd9\u4e9b\u8282\u70b9\u5728\u539f\u6811\u79cd\u7ec4\u6210\u4e86\u591a\u9897\u5b50\u6811\uff0c\u90a3\u4e48\u8bf4\u660e\u8fd9\u4e9b\u5b50\u6811\u7684\u6839\u8282\u70b9\u6743\u503c\u4e24\u4e24\u6c42$\\gcd$\u4e00\u5b9a\u80fd\u6c42\u51fa$k$,\u800c$k$\u4e0d\u5b58\u5728\uff0c\u5219\u65e0\u89e3. \u5426\u5219\uff0c\u5982\u679c\u53ea\u6709\u4e00\u9897\u5b50\u6811\uff0c\u5c31\u53ea\u4f1a\u6c42\u51fa\u90a3\u4e2a\u6839\u8282\u70b9\uff0c\u4e0d\u4f1a\u6c42\u51fa$k$\u3002 \u90a3\u4e48\u600e\u4e48\u5224\u65ad\u5462\uff1f\u6211\u4eec\u76f4\u63a5\u5224\u65ad\u8fd9\u4e9b\u8282\u70b9\u662f\u5426\u6709\u7236\u4eb2\uff0c\u6216\u8005\u5176\u7236\u4eb2\u8282\u70b9\u662f\u4e0d\u662f$k$\u7684\u500d\u6570\u65f6\uff0c\u5982\u679c\u6ca1\u6709\u7236\u4eb2\u6216\u8005\u6ca1\u6709\u662f$k$\u500d\u6570\u7684\u7236\u4eb2\uff0c\u8bf4\u660e\u5b83\u662f\u67d0\u9897\u5b50\u6811\u7684\u6839\u8282\u70b9\uff0c\u8ba1\u6570\u5668\u52a0\u4e00\uff1b\u5f53\u8ba1\u6570\u5668$>1$\u65f6\uff0c\u5c31\u65e0\u89e3\u4e86\u3002 \u6240\u4ee5\u6700\u7ec8\u590d\u6742\u5ea6$O((n+m)\\log n)$ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<vector> using namespace std; const int N=1e5+10,M=1e6+10; int gcd(int a,int b){ return !b?a:gcd(b,a%b); } int n,cnt; int fa[N],b[N],f[M],head[N]; vector<int> vis[M]; struct node{ int id,val; }a[N]; bool cmp(node a,node b){ return a.val>b.val; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i) scanf(\"%d\",&a[i].val),a[i].id=i,b[i]=a[i].val,vis[a[i].val].push_back(a[i].id); sort(a+1,a+n+1,cmp); int lst=0,flag=1; for(int i=1;i<=n;++i){ int pre=a[i].id; if(lst==a[i].val) continue; for(int j=a[i].val;j<M;j+=a[i].val){ if(vis[j].size()){ for(int k=0;k<vis[j].size();++k){ int now=vis[j][k]; if(now==pre) continue; if(!fa[now]) fa[now]=pre; else{ int g=gcd(b[fa[now]],b[pre]); if(g!=b[pre]) flag=0; } } } } lst=a[i].val; } for(int i=1;i<M;++i){ int tmp=0; for(int j=i;j<M;j+=i){ if(vis[j].size()){ for(int k=0;k<vis[j].size();++k){ int now=vis[j][k]; if(fa[now]==0 || b[fa[now]]%i!=0) ++tmp; } } } if(tmp>1){ flag=0;break; } } if(!flag) printf(\"-1\"); else for(int i=1;i<=n;++i) printf(\"%d \",fa[i]); return 0; } P3557 \u6ce8\u610f\u5230\u8ddd\u79bb\u4e3a1\u7684\u60c5\u51b5\u7684 \u6700\u4f18\u89e3 \u5c31\u662f\u8ddd\u79bb\u4e3a2\u7684\u60c5\u51b5\u7684\u4e00\u4e2a \u53ef\u884c\u89e3 ,\u56e0\u4e3a\u8ddd\u79bb\u4e3a1\u65f6\uff0c\u4e24\u4e2a\u5854\u4e4b\u95f4\u6700\u591a\u53ea\u80fd\u95f4\u9694\u4e24\u4e2a\u8282\u70b9\uff0c\u8fd9\u6837\u624d\u80fd\u4fdd\u8bc1\u5854\u6570\u91cf\u6700\u5c11\u4e14\u8986\u76d6\u5168\u56fe,\u800c\u8fd9\u79cd\u6784\u9020\u65b9\u5f0f\u7b49\u4ef7\u4e8e\u8ddd\u79bb\u4e3a2\u7684\u60c5\u51b5\u4e0b\u5c06\u6240\u6709\u672a\u8986\u76d6\u7684\u8282\u70b9\u9009\u4f5c\u5854\uff0c\u5e76\u8986\u76d6\u4e0a\u5468\u56f4\u70b9\u7684\u6784\u9020\u65b9\u5f0f\u3002\u800c\u9898\u76ee\u4fdd\u8bc1\u4e00\u5b9a\u53ef\u4ee5\u6784\u9020\u51fa\u7b49\u4e8e$k$\u7684\u6700\u4f18\u89e3$1$\u3002\u56e0\u6b64\u8fd9\u79cd\u6784\u9020\u65b9\u5f0f\u4e00\u5b9a\u80fd\u6784\u9020\u51fa$\\leq k$\u7684\u53ef\u884c\u89e3$2$\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=5e5+10,M=1e6+10; int n,m,k,cnt,u,v; int head[N],ans[N],vis[N]; struct edge{ int v,nxt; }e[M<<1]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void dfs(int u,int p,int dep){ vis[u]=1; if(dep>=2) return; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; dfs(v,u,dep+1); } } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d%d%d\",&n,&m,&k); for(int i=1;i<=m;++i) scanf(\"%d%d\",&u,&v),add(u,v),add(v,u); for(int i=1;i<=n;++i) if(!vis[i]) ans[++ans[0]]=i,dfs(i,0,0); printf(\"%d\\n\",ans[0]); for(int i=1;i<=ans[0];++i) printf(\"%d \",ans[i]); return 0; } P5441 ~~\u540d\u526f\u5176\u5b9e\u7684MO\u9898~~ \u521d\u59cb\u7b54\u6848\u663e\u7136\uff0c\u4e3a$C_n^4$ \u5b9a\u4e49$S_k$\u8868\u793a$i\\to ((i+k-1)\\mod n+1)$\u7684\u6240\u6709\u8fb9\u7684\u96c6\u5408,\u5373\u8df3\u8fc7\u4e86$k-1$\u4e2a\u70b9\u3002$S_k=S_{n-k},|S_k|=\\frac n2$ \u6ce8\u610f\u5230\u6700\u5916\u5c42$S_1$/\u6b21\u5916\u5c42$S_2$\u7684\u8fb9\u90fd\u53ef\u4ee5\u6309\u7167\u4e00\u4e2a\u65b9\u5411\u653e\u7f6e\uff0c\u4e0d\u9700\u8981\u53cc\u5411\u8fb9\uff0c\u5bf9\u7b54\u6848\u6ca1\u6709\u5f71\u54cd\u3002 \u800c\u5bf9\u4e8e$k\\geq 3$\u7684\u60c5\u51b5\uff0c\u7531\u4e8e\u524d\u4e24\u5c42\u7684\u8fb9\u662f\u6309\u7167\u4e00\u4e2a\u65b9\u5411\u653e\u7f6e\u7684\uff0c\u6240\u4ee5\u4f1a\u51fa\u73b0\u4e24\u4e2a\u4e0d\u540c\u65b9\u5411\u7684\u73af\u5171\u7528\u8fd9\u4e00\u6761\u8fb9\uff0c\u5373\u9700\u8981\u53cc\u5411\u8fb9\u3002\u5982\u679c\u4e0d\u7528\u53cc\u5411\u8fb9\uff0c\u5c31\u4f1a\u4e22\u5931\u4e00\u90e8\u5206\u65b9\u6848\u6570\u3002 \u90a3\u4e48\u6211\u4eec\u8d2a\u5fc3\u5730\u53d6\u4e24\u73af\u4e2d\u6700\u5927\u73af\u7684\u65b9\u5411\u4f5c\u4e3a\u8fd9\u6761\u8fb9\u7684\u65b9\u5411\uff0c\u4e22\u5931\u4e00\u90e8\u5206\u6700\u5c0f\u73af\u4e0a\u7684\u65b9\u6848\u6570,\u8fd9\u79cd\u8fb9\u7684\u6570\u91cf\u4e3a$n$\u6761\u3002(\u4e24\u73af\u76f8\u7b49\u4efb\u53d6\u4e00\u4e2a\uff0c\u4f46\u6ce8\u610f\u8fb9\u6570\u53ea\u6709$\\frac n2$\u6761) \u53ef\u4ee5\u53d1\u73b0$S_k$\u7684\u6240\u6709\u8fb9\u53ef\u4ee5\u7ec4\u6210\u6240\u6709\u70b9\u6570\u4e3a$k$\u7684\u73af\u3002 \u5c0f\u73af\u65b9\u6848\u6570$=C_{k-2}^2$,\u56e0\u4e3a\u4e00\u4e2a\u8fb9\u7684\u4e24\u4e2a\u70b9\u4e00\u5b9a\u8981\u53d6\uff0c\u4e0d\u7136\u72b6\u6001\u6709\u91cd\u590d\u3002 \u90a3\u4e48\u6211\u4eec\u6309\u7167\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\uff0c\u51cf\u53bb\u8fd9\u4e9b\u8d21\u732e\uff0c\u6700\u540e\u5269\u4e0b\u7684\u5c31\u662f\u6700\u5927\u65b9\u6848\u6570\u3002 \u81f3\u4e8e\u65b9\u6848\uff0c\u53ea\u9700\u8981\u5728\u7edf\u8ba1$k\\geq 3$\u8fb9\u7684\u65f6\u5019\u8bb0\u5f55\u4e00\u4e0b\u4e24\u4e2a\u7aef\u70b9\uff0c\u5c06\u51cf\u53bb\u7684\u8bbe\u4e3a\u5355\u5411\uff0c\u5269\u4e0b\u7684\u8bbe\u4e3a\u53cc\u5411\u5373\u53ef\u3002\u518d\u52a0\u4e0a$k\\leq 2$\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=110,M=1e5+10; int C[N],c[N],f[N][N]; int n,cnt,sum,m; struct node{ int u,v,w; node(int uu=0,int vv=0,int ww=0){ u=uu,v=vv,w=ww; } }ans[M]; void work(){ C[4]=1;c[2]=1; for(int i=5;i<=n;++i) C[i]=C[i-1]*i/(i-4); for(int i=3;i<=n;++i) c[i]=c[i-1]*i/(i-2); cnt=0;sum=C[n]; for(int i=1;i<=n;++i) for(int j=1;j<=2;++j) f[i][(i+j-1)%n+1]=1,f[i][i]=0; for(int i=4;i<=n-i+2;++i){ int tmp=c[i-2]; if(i==n-i+2) for(int j=1;j<=n/2;++j) ans[++cnt]=node(j,(j+i-1-1)%n+1,tmp);//\u5bf9\u5e94\u4e24\u73af\u5927\u5c0f\u76f8\u7b49\u7684\u60c5\u51b5\u3002 else for(int j=1;j<=n;++j) ans[++cnt]=node(j,(j+i-1-1)%n+1,tmp); } m=max(0,n*(n-7)/2); for(int i=1;i<=m;++i){ int u=ans[i].u,v=ans[i].v,w=ans[i].w; sum-=w;f[u][v]=1; } for(int i=m+1;i<=cnt;++i){ int u=ans[i].u,v=ans[i].v; f[u][v]=f[v][u]=1; } } int main(){ scanf(\"%d\",&n); work(); printf(\"%d\\n\",sum); for(int i=1;i<=n;++i){ for(int j=1;j<=n;++j) printf(\"%d \",f[i][j]); printf(\"\\n\"); } return 0; }","title":"\u65b9\u6848\u6784\u9020"},{"location":"my%20past/OI/%E6%A0%91%E5%BD%A2dp/","text":"\u6811\u5f62dp\u603b\u7ed3 \u7edf\u8ba1\u7b54\u6848\u7c7b P3047 dp[u][k]\u8868\u793a\u8ddd\u79bbu\u4e0d\u8d85\u8fc7k\u7684\u70b9\u6743\u503c\u4e4b\u548c dfs1:$ dp[u][k]+=\\sum dp[v][k-1]$ \u4e0b\u884c\uff0c\u4e0d\u9700\u8981\u5bb9\u65a5\uff0c\u76f4\u63a5\u7531\u513f\u5b50\u7d2f\u52a0\u5373\u53ef \u6c42\u51fau\u7684\u5b50\u6811\u6240\u6709\u4e0d\u8d85\u8fc7k\u7684\u70b9\u6743\u503c\u4e4b\u548c dfs2:$dp[v][k]+=dp[u][k-1]-(k>=2)dp[v][k-2]$\u4e0a\u884c\uff0c\u9700\u8981\u7b80\u5355\u5bb9\u65a5\uff0c\u5e76\u4e14\u6ce8\u610f\u8981\u9006\u5e8f\uff0c\u56e0\u4e3a\u82e5dp[v][k-2]\u5148\u66f4\u6539\uff0c\u5219dp[v][k]\u4f1a\u51fa\u9519 \u6c42\u51fa\u6700\u7ec8\u7b54\u6848 P2986 dp[u]\u8868\u793a\u6bcf\u4e2a\u70b9\u7684\u7b54\u6848 f[u]\u8868\u793a\u8be5\u8282\u70b9\u6240\u6709\u5b50\u8282\u70b9\u5230\u5b83\u7684\u8ddd\u79bb\u4e4b\u548c f[u]=f[v]+w * sz[v] \u5219\u6709dp[1]=f[1] \u90a3\u4e48 dp[v]=dp[u]-sz[v] * w+(sz[1] * w-sz[v] * w) =dp[u]-2 * sz[v] * w+sz[1] * w \u8f6c\u79fb\u65f6\u53ea\u66f4\u6539\u7684\u662f\u4e0e\u8be5\u8fb9\u6709\u5173\u8054\u7684\u7b54\u6848\u3002 \u6ce8\u610f\u521d\u59cb\u72b6\u6001\u4e3adp[1] CF9D f[i][j]\u8868\u793ai\u4e2a\u8282\u70b9\uff0c\u6df1\u5ea6\u4e0d\u8d85\u8fc7j\u7684\u4e8c\u53c9\u6811\u603b\u6570\u91cf,\u5219 $f[i][j]=\\sum_{k=1}^{i-1}f[k][j-1]* f[i-k-1][j-1] $ P1623 dp+\u9ad8\u7cbe\u5ea6 \u8bbef[i][0/1]\u4e3a\u6700\u5927\u5339\u914d\u4e2a\u6570\uff0c0\u8868\u793a\u4e0e\u513f\u5b50\u4e0d\u5339\u914d\uff0c1\u8868\u793a\u4e0e\u5176\u4e2d\u4e00\u4e2a\u513f\u5b50\u5339\u914d\uff1bg[i][0/1]\u4e3a\u5bf9\u5e94\u7684\u65b9\u6848\u6570 \u8f6c\u79fb\u65b9\u7a0b\uff1a(\u6709'\u4ebf'\u70b9\u590d\u6742) //\u65e0\u9ad8\u7cbe\u5ea6 void dp1(int u,int p){ int sum=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; dp1(v,u); sum+=max(f[v][0],f[v][1]); } f[u][0]=sum; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; f[u][1]=max(f[u][1],sum-max(f[v][0],f[v][1])+f[v][0]+1); } return; } void dp2(int u,int p){ int sum=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; dp2(v,u); if(f[v][0]<f[v][1]){ sum*=g[v][1]; }else if(f[v][0]>f[v][1]){ sum*=g[v][0]; }else{ sum*=(g[v][0]+g[v][1]); } } g[u][0]=sum; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; int tmp=1; if(v==p)continue; if(f[v][0]<f[v][1]){ tmp=g[v][1]; }else if(f[v][0]>f[v][1]){ tmp=g[v][0]; }else{ tmp=(g[v][0]+g[v][1]); } if(f[u][1]==f[u][0]-max(f[v][0],f[v][1])+f[v][0]+1){ g[u][1]+=(g[u][0]/tmp)*g[v][0]; } } return; } \u6ce8\u610f\u6700\u540e\u7684g\u4e5f\u8981\u6839\u636ef\u5224\u65ad\uff0c\u8fd9\u4e2a\u5751\u4e86\u6211\u4e00\u6b21 ~~(\u6211\u751a\u81f3\u8fde\u9ad8\u7cbe\u5ea6\u90fd\u6ca1\u5199\uff0c\u53ea\u62ff\u4e8660pts)~~ \u8282\u70b9\u9009\u62e9\u7c7b(\u67d3\u8272\u7c7b) P4084 \u6811\u5f62dp\u5165\u95e8\u9898:) dp[i][j]\u8868\u793a\u5f53\u524d\u8282\u70b9\u4e3aj\u989c\u8272\u662f\u7684\u65b9\u6848\u6570 \u6ce8\u610f\u5f53\u8be5\u8282\u70b9\u5df2\u7ecf\u6709\u989c\u8272\u65f6\uff0c\u5219dp[u][c[u]]=1,\u5176\u4ed6\u4e3a0 \uff1b\u5426\u5219dp[u][1,2,3]=1; \u8f6c\u79fb\uff1a //1.c[u]!=0 for(i;1-3) if(i!=c[u])sum+=dp[v][i]; dp[u][c[u]]=(dp[u][c[u]]*sum)%P; //2.c[u]==0 for(i;1-3) for(j;1-3) if(j!=i)sum+=dp[v][j]; dp[u][i]=(dp[u][i]*sum)%P; P2279 \u975e\u5e38\u597d\u3002\u975e\u5e38\u6076\u5fc3 dp[u][0,1,2,3,4]\u4e00\u51710\uff0c1\uff0c2\uff0c3\uff0c4\u4e94\u79cd\u72b6\u6001\uff0c\u5206\u522b\u4e3a\u7237\u7237\uff0c\u7236\u4eb2\uff0c\u81ea\u5df1\uff0c\u513f\u5b50\uff0c\u5b59\u5b50 \u540c\u6837\u8981\u6ce8\u610f\u4e0a\u884c\u7684\u72b6\u6001dp[u][3] \u548cdp[u][4] P2899 dp[u][0/1/2]\u8868\u793a\u4e09\u79cd\u72b6\u6001\uff0c\u88ab\u81ea\u5df1\u8986\u76d6\uff0c\u88ab\u513f\u5b50\u8986\u76d6\uff0c\u88ab\u7236\u4eb2\u8986\u76d6 \u6ce8\u610f\u987a\u5e8f\u65f6\u4ece\u4e0b\u5f80\u4e0a\u56de\u6eaf\u65f6\u641c\uff0c\u6240\u4ee5\u641c\u5230\u7236\u4eb2\u65f6\u513f\u5b50\u5df2\u7ecf\u88ab\u66f4\u65b0\u5b8c\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528 1.dp[u][0]=$\\sum$min(dp[v][0],dp[v][1],dp[v][2]),\u56e0\u4e3a\u81ea\u5df1\u5df2\u7ecf\u88ab\u81ea\u5df1\u8986\u76d6\uff0c\u6240\u4ee5\u53ef\u4ee5\u53d6\u513f\u5b50\u7684\u6240\u6709\u503c\uff1b 2.dp[u][2]=$\\sum$min(dp[v][0],dp[v][1]),\u5982\u679cu\u88abfa[u]\u8986\u76d6\uff0c\u5219u\u4e0d\u4f1a\u88abu\u81ea\u5df1\uff0c\u4e5f\u5c31\u662fdp[v][2]\u8986\u76d6\uff0c\u5c31\u4e0d\u53d6\u4e86 update:2021.11.12 \u5e94\u8be5\u662fdp[u][2]=$\\sum$dp[v][1]\uff0c\u56e0\u4e3au\u53ea\u88ab\u7236\u4eb2\u8986\u76d6\uff0c\u5982\u679c\u53d6dp[v][0]\u5219\u8868\u660eu\u8fd8\u88ab\u513f\u5b50\u8986\u76d6\uff0c\u5219\u4f1a\u51fa\u9519. 3.< \u91cd\u70b9 >dp[u][1]=min(f[v][0]+$\\sum_{i=son[u]}^{i!=v} $min(f[i][0],f[i][1])),\u56e0\u4e3au\u8981\u88ab\u81f3\u5c11\u4e00\u4e2a\u5b50\u8282\u70b9\u8986\u76d6\uff0c\u6240\u4ee5\u53ef\u4ee5\u66b4\u529b\u679a\u4e3e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u5219\u5269\u4f59\u7684\u8282\u70b9\u7684\u72b6\u6001\u4e0e2\u76f8\u540c\u3002 \u4e5f\u53ef\u4ee5\u8fdb\u884c\u6570\u5b66\u65b9\u6cd5\u7684\u4f18\u5316\uff0c\u8be6\u89c1\u9898\u89e3 P3174 \u6709\u610f\u601d\u7684\u4e00\u9053\u9898 \u5b9a\u4e49: f[n]\u8868\u793a\u5f53\u524d\u8282\u70b9\u7684\u5b50\u6811\u91cc\u6700\u957f\u7684\u94fe\u4e2d\u5305\u542b\u7684\u70b9(\u4e3b\u5e72\u4e0e\u5206\u53c9) ans[n]\u8868\u793a\u5f53\u524d\u8282\u70b9\u7684\u7b54\u6848 \u56e0\u4e3a\u5b58\u5728\u62d0\u5f2f\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u6700\u4f18\u89e3\u4e0d\u4e00\u5b9a\u5b58\u5728\u4e8e\u6839\u8282\u70b9\uff0c\u56e0\u6b64\u8f6c\u79fb\u65b9\u7a0b\uff1a f[u]=max1+num; if(p==0) {//p\u662fu\u7684\u7236\u4eb2\uff0c\u6839\u8282\u70b9\u65e0\u7236\u4eb2 ans[u]=max1+max2+num-1; } else ans[u]=max1+max2+num; \u6700\u7ec8\u7b54\u6848\u4e3amax(ans[i]) P1352 \u6a21\u677f\u9898\u3002 * \u8981\u7528\u513f\u5b50\u66f4\u65b0\u7236\u4eb2\u800c\u4e0d\u7528\u7236\u4eb2\u66f4\u65b0\u513f\u5b50\u7684\u539f\u56e0\uff1a\u4f1a\u4ea7\u751f\u540e\u6548\u6027\uff1a\u513f\u5b50\u7684\u7b54\u6848\u4e0d\u4ec5\u4e0e\u7236\u4eb2\u6709\u5173\uff0c\u8fd8\u4e0e\u7237\u7237\u6709\u5173\uff0c\u7237\u7237\u4e0d\u9009\uff0c\u513f\u5b50\u4e5f\u4e0d\u80fd\u9009\u3002 \u6811\u5f62\u80cc\u5305\u7c7b P2015 \u6811\u5f62\u80cc\u5305\u6a21\u677f\u9898\uff0c\u6ce8\u610f\u56e0\u4e3a\u662f\u4e8c\u53c9\u6811\uff0c\u6240\u4ee5\u8f6c\u79fb\u65b9\u7a0b\u6709\u4e24\u79cd\uff1a 1.dp[u][t]=max(dp[u][t],dp[ln][t-k]+dp[rn][k]),ln rn \u8868\u793a\u5de6\u513f\u5b50\u53f3\u513f\u5b50 2.dp[u][t]=max(dp[u][t],dp[v][k]+dp[u][t-k]) 2\u7684\u597d\u5904\u4e3a\u53ef\u4ee5\u5e94\u5bf9\u591a\u53c9\u6811\u3002 \u539f\u56e0\u662f\uff1a \u56e0\u4e3a\u8981\u5148\u679a\u4e3et\uff0c\u6240\u4ee5\u5c31\u50cf\u80cc\u5305\u4e00\u6837\uff0c\u5f53\u524d\u513f\u5b50\u7684\u8d21\u732e\u80fd\u591f\u52a0\u5728\u4e4b\u524d\u7684\u72b6\u6001\u91cc\uff0c\u800c\u4e4b\u524d\u7684\u72b6\u6001\u5df2\u7ecf\u5305\u542b\u5728\u6df1\u641c\u5b83\u4e4b\u524d\u7684\u5144\u5f1f\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u8fdb\u884c\u7d2f\u52a0\u3002 v\u76f8\u5f53\u4e8e\u77f3\u5934\u79cd\u7c7b\uff1bt\u76f8\u5f53\u4e8e\u80cc\u5305\u5bb9\u91cf \u6ce8\u610f\u8981\u9006\u5e8f\u679a\u4e3et\uff0c\u4e0d\u7136\u4f1a\u5bf9\u4e4b\u524d\u5df2\u7ecf\u5f97\u5230\u7684\u72b6\u6001\u8fdb\u884c\u4e8c\u6b21\u7d2f\u52a0 P1270 \u6811\u5f62\u80cc\u5305\u3002 1.\u540c\u6837\u662fdp[u][t]=max(dp[u][t],dp[v][k]+dp[u][t-k])\uff1b 2.dp[u][t]=max(dp[u][t],dp[u][t-j*5]+j) \u5728\u6df1\u641c\u5b8c\u6240\u6709\u513f\u5b50\u540e\u505a\u8fd9\u4e2a \u540c\u6837\u6ce8\u610f\u9006\u5e8f\u679a\u4e3et \u7ed3\u8bba\uff1a\u4e0d\u4e00\u5b9a\u8981\u6309\u7167\u65f6\u95f4\u7ebf\u6027\u6d41\u901d\u8bbe\u7f6e\u72b6\u6001\uff0c\u4e5f\u53ef\u4ee5\u5c06\u65f6\u95f4\u7d2f\u52a0\u8868\u793a\uff0c\u5373\u7d2f\u52a0\u8d21\u732e\u3002 P3360 \u540c\u4e0a\uff0c\u52a0\u5165\u4e86\u4ef7\u503c\u3002 P4362 \u6bcf\u4e2a\u6811\u679d\u53ea\u6709\u4e24\u79cd\u60c5\u51b5\u4f1a\u4ea7\u751f\u96be\u53d7\u503c\uff1a 1) \u4e24\u7aef\u70b9\u90fd\u88ab\u5927\u5934\u5403\u6389 2) \u4e24\u7aef\u70b9\u90fd\u4e0d\u88ab\u5927\u5934\u5403\u6389\u5e76\u4e14\u5c0f\u5934\u53ea\u6709\u4e00\u4e2a(m==2) \u56e0\u4e3a\u5982\u679c\u5c0f\u5934\u591a\u4f59\u4e00\u4e2a\uff0c\u90a3\u4e48\u4efb\u610f\u4e00\u6761\u6ee1\u8db3\u60c5\u51b52\u7684\u6811\u679d\uff0c\u5b83\u7684\u4e24\u7aef\u90fd\u53ef\u4ee5\u88ab\u4e0d\u540c\u7684\u5c0f\u5934\u5403\uff0c\u5c31\u4e0d\u4f1a\u6709\u8d21\u732e\u3002 \u56e0\u6b64\u8f6c\u79fb\u65b9\u7a0b\uff1a $$f[u][i][0]=min(f[u][i][0],min(tmp[i-j][0]+f[v][j][0]+(m==2)* w,tmp[i-j][0]+f[v][j][1]));\\ f[u][i][1]=min(f[u][i][1],min(tmp[i-j][1]+f[v][j][1]+w,tmp[i-j][1]+f[v][j][0]));$$ \u6ce8\u610fm==2\uff0c\u5c31\u7b97\u6ca1\u6709\u96be\u53d7\u503c\u4e5f\u8981\u628a\u5b50\u6811\u7684\u8d21\u732e\u52a0\u5230\u80cc\u5305\u91cc\u3002 \u5e76\u4e14\u6bcf\u6b21dp\u4e4b\u524d\u8981\u5c06f[u]\u6570\u7ec4\u5907\u4efd\u4e0b\u6765\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u9632\u6b62f[u]\u4e0d\u65ad\u53d8\u5c0f. \u4f8b\u5982\uff1a \u65e0tmp\uff1a v1\u540e\uff1af[u][1][0]=0; v2\u540e\uff1a\u56e0\u4e3af[u][1][0]=0,\u6240\u4ee5f[u][1][0]=min(0,0+0+5)=0; \u6709tmp\uff1a v1\u540e\uff1af[u][1][0]=0; v2\u524d\uff1a f[u][1][0]=INF; tmp[1][0]=0; v2\u540e\uff1af[u][1][0]=min(INF,0+0+5)=5; \u56e0\u4e3af[u][1][0]\u5728\u4e0d\u540c\u65f6\u523b\u8868\u793a\u7684\u662f\u4e0d\u540c\u72b6\u6001\uff0c\u5982\u679c\u4e0d\u5907\u4efd\uff0c\u5c31\u4f1a\u5bfc\u81f4f[u]\u8d8a\u6765\u8d8a\u5c0f\uff0c\u5373f[u][1][0]\u53ea\u80fd\u4e0e\u5f53\u524d\u65f6\u523b\u7684\u65b0\u8d21\u732e\u6bd4\u8f83\uff0c\u4e0d\u80fd\u4e0etmp\u4e2d\u4e4b\u524d\u7684\u72b6\u6001\u505amin.tmp\u53ea\u80fd\u7528\u6765\u66f4\u65b0\u51fa\u5f53\u524dj\u4e0d\u540c\u7684\u72b6\u6001. \u6362\u79cd\u8bf4\u6cd5\uff0cf[v2][1][0]\u8868\u793a\u5f53\u524d\u72b6\u6001\uff0cf[v1][1][0]\u8868\u793a\u4e4b\u524d\u7684\u72b6\u6001\uff0c\u5219v2\u4ee5\u53ca\u5b83\u4e4b\u540e\u7684\u72b6\u6001\u90fd\u4f1a\u56e0\u4e3af[v1][1][0]=0\u800c\u8d8a\u53d8\u8d8a\u5c0f\uff0c\u4ea7\u751f\u4e86\u540e\u6548\u6027\u3002 \u4e3a\u4e86\u4e0d\u4ea7\u751f\u540e\u6548\u6027\uff0c\u5c31\u4e0d\u80fd\u8ba9v2\u8bbf\u95ee\u5230f[v1][1][0],\u6240\u4ee5\u9700\u8981\u5907\u4efdtmp\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=530; int f[N][N][2],head[N],sz[N],tmp[N][2]; int n,m,k,cnt; struct node { int v,w,nxt; } e[N<<1]; void add(int u,int v,int w) { e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; } void dp(int u,int p) { f[u][0][0]=0; f[u][1][1]=0; sz[u]=1; for(int o=head[u]; ~o; o=e[o].nxt) { int v=e[o].v,w=e[o].w; if(v==p)continue; dp(v,u); sz[u]+=sz[v]; } for(int o=head[u]; ~o; o=e[o].nxt) { int v=e[o].v,w=e[o].w; if(v==p)continue; memcpy(tmp,f[u],sizeof tmp); memset(f[u],63,sizeof f[u]); for(int i=min(k,sz[u]); i>=0; --i) {//\u6ce8\u610f\u8fd9\u91cc\u53d6min(k,sz[u])\u53ef\u4ee5\u5feb\u4e0d\u5c11 for(int j=min(i,sz[v]); j>=0; --j) { f[u][i][0]=min(f[u][i][0],min(tmp[i-j][0]+f[v][j][0]+(m==2)*w,tmp[i-j][0]+f[v][j][1])); f[u][i][1]=min(f[u][i][1],min(tmp[i-j][1]+f[v][j][1]+w,tmp[i-j][1]+f[v][j][0])); } } } } int main() { memset(head,-1,sizeof head); cnt=-1; scanf(\"%d%d%d\",&n,&m,&k); if(n-k<m-1) { printf(\"-1\"); return 0; } for(int i=1,u,v,w; i<n; ++i) { scanf(\"%d%d%d\",&u,&v,&w); add(u,v,w); add(v,u,w); } //init(); memset(f,63,sizeof f); dp(1,1); printf(\"%d\",f[1][k][1]); return 0; } \u6811\u5f62\u80cc\u5305\u7684\u590d\u6742\u5ea6\u5206\u6790\uff1a $$ \u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u679a\u4e3e\u7684\u6b21\u6570\u4e3asz[u] sz[v_1]+sz[u] sz[v_2]+...+sz[u]* sz[v_m]=O(sz[u]^2)\\ (\u5bf9\u4e8e\u679a\u4e3e\u52300\uff0c\u5176\u5b9e\u76f8\u5dee\u4e2a\u5e38\u6570\uff0c\u53ef\u4ee5\u5ffd\u7565\u3002)\\ \u6240\u4ee5\u6574\u4f53\u7684\u590d\u6742\u5ea6\u5c31\u662f\\sum_{u=1}^n sz[u]^2=O(n^3* k),k<1.\\ \u4e8b\u5b9e\u4e0a\uff0c\u6700\u6781\u9650\u7684\u60c5\u51b5\u5c31\u662f\u4e00\u6761\u94fe\uff0c\u6b64\u65f6k=\\frac12 \u6240\u4ee5k<\\frac12\\ \u6240\u4ee5\u53ef\u4ee5\u8bf4\u6811\u5f62\u80cc\u5305\u7684\u590d\u6742\u5ea6\u4e25\u683c\u5c0f\u4e8eO(0.5n^3) $$ P3177 \u597d\u9898\u3002 \u8bbef[u][i]\u8868\u793a\u6bcf\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u7684\u8fb9\u4ea7\u751f\u7684\u8d21\u732e\u3002 \u6ce8\u610f\u72b6\u6001\u7684\u542b\u4e49\u65f6\u8d21\u732e\uff0c\u4e0d\u662f\u6bcf\u4e2a\u5b50\u6811\u5185\u6240\u6709\u70b9\u7684\u7b54\u6848\uff0c\u56e0\u4e3a\u5b50\u6811\u5185\u7684\u70b9\u4f1a\u548c\u5b50\u6811\u5916\u7684\u70b9\u4ea7\u751f\u989d\u5916\u7684\u8d21\u732e\uff0c\u5e76\u4e14\u65e0\u6cd5\u8ba1\u7b97\u3002 \u8003\u8651\u6bcf\u6761\u8fb9\u7684\u8d21\u732e\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f\u4e24\u8fb9\u7684\u540c\u8272\u70b9\u7684\u4e58\u79ef\u3002 \u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a int tot=j*(k-j)+(sz[v]-j)*(n-sz[v]-k+j); f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]+tot*w); \u6ce8\u610f\uff1a 1) \u8fd9\u4e2a\u6811\u5f62\u80cc\u5305\u8981\u6e05\u7a7a\u975e\u6cd5\u72b6\u6001(-1)\uff0c\u4e0d\u7136\u4f1a\u51fa\u9519\u3002 2) \u7b2c\u4e8c\u5c42\u7684\u679a\u4e3e\u5982\u679c\u662f\u5012\u5e8f\uff0c\u5c31\u4e00\u5b9a\u8981\u5148\u8f6c\u79fbf[v][0],\u5373j==0\u5f97\u60c5\u51b5\uff0c\u4e0d\u7136\u4e5f\u4f1a\u51fa\u9519\u3002\u539f\u56e0\u5c31\u662f\uff0c\u6bcf\u6b21\u90fd\u4f1a\u7528f[u][j]\u66f4\u65b0\u4e00\u6b21:f[u][j]+f[v][0]\uff0c\u8fd9\u5c31\u4e0d\u6ee1\u8db3\u4e0d\u7528\u5f97\u51fa\u7684\u72b6\u6001\u66f4\u65b0\u5176\u4ed6\u72b6\u6001\u4e86\u3002 \u7ed3\u8bba: \u5f53\u8bbe\u8ba1\u6210\u5b50\u6811\u5185\u7b54\u6848\u884c\u4e0d\u901a\uff0c\u6362\u53e5\u8bdd\u8bf4\u5b50\u6811\u5185\u7b54\u6848\u53d7\u5b50\u6811\u5916\u8282\u70b9\u5f71\u54cd\u65f6\uff0c\u53ef\u4ee5\u8bbe\u8ba1\u6210\u5b50\u6811\u5185\u8fb9\u7684\u8d21\u732e\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=2200; int n,k,cnt; int head[N],sz[N]; int f[N][N]; struct node{ int v,nxt,w; }e[N<<1]; void add(int u,int v,int w){ e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; } void dfs(int u,int p){ sz[u]=1; for(int o=head[u];~o;o=e[o].nxt){ int v=e[o].v; if(v==p)continue; dfs(v,u); sz[u]+=sz[v]; } } void dp(int u,int p){ f[u][1]=f[u][0]=0; for(int o=head[u];~o;o=e[o].nxt){ int v=e[o].v,w=e[o].w; if(v==p)continue; dp(v,u); for(int i=min(sz[u],k);i>=0;--i){ for(int j=0;j<=min(sz[v],i);++j){ if(f[u][i-j]==-1)continue; int tot=j*(k-j)+(sz[v]-j)*(n-sz[v]-k+j); f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]+tot*w); } } } } int read1(){ int x=0; char ch=getchar(); while(ch>'9' || ch<'0'){ ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x; } void write1(int x){ if(x>9)write1(x/10); putchar(x%10+'0'); } signed main(){ memset(head,-1,sizeof head); cnt=-1; n=read1(),k=read1(); if(n-k<k)k=n-k; for(int i=1,u,v,w;i<n;++i){ u=read1(),v=read1(),w=read1(); add(u,v,w); add(v,u,w); } memset(f,-1,sizeof f); dfs(1,0); dp(1,0); write1(f[1][k]); return 0; } \u6362\u6839dp P6419 \u8bbe$f[u]$\u8868\u793a\u5b50\u6811\u5185\u8d21\u732e\uff0c$g[u]$\u8868\u793a\u5b50\u6811\u5916\u8d21\u732e\uff0c$dis[u][0/1]$\u8868\u793a\u5b50\u6811\u5185\u6700/\u6b21\u957f\u94fe\uff0c$up[u]$\u8868\u793a\u5b50\u6811\u5916\u6700\u957f\u94fe\u3002 \u6ce8\u610f\u66f4\u65b0$up[u]$\u548c$g[u]$\u65f6\uff0c\u5982\u679c\u6240\u6709\u5173\u952e\u70b9\u90fd\u5305\u542b\u5728$v$\u5b50\u6811\u5185\uff0c\u8bf4\u660e$u$\u4e0a\u9762\u6ca1\u6709\u6700\u957f\u94fe\uff0c\u90a3\u4e48$up[v]$\u548c$g[v]$\u90fd\u4e0d\u5e94\u8be5\u8f6c\u79fb\u3002\uff08\u90fd\u4e3a0\uff09 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=5e5+10; int dis[N][2],up[N],head[N],f[N],g[N],sz[N],vis[N],ans[N]; int n,k,cnt,tot; struct node { int v,w,nxt; } e[N<<1]; void add(int u,int v,int w) { e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; } void dfs(int u,int p) { sz[u]=vis[u]; for(int i=head[u]; ~i; i=e[i].nxt) { int v=e[i].v,w=e[i].w; if(v==p)continue; dfs(v,u); sz[u]+=sz[v]; if(!sz[v])continue; f[u]+=f[v]+w+w; if(dis[v][0]+w>dis[u][0]) { dis[u][1]=dis[u][0]; dis[u][0]=dis[v][0]+w; } else if(dis[v][0]+w>dis[u][1]) { dis[u][1]=dis[v][0]+w; } } } void dp(int u,int p) { for(int i=head[u]; ~i; i=e[i].nxt) { int v=e[i].v,w=e[i].w; if(v==p)continue; if((k-sz[v])) { g[v]=g[u]+f[u]-f[v]+((sz[v]==0)?(w+w):0); if(dis[v][0]+w==dis[u][0]) { up[v]=max(up[u],dis[u][1])+w; } else { up[v]=max(up[u],dis[u][0])+w; } } dp(v,u); } } signed main() { memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld\",&n,&k); for(int i=1,u,v,w; i<n; ++i) { scanf(\"%lld%lld%lld\",&u,&v,&w); add(u,v,w); add(v,u,w); } for(int i=1,tmp; i<=k; ++i) { scanf(\"%lld\",&tmp); vis[tmp]=1; } dfs(1,0); dp(1,0); for(int i=1; i<=n; ++i) { printf(\"%lld\\n\",f[i]+g[i]-max(dis[i][0],up[i])); } return 0; } \u7ed3\u8bba\uff1a 1) \u6362\u6839dp\u7684\u5957\u8def\u5c31\u662f\u5904\u7406\u5b50\u6811\u5185\u7684\u4fe1\u606f\uff0c\u5b50\u6811\u5916\u7684\u4fe1\u606f\u7531\u5b50\u6811\u5185\u4fe1\u606f\u76f8\u51cf\u5f97\u5230\u3002 2) \u5904\u7406\u5b50\u6811\u5185\u4fe1\u606f\u65f6\uff0c\u987a\u5e8f\u4e3a$v\\to u$,\u5373\u4ece\u53f6\u5b50\u5411\u4e0a\u5408\u5e76\uff1b\u5904\u7406\u5b50\u6811\u5916\u4fe1\u606f\u65f6\uff0c\u987a\u5e8f\u4e3a$u \\to v$,\u5373\u4ece\u6839\u5411\u4e0b\u63a8\u3002 P3237 ~~\u770b\u9898\u5c31\u770b\u4e8630min~~ \u7136\u800c\u770b\u61c2\u4e86\u9898\u4e5f\u4e0d\u77e5\u9053\u600e\u4e48\u505a\u3002 \u9898\u610f\u7b80\u5316: \u7ed9\u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e00\u4e2a\u6743\u503c\uff0c\u8981\u6c42\u4fee\u6539\u4e00\u4e9b\u70b9\u7684\u6743\u503c\uff0c\u4f7f\u5f97\uff1a 1) \u540c\u4e00\u4e2a\u7236\u4eb2\u7684\u513f\u5b50\u6743\u503c\u5fc5\u987b\u76f8\u540c 2) \u7236\u4eb2\u7684\u53d6\u503c\u5fc5\u987b\u662f\u6240\u6709\u513f\u5b50\u6743\u503c\u4e4b\u548c \u4e00\u4e2a\u91cd\u8981\u7ed3\u8bba \uff1a\u53ea\u8981\u6709\u4e00\u4e2a\u70b9\u88ab\u786e\u5b9a\u4e86\uff0c\u90a3\u4e48\u6574\u68f5\u6811\u7684\u6700\u7ec8\u5f62\u6001\u5c31\u968f\u4e4b\u786e\u5b9a\u4e86\u3002 \u4e5f\u5c31\u662f\u8bf4\uff0c\u4e00\u4e2a\u70b9\u88ab\u786e\u5b9a\u540e\uff0c\u53ea\u6709\u4e0e\u4ed6\"\u7b49\u4ef7\"\u7684\u70b9\u4e0d\u7528\u6539\u53d8\uff0c\u5176\u4ed6\u7684\u90fd\u8981\u53d8\u3002 \u8bbe\u6700\u591a\u7684\u7b49\u4ef7\u70b9\u4e2a\u6570\u603b\u5171\u6709$ans$\u4e2a\uff0c\u90a3\u4e48\u6700\u7ec8\u8981\u6539\u53d8$n-ans$\u4e2a\u70b9\u3002 \u4e0b\u9762\u8981\u6c42\u51fa\u6240\u6709\u7b49\u4ef7\u70b9\u3002\u6211\u4eec\u53d1\u73b0\uff0c\u4e24\u4e2a\u8282\u70b9\u7b49\u4ef7\u9700\u8981\u6ee1\u8db3\uff1a $\\prod_{i=1}^{d_x-1}son[v[i]] a[x]=\\prod_{i=1}^{d_y-1}son[v[i]] a[y]$\u3002 \u8bbe$f[i]$\u8868\u793a\u4e0a\u8ff0\u5f0f\u5b50\uff0c\u5219\uff1a$f[x]=f[y]$ \u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5~~\u5feb\u4e50\u5730~~\u6811\u5f62$dp$\u4e86. #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define int long long using namespace std; typedef double db; const int N=5e5+10; const db eps=1e-8,INF=1e8; int n,u,v,cnt,tmp,ans; int a[N],head[N]; db f[N]; struct node{ int v,nxt; }e[N<<1]; bool cmp(db a,db b){return a<b;} void add(int u,int v){e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt;} void dfs(int u,int p,db t){ f[u]+=t; int tot=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; ++tot; } for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; dfs(v,u,t+log((db)(tot))); } } signed main(){ memset(head,-1,sizeof head);cnt=-1;f[0]=-INF; scanf(\"%lld\",&n); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i]),f[i]=log((db)(a[i])); for(int i=1;i<n;++i) scanf(\"%lld%lld\",&u,&v),add(u,v),add(v,u); dfs(1,0,0); sort(f+1,f+n+1,cmp); tmp=0,ans=0; for(int i=2;i<=n;++i){ if(f[i]-f[i-1]<eps) ++tmp; else ans=max(ans,tmp),tmp=1; } ans=max(ans,tmp); printf(\"%lld\",n-ans); return 0; } P3523 \u95ee\u9898\u53ef\u4ee5\u8f6c\u5316\u4e3a\u6709\u7528\u8d85\u8fc7$m$\u4e2a\u70b9\u6765\u8986\u76d6\u6240\u6709\u5173\u952e\u70b9\uff0c\u6700\u5927\u8ddd\u79bb\u6700\u5c0f\u4e3a$ans$. \u5982\u679c\u4f7f\u7528\u8d2a\u5fc3+\u4e8c\u5206\uff0c\u5219\u9700\u8981\u4fdd\u8bc1\u6bcf\u4e2a\u65b0\u8282\u70b9\u7ba1\u8f96\u7684\u8303\u56f4\u6700\u5927\u5e76\u4e14\u4e0e\u5176\u4ed6\u8282\u70b9\u7ba1\u8f96\u7684\u8282\u70b9\u91cd\u53e0\u6700\u5c0f\u3002\u8fd9\u6837\u80fd\u4fdd\u8bc1\u7528\u7684\u70b9\u6700\u5c11\u3002 \u6240\u4ee5\u53ef\u4ee5\u8bbe$f[i]$\u8868\u793a\u5728$i$\u7684\u5b50\u6811\u91cc\u8ddd\u79bb$i$\u6700\u8fdc\u7684\u5173\u952e\u8282\u70b9\uff1b$g[i]$\u8868\u793a\u5728$i$\u7684\u5b50\u6811\u91cc\u8ddd\u79bb$i$\u6700\u8fd1\u7684\u5df2\u9009\u4e2d\u7684\u8282\u70b9\u3002 \u521d\u59cb\u503c$f[u]=-\\infty,g[u]=\\infty$ \u8f6c\u79fb\uff1a $$ f[u]=\\max_{v\\in son(u)}(f[v]+1),g[u]=\\min_{v\\in son(u)}(g[v]+1) $$ \u8fd8\u6709\u4e09\u4e2a\u7279\u5224\uff1a ($k$\u4e3a\u5f53\u524d\u4e8c\u5206\u7684\u8ddd\u79bb) 1) $f[u]+g[u]<=k$\uff0c\u8bf4\u660e\u5f53\u524d\u7684\u5b50\u6811\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u9009\u4e2d\u8282\u70b9\u88ab\u5b8c\u5168\u8986\u76d6\uff0c\u6240\u4ee5$f[u]=-\\infty$,\u8868\u793a\u4e0d\u5bf9\u7236\u8282\u70b9\u7684$f$\u4ea7\u751f\u5f71\u54cd 2) $g[u]>k$\uff0c\u8bf4\u660e\u5f53\u524d\u7684\u5b50\u6811\u4e0a\u7aef\u4e0d\u4f1a\u88ab$u$\u7684\u5b50\u5b59\u5b8c\u5168\u8986\u76d6\uff0c\u90a3\u4e48\u53ef\u4ee5\u66f4\u65b0\u4e00\u4e0b$f[u]$\u4ea4\u7ed9$u$\u7684\u7236\u4eb2\u5904\u7406\uff0c\u8fd9\u6837\u4fdd\u8bc1\u91cd\u53e0\u6700\u5c0f\u3002$f[u]=\\max(f[u],0)$\uff0c\u8868\u793a\u5982\u679c\u6ca1\u6709\u672a\u8986\u76d6\u5173\u952e\u8282\u70b9\u5728\u5b50\u6811\u91cc\u5c31\u53ea\u7b97\u5b83\u81ea\u5df1\u3002 3) $f[u]==k$,\u8bf4\u660e\u5f53\u524d\u8282\u70b9\u6070\u597d\u80fd\u7528\u6700\u5c0f\u91cd\u53e0\u8986\u76d6\u6574\u9897\u5b50\u6811\uff0c\u5e76\u4e14\u56e0\u4e3a\u8fd9\u4e2a\u66f4\u65b0\u662f\u5728\u56de\u6eaf\u8fc7\u7a0b\u4e2d\u7684\uff0c\u8981\u5f80\u4e0a\u8d70\uff0c\u5982\u679c\u4e0d\u9009\u8fd9\u4e2a\u8282\u70b9\uff0c\u540e\u9762\u5c31\u65e0\u6cd5\u8986\u76d6\u6240\u6709\u8282\u70b9\uff0c\u6240\u4ee5\u5f3a\u5236\u9009$u$,$f[u]=-\\infty,g[u]=0,++tot$ \u6700\u540e\u7279\u5224\u4e00\u4e0b\u6839\u8282\u70b9\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=3e5+10,INF=1e9+10; int f[N],g[N],head[N],a[N]; int cnt,n,m,u,v,tot; struct node{ int v,nxt; }e[N<<1]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void dfs(int u,int p,int k){ f[u]=-INF,g[u]=INF; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; dfs(v,u,k); f[u]=max(f[u],f[v]+1); g[u]=min(g[u],g[v]+1); } if(f[u]+g[u]<=k) f[u]=-INF; if(g[u]>k && a[u]) f[u]=max(f[u],0); if(f[u]==k) f[u]=-INF,g[u]=0,++tot; } bool check(int k){ tot=0; dfs(1,0,k); if(f[1]>=0) ++tot; return tot<=m; } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=1;i<n;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u); int l=0,r=n,ans=INF; while(l<=r){ int mid=l+r>>1; if(check(mid)) r=mid-1,ans=mid; else l=mid+1; } printf(\"%d\",ans); return 0; }","title":"\u6811\u5f62dp\u603b\u7ed3"},{"location":"my%20past/OI/%E6%A0%91%E5%BD%A2dp/#dp","text":"","title":"\u6811\u5f62dp\u603b\u7ed3"},{"location":"my%20past/OI/%E6%A0%91%E5%BD%A2dp/#_1","text":"P3047 dp[u][k]\u8868\u793a\u8ddd\u79bbu\u4e0d\u8d85\u8fc7k\u7684\u70b9\u6743\u503c\u4e4b\u548c dfs1:$ dp[u][k]+=\\sum dp[v][k-1]$ \u4e0b\u884c\uff0c\u4e0d\u9700\u8981\u5bb9\u65a5\uff0c\u76f4\u63a5\u7531\u513f\u5b50\u7d2f\u52a0\u5373\u53ef \u6c42\u51fau\u7684\u5b50\u6811\u6240\u6709\u4e0d\u8d85\u8fc7k\u7684\u70b9\u6743\u503c\u4e4b\u548c dfs2:$dp[v][k]+=dp[u][k-1]-(k>=2)dp[v][k-2]$\u4e0a\u884c\uff0c\u9700\u8981\u7b80\u5355\u5bb9\u65a5\uff0c\u5e76\u4e14\u6ce8\u610f\u8981\u9006\u5e8f\uff0c\u56e0\u4e3a\u82e5dp[v][k-2]\u5148\u66f4\u6539\uff0c\u5219dp[v][k]\u4f1a\u51fa\u9519 \u6c42\u51fa\u6700\u7ec8\u7b54\u6848 P2986 dp[u]\u8868\u793a\u6bcf\u4e2a\u70b9\u7684\u7b54\u6848 f[u]\u8868\u793a\u8be5\u8282\u70b9\u6240\u6709\u5b50\u8282\u70b9\u5230\u5b83\u7684\u8ddd\u79bb\u4e4b\u548c f[u]=f[v]+w * sz[v] \u5219\u6709dp[1]=f[1] \u90a3\u4e48 dp[v]=dp[u]-sz[v] * w+(sz[1] * w-sz[v] * w) =dp[u]-2 * sz[v] * w+sz[1] * w \u8f6c\u79fb\u65f6\u53ea\u66f4\u6539\u7684\u662f\u4e0e\u8be5\u8fb9\u6709\u5173\u8054\u7684\u7b54\u6848\u3002 \u6ce8\u610f\u521d\u59cb\u72b6\u6001\u4e3adp[1] CF9D f[i][j]\u8868\u793ai\u4e2a\u8282\u70b9\uff0c\u6df1\u5ea6\u4e0d\u8d85\u8fc7j\u7684\u4e8c\u53c9\u6811\u603b\u6570\u91cf,\u5219 $f[i][j]=\\sum_{k=1}^{i-1}f[k][j-1]* f[i-k-1][j-1] $ P1623 dp+\u9ad8\u7cbe\u5ea6 \u8bbef[i][0/1]\u4e3a\u6700\u5927\u5339\u914d\u4e2a\u6570\uff0c0\u8868\u793a\u4e0e\u513f\u5b50\u4e0d\u5339\u914d\uff0c1\u8868\u793a\u4e0e\u5176\u4e2d\u4e00\u4e2a\u513f\u5b50\u5339\u914d\uff1bg[i][0/1]\u4e3a\u5bf9\u5e94\u7684\u65b9\u6848\u6570 \u8f6c\u79fb\u65b9\u7a0b\uff1a(\u6709'\u4ebf'\u70b9\u590d\u6742) //\u65e0\u9ad8\u7cbe\u5ea6 void dp1(int u,int p){ int sum=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; dp1(v,u); sum+=max(f[v][0],f[v][1]); } f[u][0]=sum; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; f[u][1]=max(f[u][1],sum-max(f[v][0],f[v][1])+f[v][0]+1); } return; } void dp2(int u,int p){ int sum=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; dp2(v,u); if(f[v][0]<f[v][1]){ sum*=g[v][1]; }else if(f[v][0]>f[v][1]){ sum*=g[v][0]; }else{ sum*=(g[v][0]+g[v][1]); } } g[u][0]=sum; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; int tmp=1; if(v==p)continue; if(f[v][0]<f[v][1]){ tmp=g[v][1]; }else if(f[v][0]>f[v][1]){ tmp=g[v][0]; }else{ tmp=(g[v][0]+g[v][1]); } if(f[u][1]==f[u][0]-max(f[v][0],f[v][1])+f[v][0]+1){ g[u][1]+=(g[u][0]/tmp)*g[v][0]; } } return; } \u6ce8\u610f\u6700\u540e\u7684g\u4e5f\u8981\u6839\u636ef\u5224\u65ad\uff0c\u8fd9\u4e2a\u5751\u4e86\u6211\u4e00\u6b21 ~~(\u6211\u751a\u81f3\u8fde\u9ad8\u7cbe\u5ea6\u90fd\u6ca1\u5199\uff0c\u53ea\u62ff\u4e8660pts)~~","title":"\u7edf\u8ba1\u7b54\u6848\u7c7b"},{"location":"my%20past/OI/%E6%A0%91%E5%BD%A2dp/#_2","text":"P4084 \u6811\u5f62dp\u5165\u95e8\u9898:) dp[i][j]\u8868\u793a\u5f53\u524d\u8282\u70b9\u4e3aj\u989c\u8272\u662f\u7684\u65b9\u6848\u6570 \u6ce8\u610f\u5f53\u8be5\u8282\u70b9\u5df2\u7ecf\u6709\u989c\u8272\u65f6\uff0c\u5219dp[u][c[u]]=1,\u5176\u4ed6\u4e3a0 \uff1b\u5426\u5219dp[u][1,2,3]=1; \u8f6c\u79fb\uff1a //1.c[u]!=0 for(i;1-3) if(i!=c[u])sum+=dp[v][i]; dp[u][c[u]]=(dp[u][c[u]]*sum)%P; //2.c[u]==0 for(i;1-3) for(j;1-3) if(j!=i)sum+=dp[v][j]; dp[u][i]=(dp[u][i]*sum)%P; P2279 \u975e\u5e38\u597d\u3002\u975e\u5e38\u6076\u5fc3 dp[u][0,1,2,3,4]\u4e00\u51710\uff0c1\uff0c2\uff0c3\uff0c4\u4e94\u79cd\u72b6\u6001\uff0c\u5206\u522b\u4e3a\u7237\u7237\uff0c\u7236\u4eb2\uff0c\u81ea\u5df1\uff0c\u513f\u5b50\uff0c\u5b59\u5b50 \u540c\u6837\u8981\u6ce8\u610f\u4e0a\u884c\u7684\u72b6\u6001dp[u][3] \u548cdp[u][4] P2899 dp[u][0/1/2]\u8868\u793a\u4e09\u79cd\u72b6\u6001\uff0c\u88ab\u81ea\u5df1\u8986\u76d6\uff0c\u88ab\u513f\u5b50\u8986\u76d6\uff0c\u88ab\u7236\u4eb2\u8986\u76d6 \u6ce8\u610f\u987a\u5e8f\u65f6\u4ece\u4e0b\u5f80\u4e0a\u56de\u6eaf\u65f6\u641c\uff0c\u6240\u4ee5\u641c\u5230\u7236\u4eb2\u65f6\u513f\u5b50\u5df2\u7ecf\u88ab\u66f4\u65b0\u5b8c\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528 1.dp[u][0]=$\\sum$min(dp[v][0],dp[v][1],dp[v][2]),\u56e0\u4e3a\u81ea\u5df1\u5df2\u7ecf\u88ab\u81ea\u5df1\u8986\u76d6\uff0c\u6240\u4ee5\u53ef\u4ee5\u53d6\u513f\u5b50\u7684\u6240\u6709\u503c\uff1b 2.dp[u][2]=$\\sum$min(dp[v][0],dp[v][1]),\u5982\u679cu\u88abfa[u]\u8986\u76d6\uff0c\u5219u\u4e0d\u4f1a\u88abu\u81ea\u5df1\uff0c\u4e5f\u5c31\u662fdp[v][2]\u8986\u76d6\uff0c\u5c31\u4e0d\u53d6\u4e86 update:2021.11.12 \u5e94\u8be5\u662fdp[u][2]=$\\sum$dp[v][1]\uff0c\u56e0\u4e3au\u53ea\u88ab\u7236\u4eb2\u8986\u76d6\uff0c\u5982\u679c\u53d6dp[v][0]\u5219\u8868\u660eu\u8fd8\u88ab\u513f\u5b50\u8986\u76d6\uff0c\u5219\u4f1a\u51fa\u9519. 3.< \u91cd\u70b9 >dp[u][1]=min(f[v][0]+$\\sum_{i=son[u]}^{i!=v} $min(f[i][0],f[i][1])),\u56e0\u4e3au\u8981\u88ab\u81f3\u5c11\u4e00\u4e2a\u5b50\u8282\u70b9\u8986\u76d6\uff0c\u6240\u4ee5\u53ef\u4ee5\u66b4\u529b\u679a\u4e3e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u5219\u5269\u4f59\u7684\u8282\u70b9\u7684\u72b6\u6001\u4e0e2\u76f8\u540c\u3002 \u4e5f\u53ef\u4ee5\u8fdb\u884c\u6570\u5b66\u65b9\u6cd5\u7684\u4f18\u5316\uff0c\u8be6\u89c1\u9898\u89e3 P3174 \u6709\u610f\u601d\u7684\u4e00\u9053\u9898 \u5b9a\u4e49: f[n]\u8868\u793a\u5f53\u524d\u8282\u70b9\u7684\u5b50\u6811\u91cc\u6700\u957f\u7684\u94fe\u4e2d\u5305\u542b\u7684\u70b9(\u4e3b\u5e72\u4e0e\u5206\u53c9) ans[n]\u8868\u793a\u5f53\u524d\u8282\u70b9\u7684\u7b54\u6848 \u56e0\u4e3a\u5b58\u5728\u62d0\u5f2f\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u6700\u4f18\u89e3\u4e0d\u4e00\u5b9a\u5b58\u5728\u4e8e\u6839\u8282\u70b9\uff0c\u56e0\u6b64\u8f6c\u79fb\u65b9\u7a0b\uff1a f[u]=max1+num; if(p==0) {//p\u662fu\u7684\u7236\u4eb2\uff0c\u6839\u8282\u70b9\u65e0\u7236\u4eb2 ans[u]=max1+max2+num-1; } else ans[u]=max1+max2+num; \u6700\u7ec8\u7b54\u6848\u4e3amax(ans[i]) P1352 \u6a21\u677f\u9898\u3002 * \u8981\u7528\u513f\u5b50\u66f4\u65b0\u7236\u4eb2\u800c\u4e0d\u7528\u7236\u4eb2\u66f4\u65b0\u513f\u5b50\u7684\u539f\u56e0\uff1a\u4f1a\u4ea7\u751f\u540e\u6548\u6027\uff1a\u513f\u5b50\u7684\u7b54\u6848\u4e0d\u4ec5\u4e0e\u7236\u4eb2\u6709\u5173\uff0c\u8fd8\u4e0e\u7237\u7237\u6709\u5173\uff0c\u7237\u7237\u4e0d\u9009\uff0c\u513f\u5b50\u4e5f\u4e0d\u80fd\u9009\u3002","title":"\u8282\u70b9\u9009\u62e9\u7c7b(\u67d3\u8272\u7c7b)"},{"location":"my%20past/OI/%E6%A0%91%E5%BD%A2dp/#_3","text":"P2015 \u6811\u5f62\u80cc\u5305\u6a21\u677f\u9898\uff0c\u6ce8\u610f\u56e0\u4e3a\u662f\u4e8c\u53c9\u6811\uff0c\u6240\u4ee5\u8f6c\u79fb\u65b9\u7a0b\u6709\u4e24\u79cd\uff1a 1.dp[u][t]=max(dp[u][t],dp[ln][t-k]+dp[rn][k]),ln rn \u8868\u793a\u5de6\u513f\u5b50\u53f3\u513f\u5b50 2.dp[u][t]=max(dp[u][t],dp[v][k]+dp[u][t-k]) 2\u7684\u597d\u5904\u4e3a\u53ef\u4ee5\u5e94\u5bf9\u591a\u53c9\u6811\u3002 \u539f\u56e0\u662f\uff1a \u56e0\u4e3a\u8981\u5148\u679a\u4e3et\uff0c\u6240\u4ee5\u5c31\u50cf\u80cc\u5305\u4e00\u6837\uff0c\u5f53\u524d\u513f\u5b50\u7684\u8d21\u732e\u80fd\u591f\u52a0\u5728\u4e4b\u524d\u7684\u72b6\u6001\u91cc\uff0c\u800c\u4e4b\u524d\u7684\u72b6\u6001\u5df2\u7ecf\u5305\u542b\u5728\u6df1\u641c\u5b83\u4e4b\u524d\u7684\u5144\u5f1f\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u8fdb\u884c\u7d2f\u52a0\u3002 v\u76f8\u5f53\u4e8e\u77f3\u5934\u79cd\u7c7b\uff1bt\u76f8\u5f53\u4e8e\u80cc\u5305\u5bb9\u91cf \u6ce8\u610f\u8981\u9006\u5e8f\u679a\u4e3et\uff0c\u4e0d\u7136\u4f1a\u5bf9\u4e4b\u524d\u5df2\u7ecf\u5f97\u5230\u7684\u72b6\u6001\u8fdb\u884c\u4e8c\u6b21\u7d2f\u52a0 P1270 \u6811\u5f62\u80cc\u5305\u3002 1.\u540c\u6837\u662fdp[u][t]=max(dp[u][t],dp[v][k]+dp[u][t-k])\uff1b 2.dp[u][t]=max(dp[u][t],dp[u][t-j*5]+j) \u5728\u6df1\u641c\u5b8c\u6240\u6709\u513f\u5b50\u540e\u505a\u8fd9\u4e2a \u540c\u6837\u6ce8\u610f\u9006\u5e8f\u679a\u4e3et \u7ed3\u8bba\uff1a\u4e0d\u4e00\u5b9a\u8981\u6309\u7167\u65f6\u95f4\u7ebf\u6027\u6d41\u901d\u8bbe\u7f6e\u72b6\u6001\uff0c\u4e5f\u53ef\u4ee5\u5c06\u65f6\u95f4\u7d2f\u52a0\u8868\u793a\uff0c\u5373\u7d2f\u52a0\u8d21\u732e\u3002 P3360 \u540c\u4e0a\uff0c\u52a0\u5165\u4e86\u4ef7\u503c\u3002 P4362 \u6bcf\u4e2a\u6811\u679d\u53ea\u6709\u4e24\u79cd\u60c5\u51b5\u4f1a\u4ea7\u751f\u96be\u53d7\u503c\uff1a 1) \u4e24\u7aef\u70b9\u90fd\u88ab\u5927\u5934\u5403\u6389 2) \u4e24\u7aef\u70b9\u90fd\u4e0d\u88ab\u5927\u5934\u5403\u6389\u5e76\u4e14\u5c0f\u5934\u53ea\u6709\u4e00\u4e2a(m==2) \u56e0\u4e3a\u5982\u679c\u5c0f\u5934\u591a\u4f59\u4e00\u4e2a\uff0c\u90a3\u4e48\u4efb\u610f\u4e00\u6761\u6ee1\u8db3\u60c5\u51b52\u7684\u6811\u679d\uff0c\u5b83\u7684\u4e24\u7aef\u90fd\u53ef\u4ee5\u88ab\u4e0d\u540c\u7684\u5c0f\u5934\u5403\uff0c\u5c31\u4e0d\u4f1a\u6709\u8d21\u732e\u3002 \u56e0\u6b64\u8f6c\u79fb\u65b9\u7a0b\uff1a $$f[u][i][0]=min(f[u][i][0],min(tmp[i-j][0]+f[v][j][0]+(m==2)* w,tmp[i-j][0]+f[v][j][1]));\\ f[u][i][1]=min(f[u][i][1],min(tmp[i-j][1]+f[v][j][1]+w,tmp[i-j][1]+f[v][j][0]));$$ \u6ce8\u610fm==2\uff0c\u5c31\u7b97\u6ca1\u6709\u96be\u53d7\u503c\u4e5f\u8981\u628a\u5b50\u6811\u7684\u8d21\u732e\u52a0\u5230\u80cc\u5305\u91cc\u3002 \u5e76\u4e14\u6bcf\u6b21dp\u4e4b\u524d\u8981\u5c06f[u]\u6570\u7ec4\u5907\u4efd\u4e0b\u6765\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u9632\u6b62f[u]\u4e0d\u65ad\u53d8\u5c0f. \u4f8b\u5982\uff1a \u65e0tmp\uff1a v1\u540e\uff1af[u][1][0]=0; v2\u540e\uff1a\u56e0\u4e3af[u][1][0]=0,\u6240\u4ee5f[u][1][0]=min(0,0+0+5)=0; \u6709tmp\uff1a v1\u540e\uff1af[u][1][0]=0; v2\u524d\uff1a f[u][1][0]=INF; tmp[1][0]=0; v2\u540e\uff1af[u][1][0]=min(INF,0+0+5)=5; \u56e0\u4e3af[u][1][0]\u5728\u4e0d\u540c\u65f6\u523b\u8868\u793a\u7684\u662f\u4e0d\u540c\u72b6\u6001\uff0c\u5982\u679c\u4e0d\u5907\u4efd\uff0c\u5c31\u4f1a\u5bfc\u81f4f[u]\u8d8a\u6765\u8d8a\u5c0f\uff0c\u5373f[u][1][0]\u53ea\u80fd\u4e0e\u5f53\u524d\u65f6\u523b\u7684\u65b0\u8d21\u732e\u6bd4\u8f83\uff0c\u4e0d\u80fd\u4e0etmp\u4e2d\u4e4b\u524d\u7684\u72b6\u6001\u505amin.tmp\u53ea\u80fd\u7528\u6765\u66f4\u65b0\u51fa\u5f53\u524dj\u4e0d\u540c\u7684\u72b6\u6001. \u6362\u79cd\u8bf4\u6cd5\uff0cf[v2][1][0]\u8868\u793a\u5f53\u524d\u72b6\u6001\uff0cf[v1][1][0]\u8868\u793a\u4e4b\u524d\u7684\u72b6\u6001\uff0c\u5219v2\u4ee5\u53ca\u5b83\u4e4b\u540e\u7684\u72b6\u6001\u90fd\u4f1a\u56e0\u4e3af[v1][1][0]=0\u800c\u8d8a\u53d8\u8d8a\u5c0f\uff0c\u4ea7\u751f\u4e86\u540e\u6548\u6027\u3002 \u4e3a\u4e86\u4e0d\u4ea7\u751f\u540e\u6548\u6027\uff0c\u5c31\u4e0d\u80fd\u8ba9v2\u8bbf\u95ee\u5230f[v1][1][0],\u6240\u4ee5\u9700\u8981\u5907\u4efdtmp\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=530; int f[N][N][2],head[N],sz[N],tmp[N][2]; int n,m,k,cnt; struct node { int v,w,nxt; } e[N<<1]; void add(int u,int v,int w) { e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; } void dp(int u,int p) { f[u][0][0]=0; f[u][1][1]=0; sz[u]=1; for(int o=head[u]; ~o; o=e[o].nxt) { int v=e[o].v,w=e[o].w; if(v==p)continue; dp(v,u); sz[u]+=sz[v]; } for(int o=head[u]; ~o; o=e[o].nxt) { int v=e[o].v,w=e[o].w; if(v==p)continue; memcpy(tmp,f[u],sizeof tmp); memset(f[u],63,sizeof f[u]); for(int i=min(k,sz[u]); i>=0; --i) {//\u6ce8\u610f\u8fd9\u91cc\u53d6min(k,sz[u])\u53ef\u4ee5\u5feb\u4e0d\u5c11 for(int j=min(i,sz[v]); j>=0; --j) { f[u][i][0]=min(f[u][i][0],min(tmp[i-j][0]+f[v][j][0]+(m==2)*w,tmp[i-j][0]+f[v][j][1])); f[u][i][1]=min(f[u][i][1],min(tmp[i-j][1]+f[v][j][1]+w,tmp[i-j][1]+f[v][j][0])); } } } } int main() { memset(head,-1,sizeof head); cnt=-1; scanf(\"%d%d%d\",&n,&m,&k); if(n-k<m-1) { printf(\"-1\"); return 0; } for(int i=1,u,v,w; i<n; ++i) { scanf(\"%d%d%d\",&u,&v,&w); add(u,v,w); add(v,u,w); } //init(); memset(f,63,sizeof f); dp(1,1); printf(\"%d\",f[1][k][1]); return 0; } \u6811\u5f62\u80cc\u5305\u7684\u590d\u6742\u5ea6\u5206\u6790\uff1a $$ \u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u679a\u4e3e\u7684\u6b21\u6570\u4e3asz[u] sz[v_1]+sz[u] sz[v_2]+...+sz[u]* sz[v_m]=O(sz[u]^2)\\ (\u5bf9\u4e8e\u679a\u4e3e\u52300\uff0c\u5176\u5b9e\u76f8\u5dee\u4e2a\u5e38\u6570\uff0c\u53ef\u4ee5\u5ffd\u7565\u3002)\\ \u6240\u4ee5\u6574\u4f53\u7684\u590d\u6742\u5ea6\u5c31\u662f\\sum_{u=1}^n sz[u]^2=O(n^3* k),k<1.\\ \u4e8b\u5b9e\u4e0a\uff0c\u6700\u6781\u9650\u7684\u60c5\u51b5\u5c31\u662f\u4e00\u6761\u94fe\uff0c\u6b64\u65f6k=\\frac12 \u6240\u4ee5k<\\frac12\\ \u6240\u4ee5\u53ef\u4ee5\u8bf4\u6811\u5f62\u80cc\u5305\u7684\u590d\u6742\u5ea6\u4e25\u683c\u5c0f\u4e8eO(0.5n^3) $$ P3177 \u597d\u9898\u3002 \u8bbef[u][i]\u8868\u793a\u6bcf\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u7684\u8fb9\u4ea7\u751f\u7684\u8d21\u732e\u3002 \u6ce8\u610f\u72b6\u6001\u7684\u542b\u4e49\u65f6\u8d21\u732e\uff0c\u4e0d\u662f\u6bcf\u4e2a\u5b50\u6811\u5185\u6240\u6709\u70b9\u7684\u7b54\u6848\uff0c\u56e0\u4e3a\u5b50\u6811\u5185\u7684\u70b9\u4f1a\u548c\u5b50\u6811\u5916\u7684\u70b9\u4ea7\u751f\u989d\u5916\u7684\u8d21\u732e\uff0c\u5e76\u4e14\u65e0\u6cd5\u8ba1\u7b97\u3002 \u8003\u8651\u6bcf\u6761\u8fb9\u7684\u8d21\u732e\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f\u4e24\u8fb9\u7684\u540c\u8272\u70b9\u7684\u4e58\u79ef\u3002 \u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a int tot=j*(k-j)+(sz[v]-j)*(n-sz[v]-k+j); f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]+tot*w); \u6ce8\u610f\uff1a 1) \u8fd9\u4e2a\u6811\u5f62\u80cc\u5305\u8981\u6e05\u7a7a\u975e\u6cd5\u72b6\u6001(-1)\uff0c\u4e0d\u7136\u4f1a\u51fa\u9519\u3002 2) \u7b2c\u4e8c\u5c42\u7684\u679a\u4e3e\u5982\u679c\u662f\u5012\u5e8f\uff0c\u5c31\u4e00\u5b9a\u8981\u5148\u8f6c\u79fbf[v][0],\u5373j==0\u5f97\u60c5\u51b5\uff0c\u4e0d\u7136\u4e5f\u4f1a\u51fa\u9519\u3002\u539f\u56e0\u5c31\u662f\uff0c\u6bcf\u6b21\u90fd\u4f1a\u7528f[u][j]\u66f4\u65b0\u4e00\u6b21:f[u][j]+f[v][0]\uff0c\u8fd9\u5c31\u4e0d\u6ee1\u8db3\u4e0d\u7528\u5f97\u51fa\u7684\u72b6\u6001\u66f4\u65b0\u5176\u4ed6\u72b6\u6001\u4e86\u3002 \u7ed3\u8bba: \u5f53\u8bbe\u8ba1\u6210\u5b50\u6811\u5185\u7b54\u6848\u884c\u4e0d\u901a\uff0c\u6362\u53e5\u8bdd\u8bf4\u5b50\u6811\u5185\u7b54\u6848\u53d7\u5b50\u6811\u5916\u8282\u70b9\u5f71\u54cd\u65f6\uff0c\u53ef\u4ee5\u8bbe\u8ba1\u6210\u5b50\u6811\u5185\u8fb9\u7684\u8d21\u732e\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=2200; int n,k,cnt; int head[N],sz[N]; int f[N][N]; struct node{ int v,nxt,w; }e[N<<1]; void add(int u,int v,int w){ e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; } void dfs(int u,int p){ sz[u]=1; for(int o=head[u];~o;o=e[o].nxt){ int v=e[o].v; if(v==p)continue; dfs(v,u); sz[u]+=sz[v]; } } void dp(int u,int p){ f[u][1]=f[u][0]=0; for(int o=head[u];~o;o=e[o].nxt){ int v=e[o].v,w=e[o].w; if(v==p)continue; dp(v,u); for(int i=min(sz[u],k);i>=0;--i){ for(int j=0;j<=min(sz[v],i);++j){ if(f[u][i-j]==-1)continue; int tot=j*(k-j)+(sz[v]-j)*(n-sz[v]-k+j); f[u][i]=max(f[u][i],f[u][i-j]+f[v][j]+tot*w); } } } } int read1(){ int x=0; char ch=getchar(); while(ch>'9' || ch<'0'){ ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x; } void write1(int x){ if(x>9)write1(x/10); putchar(x%10+'0'); } signed main(){ memset(head,-1,sizeof head); cnt=-1; n=read1(),k=read1(); if(n-k<k)k=n-k; for(int i=1,u,v,w;i<n;++i){ u=read1(),v=read1(),w=read1(); add(u,v,w); add(v,u,w); } memset(f,-1,sizeof f); dfs(1,0); dp(1,0); write1(f[1][k]); return 0; }","title":"\u6811\u5f62\u80cc\u5305\u7c7b"},{"location":"my%20past/OI/%E6%A0%91%E5%BD%A2dp/#dp_1","text":"P6419 \u8bbe$f[u]$\u8868\u793a\u5b50\u6811\u5185\u8d21\u732e\uff0c$g[u]$\u8868\u793a\u5b50\u6811\u5916\u8d21\u732e\uff0c$dis[u][0/1]$\u8868\u793a\u5b50\u6811\u5185\u6700/\u6b21\u957f\u94fe\uff0c$up[u]$\u8868\u793a\u5b50\u6811\u5916\u6700\u957f\u94fe\u3002 \u6ce8\u610f\u66f4\u65b0$up[u]$\u548c$g[u]$\u65f6\uff0c\u5982\u679c\u6240\u6709\u5173\u952e\u70b9\u90fd\u5305\u542b\u5728$v$\u5b50\u6811\u5185\uff0c\u8bf4\u660e$u$\u4e0a\u9762\u6ca1\u6709\u6700\u957f\u94fe\uff0c\u90a3\u4e48$up[v]$\u548c$g[v]$\u90fd\u4e0d\u5e94\u8be5\u8f6c\u79fb\u3002\uff08\u90fd\u4e3a0\uff09 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=5e5+10; int dis[N][2],up[N],head[N],f[N],g[N],sz[N],vis[N],ans[N]; int n,k,cnt,tot; struct node { int v,w,nxt; } e[N<<1]; void add(int u,int v,int w) { e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; } void dfs(int u,int p) { sz[u]=vis[u]; for(int i=head[u]; ~i; i=e[i].nxt) { int v=e[i].v,w=e[i].w; if(v==p)continue; dfs(v,u); sz[u]+=sz[v]; if(!sz[v])continue; f[u]+=f[v]+w+w; if(dis[v][0]+w>dis[u][0]) { dis[u][1]=dis[u][0]; dis[u][0]=dis[v][0]+w; } else if(dis[v][0]+w>dis[u][1]) { dis[u][1]=dis[v][0]+w; } } } void dp(int u,int p) { for(int i=head[u]; ~i; i=e[i].nxt) { int v=e[i].v,w=e[i].w; if(v==p)continue; if((k-sz[v])) { g[v]=g[u]+f[u]-f[v]+((sz[v]==0)?(w+w):0); if(dis[v][0]+w==dis[u][0]) { up[v]=max(up[u],dis[u][1])+w; } else { up[v]=max(up[u],dis[u][0])+w; } } dp(v,u); } } signed main() { memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld\",&n,&k); for(int i=1,u,v,w; i<n; ++i) { scanf(\"%lld%lld%lld\",&u,&v,&w); add(u,v,w); add(v,u,w); } for(int i=1,tmp; i<=k; ++i) { scanf(\"%lld\",&tmp); vis[tmp]=1; } dfs(1,0); dp(1,0); for(int i=1; i<=n; ++i) { printf(\"%lld\\n\",f[i]+g[i]-max(dis[i][0],up[i])); } return 0; } \u7ed3\u8bba\uff1a 1) \u6362\u6839dp\u7684\u5957\u8def\u5c31\u662f\u5904\u7406\u5b50\u6811\u5185\u7684\u4fe1\u606f\uff0c\u5b50\u6811\u5916\u7684\u4fe1\u606f\u7531\u5b50\u6811\u5185\u4fe1\u606f\u76f8\u51cf\u5f97\u5230\u3002 2) \u5904\u7406\u5b50\u6811\u5185\u4fe1\u606f\u65f6\uff0c\u987a\u5e8f\u4e3a$v\\to u$,\u5373\u4ece\u53f6\u5b50\u5411\u4e0a\u5408\u5e76\uff1b\u5904\u7406\u5b50\u6811\u5916\u4fe1\u606f\u65f6\uff0c\u987a\u5e8f\u4e3a$u \\to v$,\u5373\u4ece\u6839\u5411\u4e0b\u63a8\u3002 P3237 ~~\u770b\u9898\u5c31\u770b\u4e8630min~~ \u7136\u800c\u770b\u61c2\u4e86\u9898\u4e5f\u4e0d\u77e5\u9053\u600e\u4e48\u505a\u3002 \u9898\u610f\u7b80\u5316: \u7ed9\u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e00\u4e2a\u6743\u503c\uff0c\u8981\u6c42\u4fee\u6539\u4e00\u4e9b\u70b9\u7684\u6743\u503c\uff0c\u4f7f\u5f97\uff1a 1) \u540c\u4e00\u4e2a\u7236\u4eb2\u7684\u513f\u5b50\u6743\u503c\u5fc5\u987b\u76f8\u540c 2) \u7236\u4eb2\u7684\u53d6\u503c\u5fc5\u987b\u662f\u6240\u6709\u513f\u5b50\u6743\u503c\u4e4b\u548c \u4e00\u4e2a\u91cd\u8981\u7ed3\u8bba \uff1a\u53ea\u8981\u6709\u4e00\u4e2a\u70b9\u88ab\u786e\u5b9a\u4e86\uff0c\u90a3\u4e48\u6574\u68f5\u6811\u7684\u6700\u7ec8\u5f62\u6001\u5c31\u968f\u4e4b\u786e\u5b9a\u4e86\u3002 \u4e5f\u5c31\u662f\u8bf4\uff0c\u4e00\u4e2a\u70b9\u88ab\u786e\u5b9a\u540e\uff0c\u53ea\u6709\u4e0e\u4ed6\"\u7b49\u4ef7\"\u7684\u70b9\u4e0d\u7528\u6539\u53d8\uff0c\u5176\u4ed6\u7684\u90fd\u8981\u53d8\u3002 \u8bbe\u6700\u591a\u7684\u7b49\u4ef7\u70b9\u4e2a\u6570\u603b\u5171\u6709$ans$\u4e2a\uff0c\u90a3\u4e48\u6700\u7ec8\u8981\u6539\u53d8$n-ans$\u4e2a\u70b9\u3002 \u4e0b\u9762\u8981\u6c42\u51fa\u6240\u6709\u7b49\u4ef7\u70b9\u3002\u6211\u4eec\u53d1\u73b0\uff0c\u4e24\u4e2a\u8282\u70b9\u7b49\u4ef7\u9700\u8981\u6ee1\u8db3\uff1a $\\prod_{i=1}^{d_x-1}son[v[i]] a[x]=\\prod_{i=1}^{d_y-1}son[v[i]] a[y]$\u3002 \u8bbe$f[i]$\u8868\u793a\u4e0a\u8ff0\u5f0f\u5b50\uff0c\u5219\uff1a$f[x]=f[y]$ \u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5~~\u5feb\u4e50\u5730~~\u6811\u5f62$dp$\u4e86. #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define int long long using namespace std; typedef double db; const int N=5e5+10; const db eps=1e-8,INF=1e8; int n,u,v,cnt,tmp,ans; int a[N],head[N]; db f[N]; struct node{ int v,nxt; }e[N<<1]; bool cmp(db a,db b){return a<b;} void add(int u,int v){e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt;} void dfs(int u,int p,db t){ f[u]+=t; int tot=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; ++tot; } for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; dfs(v,u,t+log((db)(tot))); } } signed main(){ memset(head,-1,sizeof head);cnt=-1;f[0]=-INF; scanf(\"%lld\",&n); for(int i=1;i<=n;++i) scanf(\"%lld\",&a[i]),f[i]=log((db)(a[i])); for(int i=1;i<n;++i) scanf(\"%lld%lld\",&u,&v),add(u,v),add(v,u); dfs(1,0,0); sort(f+1,f+n+1,cmp); tmp=0,ans=0; for(int i=2;i<=n;++i){ if(f[i]-f[i-1]<eps) ++tmp; else ans=max(ans,tmp),tmp=1; } ans=max(ans,tmp); printf(\"%lld\",n-ans); return 0; } P3523 \u95ee\u9898\u53ef\u4ee5\u8f6c\u5316\u4e3a\u6709\u7528\u8d85\u8fc7$m$\u4e2a\u70b9\u6765\u8986\u76d6\u6240\u6709\u5173\u952e\u70b9\uff0c\u6700\u5927\u8ddd\u79bb\u6700\u5c0f\u4e3a$ans$. \u5982\u679c\u4f7f\u7528\u8d2a\u5fc3+\u4e8c\u5206\uff0c\u5219\u9700\u8981\u4fdd\u8bc1\u6bcf\u4e2a\u65b0\u8282\u70b9\u7ba1\u8f96\u7684\u8303\u56f4\u6700\u5927\u5e76\u4e14\u4e0e\u5176\u4ed6\u8282\u70b9\u7ba1\u8f96\u7684\u8282\u70b9\u91cd\u53e0\u6700\u5c0f\u3002\u8fd9\u6837\u80fd\u4fdd\u8bc1\u7528\u7684\u70b9\u6700\u5c11\u3002 \u6240\u4ee5\u53ef\u4ee5\u8bbe$f[i]$\u8868\u793a\u5728$i$\u7684\u5b50\u6811\u91cc\u8ddd\u79bb$i$\u6700\u8fdc\u7684\u5173\u952e\u8282\u70b9\uff1b$g[i]$\u8868\u793a\u5728$i$\u7684\u5b50\u6811\u91cc\u8ddd\u79bb$i$\u6700\u8fd1\u7684\u5df2\u9009\u4e2d\u7684\u8282\u70b9\u3002 \u521d\u59cb\u503c$f[u]=-\\infty,g[u]=\\infty$ \u8f6c\u79fb\uff1a $$ f[u]=\\max_{v\\in son(u)}(f[v]+1),g[u]=\\min_{v\\in son(u)}(g[v]+1) $$ \u8fd8\u6709\u4e09\u4e2a\u7279\u5224\uff1a ($k$\u4e3a\u5f53\u524d\u4e8c\u5206\u7684\u8ddd\u79bb) 1) $f[u]+g[u]<=k$\uff0c\u8bf4\u660e\u5f53\u524d\u7684\u5b50\u6811\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u9009\u4e2d\u8282\u70b9\u88ab\u5b8c\u5168\u8986\u76d6\uff0c\u6240\u4ee5$f[u]=-\\infty$,\u8868\u793a\u4e0d\u5bf9\u7236\u8282\u70b9\u7684$f$\u4ea7\u751f\u5f71\u54cd 2) $g[u]>k$\uff0c\u8bf4\u660e\u5f53\u524d\u7684\u5b50\u6811\u4e0a\u7aef\u4e0d\u4f1a\u88ab$u$\u7684\u5b50\u5b59\u5b8c\u5168\u8986\u76d6\uff0c\u90a3\u4e48\u53ef\u4ee5\u66f4\u65b0\u4e00\u4e0b$f[u]$\u4ea4\u7ed9$u$\u7684\u7236\u4eb2\u5904\u7406\uff0c\u8fd9\u6837\u4fdd\u8bc1\u91cd\u53e0\u6700\u5c0f\u3002$f[u]=\\max(f[u],0)$\uff0c\u8868\u793a\u5982\u679c\u6ca1\u6709\u672a\u8986\u76d6\u5173\u952e\u8282\u70b9\u5728\u5b50\u6811\u91cc\u5c31\u53ea\u7b97\u5b83\u81ea\u5df1\u3002 3) $f[u]==k$,\u8bf4\u660e\u5f53\u524d\u8282\u70b9\u6070\u597d\u80fd\u7528\u6700\u5c0f\u91cd\u53e0\u8986\u76d6\u6574\u9897\u5b50\u6811\uff0c\u5e76\u4e14\u56e0\u4e3a\u8fd9\u4e2a\u66f4\u65b0\u662f\u5728\u56de\u6eaf\u8fc7\u7a0b\u4e2d\u7684\uff0c\u8981\u5f80\u4e0a\u8d70\uff0c\u5982\u679c\u4e0d\u9009\u8fd9\u4e2a\u8282\u70b9\uff0c\u540e\u9762\u5c31\u65e0\u6cd5\u8986\u76d6\u6240\u6709\u8282\u70b9\uff0c\u6240\u4ee5\u5f3a\u5236\u9009$u$,$f[u]=-\\infty,g[u]=0,++tot$ \u6700\u540e\u7279\u5224\u4e00\u4e0b\u6839\u8282\u70b9\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=3e5+10,INF=1e9+10; int f[N],g[N],head[N],a[N]; int cnt,n,m,u,v,tot; struct node{ int v,nxt; }e[N<<1]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void dfs(int u,int p,int k){ f[u]=-INF,g[u]=INF; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p)continue; dfs(v,u,k); f[u]=max(f[u],f[v]+1); g[u]=min(g[u],g[v]+1); } if(f[u]+g[u]<=k) f[u]=-INF; if(g[u]>k && a[u]) f[u]=max(f[u],0); if(f[u]==k) f[u]=-INF,g[u]=0,++tot; } bool check(int k){ tot=0; dfs(1,0,k); if(f[1]>=0) ++tot; return tot<=m; } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); for(int i=1;i<n;++i)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u); int l=0,r=n,ans=INF; while(l<=r){ int mid=l+r>>1; if(check(mid)) r=mid-1,ans=mid; else l=mid+1; } printf(\"%d\",ans); return 0; }","title":"\u6362\u6839dp"},{"location":"my%20past/OI/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","text":"\u6811\u7684\u76f4\u5f84 \u6709\u4e00\u4e2a\u91cd\u8981\u6027\u8d28:\u5230\u6811\u4e0a\u7684\u70b9\u7684\u8ddd\u79bb\u6700\u5927\u7684\u70b9\u4e00\u5b9a\u662f\u76f4\u5f84\u7684\u4e24\u4e2a\u7aef\u70b9\u4e4b\u4e00\u3002 P1099 & 2491 \u5bf9\u4e8e\u6bcf\u4e2a\u76f4\u5f84\u4e0a\u7684\u8def\u5f84\u6765\u8bf4\uff0c\u4e24\u4e2a\u7aef\u70b9\u7684\u6700\u8fdc\u8ddd\u79bb\u4e00\u5b9a\u662f\u5230 \u5bf9\u5e94\u7684 \u76f4\u5f84\u7aef\u70b9\u7684\u8ddd\u79bb(\u6ce8\u610f\u662f \u5bf9\u5e94\u7684 \u76f4\u5f84\u7aef\u70b9\uff0c\u4e0d\u80fd\u7ecf\u8fc7\u8def\u5f84)\u3002\u800c\u8fd9\u4e2a\u6700\u5927\u503c\u4e0d\u4e00\u5b9a\u5c31\u662f\u6700\u7ec8\u7b54\u6848\uff0c\u56e0\u4e3a\u8def\u5f84\u4e0a\u7684\u5176\u4ed6\u70b9\u4e5f\u6709\u8d21\u732e\u3002 \u8bbe$f[i]$\u8868\u793a \u4e0d\u7ecf\u8fc7\u76f4\u5f84 \u7684\uff0c\u5230$i$\u53f7\u70b9\u6700\u8fdc\u7684\u8ddd\u79bb\u3002 \u90a3\u4e48\u8def\u5f84\u4e0a\u7684\u70b9\u5c31\u662f\u8fd9\u4e9b\u70b9\u7684$f[i]$\u3002 \u53c8\u56e0\u4e3a\u6bcf\u6b21\u5c06\u4e00\u4e2a\u70b9\u5f52\u5e76\u4e3a\u8def\u5f84\u540e\uff0c\u5b83\u7684\u7b54\u6848\u53ea\u4f1a\u7531\u5230\u76f4\u5f84\u53d8\u4e3a$f[i]$\uff0c\u5373\u4e0d\u4f1a\u518d\u53d8\u5927\uff0c\u6240\u4ee5\u53ef\u4ee5\u8bc1\u660e\u8def\u5f84\u957f\u5ea6\u8d8a\u957f\u8d8a\u597d\uff0c\u5373\u521a\u597d\u5c0f\u4e8e\u7b49\u4e8e$s$\u3002 \u8fd9\u6837\uff0c\u5c31\u53ef\u4ee5\u7528\u5c3a\u53d6\u6cd5+\u5355\u8c03\u961f\u5217\uff0c\u6bcf\u6b21\u679a\u4e3e\u4e00\u4e2a\u5de6\u7aef\u70b9$i$\uff0c\u8ba1\u7b97\u51fa\u957f\u5ea6$\\leq s$\u7684\u53f3\u7aef\u70b9$j$\uff0c\u901a\u8fc7\u5355\u8c03\u961f\u5217\u6c42\u51fa\u533a\u95f4$f[i]$\u7684\u6700\u5927\u503c\uff0c\u4e0e\u4e24\u7aef\u70b9\u7684\u76f4\u5f84\u8ddd\u79bb\u6bd4\u8f83\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=4e5+10,INF=1e13; int n,s,u,v,w,cnt,top,maxn,S,T,D,tmp; int head[N],dis[N],d[N],stk[N],ans[N],fa[N],f[N],vis[N]; struct edge{ int v,w,nxt; }e[N<<1]; struct node{ int num,dis; node(int Num,int Dis){ num=Num,dis=Dis; } }; void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void dfs(int u,int p,int &a){ if(dis[u]>maxn)maxn=dis[u],a=u; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w;if(v==p)continue; dis[v]=dis[u]+w; dfs(v,u,a); } } void _dfs(int u,int p){ stk[++top]=u; if(u==T){ ans[0]=top; for(int i=1;i<=top;++i)ans[i]=stk[i]; return; } for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v;if(v==p)continue; fa[v]=u; _dfs(v,u); } --top; } void __dfs(int u,int p){ maxn=max(maxn,dis[u]); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w;if(v==p || vis[v])continue; dis[v]=dis[u]+w; __dfs(v,u); } } void init(){ for(int i=T;i;i=fa[i])vis[i]=1; for(int i=T;i;i=fa[i]){// get every node on diameter T~S maxn=0;dis[i]=0;__dfs(i,0);f[i]=maxn; } } inline int Abs(int x){return x>=0?x:-x;} void two_pointers(){ deque<node> q; int i=T,j=T,lst=T,ans=INF,tmp=0; for(i=T;i;i=fa[i]){ while(fa[j] && Abs(d[i]-d[fa[j]])<=s)j=fa[j]; for(int k=fa[lst];k!=fa[j];k=fa[k]){ while(!q.empty() && q.back().dis<f[k]) q.pop_back(); q.push_back(node(k,f[k])); } tmp=0; if(!q.empty())tmp=q.front().dis; tmp=max(tmp,max(Abs(d[T]-d[i]),Abs(d[j]-d[S]))); ans=min(ans,tmp); if(!q.empty() && q.front().num==i)q.pop_front();//\u6ce8\u610f\u4e00\u5b9a\u662f\u53ea\u6709num==i\u65f6\u624d\u9700\u8981\u5f39\u51fa\u5de6\u7aef\u70b9\u3002 lst=j; } printf(\"%lld\",ans); } signed main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%lld%lld\",&n,&s); for(int i=1;i<n;++i){ scanf(\"%lld%lld%lld\",&u,&v,&w); add(u,v,w),add(v,u,w); } maxn=0,S=0; dis[1]=0;dfs(1,0,S); maxn=0,T=0; dis[S]=0;dfs(S,0,T); D=maxn; top=0;_dfs(S,0); for(int i=1;i<=ans[0];++i)d[ans[i]]=dis[ans[i]]; init(); two_pointers(); return 0; } ~~STL\u5c45\u7136\u6ca1\u7206\u70b8!?\u770b\u6765\u7ebf\u6027\u590d\u6742\u5ea6\u7684\u9898\u505a\u8d77\u6765\u8fd8\u662fSTL\u6bd4\u8f83\u9999~~","title":"\u6811\u7684\u76f4\u5f84"},{"location":"my%20past/OI/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/#_1","text":"\u6709\u4e00\u4e2a\u91cd\u8981\u6027\u8d28:\u5230\u6811\u4e0a\u7684\u70b9\u7684\u8ddd\u79bb\u6700\u5927\u7684\u70b9\u4e00\u5b9a\u662f\u76f4\u5f84\u7684\u4e24\u4e2a\u7aef\u70b9\u4e4b\u4e00\u3002 P1099 & 2491 \u5bf9\u4e8e\u6bcf\u4e2a\u76f4\u5f84\u4e0a\u7684\u8def\u5f84\u6765\u8bf4\uff0c\u4e24\u4e2a\u7aef\u70b9\u7684\u6700\u8fdc\u8ddd\u79bb\u4e00\u5b9a\u662f\u5230 \u5bf9\u5e94\u7684 \u76f4\u5f84\u7aef\u70b9\u7684\u8ddd\u79bb(\u6ce8\u610f\u662f \u5bf9\u5e94\u7684 \u76f4\u5f84\u7aef\u70b9\uff0c\u4e0d\u80fd\u7ecf\u8fc7\u8def\u5f84)\u3002\u800c\u8fd9\u4e2a\u6700\u5927\u503c\u4e0d\u4e00\u5b9a\u5c31\u662f\u6700\u7ec8\u7b54\u6848\uff0c\u56e0\u4e3a\u8def\u5f84\u4e0a\u7684\u5176\u4ed6\u70b9\u4e5f\u6709\u8d21\u732e\u3002 \u8bbe$f[i]$\u8868\u793a \u4e0d\u7ecf\u8fc7\u76f4\u5f84 \u7684\uff0c\u5230$i$\u53f7\u70b9\u6700\u8fdc\u7684\u8ddd\u79bb\u3002 \u90a3\u4e48\u8def\u5f84\u4e0a\u7684\u70b9\u5c31\u662f\u8fd9\u4e9b\u70b9\u7684$f[i]$\u3002 \u53c8\u56e0\u4e3a\u6bcf\u6b21\u5c06\u4e00\u4e2a\u70b9\u5f52\u5e76\u4e3a\u8def\u5f84\u540e\uff0c\u5b83\u7684\u7b54\u6848\u53ea\u4f1a\u7531\u5230\u76f4\u5f84\u53d8\u4e3a$f[i]$\uff0c\u5373\u4e0d\u4f1a\u518d\u53d8\u5927\uff0c\u6240\u4ee5\u53ef\u4ee5\u8bc1\u660e\u8def\u5f84\u957f\u5ea6\u8d8a\u957f\u8d8a\u597d\uff0c\u5373\u521a\u597d\u5c0f\u4e8e\u7b49\u4e8e$s$\u3002 \u8fd9\u6837\uff0c\u5c31\u53ef\u4ee5\u7528\u5c3a\u53d6\u6cd5+\u5355\u8c03\u961f\u5217\uff0c\u6bcf\u6b21\u679a\u4e3e\u4e00\u4e2a\u5de6\u7aef\u70b9$i$\uff0c\u8ba1\u7b97\u51fa\u957f\u5ea6$\\leq s$\u7684\u53f3\u7aef\u70b9$j$\uff0c\u901a\u8fc7\u5355\u8c03\u961f\u5217\u6c42\u51fa\u533a\u95f4$f[i]$\u7684\u6700\u5927\u503c\uff0c\u4e0e\u4e24\u7aef\u70b9\u7684\u76f4\u5f84\u8ddd\u79bb\u6bd4\u8f83\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=4e5+10,INF=1e13; int n,s,u,v,w,cnt,top,maxn,S,T,D,tmp; int head[N],dis[N],d[N],stk[N],ans[N],fa[N],f[N],vis[N]; struct edge{ int v,w,nxt; }e[N<<1]; struct node{ int num,dis; node(int Num,int Dis){ num=Num,dis=Dis; } }; void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void dfs(int u,int p,int &a){ if(dis[u]>maxn)maxn=dis[u],a=u; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w;if(v==p)continue; dis[v]=dis[u]+w; dfs(v,u,a); } } void _dfs(int u,int p){ stk[++top]=u; if(u==T){ ans[0]=top; for(int i=1;i<=top;++i)ans[i]=stk[i]; return; } for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v;if(v==p)continue; fa[v]=u; _dfs(v,u); } --top; } void __dfs(int u,int p){ maxn=max(maxn,dis[u]); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w;if(v==p || vis[v])continue; dis[v]=dis[u]+w; __dfs(v,u); } } void init(){ for(int i=T;i;i=fa[i])vis[i]=1; for(int i=T;i;i=fa[i]){// get every node on diameter T~S maxn=0;dis[i]=0;__dfs(i,0);f[i]=maxn; } } inline int Abs(int x){return x>=0?x:-x;} void two_pointers(){ deque<node> q; int i=T,j=T,lst=T,ans=INF,tmp=0; for(i=T;i;i=fa[i]){ while(fa[j] && Abs(d[i]-d[fa[j]])<=s)j=fa[j]; for(int k=fa[lst];k!=fa[j];k=fa[k]){ while(!q.empty() && q.back().dis<f[k]) q.pop_back(); q.push_back(node(k,f[k])); } tmp=0; if(!q.empty())tmp=q.front().dis; tmp=max(tmp,max(Abs(d[T]-d[i]),Abs(d[j]-d[S]))); ans=min(ans,tmp); if(!q.empty() && q.front().num==i)q.pop_front();//\u6ce8\u610f\u4e00\u5b9a\u662f\u53ea\u6709num==i\u65f6\u624d\u9700\u8981\u5f39\u51fa\u5de6\u7aef\u70b9\u3002 lst=j; } printf(\"%lld\",ans); } signed main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%lld%lld\",&n,&s); for(int i=1;i<n;++i){ scanf(\"%lld%lld%lld\",&u,&v,&w); add(u,v,w),add(v,u,w); } maxn=0,S=0; dis[1]=0;dfs(1,0,S); maxn=0,T=0; dis[S]=0;dfs(S,0,T); D=maxn; top=0;_dfs(S,0); for(int i=1;i<=ans[0];++i)d[ans[i]]=dis[ans[i]]; init(); two_pointers(); return 0; } ~~STL\u5c45\u7136\u6ca1\u7206\u70b8!?\u770b\u6765\u7ebf\u6027\u590d\u6742\u5ea6\u7684\u9898\u505a\u8d77\u6765\u8fd8\u662fSTL\u6bd4\u8f83\u9999~~","title":"\u6811\u7684\u76f4\u5f84"},{"location":"my%20past/OI/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","text":"\u6811\u94fe\u5256\u5206 P4315 \u7ebf\u6bb5\u6811+\u6811\u94fe\u5256\u5206\u6a21\u677f\u9898\u3002 \u6ce8\u610f\u8981\u5c06\u8fb9\u8f6c\u5316\u5230\u70b9\u4e0a\u3002 \u8fd8\u6709\u8981\u6ce8\u610fdfs\u5e8f\u4e0d\u80fd\u5728dfs1\u4e2d\u6c42\uff0c\u4e0d\u7136\u7684\u8bdddfs\u9700\u7684\u987a\u5e8f\u5c31\u4e0d\u662f\u5148\u91cd\u513f\u5b50\u518d\u8f7b\u513f\u5b50\u4e86\u3002 void dfs1(int u,int f){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==f)continue; dep[v]=dep[u]+1; fa[v]=u; p[v]=w; dfs1(v,u); sz[u]+=sz[v]; if(sz[son[u]]<sz[v])son[u]=v; } return; } void dfs2(int u,int t){ id[u]=++tot; top[u]=t; a[tot]=p[u]; if(son[u])dfs2(son[u],t); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==fa[u] || v==son[u])continue; dfs2(v,v); } return; } \u7ed3\u8bba: $\u6811\u94fe\u5256\u5206\u65f6dfs\u5e8f\u4e00\u5b9a\u8981\u5728dfs2\u4e2d\u6c42\uff1b$ $\u5f53\u7ebf\u6bb5\u6811\u540c\u65f6\u6d89\u53caop1:\"\u5c06[l,r]\u52a0k\"\u548cop2:\"\u5c06[l,r]\u6539\u4e3ak\"\u65f6\uff0c\u8981\u6ce8\u610f\u7ef4\u62a4\u7684\u987a\u5e8f\uff0c\u5148op2\u518dop1,\u5e76\u4e14lazytag\u8981\u5206\u522b\u7ef4\u62a4\u3002$","title":"\u6811\u94fe\u5256\u5206"},{"location":"my%20past/OI/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/#_1","text":"P4315 \u7ebf\u6bb5\u6811+\u6811\u94fe\u5256\u5206\u6a21\u677f\u9898\u3002 \u6ce8\u610f\u8981\u5c06\u8fb9\u8f6c\u5316\u5230\u70b9\u4e0a\u3002 \u8fd8\u6709\u8981\u6ce8\u610fdfs\u5e8f\u4e0d\u80fd\u5728dfs1\u4e2d\u6c42\uff0c\u4e0d\u7136\u7684\u8bdddfs\u9700\u7684\u987a\u5e8f\u5c31\u4e0d\u662f\u5148\u91cd\u513f\u5b50\u518d\u8f7b\u513f\u5b50\u4e86\u3002 void dfs1(int u,int f){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==f)continue; dep[v]=dep[u]+1; fa[v]=u; p[v]=w; dfs1(v,u); sz[u]+=sz[v]; if(sz[son[u]]<sz[v])son[u]=v; } return; } void dfs2(int u,int t){ id[u]=++tot; top[u]=t; a[tot]=p[u]; if(son[u])dfs2(son[u],t); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==fa[u] || v==son[u])continue; dfs2(v,v); } return; } \u7ed3\u8bba: $\u6811\u94fe\u5256\u5206\u65f6dfs\u5e8f\u4e00\u5b9a\u8981\u5728dfs2\u4e2d\u6c42\uff1b$ $\u5f53\u7ebf\u6bb5\u6811\u540c\u65f6\u6d89\u53caop1:\"\u5c06[l,r]\u52a0k\"\u548cop2:\"\u5c06[l,r]\u6539\u4e3ak\"\u65f6\uff0c\u8981\u6ce8\u610f\u7ef4\u62a4\u7684\u987a\u5e8f\uff0c\u5148op2\u518dop1,\u5e76\u4e14lazytag\u8981\u5206\u522b\u7ef4\u62a4\u3002$","title":"\u6811\u94fe\u5256\u5206"},{"location":"my%20past/OI/%E6%A8%A1%E6%8B%9F/","text":"\u6a21\u62df P5682 \u5148\u5c06$a$\u6570\u7ec4\u6392\u4e2a\u5e8f\u5e76\u53bb\u91cd\u3002 \u5bf9\u4e8e\u6700\u5927\u503c\uff0c\u53ea\u80fd\u662f$a_{n-1} mod a_n$ \u800c\u6b21\u5927\u503c\u53ef\u4ee5\u662f $a_{n-2}moda_n$\u6216$a_nmoda_{n-1}$,\u6240\u4ee5\u53ea\u9700\u8981\u5224\u65ad\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u503c\u5373\u53ef\u3002 P3951 \u5047\u8bbe\u6709k\u4e2ab\uff0c\u90a3\u4e48kb mod a\u90fd\u4f1a\u8986\u76d6\u6570\u8f740\\~a-1\u4e2d\u4e00\u4e2a\u70b9\uff0c\u800c\u6700\u540e\u4e00\u4e2a\u70b9\u88ab\u8986\u76d6\u65f6\uff0c\u8fd9\u4e2a\u6570\u5c31\u662f(a-1)b\uff0c\u5373k=a-1. \u6240\u4ee5\uff0c\u5728\u8fd9\u4e2a\u6570\u8f74\u4e0a\u8986\u76d6\u7684\u70b9\u7684\u4e0a\u4e00\u4e2a\u672a\u8986\u76d6\u7684\u70b9\u5c31\u662f(a-1)* b-a. P2822 \u56e0\u4e3a\u6bcf\u4e2a\u7ec4\u5408\u6570\u90fd\u662f\u6768\u8f89\u4e09\u89d2\u91cc\u7684\u4e00\u4e2a\u6570\uff0c\u6240\u4ee5\u76f4\u63a5\u6253\u51fa\u6768\u8f89\u4e09\u89d2\u518d\u8ba1\u7b97\u7b54\u6848\u5373\u53ef\u3002 P1627 \u5c06\u6bcf\u4e2a\u5927\u4e8eb\u7684\u6570\u770b\u62101\uff0c\u5c0f\u4e8eb\u7684\u6570\u770b\u6210-1\uff0c\u90a3\u4e48\u53ea\u8981\u6c42\u51fa\u6240\u6709\u5305\u542bb\u5e76\u4e14\u548c\u4e3a0\u7684\u533a\u95f4\u4e2a\u6570\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #define int long long using namespace std; const int N=2e5+10; int t[N],s[N],a[N],b[N]; int n,m,pos; signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i){ scanf(\"%lld\",&t[i]); if(t[i]>m) s[i]=1; else if(t[i]<m) s[i]=-1; else s[i]=0,pos=i; } int tmp=0; for(int i=pos-1;i>=1;--i){ tmp+=s[i]; if(tmp>=0)a[tmp]++; else a[tmp+n+n]++; } tmp=0; for(int i=pos+1;i<=n;++i){ tmp+=s[i]; if(tmp>=0)b[tmp]++; else b[tmp+n+n]++; } int ans=1+a[0]+b[0]+a[0]*b[0]; for(int i=1;i<=n;++i){ if(a[n+n-i]>0)ans+=a[n+n-i]*b[i]; } for(int i=1;i<=n;++i){ if(a[i]>0)ans+=a[i]*b[n+n-i]; } printf(\"%lld\",ans); return 0; } /* 7 4 5 7 2 4 3 1 6 7 3 6 4 2 3 1 5 7 7 2 6 4 2 3 1 5 7 */ ~~\u6240\u4ee5\u8fd9\u4e48\u6c34\u7684\u9898\u8fd8\u6709\u5199\u5b83\u7684\u5fc5\u8981\u5417~~","title":"\u6a21\u62df"},{"location":"my%20past/OI/%E6%A8%A1%E6%8B%9F/#_1","text":"P5682 \u5148\u5c06$a$\u6570\u7ec4\u6392\u4e2a\u5e8f\u5e76\u53bb\u91cd\u3002 \u5bf9\u4e8e\u6700\u5927\u503c\uff0c\u53ea\u80fd\u662f$a_{n-1} mod a_n$ \u800c\u6b21\u5927\u503c\u53ef\u4ee5\u662f $a_{n-2}moda_n$\u6216$a_nmoda_{n-1}$,\u6240\u4ee5\u53ea\u9700\u8981\u5224\u65ad\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u503c\u5373\u53ef\u3002 P3951 \u5047\u8bbe\u6709k\u4e2ab\uff0c\u90a3\u4e48kb mod a\u90fd\u4f1a\u8986\u76d6\u6570\u8f740\\~a-1\u4e2d\u4e00\u4e2a\u70b9\uff0c\u800c\u6700\u540e\u4e00\u4e2a\u70b9\u88ab\u8986\u76d6\u65f6\uff0c\u8fd9\u4e2a\u6570\u5c31\u662f(a-1)b\uff0c\u5373k=a-1. \u6240\u4ee5\uff0c\u5728\u8fd9\u4e2a\u6570\u8f74\u4e0a\u8986\u76d6\u7684\u70b9\u7684\u4e0a\u4e00\u4e2a\u672a\u8986\u76d6\u7684\u70b9\u5c31\u662f(a-1)* b-a. P2822 \u56e0\u4e3a\u6bcf\u4e2a\u7ec4\u5408\u6570\u90fd\u662f\u6768\u8f89\u4e09\u89d2\u91cc\u7684\u4e00\u4e2a\u6570\uff0c\u6240\u4ee5\u76f4\u63a5\u6253\u51fa\u6768\u8f89\u4e09\u89d2\u518d\u8ba1\u7b97\u7b54\u6848\u5373\u53ef\u3002 P1627 \u5c06\u6bcf\u4e2a\u5927\u4e8eb\u7684\u6570\u770b\u62101\uff0c\u5c0f\u4e8eb\u7684\u6570\u770b\u6210-1\uff0c\u90a3\u4e48\u53ea\u8981\u6c42\u51fa\u6240\u6709\u5305\u542bb\u5e76\u4e14\u548c\u4e3a0\u7684\u533a\u95f4\u4e2a\u6570\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #define int long long using namespace std; const int N=2e5+10; int t[N],s[N],a[N],b[N]; int n,m,pos; signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i){ scanf(\"%lld\",&t[i]); if(t[i]>m) s[i]=1; else if(t[i]<m) s[i]=-1; else s[i]=0,pos=i; } int tmp=0; for(int i=pos-1;i>=1;--i){ tmp+=s[i]; if(tmp>=0)a[tmp]++; else a[tmp+n+n]++; } tmp=0; for(int i=pos+1;i<=n;++i){ tmp+=s[i]; if(tmp>=0)b[tmp]++; else b[tmp+n+n]++; } int ans=1+a[0]+b[0]+a[0]*b[0]; for(int i=1;i<=n;++i){ if(a[n+n-i]>0)ans+=a[n+n-i]*b[i]; } for(int i=1;i<=n;++i){ if(a[i]>0)ans+=a[i]*b[n+n-i]; } printf(\"%lld\",ans); return 0; } /* 7 4 5 7 2 4 3 1 6 7 3 6 4 2 3 1 5 7 7 2 6 4 2 3 1 5 7 */ ~~\u6240\u4ee5\u8fd9\u4e48\u6c34\u7684\u9898\u8fd8\u6709\u5199\u5b83\u7684\u5fc5\u8981\u5417~~","title":"\u6a21\u62df"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","text":"\u6b27\u62c9\u51fd\u6570 \u6b27\u62c9\u51fd\u6570\u7684\u5b9a\u4e49 \u5c31\u662f\u5bf9\u4e8e\u4e00\u4e2a\u6b63\u6574\u6570$n$\uff0c\u5c0f\u4e8e$n$\u4e14\u548c$n$\u4e92\u8d28\u7684\u6b63\u6574\u6570\uff08\u5305\u62ec$1$\uff09\u7684\u4e2a\u6570\uff0c\u8bb0\u4f5c$\\phi(n)$ \u3002 $$\\phi(x)=x\\prod_{i=1}^n(1-\\frac{1}{p_i})$$ \u7ebf\u6027\u7b5b\u6c42\u6b27\u62c9\u51fd\u6570 1.\u6027\u8d28\u6cd5(\u6b27\u62c9\u7b5b) O(n) 1) $\\phi(i j)_ {j|i}=\\phi(i) j $ 2) $\\phi(i j)_ {j\u22a5i}=\\phi(i) \\phi(j)$ euler[1]=0; for(int i=1;i<=n;++i)v[i]=1; for(int i=2;i<=n;++i){ if(v[i]==1){ p[++m]=i; euler[i]=i-1; } for(int j=1;j<=m;++j){ if(p[j]*i>n)break; v[p[j]*i]=0; if(i%p[j]==0){ euler[i*p[j]]=euler[i]*p[j];break; }else{ euler[i*p[j]]=euler[i]*euler[p[j]]; } } } 2.\u5b9a\u4e49\u6cd5 O(nlogn) phi[i]=1; for(int i=2;i<=n;++i){ if(!phi[i]){//i\u662f\u4e2a\u8d28\u6570\uff0c\u5219\u8981\u679a\u4e3e\u5b83\u7684\u500d\u6570\uff0c\u66f4\u65b0\u8fd9\u4e9b\u500d\u6570j for(int j=i;j<=n;j+=i){ if(!phi[j])phi[j]=j;//\u521d\u59cb\u5316\u4e3aj phi[j]=phi[j]/i*(i-1);//i\u662fj\u7684\u4e00\u4e2a\u8d28\u56e0\u5b50 } } } \u6b27\u62c9\u51fd\u6570\u7684\u6027\u8d28\uff1a 1) \u82e5$p$\u4e3a\u8d28\u6570\uff0c\u5219$\\phi(p)=p-1$ 2) \u82e5$n=p^k$\u4e14$p$\u4e3a\u8d28\u6570\uff0c\u5219$\\phi(n)=p^k-p^{k-1}$ 3) \u82e5$m\u22a5n$\uff0c\u6709$\\phi(m n)= \\phi(m) \\phi(n)$; \u82e5$m|n$\uff0c\u6709$\\phi(m* n) = m * \\phi(n)$ 4) \u6b27\u62c9\u5b9a\u7406\uff0c\u82e5$m\u22a5a$,\u5219$a^{\\phi(m)}\\equiv 1\\pmod m$ 5) \u5f53$n$\u4e3a\u5947\u6570\u65f6\uff0c$\\phi(2n)=\\phi(n)$ 6) $n=\\sum_{d|n}\\phi(d)$ \u7ed9\u51fa\u5176\u4e2d\u4e00\u4e9b\u5b9a\u7406\u7684\u8bc1\u660e\uff1a \u6027\u8d281 \u56e0\u4e3a$p$\u4e3a\u8d28\u6570\uff0c\u6240\u4ee5\u6240\u6709\u5c0f\u4e8e\u4ed6\u7684$p-1$\u4e2a\u6570\u90fd\u4e0e\u5b83\u4e92\u7d20\u3002 \u6027\u8d282 $n$\u53ea\u6709\u4e00\u4e2a\u8d28\u56e0\u6570$p$,\u6240\u4ee5\u6839\u636e\u5b9a\u4e49$\\phi(n)=n(1-\\frac1p)=p^k-p^{k-1}$ \u6027\u8d283 1. \u56e0\u4e3a$m\u22a5n$,\u6240\u4ee5$m$\u4e0e$n$\u65e0\u516c\u5171\u8d28\u56e0\u6570 \u6240\u4ee5\u8bbe$m$\u7531$a_m$\u4e2a\u8d28\u56e0\u6570\uff0c$n$\u7531$a_n$\u4e2a\u8d28\u56e0\u6570\u3002 $$\\therefore \\phi(m) \\phi(n)=m * n * \\prod_{i=1}^{a_m}(1-\\frac{1}{p_i}) * \\prod_{i=1}^{a_n}(1-\\frac{1}{p_i})\\ =(m n) * \\prod_{i=1}^{a_m+a_n}(1-\\frac{1}{p_i}) =\\phi(m* n) $$ 2. \u56e0\u4e3a$m|n$,\u6240\u4ee5$n$\u5305\u542b\u4e86$m$\u7684\u6240\u6709\u8d28\u56e0\u6570\u3002 \u6240\u4ee5\u8bbe$n$\u542b\u6709\u7684\u76f8\u540c\u7684\u8d28\u56e0\u6570\u4e3a$a_n$,\u5219$m * n$\u6240\u542b\u8d28\u56e0\u6570\u4e0e$n$\u5b8c\u5168\u76f8\u540c.(\u4e0d\u8ba1\u8d28\u56e0\u5b50\u4e2a\u6570) $$\\therefore \\phi(m * n)=m * n * \\prod_{i=1}^{a_n}(1-\\frac{1}{p_i}) \\ =m*\\phi(n) $$ \u6027\u8d286 \u8bc1$F(n)=\\sum_{d|n}\\phi(d)$\u4e3a\u79ef\u6027\u51fd\u6570 \u8bbe $ F(m) F(n)=\\sum_{i|m}\\phi(i) * \\sum_{j|n}\\phi(j)= \\phi(i_1) \\phi(j_1)+\\phi(i_1) \\phi(j_2)+...+\\phi(i_{k_m}) \\phi(j_{k_n}) $ \u56e0\u4e3a$m\u22a5n$\uff0c\u6240\u4ee5\u6240\u6709\u7684$i$\u4e0e$j$\u4e92\u8d28\uff0c\u6240\u4ee5\u539f\u5f0f$=\\phi(i_1 j_1)+...+\\phi(i_{k_m} \\phi(j_{k_n}))$ \u53c8\u56e0\u4e3a$i_1 j_1,...,i_{k_m} j_{k_n}$\u6784\u6210\u4e86$m n$\u6240\u6709\u56e0\u6570\uff0c\u6240\u4ee5$F(m) * F(n)=F(m n)$. 2.\u8bc1\u660e$F(p^k)=\\sum_{d|p^k}\\phi(d)$ \u56e0\u4e3a$p^k$\u7684\u56e0\u6570\u53ea\u6709$1,p,p^2,...,p^k$. \u6240\u4ee5$F(p^k)=\\phi(1)+\\phi(p)+...+\\phi(p^k)=1+p-1+p^2-p+...+p^k-p^{k-1}=p^k$ \u63a8\u5e7f \u56e0\u4e3a\u5bf9\u4e8e\u4efb\u610f$p$\u4e3a\u8d28\u6570\uff0c$F(p^k)$\u7b26\u5408\u6761\u4ef6\uff0c\u800c$F$\u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u6240\u4ee5\u53ef\u4ee5\u63a8\u5e7f\u5230\u4efb\u610f\u6b63\u6574\u6570\u3002","title":"\u6b27\u62c9\u51fd\u6570"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_1","text":"","title":"\u6b27\u62c9\u51fd\u6570"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_2","text":"\u5c31\u662f\u5bf9\u4e8e\u4e00\u4e2a\u6b63\u6574\u6570$n$\uff0c\u5c0f\u4e8e$n$\u4e14\u548c$n$\u4e92\u8d28\u7684\u6b63\u6574\u6570\uff08\u5305\u62ec$1$\uff09\u7684\u4e2a\u6570\uff0c\u8bb0\u4f5c$\\phi(n)$ \u3002 $$\\phi(x)=x\\prod_{i=1}^n(1-\\frac{1}{p_i})$$","title":"\u6b27\u62c9\u51fd\u6570\u7684\u5b9a\u4e49"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_3","text":"","title":"\u7ebf\u6027\u7b5b\u6c42\u6b27\u62c9\u51fd\u6570"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#1-on","text":"1) $\\phi(i j)_ {j|i}=\\phi(i) j $ 2) $\\phi(i j)_ {j\u22a5i}=\\phi(i) \\phi(j)$ euler[1]=0; for(int i=1;i<=n;++i)v[i]=1; for(int i=2;i<=n;++i){ if(v[i]==1){ p[++m]=i; euler[i]=i-1; } for(int j=1;j<=m;++j){ if(p[j]*i>n)break; v[p[j]*i]=0; if(i%p[j]==0){ euler[i*p[j]]=euler[i]*p[j];break; }else{ euler[i*p[j]]=euler[i]*euler[p[j]]; } } }","title":"1.\u6027\u8d28\u6cd5(\u6b27\u62c9\u7b5b) O(n)"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#2-onlogn","text":"phi[i]=1; for(int i=2;i<=n;++i){ if(!phi[i]){//i\u662f\u4e2a\u8d28\u6570\uff0c\u5219\u8981\u679a\u4e3e\u5b83\u7684\u500d\u6570\uff0c\u66f4\u65b0\u8fd9\u4e9b\u500d\u6570j for(int j=i;j<=n;j+=i){ if(!phi[j])phi[j]=j;//\u521d\u59cb\u5316\u4e3aj phi[j]=phi[j]/i*(i-1);//i\u662fj\u7684\u4e00\u4e2a\u8d28\u56e0\u5b50 } } }","title":"2.\u5b9a\u4e49\u6cd5 O(nlogn)"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_4","text":"1) \u82e5$p$\u4e3a\u8d28\u6570\uff0c\u5219$\\phi(p)=p-1$ 2) \u82e5$n=p^k$\u4e14$p$\u4e3a\u8d28\u6570\uff0c\u5219$\\phi(n)=p^k-p^{k-1}$ 3) \u82e5$m\u22a5n$\uff0c\u6709$\\phi(m n)= \\phi(m) \\phi(n)$; \u82e5$m|n$\uff0c\u6709$\\phi(m* n) = m * \\phi(n)$ 4) \u6b27\u62c9\u5b9a\u7406\uff0c\u82e5$m\u22a5a$,\u5219$a^{\\phi(m)}\\equiv 1\\pmod m$ 5) \u5f53$n$\u4e3a\u5947\u6570\u65f6\uff0c$\\phi(2n)=\\phi(n)$ 6) $n=\\sum_{d|n}\\phi(d)$","title":"\u6b27\u62c9\u51fd\u6570\u7684\u6027\u8d28\uff1a"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#_5","text":"","title":"\u7ed9\u51fa\u5176\u4e2d\u4e00\u4e9b\u5b9a\u7406\u7684\u8bc1\u660e\uff1a"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#1","text":"\u56e0\u4e3a$p$\u4e3a\u8d28\u6570\uff0c\u6240\u4ee5\u6240\u6709\u5c0f\u4e8e\u4ed6\u7684$p-1$\u4e2a\u6570\u90fd\u4e0e\u5b83\u4e92\u7d20\u3002","title":"\u6027\u8d281"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#2","text":"$n$\u53ea\u6709\u4e00\u4e2a\u8d28\u56e0\u6570$p$,\u6240\u4ee5\u6839\u636e\u5b9a\u4e49$\\phi(n)=n(1-\\frac1p)=p^k-p^{k-1}$","title":"\u6027\u8d282"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#3","text":"1. \u56e0\u4e3a$m\u22a5n$,\u6240\u4ee5$m$\u4e0e$n$\u65e0\u516c\u5171\u8d28\u56e0\u6570 \u6240\u4ee5\u8bbe$m$\u7531$a_m$\u4e2a\u8d28\u56e0\u6570\uff0c$n$\u7531$a_n$\u4e2a\u8d28\u56e0\u6570\u3002 $$\\therefore \\phi(m) \\phi(n)=m * n * \\prod_{i=1}^{a_m}(1-\\frac{1}{p_i}) * \\prod_{i=1}^{a_n}(1-\\frac{1}{p_i})\\ =(m n) * \\prod_{i=1}^{a_m+a_n}(1-\\frac{1}{p_i}) =\\phi(m* n) $$ 2. \u56e0\u4e3a$m|n$,\u6240\u4ee5$n$\u5305\u542b\u4e86$m$\u7684\u6240\u6709\u8d28\u56e0\u6570\u3002 \u6240\u4ee5\u8bbe$n$\u542b\u6709\u7684\u76f8\u540c\u7684\u8d28\u56e0\u6570\u4e3a$a_n$,\u5219$m * n$\u6240\u542b\u8d28\u56e0\u6570\u4e0e$n$\u5b8c\u5168\u76f8\u540c.(\u4e0d\u8ba1\u8d28\u56e0\u5b50\u4e2a\u6570) $$\\therefore \\phi(m * n)=m * n * \\prod_{i=1}^{a_n}(1-\\frac{1}{p_i}) \\ =m*\\phi(n) $$","title":"\u6027\u8d283"},{"location":"my%20past/OI/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/#6","text":"\u8bc1$F(n)=\\sum_{d|n}\\phi(d)$\u4e3a\u79ef\u6027\u51fd\u6570 \u8bbe $ F(m) F(n)=\\sum_{i|m}\\phi(i) * \\sum_{j|n}\\phi(j)= \\phi(i_1) \\phi(j_1)+\\phi(i_1) \\phi(j_2)+...+\\phi(i_{k_m}) \\phi(j_{k_n}) $ \u56e0\u4e3a$m\u22a5n$\uff0c\u6240\u4ee5\u6240\u6709\u7684$i$\u4e0e$j$\u4e92\u8d28\uff0c\u6240\u4ee5\u539f\u5f0f$=\\phi(i_1 j_1)+...+\\phi(i_{k_m} \\phi(j_{k_n}))$ \u53c8\u56e0\u4e3a$i_1 j_1,...,i_{k_m} j_{k_n}$\u6784\u6210\u4e86$m n$\u6240\u6709\u56e0\u6570\uff0c\u6240\u4ee5$F(m) * F(n)=F(m n)$. 2.\u8bc1\u660e$F(p^k)=\\sum_{d|p^k}\\phi(d)$ \u56e0\u4e3a$p^k$\u7684\u56e0\u6570\u53ea\u6709$1,p,p^2,...,p^k$. \u6240\u4ee5$F(p^k)=\\phi(1)+\\phi(p)+...+\\phi(p^k)=1+p-1+p^2-p+...+p^k-p^{k-1}=p^k$ \u63a8\u5e7f \u56e0\u4e3a\u5bf9\u4e8e\u4efb\u610f$p$\u4e3a\u8d28\u6570\uff0c$F(p^k)$\u7b26\u5408\u6761\u4ef6\uff0c\u800c$F$\u4e3a\u79ef\u6027\u51fd\u6570\uff0c\u6240\u4ee5\u53ef\u4ee5\u63a8\u5e7f\u5230\u4efb\u610f\u6b63\u6574\u6570\u3002","title":"\u6027\u8d286"},{"location":"my%20past/OI/%E7%82%B9%E5%88%86%E6%B2%BB/","text":"\u70b9\u5206\u6cbb \u4e3b\u8981\u601d\u60f3 \u56e0\u4e3a\u5206\u6cbb\u540e\uff0c\u6211\u4eec\u5e0c\u671b\u5c42\u6570\u5c3d\u91cf\u5c0f\uff0c\u4e5f\u5c31\u662f\u9009\u62e9\u6240\u6709\u5b50\u6811\u5c3d\u91cf\u5e73\u8861\u7684\u70b9\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u8d2a\u5fc3\u7684\u53d6\u91cd\u5fc3\u3002\u53ef\u4ee5\u8bc1\u660e\uff0c\u56e0\u4e3a\u91cd\u5fc3\u7684\u5b50\u6811\u4e0d\u8d85\u8fc7$\\frac n2$,\u6240\u4ee5\u5c42\u6570\u4e0d\u8d85\u8fc7$O(\\log_2n)$ \u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e00\u5c42\u7684\u6bcf\u4e2a\u91cd\u5fc3\uff0c\u6211\u4eec\u9700\u8981\u6c42\u51fa\u5f53\u524d\u91cd\u5fc3\u6240\u5728\u5b50\u6811\u7684\u6240\u6709\u8ddd\u79bb\uff0c\u53ef\u4ee5\u7528\u6876\u8bb0\u5f55\uff1b\u800c\u7edf\u8ba1\u70b9\u5bf9\u65f6\uff0c\u8fd9\u91cc\u9762\u5305\u62ec\u4e86\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u9897\u5b50\u6811\u7684\u60c5\u51b5(\u4e0d\u662f\u4e00\u6761\u7b80\u5355\u8def\u5f84)\uff0c\u90a3\u4e48\u6211\u4eec\u8fd0\u7528\u5bb9\u65a5\u539f\u7406\uff0c\u51cf\u53bb\u5206\u88c2\u51fa\u7684\u5b50\u6811\u4e2d\u7684\u8d21\u732e\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=2e4+10,K=2e6+10; int ans[K],dis[N],head[N],sz[N],vis[N],maxp[N],d[N]; int n,m,cnt,u,v,w,k,tot; struct node{ int v,w,nxt; }e[N<<1]; void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void __dfs(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; __dfs(v,u); sz[u]+=sz[v]; } } void dfs(int u,int p,int S,int &rt,int &tmp){ maxp[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; dfs(v,u,S,rt,tmp); maxp[u]=max(maxp[u],sz[v]); } maxp[u]=max(maxp[u],S-sz[u]); if(maxp[u]<tmp) tmp=maxp[u],rt=u; } void _dfs(int u,int p){ d[++tot]=dis[u]; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; dis[v]=dis[u]+w; _dfs(v,u); } } void solve(int u,int len,int t){ dis[u]=len;tot=0; _dfs(u,0); for(int i=1;i<=tot;++i) for(int j=1;j<=tot;++j) if(i!=j && d[i]+d[j]<K) ans[d[i]+d[j]]+=t; } void div(int u){ solve(u,0,1);vis[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v])continue; solve(v,w,-1); int rt=0,tmp=K; __dfs(v,u); dfs(v,u,sz[u],rt,tmp); div(rt); } } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<n;++i) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w); int rt=0,tmp=K; __dfs(1,0); dfs(1,0,n,rt,tmp); div(rt); for(int i=1;i<=m;++i){ scanf(\"%d\",&k); if(ans[k]>0 || k==0) printf(\"Yes\\n\"); else printf(\"No\\n\"); } //for(int i=0;i<=10;++i) cout<<ans[i]<<\" \"; return 0; } ~~\u7136\u540e\u4f60\u4f1a\u53d1\u73b0\uff0cbzoj1316:Accepted,luoguP3806:Time Limit Exceeded~~ \u4e0b\u9762\u662f\u5e38\u89c1\u7684\u95ee\u9898. 1) \u6709\u5173\u9519\u8bef\u7684\u6c42\u91cd\u5fc3\u5bf9\u590d\u6742\u5ea6\u7684\u5f71\u54cd \u6bcf\u6b21\u6c42\u4e2d\u5fc3\u4e4b\u524d\u4e00\u5b9a\u8981\u5148$dfs$\u4e00\u904d\u6574\u9897\u5b50\u6811\uff0c\u6c42\u51fa\u5927\u5c0f\u540e\u518d\u7528\u8fd9\u4e2a\u8282\u70b9\u6570\u53d6\u66f4\u65b0\u91cd\u5fc3\u3002\u4e0d\u7136\u53ef\u80fd\u4f1a\u51fa\u73b0\u8fd9\u6837\u7684\u60c5\u51b5\uff1a //\u5bf9\u4e8e\u8fd9\u6837\u4e00\u9897\u6811 11//n 6 7 1//u v w 6 8 1 7 9 1 7 10 1 8 11 1 1 2 1 1 3 1 2 4 1 2 5 1 3 6 1 \u5728\u5206\u6cbb\u5230$6$\u53f7\u70b9\u65f6\uff0c\u56e0\u4e3a\u6b64\u65f6$sz[3]=7$,\u6240\u4ee5\u6c42\u51fa\u7684\u91cd\u5fc3\u4e3a$1$\uff1b\u800c\u4e8b\u5b9e\u4e0a$sz[3]=5$\uff0c\u6c42\u51fa\u91cd\u5fc3\u4e3a$2$. 2) \u6709\u5173\u5e38\u89c4\u505a\u6cd5\u9519\u8bef\u7684\u590d\u6742\u5ea6 \u672c\u6765\u5206\u6cbb\u7684\u5c42\u6570\u662f\u4e25\u683c\u5c0f\u4e8e$O(\\log n)$\u8fd9\u4e2a\u4e0a\u754c\u7684\uff0c\u6bcf\u4e00\u5c42\u6700\u591a\u904d\u5386\u4e00\u904d\u6240\u6709\u8282\u70b9\uff0c\u6240\u4ee5\u590d\u6742\u5ea6$O(n\\log n)$. \u4f46\u662f ,\u6734\u7d20\u7684\u7edf\u8ba1\u6709\u4e2a$O(n^2)$\u7684\u7edf\u8ba1\uff0c\u5bf9\u4e8e\u83ca\u82b1\u56fe\u8fd9\u6837\u5b50\u8282\u70b9\u5de8\u591a\u7684\u6570\u636e \u4e00\u5b9a\u4f1aT .\u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u53cc\u6307\u9488\u7684\u65b9\u5f0f\u7edf\u8ba1\u3002 \u5148$dfs$\u4e00\u8fb9\u6c42\u51fa\u5f53\u524d\u5b50\u6811\u4e2d\u8282\u70b9\u6df1\u5ea6$d[i]$,\u6240\u6709\u8282\u70b9\u6807\u53f7$a[i]$,\u4ee5\u53ca\u8282\u70b9\u5904\u5728\u54ea\u4e2a\u5b50\u6811\u4e2d$b[i]$\u3002 \u5bf9\u4e8e\u6df1\u5ea6\u4ece\u5c0f\u5230\u5927\u6392\u5e8f(\u4e0d\u8981\u5fd8\u8bb0\u52a0\u5165\u91cd\u5fc3$u$),\u7136\u540e\u5bf9\u4e8e\u4e0d\u540c\u7684\u8be2\u95ee\uff0c$l=1,r=tot$\u5730\u626b\u4e00\u904d\uff0c\u6ce8\u610f\u8981\u6ee1\u8db3$b[a[l]]\\not=b[a[r]]$,\u53bb\u6389\u4e86\u5bb9\u65a5\u3002\u5206\u6cbb+\u6392\u5e8f\u590d\u6742\u5ea6$O(n\\log^2n)$\uff0c\u5206\u6cbb+\u53cc\u6307\u9488\u590d\u6742\u5ea6$O(nm\\log n)$,\u603b$O(n\\log^2n + nm\\log n)$ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e4+10,K=1e7+10; int query[N],head[N],sz[N],vis[N],maxp[N],d[N],a[N],b[N]; int n,m,cnt,u,v,w,k,tot; bool ans[K]; bool cmp(int x,int y){ return d[x]<d[y]; } struct node{ int v,w,nxt; }e[N<<1]; void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void __dfs(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; __dfs(v,u); sz[u]+=sz[v]; } } void dfs(int u,int p,int S,int &rt,int &tmp){ maxp[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; dfs(v,u,S,rt,tmp); maxp[u]=max(maxp[u],sz[v]); } maxp[u]=max(maxp[u],S-sz[u]); if(maxp[u]<tmp) tmp=maxp[u],rt=u; } void _dfs(int u,int p,int dis,int P){ a[++tot]=u;d[u]=dis;b[u]=P; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; _dfs(v,u,dis+w,P); } } void solve(int u){ tot=0; a[++tot]=u; b[u]=u;d[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v])continue; _dfs(v,u,w,v); } sort(a+1,a+tot+1,cmp); for(int i=1;i<=m;++i){ int l=1,r=tot; if(ans[i]) continue; while(l<r){ //cout<<u<<\" \"<<i<<\": \"<<a[l]<<\" \"<<a[r]<<\" \"<<d[a[l]]<<\" \"<<d[a[r]]<<endl; if(d[a[l]]+d[a[r]]>query[i]) --r; else if(d[a[l]]+d[a[r]]<query[i]) ++l; else if(b[a[l]]==b[a[r]]){ if(d[a[r]]==d[a[r-1]]) --r; else ++l; } else { ans[i]=1;break; } } } } void div(int u){ vis[u]=1;solve(u); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v])continue; int rt=0,tmp=K; __dfs(v,u); dfs(v,u,sz[v],rt,tmp); div(rt); } } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<n;++i) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w); for(int i=1;i<=m;++i){ scanf(\"%d\",&query[i]); if(!query[i]) ans[i]=1; } int rt=0,tmp=K; __dfs(1,0); dfs(1,0,sz[1],rt,tmp); div(rt); for(int i=1;i<=m;++i){ if(ans[i]) printf(\"AYE\\n\"); else printf(\"NAY\\n\"); } return 0; } /* 7 1 1 6 13 6 3 9 3 5 7 4 1 3 2 4 20 4 7 2 10 6 4 1 2 5 1 3 7 1 4 1 3 5 2 3 6 3 0 8 13 14 11 1 6 7 1 6 8 1 7 9 1 7 10 1 8 11 1 1 2 1 1 3 1 2 4 1 2 5 1 3 6 1 2 */ ...\u7136\u800c\uff0c\u5bb9\u65a5\u771f\u7684\u6beb\u65e0\u7528\u6b66\u4e4b\u5730\u5417\uff1f P4178 \u8fd9\u9053\u9898\u53ea\u6709\u4e00\u4e2a\u8be2\u95ee\uff0c\u7136\u800c\u5374\u53d8\u6210$\\leq k$\u5730\u70b9\u5bf9\u6570\u91cf\u3002\u8fd9\u65f6\u6211\u4eec\u5c31\u53ef\u4ee5\u7528\u5bb9\u65a5\u3002\u5f53\u7136\uff0c\u53cc\u6307\u9488\u662f\u5fc5\u9700\u7684\u3002 \u5bf9\u4e8e\u6bcf\u6b21\u5206\u6cbb\u8ba1\u7b97\u65f6\uff0c\u8fd8\u662f\u5c06$a[i]$\u6309\u7167$d[a[i]]$\u6392\u5e8f.\u7136\u540e\uff0c\u53cc\u6307\u9488$l=1,r=tot$\u4ece\u4e24\u5934\u5411\u4e2d\u95f4\u626b\u3002\u6bcf\u6b21\u6ee1\u8db3$d[a[l]]+d[a[r]]<=k$\u65f6\u5c31$ans+=r-l$.\u800c\u8fd9\u4e9b\u91cd\u590d\u7684\u70b9\u5bf9\u7528\u5bb9\u65a5\u5373\u53ef\u89e3\u51b3\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=4e4+10,K=2e4+10,INF=1e8+10; struct edge{ int v,w,nxt; }e[N<<1]; int head[N],sz[N],vis[N],maxp[N],a[N],b[N],d[N]; int cnt,n,u,v,w,tot,ans,k; bool cmp(int x,int y){ return d[x]<d[y]; } void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void get_size(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_size(v,u); sz[u]+=sz[v]; } } void get_root(int u,int p,int S,int &rt,int &tmp){ maxp[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_root(v,u,S,rt,tmp); maxp[u]=max(maxp[u],sz[v]); } maxp[u]=max(maxp[u],S-sz[u]); if(maxp[u]<tmp) tmp=maxp[u],rt=u; } void get_dis(int u,int p,int dis){ a[++tot]=u; d[u]=dis; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_dis(v,u,dis+w); } } int calc(int u,int len){ tot=0;get_dis(u,0,len); sort(a+1,a+tot+1,cmp); int l=1,r=tot,res=0; while(l<r){ while(d[a[l]]+d[a[r]]>k && l<r) --r; res+=r-l; ++l; } return res; } void div(int u){ vis[u]=1; ans+=calc(u,0); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v]) continue; ans-=calc(v,w); int rt=0,tmp=INF; get_size(v,u); get_root(v,u,sz[v],rt,tmp); div(rt); } } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d\",&n); for(int i=1;i<n;++i) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w); scanf(\"%d\",&k);ans=0; int rt=0,tmp=INF; get_size(1,0); get_root(1,0,sz[1],rt,tmp); div(rt); printf(\"%d\",ans); return 0; } P2634 \u6811\u5f62$dp$\u53ef\u80fd\u4f1a\u66f4\u7b80\u5355\u4e00\u4e9b\uff0c\u4e0d\u8fc7\u70b9\u5206\u6cbb\u4e5f\u53ef\u505a\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=2e4+10,INF=1e8+10; struct edge{ int v,w,nxt; }e[N<<1]; int cnt,ans,n,u,v,w; int gcd(int a,int b){ if(a<b) swap(a,b); return !b?a:gcd(b,a%b); } int head[N],vis[N],sz[N],maxp[N],f[N],d[N]; void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void get_size(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_size(v,u); sz[u]+=sz[v]; } } void get_root(int u,int p,int S,int &rt,int &tmp){ maxp[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_root(v,u,S,rt,tmp); maxp[u]=max(maxp[u],sz[v]); } maxp[u]=max(maxp[u],S-sz[u]); if(maxp[u]<tmp) tmp=maxp[u],rt=u; } void get_dis(int u,int p,int dis){ d[u]=dis%3; ++f[d[u]]; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_dis(v,u,(dis+w)%3); } } int calc(int u,int len){ f[0]=f[1]=f[2]=0; get_dis(u,0,len); return f[0]*f[0]+f[1]*f[2]*2; } void div(int u){ vis[u]=1;ans+=calc(u,0); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v]) continue; ans-=calc(v,w); int rt=0,tmp=INF; get_size(v,u); get_root(v,u,sz[v],rt,tmp); div(rt); } } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d\",&n); for(int i=1;i<n;++i) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w); int rt=0,tmp=INF; get_size(1,0); get_root(1,0,sz[1],rt,tmp); div(rt); int g=gcd(ans,n*n); printf(\"%d/%d\",ans/g,n*n/g); return 0; } P4149 \u70b9\u5206\u6cbb\u7684\u88f8\u9898\uff0c\u4e0eP3806\u76f8\u4f3c\uff0c\u4e5f\u662f\u7528\u53cc\u6307\u9488\u7ef4\u62a4\u4e00\u4e0b\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2e5+10,INF=1e14; int n,k,u,v,rt,tmp,minn,tot,cnt,w; int head[N],sz[N],vis[N],maxp[N],d[N],a[N],b[N],c[N]; struct node{ int v,w,nxt; }e[N<<1]; bool cmp(int x,int y){ return d[x]<d[y]; } void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void get_size(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_size(v,u); sz[u]+=sz[v]; } } void get_dis(int u,int p,int dis,int dep,int P){ a[++tot]=u;d[u]=dis;b[u]=P;c[u]=dep; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_dis(v,u,dis+w,dep+1,P); } } void get_root(int u,int p,int S,int &rt,int &tmp){ maxp[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_root(v,u,S,rt,tmp); maxp[u]=max(maxp[u],sz[v]); } maxp[u]=max(maxp[u],S-sz[u]); if(maxp[u]<tmp) tmp=maxp[u],rt=u; } void calc(int u){ tot=0;a[++tot]=u;d[u]=0;b[u]=u;c[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v]) continue; get_dis(v,u,w,1,v); } sort(a+1,a+tot+1,cmp); int l=1,r=tot; while(l<r){ if(d[a[l]]+d[a[r]]>k) --r; else if(d[a[l]]+d[a[r]]<k) ++l; else{ if(b[a[l]]!=b[a[r]]) minn=min(minn,c[a[l]]+c[a[r]]); if(d[a[r]]==d[a[r-1]]) --r; else ++l; } } } void div(int u){ vis[u]=1;calc(u); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v])continue; rt=0,tmp=INF; get_size(v,u); get_root(v,u,sz[v],rt,tmp); div(rt); } return; } signed main(){ memset(head,-1,sizeof head);cnt=-1;minn=INF; scanf(\"%lld%lld\",&n,&k); for(int i=1;i<n;++i) scanf(\"%lld%lld%lld\",&u,&v,&w),add(u+1,v+1,w),add(v+1,u+1,w); rt=0,tmp=INF; get_size(1,0); get_root(1,0,sz[1],rt,tmp); div(rt); if(minn==INF) printf(\"-1\"); else printf(\"%lld\",minn); return 0; } ~~\u7136\u540e\u4f60\u4f1a\u53d1\u73b0\uff0cWA#7~~ \u770b\u4e86\u8ba8\u8bba\u533a\u624d\u660e\u767d\uff0c\u662f\u6392\u5e8f\u51fa\u4e86\u95ee\u9898\uff0c\u6539\u6210 return (d[x]==d[y])?c[x]<c[y]:d[x]<d[y] \u5c31\u884c\u4e86\u3002 \u8003\u8651\u4e00\u4e2a\u4e2d\u95f4\u72b6\u6001\u7684$hack$\u6570\u636e\u3002 d: 3 3 ... 5 5 c: 6 4 ... 7 3 \u90a3\u4e48\u6211\u4eec\u4f1a\u641c\u5230\u7684\u662f$6+3,6+7,4+7$,\u5374\u6ca1\u6709\u641c\u5230$4+3$,\u6240\u4ee5\u51fa\u9519\u4e86\u3002 \u8bf4\u767d\u4e86\uff0c\u5728$d[i]$\u76f8\u7b49\u7684\u60c5\u51b5\u4e0b\uff0c\u6307\u9488\u4e0d\u4f1a\u56de\u9000\uff0c\u6b64\u65f6\u5fc5\u987b\u8981\u5c06$c[i]$\u6392\u5e8f\u3002","title":"\u70b9\u5206\u6cbb"},{"location":"my%20past/OI/%E7%82%B9%E5%88%86%E6%B2%BB/#_1","text":"","title":"\u70b9\u5206\u6cbb"},{"location":"my%20past/OI/%E7%82%B9%E5%88%86%E6%B2%BB/#_2","text":"\u56e0\u4e3a\u5206\u6cbb\u540e\uff0c\u6211\u4eec\u5e0c\u671b\u5c42\u6570\u5c3d\u91cf\u5c0f\uff0c\u4e5f\u5c31\u662f\u9009\u62e9\u6240\u6709\u5b50\u6811\u5c3d\u91cf\u5e73\u8861\u7684\u70b9\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u8d2a\u5fc3\u7684\u53d6\u91cd\u5fc3\u3002\u53ef\u4ee5\u8bc1\u660e\uff0c\u56e0\u4e3a\u91cd\u5fc3\u7684\u5b50\u6811\u4e0d\u8d85\u8fc7$\\frac n2$,\u6240\u4ee5\u5c42\u6570\u4e0d\u8d85\u8fc7$O(\\log_2n)$ \u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e00\u5c42\u7684\u6bcf\u4e2a\u91cd\u5fc3\uff0c\u6211\u4eec\u9700\u8981\u6c42\u51fa\u5f53\u524d\u91cd\u5fc3\u6240\u5728\u5b50\u6811\u7684\u6240\u6709\u8ddd\u79bb\uff0c\u53ef\u4ee5\u7528\u6876\u8bb0\u5f55\uff1b\u800c\u7edf\u8ba1\u70b9\u5bf9\u65f6\uff0c\u8fd9\u91cc\u9762\u5305\u62ec\u4e86\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u9897\u5b50\u6811\u7684\u60c5\u51b5(\u4e0d\u662f\u4e00\u6761\u7b80\u5355\u8def\u5f84)\uff0c\u90a3\u4e48\u6211\u4eec\u8fd0\u7528\u5bb9\u65a5\u539f\u7406\uff0c\u51cf\u53bb\u5206\u88c2\u51fa\u7684\u5b50\u6811\u4e2d\u7684\u8d21\u732e\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=2e4+10,K=2e6+10; int ans[K],dis[N],head[N],sz[N],vis[N],maxp[N],d[N]; int n,m,cnt,u,v,w,k,tot; struct node{ int v,w,nxt; }e[N<<1]; void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void __dfs(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; __dfs(v,u); sz[u]+=sz[v]; } } void dfs(int u,int p,int S,int &rt,int &tmp){ maxp[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; dfs(v,u,S,rt,tmp); maxp[u]=max(maxp[u],sz[v]); } maxp[u]=max(maxp[u],S-sz[u]); if(maxp[u]<tmp) tmp=maxp[u],rt=u; } void _dfs(int u,int p){ d[++tot]=dis[u]; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; dis[v]=dis[u]+w; _dfs(v,u); } } void solve(int u,int len,int t){ dis[u]=len;tot=0; _dfs(u,0); for(int i=1;i<=tot;++i) for(int j=1;j<=tot;++j) if(i!=j && d[i]+d[j]<K) ans[d[i]+d[j]]+=t; } void div(int u){ solve(u,0,1);vis[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v])continue; solve(v,w,-1); int rt=0,tmp=K; __dfs(v,u); dfs(v,u,sz[u],rt,tmp); div(rt); } } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<n;++i) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w); int rt=0,tmp=K; __dfs(1,0); dfs(1,0,n,rt,tmp); div(rt); for(int i=1;i<=m;++i){ scanf(\"%d\",&k); if(ans[k]>0 || k==0) printf(\"Yes\\n\"); else printf(\"No\\n\"); } //for(int i=0;i<=10;++i) cout<<ans[i]<<\" \"; return 0; } ~~\u7136\u540e\u4f60\u4f1a\u53d1\u73b0\uff0cbzoj1316:Accepted,luoguP3806:Time Limit Exceeded~~ \u4e0b\u9762\u662f\u5e38\u89c1\u7684\u95ee\u9898. 1) \u6709\u5173\u9519\u8bef\u7684\u6c42\u91cd\u5fc3\u5bf9\u590d\u6742\u5ea6\u7684\u5f71\u54cd \u6bcf\u6b21\u6c42\u4e2d\u5fc3\u4e4b\u524d\u4e00\u5b9a\u8981\u5148$dfs$\u4e00\u904d\u6574\u9897\u5b50\u6811\uff0c\u6c42\u51fa\u5927\u5c0f\u540e\u518d\u7528\u8fd9\u4e2a\u8282\u70b9\u6570\u53d6\u66f4\u65b0\u91cd\u5fc3\u3002\u4e0d\u7136\u53ef\u80fd\u4f1a\u51fa\u73b0\u8fd9\u6837\u7684\u60c5\u51b5\uff1a //\u5bf9\u4e8e\u8fd9\u6837\u4e00\u9897\u6811 11//n 6 7 1//u v w 6 8 1 7 9 1 7 10 1 8 11 1 1 2 1 1 3 1 2 4 1 2 5 1 3 6 1 \u5728\u5206\u6cbb\u5230$6$\u53f7\u70b9\u65f6\uff0c\u56e0\u4e3a\u6b64\u65f6$sz[3]=7$,\u6240\u4ee5\u6c42\u51fa\u7684\u91cd\u5fc3\u4e3a$1$\uff1b\u800c\u4e8b\u5b9e\u4e0a$sz[3]=5$\uff0c\u6c42\u51fa\u91cd\u5fc3\u4e3a$2$. 2) \u6709\u5173\u5e38\u89c4\u505a\u6cd5\u9519\u8bef\u7684\u590d\u6742\u5ea6 \u672c\u6765\u5206\u6cbb\u7684\u5c42\u6570\u662f\u4e25\u683c\u5c0f\u4e8e$O(\\log n)$\u8fd9\u4e2a\u4e0a\u754c\u7684\uff0c\u6bcf\u4e00\u5c42\u6700\u591a\u904d\u5386\u4e00\u904d\u6240\u6709\u8282\u70b9\uff0c\u6240\u4ee5\u590d\u6742\u5ea6$O(n\\log n)$. \u4f46\u662f ,\u6734\u7d20\u7684\u7edf\u8ba1\u6709\u4e2a$O(n^2)$\u7684\u7edf\u8ba1\uff0c\u5bf9\u4e8e\u83ca\u82b1\u56fe\u8fd9\u6837\u5b50\u8282\u70b9\u5de8\u591a\u7684\u6570\u636e \u4e00\u5b9a\u4f1aT .\u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u53cc\u6307\u9488\u7684\u65b9\u5f0f\u7edf\u8ba1\u3002 \u5148$dfs$\u4e00\u8fb9\u6c42\u51fa\u5f53\u524d\u5b50\u6811\u4e2d\u8282\u70b9\u6df1\u5ea6$d[i]$,\u6240\u6709\u8282\u70b9\u6807\u53f7$a[i]$,\u4ee5\u53ca\u8282\u70b9\u5904\u5728\u54ea\u4e2a\u5b50\u6811\u4e2d$b[i]$\u3002 \u5bf9\u4e8e\u6df1\u5ea6\u4ece\u5c0f\u5230\u5927\u6392\u5e8f(\u4e0d\u8981\u5fd8\u8bb0\u52a0\u5165\u91cd\u5fc3$u$),\u7136\u540e\u5bf9\u4e8e\u4e0d\u540c\u7684\u8be2\u95ee\uff0c$l=1,r=tot$\u5730\u626b\u4e00\u904d\uff0c\u6ce8\u610f\u8981\u6ee1\u8db3$b[a[l]]\\not=b[a[r]]$,\u53bb\u6389\u4e86\u5bb9\u65a5\u3002\u5206\u6cbb+\u6392\u5e8f\u590d\u6742\u5ea6$O(n\\log^2n)$\uff0c\u5206\u6cbb+\u53cc\u6307\u9488\u590d\u6742\u5ea6$O(nm\\log n)$,\u603b$O(n\\log^2n + nm\\log n)$ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e4+10,K=1e7+10; int query[N],head[N],sz[N],vis[N],maxp[N],d[N],a[N],b[N]; int n,m,cnt,u,v,w,k,tot; bool ans[K]; bool cmp(int x,int y){ return d[x]<d[y]; } struct node{ int v,w,nxt; }e[N<<1]; void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void __dfs(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; __dfs(v,u); sz[u]+=sz[v]; } } void dfs(int u,int p,int S,int &rt,int &tmp){ maxp[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; dfs(v,u,S,rt,tmp); maxp[u]=max(maxp[u],sz[v]); } maxp[u]=max(maxp[u],S-sz[u]); if(maxp[u]<tmp) tmp=maxp[u],rt=u; } void _dfs(int u,int p,int dis,int P){ a[++tot]=u;d[u]=dis;b[u]=P; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; _dfs(v,u,dis+w,P); } } void solve(int u){ tot=0; a[++tot]=u; b[u]=u;d[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v])continue; _dfs(v,u,w,v); } sort(a+1,a+tot+1,cmp); for(int i=1;i<=m;++i){ int l=1,r=tot; if(ans[i]) continue; while(l<r){ //cout<<u<<\" \"<<i<<\": \"<<a[l]<<\" \"<<a[r]<<\" \"<<d[a[l]]<<\" \"<<d[a[r]]<<endl; if(d[a[l]]+d[a[r]]>query[i]) --r; else if(d[a[l]]+d[a[r]]<query[i]) ++l; else if(b[a[l]]==b[a[r]]){ if(d[a[r]]==d[a[r-1]]) --r; else ++l; } else { ans[i]=1;break; } } } } void div(int u){ vis[u]=1;solve(u); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v])continue; int rt=0,tmp=K; __dfs(v,u); dfs(v,u,sz[v],rt,tmp); div(rt); } } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<n;++i) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w); for(int i=1;i<=m;++i){ scanf(\"%d\",&query[i]); if(!query[i]) ans[i]=1; } int rt=0,tmp=K; __dfs(1,0); dfs(1,0,sz[1],rt,tmp); div(rt); for(int i=1;i<=m;++i){ if(ans[i]) printf(\"AYE\\n\"); else printf(\"NAY\\n\"); } return 0; } /* 7 1 1 6 13 6 3 9 3 5 7 4 1 3 2 4 20 4 7 2 10 6 4 1 2 5 1 3 7 1 4 1 3 5 2 3 6 3 0 8 13 14 11 1 6 7 1 6 8 1 7 9 1 7 10 1 8 11 1 1 2 1 1 3 1 2 4 1 2 5 1 3 6 1 2 */ ...\u7136\u800c\uff0c\u5bb9\u65a5\u771f\u7684\u6beb\u65e0\u7528\u6b66\u4e4b\u5730\u5417\uff1f P4178 \u8fd9\u9053\u9898\u53ea\u6709\u4e00\u4e2a\u8be2\u95ee\uff0c\u7136\u800c\u5374\u53d8\u6210$\\leq k$\u5730\u70b9\u5bf9\u6570\u91cf\u3002\u8fd9\u65f6\u6211\u4eec\u5c31\u53ef\u4ee5\u7528\u5bb9\u65a5\u3002\u5f53\u7136\uff0c\u53cc\u6307\u9488\u662f\u5fc5\u9700\u7684\u3002 \u5bf9\u4e8e\u6bcf\u6b21\u5206\u6cbb\u8ba1\u7b97\u65f6\uff0c\u8fd8\u662f\u5c06$a[i]$\u6309\u7167$d[a[i]]$\u6392\u5e8f.\u7136\u540e\uff0c\u53cc\u6307\u9488$l=1,r=tot$\u4ece\u4e24\u5934\u5411\u4e2d\u95f4\u626b\u3002\u6bcf\u6b21\u6ee1\u8db3$d[a[l]]+d[a[r]]<=k$\u65f6\u5c31$ans+=r-l$.\u800c\u8fd9\u4e9b\u91cd\u590d\u7684\u70b9\u5bf9\u7528\u5bb9\u65a5\u5373\u53ef\u89e3\u51b3\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=4e4+10,K=2e4+10,INF=1e8+10; struct edge{ int v,w,nxt; }e[N<<1]; int head[N],sz[N],vis[N],maxp[N],a[N],b[N],d[N]; int cnt,n,u,v,w,tot,ans,k; bool cmp(int x,int y){ return d[x]<d[y]; } void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void get_size(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_size(v,u); sz[u]+=sz[v]; } } void get_root(int u,int p,int S,int &rt,int &tmp){ maxp[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_root(v,u,S,rt,tmp); maxp[u]=max(maxp[u],sz[v]); } maxp[u]=max(maxp[u],S-sz[u]); if(maxp[u]<tmp) tmp=maxp[u],rt=u; } void get_dis(int u,int p,int dis){ a[++tot]=u; d[u]=dis; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_dis(v,u,dis+w); } } int calc(int u,int len){ tot=0;get_dis(u,0,len); sort(a+1,a+tot+1,cmp); int l=1,r=tot,res=0; while(l<r){ while(d[a[l]]+d[a[r]]>k && l<r) --r; res+=r-l; ++l; } return res; } void div(int u){ vis[u]=1; ans+=calc(u,0); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v]) continue; ans-=calc(v,w); int rt=0,tmp=INF; get_size(v,u); get_root(v,u,sz[v],rt,tmp); div(rt); } } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d\",&n); for(int i=1;i<n;++i) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w); scanf(\"%d\",&k);ans=0; int rt=0,tmp=INF; get_size(1,0); get_root(1,0,sz[1],rt,tmp); div(rt); printf(\"%d\",ans); return 0; } P2634 \u6811\u5f62$dp$\u53ef\u80fd\u4f1a\u66f4\u7b80\u5355\u4e00\u4e9b\uff0c\u4e0d\u8fc7\u70b9\u5206\u6cbb\u4e5f\u53ef\u505a\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=2e4+10,INF=1e8+10; struct edge{ int v,w,nxt; }e[N<<1]; int cnt,ans,n,u,v,w; int gcd(int a,int b){ if(a<b) swap(a,b); return !b?a:gcd(b,a%b); } int head[N],vis[N],sz[N],maxp[N],f[N],d[N]; void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void get_size(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_size(v,u); sz[u]+=sz[v]; } } void get_root(int u,int p,int S,int &rt,int &tmp){ maxp[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_root(v,u,S,rt,tmp); maxp[u]=max(maxp[u],sz[v]); } maxp[u]=max(maxp[u],S-sz[u]); if(maxp[u]<tmp) tmp=maxp[u],rt=u; } void get_dis(int u,int p,int dis){ d[u]=dis%3; ++f[d[u]]; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_dis(v,u,(dis+w)%3); } } int calc(int u,int len){ f[0]=f[1]=f[2]=0; get_dis(u,0,len); return f[0]*f[0]+f[1]*f[2]*2; } void div(int u){ vis[u]=1;ans+=calc(u,0); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v]) continue; ans-=calc(v,w); int rt=0,tmp=INF; get_size(v,u); get_root(v,u,sz[v],rt,tmp); div(rt); } } int main(){ memset(head,-1,sizeof head);cnt=-1; scanf(\"%d\",&n); for(int i=1;i<n;++i) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w); int rt=0,tmp=INF; get_size(1,0); get_root(1,0,sz[1],rt,tmp); div(rt); int g=gcd(ans,n*n); printf(\"%d/%d\",ans/g,n*n/g); return 0; } P4149 \u70b9\u5206\u6cbb\u7684\u88f8\u9898\uff0c\u4e0eP3806\u76f8\u4f3c\uff0c\u4e5f\u662f\u7528\u53cc\u6307\u9488\u7ef4\u62a4\u4e00\u4e0b\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2e5+10,INF=1e14; int n,k,u,v,rt,tmp,minn,tot,cnt,w; int head[N],sz[N],vis[N],maxp[N],d[N],a[N],b[N],c[N]; struct node{ int v,w,nxt; }e[N<<1]; bool cmp(int x,int y){ return d[x]<d[y]; } void add(int u,int v,int w){ e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void get_size(int u,int p){ sz[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_size(v,u); sz[u]+=sz[v]; } } void get_dis(int u,int p,int dis,int dep,int P){ a[++tot]=u;d[u]=dis;b[u]=P;c[u]=dep; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_dis(v,u,dis+w,dep+1,P); } } void get_root(int u,int p,int S,int &rt,int &tmp){ maxp[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(v==p || vis[v])continue; get_root(v,u,S,rt,tmp); maxp[u]=max(maxp[u],sz[v]); } maxp[u]=max(maxp[u],S-sz[u]); if(maxp[u]<tmp) tmp=maxp[u],rt=u; } void calc(int u){ tot=0;a[++tot]=u;d[u]=0;b[u]=u;c[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v]) continue; get_dis(v,u,w,1,v); } sort(a+1,a+tot+1,cmp); int l=1,r=tot; while(l<r){ if(d[a[l]]+d[a[r]]>k) --r; else if(d[a[l]]+d[a[r]]<k) ++l; else{ if(b[a[l]]!=b[a[r]]) minn=min(minn,c[a[l]]+c[a[r]]); if(d[a[r]]==d[a[r-1]]) --r; else ++l; } } } void div(int u){ vis[u]=1;calc(u); for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w; if(vis[v])continue; rt=0,tmp=INF; get_size(v,u); get_root(v,u,sz[v],rt,tmp); div(rt); } return; } signed main(){ memset(head,-1,sizeof head);cnt=-1;minn=INF; scanf(\"%lld%lld\",&n,&k); for(int i=1;i<n;++i) scanf(\"%lld%lld%lld\",&u,&v,&w),add(u+1,v+1,w),add(v+1,u+1,w); rt=0,tmp=INF; get_size(1,0); get_root(1,0,sz[1],rt,tmp); div(rt); if(minn==INF) printf(\"-1\"); else printf(\"%lld\",minn); return 0; } ~~\u7136\u540e\u4f60\u4f1a\u53d1\u73b0\uff0cWA#7~~ \u770b\u4e86\u8ba8\u8bba\u533a\u624d\u660e\u767d\uff0c\u662f\u6392\u5e8f\u51fa\u4e86\u95ee\u9898\uff0c\u6539\u6210 return (d[x]==d[y])?c[x]<c[y]:d[x]<d[y] \u5c31\u884c\u4e86\u3002 \u8003\u8651\u4e00\u4e2a\u4e2d\u95f4\u72b6\u6001\u7684$hack$\u6570\u636e\u3002 d: 3 3 ... 5 5 c: 6 4 ... 7 3 \u90a3\u4e48\u6211\u4eec\u4f1a\u641c\u5230\u7684\u662f$6+3,6+7,4+7$,\u5374\u6ca1\u6709\u641c\u5230$4+3$,\u6240\u4ee5\u51fa\u9519\u4e86\u3002 \u8bf4\u767d\u4e86\uff0c\u5728$d[i]$\u76f8\u7b49\u7684\u60c5\u51b5\u4e0b\uff0c\u6307\u9488\u4e0d\u4f1a\u56de\u9000\uff0c\u6b64\u65f6\u5fc5\u987b\u8981\u5c06$c[i]$\u6392\u5e8f\u3002","title":"\u4e3b\u8981\u601d\u60f3"},{"location":"my%20past/OI/%E7%8A%B6%E5%8E%8Bdp/","text":"\u72b6\u538bdp\u603b\u7ed3 \u7edf\u8ba1\u7b54\u6848\u7c7b P1879 \u975e\u5e38\u7ecf\u5178\u7684\u4e00\u9053\u5165\u95e8\u9898 \u6ce8\u610f\u5224\u65ad\u662f\u5426\u5408\u6cd5\uff1a 1.\u4e0e\u81ea\u5df1\u5224\u65ad\uff0c\u5fc5\u987b\u4e3a101010101 \u7b49\u7269\u76f8\u90bb1 \u7684\u4e32\uff0c\u5224\u65ad\u65b9\u6cd5\u4e3a\uff1a !(s&(s<<1)) && !(s&(s>>1)) \u7ed3\u679c\u4e3a0\u5373\u53ef 2.\u4e0e\u524d\u4e00\u884c\u5224\u65ad\uff0c\u76f4\u63a5\u4f5c\u4e0e\u76840\u5c31\u884c 3.\u4e0e\u5730\u56fe\u5224\u65ad\uff0c\u5c06\u5730\u56fe\u53cd\u8f6c\u540e\u4f5c\u4e0e\u76840 \u6700\u540e\u7b54\u6848=$\\sum dp[n][i]$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=13,P=1e9; int n,m,M; int map[N][N]; int f[N]; //int state[1<<N]; int dp[N][1<<N]; signed main() { scanf(\"%lld%lld\",&n,&m);M=1<<m; for(int i=1; i<=n; ++i) { for(int j=1; j<=m; ++j) { scanf(\"%lld\",&map[i][j]); } } for(int i=1; i<=n; ++i) { for(int j=1; j<=m; ++j)f[i]=(f[i]<<1)+(1-map[i][j]); } for(int i=0;i<M;++i)if(!(i&(i<<1)) && !(i&(i>>1)) && !(i&f[1])) dp[1][i]=1; for(int i=2; i<=n; ++i) { for(int s=0; s<M; ++s) { if(!(s&(s<<1)) && !(s&(s>>1)) && !(s&f[i])) { //legal for(int k=0;k<M;++k){ if(!(k&(k<<1)) && !(k&(k>>1)) && !(k&f[i-1]) && !(k&s)) { //legal dp[i][s]=(dp[i][s]+dp[i-1][k])%P; } } } } } int sum=0; for(int i=0;i<M;++i)sum=(sum+dp[n][i])%P;//dp[n][i]; printf(\"%lld\",sum); return 0; } \u7384\u5b66\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(n*2^{2n})$\uff0cOrz P1896 \u72b6\u538bdp+\u80cc\u5305 \u4e0eP1879\u5341\u5206\u76f8\u4f3c\uff0c\u53ea\u662f\u591a\u4e86\u4e2a\u80cc\u5305\u548c\u884c\u4e0e\u884c\u4e4b\u95f4\u7684\u6bd4\u8f83 data\u8bb0\u5f55\u6bcf\u79cd\u72b6\u6001\u4e2d\u5305\u542b\u591a\u5c11\u4e2a\u56fd\u738b map\u8bb0\u5f55\u5f53\u524d\u72b6\u6001\u5bf9\u4e0a\u4e00\u884c\u7684\u9650\u5236 ok\u8bb0\u5f55\u5f53\u524d\u72b6\u6001\u662f\u5426\u5408\u6cd5(!(s&(s>>1)) && !(s&(s<<1))) f\u8bb0\u5f55\u7b54\u6848 //\u8f6c\u79fb\u65b9\u7a0b for(int i=2;i<=n;++i){ for(int s=0;s<m;++s){ if(ok[s]){ for(int s1=0;s1<m;++s1){ if(!(map[s]&s1) && ok[s1]){ for(int j=k;j>=data[s];--j){ f[s][i][j]+=f[s1][i-1][j-data[s]]; } } } } } } \u6700\u4f18\u89e3\u7c7b P3052 f[1<<n]\u8868\u793a\u7b54\u6848\uff0cg[1<<n]\u8868\u793a\u8be5\u72b6\u6001\u7684\u6700\u540e\u4e00\u4e2a\u7535\u68af\u7684\u6700\u5927\u5269\u4f59\u4f53\u79ef \u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a if(g[i]>=a[j] && f[i | (1<<(j-1))]>=f[i]){ f[i | (1<<(j-1))]=f[i]; g[i | (1<<(j-1))]=max(g[i | (1<<(j-1))],g[i]-a[j]); }else if(g[i]<a[j] && f[i | (1<<(j-1))]>=f[i]+1){ f[i | (1<<(j-1))]=f[i]+1; g[i | (1<<(j-1))]=max(g[i | (1<<(j-1))],w-a[j]); } \u56e0\u4e3a\u5f53\u524d\u72b6\u6001\u7684\u524dn-1\u4e2a\u72b6\u6001\u4e00\u5b9a\u5df2\u6ee1\uff0c\u4f46\u4e0d\u4e00\u5b9a\u65f6\u6700\u4f18\uff1b\u7b2cn\u4e2a\u72b6\u6001\u672a\u6ee1\uff0c\u4e14\u4e0d\u4e00\u5b9a\u6700\u4f18\uff0c\u56e0\u6b64\u4e00\u5b9a\u8981\u5148\u53d6f\u7684\u6700\u4f18\uff0c\u5728\u66f4\u65b0g\u53d6\u6700\u4f18\u3002 \u5f53f\u6700\u4f18\u65f6\uff0c\u524dn-1\u4e00\u5b9a\u65f6\u5f53\u524d\u6700\u6ee1\u7684\u72b6\u6001\uff0c\u6240\u4ee5\u4e0d\u7528\u518d\u8003\u8651\uff0c\u76f4\u63a5\u8003\u8651\u6700\u540e\u4e00\u4e2a\u72b6\u6001\u7684\u6700\u5927\u503c\u5373\u53ef\u3002\u5e76\u4e14f\u6700\u4f18\u5c31\u8bc1\u660eg\u66f4\u5927\u3002 \u4f8b\u5982\uff1a 3 10 4 6 7 4 6 7\u53ef\u4ee5\u75314 6 \u62166 7\u8f6c\u79fb\u800c\u6765\uff0c\u4f466 7\u7b54\u6848\u5df2\u7ecf\u4e3a2\uff0c\u800c4 6 \u4e3a1\uff0c\u5219\u5e94\u8be5\u53d64 6 \u7684\u72b6\u6001\u4f5c\u4e3a4 6 7 \u7684\u8f6c\u79fb\u3002 \uff08\u6bcf\u4e2a\u72b6\u6001\u7684\u6700\u4f18\u89e3\u65f6\u552f\u4e00\u7684\uff09 P1357 \u8fd9\u9053\u9898\u7528\u5230\u4e86\u77e9\u9635\u5feb\u901f\u5e42\u3002 \u9996\u5148\u8003\u8651\u66b4\u529b$dp$. \u8bbe\u72b6\u6001$f[i][S]$\u8868\u793a\u5f53\u524d\u4f4d\u7f6e\u4e3a$i$,\u72b6\u6001\u4e3a$S$\u7684\u65b9\u6848\u6570\u3002 \u5047\u8bbe\u5f53\u524d\u7684\u8d77\u70b9\u4e3a$0$,\u72b6\u6001\u4e3a$S$\uff0c\u90a3\u4e48\u521d\u59cb\u503c$f[0][S]=1$. \u7136\u540e\u7531\u4e8e\u5934\u4e0e\u5c3e\u8981\u5b8c\u5168\u91cd\u5408\uff0c\u6240\u4ee5\u6700\u7ec8\u7b54\u6848\u4e3a$f[n][S]$. \u8f6c\u79fb\u65b9\u7a0b\u4e3a: $$ f[i+1][T>>1]=\\sum f[i][T] \\ f[i+1][(T>>1)|(1< >1)|(1<<m))\\leq k \\popcnt(i)\u8868\u793ai\u5728\u4e8c\u8fdb\u5236\u4e0b\u6709\u51e0\u4e2a1 $$ \u6211\u4eec\u53d1\u73b0\uff0c\u6bcf\u6b21\u7684\u8f6c\u79fb\u65b9\u5f0f\u90fd\u662f\u56fa\u5b9a\u7684\uff0c\u90fd\u53ef\u4ee5\u8868\u793a\u6210\u4e00\u4e2a$01\u77e9\u9635. \u6545\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5bbd\u4e3a$2^m$\u7684\u77e9\u9635\u6765\u52a0\u901f\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=33,P=1e9+7; int n,m,k,res; int popcnt(int x) { int cnt=0; while(x) cnt+=(x&1),x>>=1; return cnt; } struct ma { int f[N][N],n,m; ma() { memset(f,0,sizeof f),n=m=0; } } s,t,ans; ma operator *(ma a,ma b) { ma c=ma(); int n=a.n,m=a.m,p=b.m; c.n=n,c.m=p; for(int i=0; i<n; ++i) for(int j=0; j<p; ++j) for(int k=0; k<m; ++k) c.f[i][j]=(c.f[i][j]+a.f[i][k]*b.f[k][j]%P)%P; return c; } ma kp(ma x,int p) { if(p<=1) return x; if(p&1) return x*kp(x*x,p>>1); else return kp(x*x,p>>1); } signed main() { scanf(\"%lld%lld%lld\",&n,&m,&k); for(int S=0; S<(1<<m); ++S) { if(popcnt(S)>k) continue; s=ma(),t=ma(),ans=ma(); s.n=1,s.m=(1<<m); s.f[0][S]=1; t.n=t.m=(1<<m); for(int T=0; T<(1<<m); ++T) { if(popcnt(T)>k) continue; t.f[T][T>>1]=1; if(popcnt((T>>1)|(1<<(m-1)))<=k) t.f[T][(T>>1)|(1<<(m-1))]=1; } ans=s*kp(t,n); res=(res+ans.f[0][S])%P; } printf(\"%lld\",res); return 0; } P3959 \u5982\u679c\u53ea\u8003\u8651\u6bcf\u4e2a\u72b6\u6001\u7684\u70b9\u96c6\u7684\u8bdd\u65f6\u9519\u8bef\u7684\uff0c\u56e0\u4e3a\u66f4\u65b0\u540c\u4e00\u4e2a\u70b9\u65f6\u4f1a\u56e0\u4e3a\u4e0d\u540c\u7684\u6df1\u5ea6\u800c\u4ea7\u751f\u4e0d\u540c\u7684\u8d21\u732e\u3002 hack data 6 6 1 2 100 2 3 1 2 4 10 3 4 10 3 5 100 4 6 10000 \u597d\u50cf\u53ef\u4ee5\u5361\u6389$prim$\u548c\u90e8\u5206\u53ea\u8bb0\u5f55\u96c6\u5408\u7684\u72b6\u538b$dp$\u3002 \u6240\u4ee5\u8981\u8003\u8651\u6bcf\u4e2a\u70b9\u5230\u521d\u59cb\u70b9\u7684\u6df1\u5ea6\u3002 \u8bbe$f[i][j][S]$\u8868\u793a\u5728\u6df1\u5ea6\u4e3a$i$\u7684\u70b9$j$\u65f6\u4e00\u5171\u6316\u4e86$S$\u4e2d\u6240\u6709\u5b9d\u85cf\u7684\u6700\u5c0f\u82b1\u8d39\u3002 \u5047\u8bbe\u5f53\u524d\u8981\u66f4\u65b0\u7684\u96c6\u5408$s$\u4e2d\u5305\u542b\u4e86\u4e0e$j$\u8fde\u63a5\u7684$k$\u70b9\uff0c\u800c$j$\u5219\u5728$s$\u5173\u4e8e$S$\u7684\u8865\u96c6$_S$\u4e2d\u3002 \u90a3\u4e48\u8f6c\u79fb\u65b9\u7a0b\uff1a $$ f[i][j][S]=\\min(f[i][j][S]\uff0cd[j][k]* (i+1)+f[i][j][_S]+f[i+1][k][s]) $$ \u8fd9\u6709\u70b9\u50cf\u6811\u5f62\u80cc\u5305$dp$\u7684\u8f6c\u79fb\u65b9\u7a0b\u3002 \u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u7528\u8bb0\u5fc6\u5316\u641c\u7d22\u7684\u65b9\u5f0f\u6765\u5b9e\u73b0\u5b83\u5566! #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=13,M=1e3+10,INF=0x3f3f3f3f; int f[N][N][1<<N]; int d[N][N],D[N][N],head[N],sz[1<<N]; int n,m,v,u,w,ans,cnt; struct edge { int v,w,nxt; } e[M<<1]; int read1() { int x=0; char ch=getchar(); while(ch>'9' || ch<'0')ch=getchar(); while(ch<='9' && ch>='0')x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x) { if(x>9)write1(x/10); putchar(x%10+'0'); } void add(int u,int v,int w) { e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void init() { for(int i=1; i<=n; ++i) { for(int j=1; j<=n; ++j) { if(i==j)continue; if(d[i][j]<INF)D[i][++D[i][0]]=j; } } } int dfs(int i,int j,int S) { if(f[i][j][S]<INF)return f[i][j][S]; if(S==(1<<(j-1)))return f[i][j][S]=0; if(sz[S]>n-i)return f[i][j][S]=INF; if(sz[S]<=1)return f[i][j][S]=0; for(int s=S; s; s=(s-1)&S) { int _S=S^s; if(((1<<(j-1))&s))continue; int tmp=dfs(i,j,_S); if(tmp>=f[i][j][S])continue; for(int o=1; o<=D[j][0]; ++o) { int k=D[j][o]; if((1<<(k-1))&s) f[i][j][S]=min(f[i][j][S],d[j][k]*(i+1)+tmp+dfs(i+1,k,s)); } } return f[i][j][S]; } int main() { //freopen(\"P3959_17.in\",\"r\",stdin); ans=INF; memset(head,-1,sizeof head); cnt=-1; memset(d,0x3f,sizeof d); n=read1(),m=read1(); for (int i=1; i<(1<<n); ++i) sz[i]=sz[i&(i-1)]+1;// for(int i=1; i<=m; ++i) u=read1(),v=read1(),w=read1(),add(u,v,w),add(v,u,w),d[u][v]=min(d[u][v],w),d[v][u]=min(d[v][u],w); init(); for(int o=1; o<=n; ++o) { memset(f,0x3f,sizeof f); ans=min(ans,dfs(0,o,(1<<n)-1)); } write1(ans); return 0; } ~~\u7136\u540e\u5c31T\u4e86~~ \u6ce8\u610f\uff0c\u4e0a\u8ff0\u4ee3\u7801\u4e2d\u5305\u542b\u4e86\u5feb\u8bfb\u5feb\u5199\uff0c\u9884\u5904\u7406$j$\u7684\u679a\u4e3e\u91cf$k$,\u8bb0\u5fc6\u5316\u641c\u7d22\u81ea\u5e26\u7684\u526a\u679d\uff0c\u6700\u4f18\u6027\u526a\u679d($f[i][j][_S]<f[i][j][S]$)\uff0c\u975e\u6cd5\u72b6\u6001\u526a\u679d\u7b49\u4e00\u7cfb\u5217\u5361\u5e38\u65b9\u6cd5\uff0c\u4f46\u5bf9\u4e8e$n=12$\u7684\u6570\u636e\u8fd8\u8981\u8dd1$3s$\u4ee5\u4e0a\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u4e0d\u8981\u9012\u5f52\uff0c\u53ea\u8981\u9012\u63a8\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=13,M=1e3+10,INF=0x3f3f3f3f; int f[N][N][1<<N]; int d[N][N],D[N][N],head[N],sz[1<<N]; int n,m,v,u,w,ans,cnt; struct edge { int v,w,nxt; } e[M<<1]; int read1() { int x=0; char ch=getchar(); while(ch>'9' || ch<'0')ch=getchar(); while(ch<='9' && ch>='0')x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x) { if(x>9)write1(x/10); putchar(x%10+'0'); } void add(int u,int v,int w) { e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void init() { for(int i=1; i<=n; ++i) { for(int j=1; j<=n; ++j) { if(i==j)continue; if(d[i][j]<INF)D[i][++D[i][0]]=j; } } } void dp() { memset(f,0x3f,sizeof f); for(int i=1; i<=n; ++i)f[n-1][i][1<<(i-1)]=0; for(int i=n-2; i>=0; --i) { for(int j=1; j<=n; ++j) { f[i][j][1<<(j-1)]=0; for(int S=1; S<(1<<n); ++S) { if(sz[S]>n-i)continue; for(int s=S; s; s=(s-1)&S) { int _S=S^s; if(((1<<(j-1))&s))continue; if(sz[s]>n-i-1)continue; if(f[i][j][_S]>=f[i][j][S])continue; for(int o=1; o<=D[j][0]; ++o) { int k=D[j][o]; if((1<<(k-1))&s) f[i][j][S]=min(f[i][j][S],d[j][k]*(i+1)+f[i][j][_S]+f[i+1][k][s]); } } } } } } int main() { //freopen(\"P3959_15.in\",\"r\",stdin); ans=INF; memset(head,-1,sizeof head); cnt=-1; memset(d,0x3f,sizeof d); n=read1(),m=read1(); for (int i=1; i<(1<<n); ++i) sz[i]=sz[i&(i-1)]+1;// for(int i=1; i<=m; ++i) u=read1(),v=read1(),w=read1(),add(u,v,w),add(v,u,w),d[u][v]=min(d[u][v],w),d[v][u]=min(d[v][u],w); init(); dp(); for(int i=1; i<=n; ++i)ans=min(ans,f[0][i][(1<<n)-1]); write1(ans); return 0; } \u6ce8\u610f\u8d77\u59cb\u72b6\u6001\u4e3a\u96c6\u5408\u4e2d\u53ea\u6709\u4e00\u4e2a\u70b9\u7684\u72b6\u6001\uff0c\u6b64\u65f6\u7b54\u6848\u4e3a$0$ \u9012\u63a8\u7684\u597d\u5904\u5728\u4e8e\uff0c\u4e0d\u9700\u8981\u679a\u4e3e\u5f53\u524d\u7684\u521d\u59cb\u70b9\u5177\u4f53\u662f\u54ea\u4e2a\uff0c\u800c\u662f\u53ef\u4ee5\u4e00\u5f00\u59cb\u9884\u5904\u7406\u4e3a$0$\u540e\u4e00\u8d77\u8f6c\u79fb\u3002 P2150 \u6ce8\u610f\u5230\u4e00\u4e2a\u6027\u8d28\uff0c\u5047\u8bbe$S_1,S_2$\u8868\u793a\u7532\u4e59\u9009\u62e9\u7684\u6240\u6709\u6570\u7684\u8d28\u56e0\u6570\u96c6\u5408\uff0c\u90a3\u4e48$S_1,S_2$\u4e0d\u80fd\u6709\u4ea4\u96c6. \u90a3\u4e48\u5bf9\u4e8e$n<=30$\uff0c\u8d28\u56e0\u6570\u79cd\u7c7b\u5f88\u5c11\uff0c\u53ef\u4ee5\u72b6\u538b$dp$. \u8bbe$f[S_1][S_2]$\u8868\u793a\u7532\u4e59\u8d28\u56e0\u6570\u96c6\u5408\u4e3a$S_1,S_2$\u65f6\u7684\u65b9\u6848\u6570\u3002 \u8fb9\u754c$f[0][0]=1$,$S$\u8868\u793a$2-n$\u6bcf\u4e2a\u6570\u7684\u8d28\u56e0\u6570\u96c6\u5408\uff0c\u8f6c\u79fb\u65b9\u7a0b: $$ f[j|S][k]+=f[j][k]\\times (S\\&k==0),f[j][k|S]+=f[j][k]\\times (S\\&j==0),j\\& k ==0 $$ \u800c\u5bf9\u4e8e$n<=500$,\u53d1\u73b0\u6bcf\u4e2a\u6570\u5927\u4e8e$22$\u7684\u8d28\u56e0\u6570\u53ea\u6709\u4e00\u4e2a\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u4e00\u4e2a\u7ed3\u6784\u4f53$(o,b,S)$\u8868\u793a\u6bcf\u4e2a\u6570\u7684\u539f\u6570\uff0c\u5927\u8d28\u56e0\u6570\u548c\u5c0f\u8d28\u56e0\u6570\u96c6\u5408\u3002 \u8fd9\u6837\uff0c\u5c06\u5927\u8d28\u56e0\u6570\u76f8\u540c\u7684\u6570\u5206\u7ec4\u8f6c\u79fb\uff0c\u5373\u5bf9\u4e8e\u5927\u8d28\u56e0\u6570\u6392\u4e2a\u5e8f\u3002(\u987a\u5e8f\u65e0\u6240\u8c13) \u4e4b\u540e\uff0c\u5f00\u4e24\u4e2a\u4e34\u65f6\u6570\u7ec4$f1[S_1][S_2],f2[S_1][S_2]$\u5206\u522b\u8868\u793a\u4e00\u4e2a\u6570\u7532\u6216\u8005\u4e59\u9009\u65f6\u7684\u65b9\u6848\u6570\u3002 \u8f6c\u79fb\u4e0e\u4e0a\u9762\u7684\u7c7b\u4f3c\u3002 \u6bcf\u5f53\u4e00\u7ec4\u8f6c\u79fb\u7ed3\u675f\uff0c\u5c31\u66f4\u65b0\u4e00\u904d$f$\u6570\u7ec4\u3002 \u6ce8\u610f$f1,f2$\u4e2d\u4e0d\u5305\u542b\u7532\u4e59\u9009\u62e9\u540c\u4e00\u4e2a\u6570\uff0c\u4f46\u5305\u542b\u4e86\u7532\u4e59\u90fd\u4e0d\u9009\u540c\u4e00\u4e2a\u6570\u7684\u60c5\u51b5\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u76f4\u63a5$f[j][k]=f1[j][k]+f2[j][k]$,\u90fd\u4e0d\u9009\u7684\u60c5\u51b5\u4f1a\u91cd\u590d\uff0c\u6240\u4ee5\u518d\u51cf\u53bb\u4e00\u4e2a$f[j][k]$\u5373\u53ef\u3002 #include<bits/stdc++.h> #define int long long using namespace std; const int N=510,M=266; int p[9]= {0,2,3,5,7,11,13,17,19}; int n,P,ans; int f[M][M],f1[M][M],f2[M][M]; struct node { int o,b,S; void init() { S=0; int tmp=o; for(int i=1; i<=8; ++i) while(tmp%p[i]==0) S|=(1<<(i-1)),tmp/=p[i]; if(tmp>1) b=tmp; else b=-1; } } a[N]; bool cmp(node a,node b) { return a.b<b.b; } signed main() { scanf(\"%lld%lld\",&n,&P); for(int i=1; i<n; ++i) a[i].o=i+1,a[i].init(); sort(a+1,a+n,cmp); f[0][0]=1; for(int i=1; i<n; ++i) { int S=a[i].S; if(i==1 || a[i].b!=a[i-1].b || a[i].b==-1) memcpy(f1,f,sizeof f1),memcpy(f2,f,sizeof f2); for(int j=255; j>=0; --j) for(int k=255; k>=0; --k) if((j&k)==0) f2[j][k|S]=(f2[j][k|S]+((S&j)==0)*f2[j][k])%P,f1[j|S][k]=(f1[j|S][k]+((S&k)==0)*f1[j][k])%P; if(i==n-1 || a[i].b!=a[i+1].b || a[i].b==-1) { for(int j=0; j<=255; ++j) for(int k=0; k<=255; ++k) if((j&k)==0) f[j][k]=(f1[j][k]+f2[j][k]-f[j][k]+P)%P; } } ans=0; for(int j=0; j<=255; ++j) for(int k=0; k<=255; ++k) if((j&k)==0 && f[j][k]) ans=(ans+f[j][k])%P; printf(\"%lld\",ans%P); return 0; } P7519 \u66b4\u529b\u641c\u7d22 \u53ef\u4ee5\u7528\u8d2a\u5fc3\u89e3\u51b3\u6bcf\u4e2a\u961f\u4f0d\u7684\u8fc7\u9898\u6570$b[i]$\uff0c\u5373$b[j]=a[i]+b[i]+(i<j)-a[j]$. \u8fd9\u6837\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053\u5269\u4f59\u7684\u9898\u6570$m$,\u4e0a\u4e00\u4e2a\u961f\u4f0d\u7684$b[j]$\u548c\u4e0a\u4e2a\u961f\u4f0d\u7684\u7f16\u53f7$j$\u5373\u53ef\u8f6c\u79fb\u3002 #include<bits/stdc++.h> using namespace std; typedef long long ll; const int N=100,M=110; int a[N],b[N],vis[N]; int top,n,m; ll ans; bool cmp(int x,int y) { if(a[x]==a[y]) return x<y; return a[x]>a[y]; } void dfs(int dep,int res,int lst,int b) { if(res<0) return; if(dep>n) { if(res>=0) ++ans; return; } for(int i=1; i<=n; ++i) { if(vis[i]) continue; vis[i]=1; int tmp=max(b,a[lst]+b-a[i]+(i>lst)); dfs(dep+1,res-tmp,i,tmp); vis[i]=0; } } int main() { scanf(\"%d%d\",&n,&m); for(int i=1; i<=n; ++i) scanf(\"%d\",&a[i]),b[i]=i; sort(b+1,b+n+1,cmp); dfs(1,m,b[1],0); printf(\"%lld\",ans); return 0; } \u590d\u6742\u5ea6$O(nn!)$ \u66b4\u529b\u72b6\u538b \u7528$f[S][i][j][k][l]$\u8868\u793a\u5f53\u524d\u96c6\u5408\u4e3a$S$,\u8003\u8651\u5230\u7b2c$i$\u4e2a\u961f\u4f0d\uff0c\u5f53\u524d\u5269\u4f59\u9898\u6570\u4e3a$j$\uff0c\u4e0a\u4e00\u4e2a\u961f\u4f0d\u7f16\u53f7\u4e3a$k$,\u4e0a\u4e00\u4e2a\u961f\u4f0d\u8fc7\u9898\u6570\u4e3a$l$\u65f6\u7684\u65b9\u6848\u6570\u3002 \u90a3\u4e48\u6211\u4eec\u76f4\u63a5\u5c06\u4e0a\u9762\u7684\u641c\u7d22\u6539\u6210\u8bb0\u5fc6\u5316\u641c\u7d22\u5373\u53ef\u3002 \u590d\u6742\u5ea6$O(2^nn^2m^2)$ ~~\u8fd8\u4e0d\u5982\u66b4\u529b\u641c\u7d22~~ 3.\u4f18\u5316\u72b6\u538b \u663e\u7136\u5c06\u9012\u5f52\u6539\u6210\u9012\u63a8\u80fd\u4f18\u5316\u6389$i$\u90a3\u4e00\u7ef4\uff0c\u800c\u6709\u4e86\u4e0a\u9762\u7684\u601d\u8def\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u8003\u8651\u518d\u4f18\u5316\u6389$l$\u90a3\u4e00\u7ef4. \u7531\u4e8e$b[i]$\u5355\u8c03\u4e0d\u964d\uff0c\u6240\u4ee5\u5982\u679c\u4e00\u4e2a\u961f\u4f0d\u7684$b[i]$\u5df2\u7ecf\u786e\u5b9a\uff0c\u90a3\u4e48\u540e\u9762\u7684\u961f\u4f0d$b[j]$\u90fd\u8981\u5927\u4e8e\u7b49\u4e8e$b[i]$\u3002\u6240\u4ee5\u76f8\u5f53\u4e8e\u4e00\u5c42\u4e00\u5c42\u7684\u52a0\u4e0a\u65b0\u7684\u8d21\u732e$\\Delta b=b[j]-b[i]$,\u800c\u4e2a\u6570\u4e3a$n-|S|$,\u6240\u4ee5\u6d88\u8017\u7684\u8fc7\u9898\u6570\u4e3a$\\Delta b\\times (n-|S|)$. \u6240\u4ee5\u8bb0$d[i][j]$\u8868\u793a\u5982\u679c$j$\u8981\u8d85\u8d8a$i$\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002 \u8f6c\u79fb\u5982\u4e0b\uff1a for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) d[i][j]=max(0,a[i]-a[j]+(i<j)); \u8fd9\u6837\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u961f\u4f0d\u5bf9\u540e\u9762\u6240\u6709\u961f\u4f0d\u90fd\u4ea7\u751f\u5f71\u54cd\u3002 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u7528$f[S][i][j]$\u8868\u793a\u5f53\u524d\u96c6\u5408\u4e3a$S$,\u4e0a\u4e00\u4e2a\u961f\u4f0d\u4e3a$i$,\u5269\u4f59\u9898\u6570\u4e3a$j$\u65f6\u7684\u65b9\u6848\u6570\u3002 \u8f6c\u79fb\u65b9\u7a0b\uff1a $$ \u5bf9\u4e8ei,j\\in S,i\\not \\in A,j\\in A,k\\in [d[j][i]\\times(n-|A|),m],\u6709\\ f[S][i][k]+=f[A][j][k-d[j][i]\\times(n-|A|)] $$ \u5bf9\u4e8e\u521d\u59cb\u8fb9\u754c\uff0c\u56e0\u4e3a\u8981\u4fdd\u8bc1\u7b2c\u4e00\u4e2a\u6570\u7684$b[i]$\u80fd\u591f\u8d85\u8d8a$a_{\\max}$,\u6240\u4ee5 $f[1<<(i-1)][i][d[pos][i]\\times n]=1$ \u6700\u7ec8\u7b54\u6848\u4e3a$\\sum_{i=1}^n \\sum_{j=1}^{m}f[T][i][j]$,$T$\u8868\u793a\u5168\u96c6\u3002 #include<bits/stdc++.h> #define int long long using namespace std; const int N=14,M=550; int a[N],d[N][N],popcnt[1<<N],s[N]; int ans,n,m,T,tmp; int f[1<<N][N][M]; void init(){ int pos=0,maxn=0; T=(1<<n)-1; for(int i=1;i<=n;++i){ for(int j=1;j<=n;++j) d[i][j]=max(0ll,a[i]-a[j]+(i<j)); if(maxn<a[i] || (maxn==a[i] && pos>i)) maxn=a[i],pos=i; } for(int i=1;i<=T;++i) popcnt[i]=popcnt[i>>1]+(i&1); for(int i=1;i<=n;++i){ int tmp=d[pos][i]*n; if(tmp<=m) f[1<<(i-1)][i][tmp]=1; } } void dp(){ for(int S=0;S<=T;++S){ for(int i=1;i<=n;++i){ if(S&(1<<(i-1))){ int A=S^(1<<(i-1)); for(int j=1;j<=n;++j){ if((i!=j) && (S&(1<<(j-1)))){ int tmp=d[j][i]*(n-popcnt[A]); for(int k=tmp;k<=m;++k) f[S][i][k]+=f[A][j][k-tmp]; } } } } } for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) ans+=f[T][i][j]; printf(\"%lld\",ans); } signed main() { scanf(\"%lld%lld\",&n,&m); for(int i=1; i<=n; ++i) scanf(\"%lld\",&a[i]); init(); dp(); return 0; }","title":"\u72b6\u538bdp\u603b\u7ed3"},{"location":"my%20past/OI/%E7%8A%B6%E5%8E%8Bdp/#dp","text":"","title":"\u72b6\u538bdp\u603b\u7ed3"},{"location":"my%20past/OI/%E7%8A%B6%E5%8E%8Bdp/#_1","text":"P1879 \u975e\u5e38\u7ecf\u5178\u7684\u4e00\u9053\u5165\u95e8\u9898 \u6ce8\u610f\u5224\u65ad\u662f\u5426\u5408\u6cd5\uff1a 1.\u4e0e\u81ea\u5df1\u5224\u65ad\uff0c\u5fc5\u987b\u4e3a101010101 \u7b49\u7269\u76f8\u90bb1 \u7684\u4e32\uff0c\u5224\u65ad\u65b9\u6cd5\u4e3a\uff1a !(s&(s<<1)) && !(s&(s>>1)) \u7ed3\u679c\u4e3a0\u5373\u53ef 2.\u4e0e\u524d\u4e00\u884c\u5224\u65ad\uff0c\u76f4\u63a5\u4f5c\u4e0e\u76840\u5c31\u884c 3.\u4e0e\u5730\u56fe\u5224\u65ad\uff0c\u5c06\u5730\u56fe\u53cd\u8f6c\u540e\u4f5c\u4e0e\u76840 \u6700\u540e\u7b54\u6848=$\\sum dp[n][i]$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=13,P=1e9; int n,m,M; int map[N][N]; int f[N]; //int state[1<<N]; int dp[N][1<<N]; signed main() { scanf(\"%lld%lld\",&n,&m);M=1<<m; for(int i=1; i<=n; ++i) { for(int j=1; j<=m; ++j) { scanf(\"%lld\",&map[i][j]); } } for(int i=1; i<=n; ++i) { for(int j=1; j<=m; ++j)f[i]=(f[i]<<1)+(1-map[i][j]); } for(int i=0;i<M;++i)if(!(i&(i<<1)) && !(i&(i>>1)) && !(i&f[1])) dp[1][i]=1; for(int i=2; i<=n; ++i) { for(int s=0; s<M; ++s) { if(!(s&(s<<1)) && !(s&(s>>1)) && !(s&f[i])) { //legal for(int k=0;k<M;++k){ if(!(k&(k<<1)) && !(k&(k>>1)) && !(k&f[i-1]) && !(k&s)) { //legal dp[i][s]=(dp[i][s]+dp[i-1][k])%P; } } } } } int sum=0; for(int i=0;i<M;++i)sum=(sum+dp[n][i])%P;//dp[n][i]; printf(\"%lld\",sum); return 0; } \u7384\u5b66\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(n*2^{2n})$\uff0cOrz P1896 \u72b6\u538bdp+\u80cc\u5305 \u4e0eP1879\u5341\u5206\u76f8\u4f3c\uff0c\u53ea\u662f\u591a\u4e86\u4e2a\u80cc\u5305\u548c\u884c\u4e0e\u884c\u4e4b\u95f4\u7684\u6bd4\u8f83 data\u8bb0\u5f55\u6bcf\u79cd\u72b6\u6001\u4e2d\u5305\u542b\u591a\u5c11\u4e2a\u56fd\u738b map\u8bb0\u5f55\u5f53\u524d\u72b6\u6001\u5bf9\u4e0a\u4e00\u884c\u7684\u9650\u5236 ok\u8bb0\u5f55\u5f53\u524d\u72b6\u6001\u662f\u5426\u5408\u6cd5(!(s&(s>>1)) && !(s&(s<<1))) f\u8bb0\u5f55\u7b54\u6848 //\u8f6c\u79fb\u65b9\u7a0b for(int i=2;i<=n;++i){ for(int s=0;s<m;++s){ if(ok[s]){ for(int s1=0;s1<m;++s1){ if(!(map[s]&s1) && ok[s1]){ for(int j=k;j>=data[s];--j){ f[s][i][j]+=f[s1][i-1][j-data[s]]; } } } } } }","title":"\u7edf\u8ba1\u7b54\u6848\u7c7b"},{"location":"my%20past/OI/%E7%8A%B6%E5%8E%8Bdp/#_2","text":"P3052 f[1<<n]\u8868\u793a\u7b54\u6848\uff0cg[1<<n]\u8868\u793a\u8be5\u72b6\u6001\u7684\u6700\u540e\u4e00\u4e2a\u7535\u68af\u7684\u6700\u5927\u5269\u4f59\u4f53\u79ef \u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a if(g[i]>=a[j] && f[i | (1<<(j-1))]>=f[i]){ f[i | (1<<(j-1))]=f[i]; g[i | (1<<(j-1))]=max(g[i | (1<<(j-1))],g[i]-a[j]); }else if(g[i]<a[j] && f[i | (1<<(j-1))]>=f[i]+1){ f[i | (1<<(j-1))]=f[i]+1; g[i | (1<<(j-1))]=max(g[i | (1<<(j-1))],w-a[j]); } \u56e0\u4e3a\u5f53\u524d\u72b6\u6001\u7684\u524dn-1\u4e2a\u72b6\u6001\u4e00\u5b9a\u5df2\u6ee1\uff0c\u4f46\u4e0d\u4e00\u5b9a\u65f6\u6700\u4f18\uff1b\u7b2cn\u4e2a\u72b6\u6001\u672a\u6ee1\uff0c\u4e14\u4e0d\u4e00\u5b9a\u6700\u4f18\uff0c\u56e0\u6b64\u4e00\u5b9a\u8981\u5148\u53d6f\u7684\u6700\u4f18\uff0c\u5728\u66f4\u65b0g\u53d6\u6700\u4f18\u3002 \u5f53f\u6700\u4f18\u65f6\uff0c\u524dn-1\u4e00\u5b9a\u65f6\u5f53\u524d\u6700\u6ee1\u7684\u72b6\u6001\uff0c\u6240\u4ee5\u4e0d\u7528\u518d\u8003\u8651\uff0c\u76f4\u63a5\u8003\u8651\u6700\u540e\u4e00\u4e2a\u72b6\u6001\u7684\u6700\u5927\u503c\u5373\u53ef\u3002\u5e76\u4e14f\u6700\u4f18\u5c31\u8bc1\u660eg\u66f4\u5927\u3002 \u4f8b\u5982\uff1a 3 10 4 6 7 4 6 7\u53ef\u4ee5\u75314 6 \u62166 7\u8f6c\u79fb\u800c\u6765\uff0c\u4f466 7\u7b54\u6848\u5df2\u7ecf\u4e3a2\uff0c\u800c4 6 \u4e3a1\uff0c\u5219\u5e94\u8be5\u53d64 6 \u7684\u72b6\u6001\u4f5c\u4e3a4 6 7 \u7684\u8f6c\u79fb\u3002 \uff08\u6bcf\u4e2a\u72b6\u6001\u7684\u6700\u4f18\u89e3\u65f6\u552f\u4e00\u7684\uff09 P1357 \u8fd9\u9053\u9898\u7528\u5230\u4e86\u77e9\u9635\u5feb\u901f\u5e42\u3002 \u9996\u5148\u8003\u8651\u66b4\u529b$dp$. \u8bbe\u72b6\u6001$f[i][S]$\u8868\u793a\u5f53\u524d\u4f4d\u7f6e\u4e3a$i$,\u72b6\u6001\u4e3a$S$\u7684\u65b9\u6848\u6570\u3002 \u5047\u8bbe\u5f53\u524d\u7684\u8d77\u70b9\u4e3a$0$,\u72b6\u6001\u4e3a$S$\uff0c\u90a3\u4e48\u521d\u59cb\u503c$f[0][S]=1$. \u7136\u540e\u7531\u4e8e\u5934\u4e0e\u5c3e\u8981\u5b8c\u5168\u91cd\u5408\uff0c\u6240\u4ee5\u6700\u7ec8\u7b54\u6848\u4e3a$f[n][S]$. \u8f6c\u79fb\u65b9\u7a0b\u4e3a: $$ f[i+1][T>>1]=\\sum f[i][T] \\ f[i+1][(T>>1)|(1< >1)|(1<<m))\\leq k \\popcnt(i)\u8868\u793ai\u5728\u4e8c\u8fdb\u5236\u4e0b\u6709\u51e0\u4e2a1 $$ \u6211\u4eec\u53d1\u73b0\uff0c\u6bcf\u6b21\u7684\u8f6c\u79fb\u65b9\u5f0f\u90fd\u662f\u56fa\u5b9a\u7684\uff0c\u90fd\u53ef\u4ee5\u8868\u793a\u6210\u4e00\u4e2a$01\u77e9\u9635. \u6545\u6211\u4eec\u53ef\u4ee5\u7528\u4e00\u4e2a\u957f\u5bbd\u4e3a$2^m$\u7684\u77e9\u9635\u6765\u52a0\u901f\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=33,P=1e9+7; int n,m,k,res; int popcnt(int x) { int cnt=0; while(x) cnt+=(x&1),x>>=1; return cnt; } struct ma { int f[N][N],n,m; ma() { memset(f,0,sizeof f),n=m=0; } } s,t,ans; ma operator *(ma a,ma b) { ma c=ma(); int n=a.n,m=a.m,p=b.m; c.n=n,c.m=p; for(int i=0; i<n; ++i) for(int j=0; j<p; ++j) for(int k=0; k<m; ++k) c.f[i][j]=(c.f[i][j]+a.f[i][k]*b.f[k][j]%P)%P; return c; } ma kp(ma x,int p) { if(p<=1) return x; if(p&1) return x*kp(x*x,p>>1); else return kp(x*x,p>>1); } signed main() { scanf(\"%lld%lld%lld\",&n,&m,&k); for(int S=0; S<(1<<m); ++S) { if(popcnt(S)>k) continue; s=ma(),t=ma(),ans=ma(); s.n=1,s.m=(1<<m); s.f[0][S]=1; t.n=t.m=(1<<m); for(int T=0; T<(1<<m); ++T) { if(popcnt(T)>k) continue; t.f[T][T>>1]=1; if(popcnt((T>>1)|(1<<(m-1)))<=k) t.f[T][(T>>1)|(1<<(m-1))]=1; } ans=s*kp(t,n); res=(res+ans.f[0][S])%P; } printf(\"%lld\",res); return 0; } P3959 \u5982\u679c\u53ea\u8003\u8651\u6bcf\u4e2a\u72b6\u6001\u7684\u70b9\u96c6\u7684\u8bdd\u65f6\u9519\u8bef\u7684\uff0c\u56e0\u4e3a\u66f4\u65b0\u540c\u4e00\u4e2a\u70b9\u65f6\u4f1a\u56e0\u4e3a\u4e0d\u540c\u7684\u6df1\u5ea6\u800c\u4ea7\u751f\u4e0d\u540c\u7684\u8d21\u732e\u3002 hack data 6 6 1 2 100 2 3 1 2 4 10 3 4 10 3 5 100 4 6 10000 \u597d\u50cf\u53ef\u4ee5\u5361\u6389$prim$\u548c\u90e8\u5206\u53ea\u8bb0\u5f55\u96c6\u5408\u7684\u72b6\u538b$dp$\u3002 \u6240\u4ee5\u8981\u8003\u8651\u6bcf\u4e2a\u70b9\u5230\u521d\u59cb\u70b9\u7684\u6df1\u5ea6\u3002 \u8bbe$f[i][j][S]$\u8868\u793a\u5728\u6df1\u5ea6\u4e3a$i$\u7684\u70b9$j$\u65f6\u4e00\u5171\u6316\u4e86$S$\u4e2d\u6240\u6709\u5b9d\u85cf\u7684\u6700\u5c0f\u82b1\u8d39\u3002 \u5047\u8bbe\u5f53\u524d\u8981\u66f4\u65b0\u7684\u96c6\u5408$s$\u4e2d\u5305\u542b\u4e86\u4e0e$j$\u8fde\u63a5\u7684$k$\u70b9\uff0c\u800c$j$\u5219\u5728$s$\u5173\u4e8e$S$\u7684\u8865\u96c6$_S$\u4e2d\u3002 \u90a3\u4e48\u8f6c\u79fb\u65b9\u7a0b\uff1a $$ f[i][j][S]=\\min(f[i][j][S]\uff0cd[j][k]* (i+1)+f[i][j][_S]+f[i+1][k][s]) $$ \u8fd9\u6709\u70b9\u50cf\u6811\u5f62\u80cc\u5305$dp$\u7684\u8f6c\u79fb\u65b9\u7a0b\u3002 \u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u7528\u8bb0\u5fc6\u5316\u641c\u7d22\u7684\u65b9\u5f0f\u6765\u5b9e\u73b0\u5b83\u5566! #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=13,M=1e3+10,INF=0x3f3f3f3f; int f[N][N][1<<N]; int d[N][N],D[N][N],head[N],sz[1<<N]; int n,m,v,u,w,ans,cnt; struct edge { int v,w,nxt; } e[M<<1]; int read1() { int x=0; char ch=getchar(); while(ch>'9' || ch<'0')ch=getchar(); while(ch<='9' && ch>='0')x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x) { if(x>9)write1(x/10); putchar(x%10+'0'); } void add(int u,int v,int w) { e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void init() { for(int i=1; i<=n; ++i) { for(int j=1; j<=n; ++j) { if(i==j)continue; if(d[i][j]<INF)D[i][++D[i][0]]=j; } } } int dfs(int i,int j,int S) { if(f[i][j][S]<INF)return f[i][j][S]; if(S==(1<<(j-1)))return f[i][j][S]=0; if(sz[S]>n-i)return f[i][j][S]=INF; if(sz[S]<=1)return f[i][j][S]=0; for(int s=S; s; s=(s-1)&S) { int _S=S^s; if(((1<<(j-1))&s))continue; int tmp=dfs(i,j,_S); if(tmp>=f[i][j][S])continue; for(int o=1; o<=D[j][0]; ++o) { int k=D[j][o]; if((1<<(k-1))&s) f[i][j][S]=min(f[i][j][S],d[j][k]*(i+1)+tmp+dfs(i+1,k,s)); } } return f[i][j][S]; } int main() { //freopen(\"P3959_17.in\",\"r\",stdin); ans=INF; memset(head,-1,sizeof head); cnt=-1; memset(d,0x3f,sizeof d); n=read1(),m=read1(); for (int i=1; i<(1<<n); ++i) sz[i]=sz[i&(i-1)]+1;// for(int i=1; i<=m; ++i) u=read1(),v=read1(),w=read1(),add(u,v,w),add(v,u,w),d[u][v]=min(d[u][v],w),d[v][u]=min(d[v][u],w); init(); for(int o=1; o<=n; ++o) { memset(f,0x3f,sizeof f); ans=min(ans,dfs(0,o,(1<<n)-1)); } write1(ans); return 0; } ~~\u7136\u540e\u5c31T\u4e86~~ \u6ce8\u610f\uff0c\u4e0a\u8ff0\u4ee3\u7801\u4e2d\u5305\u542b\u4e86\u5feb\u8bfb\u5feb\u5199\uff0c\u9884\u5904\u7406$j$\u7684\u679a\u4e3e\u91cf$k$,\u8bb0\u5fc6\u5316\u641c\u7d22\u81ea\u5e26\u7684\u526a\u679d\uff0c\u6700\u4f18\u6027\u526a\u679d($f[i][j][_S]<f[i][j][S]$)\uff0c\u975e\u6cd5\u72b6\u6001\u526a\u679d\u7b49\u4e00\u7cfb\u5217\u5361\u5e38\u65b9\u6cd5\uff0c\u4f46\u5bf9\u4e8e$n=12$\u7684\u6570\u636e\u8fd8\u8981\u8dd1$3s$\u4ee5\u4e0a\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u4e0d\u8981\u9012\u5f52\uff0c\u53ea\u8981\u9012\u63a8\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=13,M=1e3+10,INF=0x3f3f3f3f; int f[N][N][1<<N]; int d[N][N],D[N][N],head[N],sz[1<<N]; int n,m,v,u,w,ans,cnt; struct edge { int v,w,nxt; } e[M<<1]; int read1() { int x=0; char ch=getchar(); while(ch>'9' || ch<'0')ch=getchar(); while(ch<='9' && ch>='0')x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x) { if(x>9)write1(x/10); putchar(x%10+'0'); } void add(int u,int v,int w) { e[++cnt].v=v,e[cnt].w=w,e[cnt].nxt=head[u],head[u]=cnt; } void init() { for(int i=1; i<=n; ++i) { for(int j=1; j<=n; ++j) { if(i==j)continue; if(d[i][j]<INF)D[i][++D[i][0]]=j; } } } void dp() { memset(f,0x3f,sizeof f); for(int i=1; i<=n; ++i)f[n-1][i][1<<(i-1)]=0; for(int i=n-2; i>=0; --i) { for(int j=1; j<=n; ++j) { f[i][j][1<<(j-1)]=0; for(int S=1; S<(1<<n); ++S) { if(sz[S]>n-i)continue; for(int s=S; s; s=(s-1)&S) { int _S=S^s; if(((1<<(j-1))&s))continue; if(sz[s]>n-i-1)continue; if(f[i][j][_S]>=f[i][j][S])continue; for(int o=1; o<=D[j][0]; ++o) { int k=D[j][o]; if((1<<(k-1))&s) f[i][j][S]=min(f[i][j][S],d[j][k]*(i+1)+f[i][j][_S]+f[i+1][k][s]); } } } } } } int main() { //freopen(\"P3959_15.in\",\"r\",stdin); ans=INF; memset(head,-1,sizeof head); cnt=-1; memset(d,0x3f,sizeof d); n=read1(),m=read1(); for (int i=1; i<(1<<n); ++i) sz[i]=sz[i&(i-1)]+1;// for(int i=1; i<=m; ++i) u=read1(),v=read1(),w=read1(),add(u,v,w),add(v,u,w),d[u][v]=min(d[u][v],w),d[v][u]=min(d[v][u],w); init(); dp(); for(int i=1; i<=n; ++i)ans=min(ans,f[0][i][(1<<n)-1]); write1(ans); return 0; } \u6ce8\u610f\u8d77\u59cb\u72b6\u6001\u4e3a\u96c6\u5408\u4e2d\u53ea\u6709\u4e00\u4e2a\u70b9\u7684\u72b6\u6001\uff0c\u6b64\u65f6\u7b54\u6848\u4e3a$0$ \u9012\u63a8\u7684\u597d\u5904\u5728\u4e8e\uff0c\u4e0d\u9700\u8981\u679a\u4e3e\u5f53\u524d\u7684\u521d\u59cb\u70b9\u5177\u4f53\u662f\u54ea\u4e2a\uff0c\u800c\u662f\u53ef\u4ee5\u4e00\u5f00\u59cb\u9884\u5904\u7406\u4e3a$0$\u540e\u4e00\u8d77\u8f6c\u79fb\u3002 P2150 \u6ce8\u610f\u5230\u4e00\u4e2a\u6027\u8d28\uff0c\u5047\u8bbe$S_1,S_2$\u8868\u793a\u7532\u4e59\u9009\u62e9\u7684\u6240\u6709\u6570\u7684\u8d28\u56e0\u6570\u96c6\u5408\uff0c\u90a3\u4e48$S_1,S_2$\u4e0d\u80fd\u6709\u4ea4\u96c6. \u90a3\u4e48\u5bf9\u4e8e$n<=30$\uff0c\u8d28\u56e0\u6570\u79cd\u7c7b\u5f88\u5c11\uff0c\u53ef\u4ee5\u72b6\u538b$dp$. \u8bbe$f[S_1][S_2]$\u8868\u793a\u7532\u4e59\u8d28\u56e0\u6570\u96c6\u5408\u4e3a$S_1,S_2$\u65f6\u7684\u65b9\u6848\u6570\u3002 \u8fb9\u754c$f[0][0]=1$,$S$\u8868\u793a$2-n$\u6bcf\u4e2a\u6570\u7684\u8d28\u56e0\u6570\u96c6\u5408\uff0c\u8f6c\u79fb\u65b9\u7a0b: $$ f[j|S][k]+=f[j][k]\\times (S\\&k==0),f[j][k|S]+=f[j][k]\\times (S\\&j==0),j\\& k ==0 $$ \u800c\u5bf9\u4e8e$n<=500$,\u53d1\u73b0\u6bcf\u4e2a\u6570\u5927\u4e8e$22$\u7684\u8d28\u56e0\u6570\u53ea\u6709\u4e00\u4e2a\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u4e00\u4e2a\u7ed3\u6784\u4f53$(o,b,S)$\u8868\u793a\u6bcf\u4e2a\u6570\u7684\u539f\u6570\uff0c\u5927\u8d28\u56e0\u6570\u548c\u5c0f\u8d28\u56e0\u6570\u96c6\u5408\u3002 \u8fd9\u6837\uff0c\u5c06\u5927\u8d28\u56e0\u6570\u76f8\u540c\u7684\u6570\u5206\u7ec4\u8f6c\u79fb\uff0c\u5373\u5bf9\u4e8e\u5927\u8d28\u56e0\u6570\u6392\u4e2a\u5e8f\u3002(\u987a\u5e8f\u65e0\u6240\u8c13) \u4e4b\u540e\uff0c\u5f00\u4e24\u4e2a\u4e34\u65f6\u6570\u7ec4$f1[S_1][S_2],f2[S_1][S_2]$\u5206\u522b\u8868\u793a\u4e00\u4e2a\u6570\u7532\u6216\u8005\u4e59\u9009\u65f6\u7684\u65b9\u6848\u6570\u3002 \u8f6c\u79fb\u4e0e\u4e0a\u9762\u7684\u7c7b\u4f3c\u3002 \u6bcf\u5f53\u4e00\u7ec4\u8f6c\u79fb\u7ed3\u675f\uff0c\u5c31\u66f4\u65b0\u4e00\u904d$f$\u6570\u7ec4\u3002 \u6ce8\u610f$f1,f2$\u4e2d\u4e0d\u5305\u542b\u7532\u4e59\u9009\u62e9\u540c\u4e00\u4e2a\u6570\uff0c\u4f46\u5305\u542b\u4e86\u7532\u4e59\u90fd\u4e0d\u9009\u540c\u4e00\u4e2a\u6570\u7684\u60c5\u51b5\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u76f4\u63a5$f[j][k]=f1[j][k]+f2[j][k]$,\u90fd\u4e0d\u9009\u7684\u60c5\u51b5\u4f1a\u91cd\u590d\uff0c\u6240\u4ee5\u518d\u51cf\u53bb\u4e00\u4e2a$f[j][k]$\u5373\u53ef\u3002 #include<bits/stdc++.h> #define int long long using namespace std; const int N=510,M=266; int p[9]= {0,2,3,5,7,11,13,17,19}; int n,P,ans; int f[M][M],f1[M][M],f2[M][M]; struct node { int o,b,S; void init() { S=0; int tmp=o; for(int i=1; i<=8; ++i) while(tmp%p[i]==0) S|=(1<<(i-1)),tmp/=p[i]; if(tmp>1) b=tmp; else b=-1; } } a[N]; bool cmp(node a,node b) { return a.b<b.b; } signed main() { scanf(\"%lld%lld\",&n,&P); for(int i=1; i<n; ++i) a[i].o=i+1,a[i].init(); sort(a+1,a+n,cmp); f[0][0]=1; for(int i=1; i<n; ++i) { int S=a[i].S; if(i==1 || a[i].b!=a[i-1].b || a[i].b==-1) memcpy(f1,f,sizeof f1),memcpy(f2,f,sizeof f2); for(int j=255; j>=0; --j) for(int k=255; k>=0; --k) if((j&k)==0) f2[j][k|S]=(f2[j][k|S]+((S&j)==0)*f2[j][k])%P,f1[j|S][k]=(f1[j|S][k]+((S&k)==0)*f1[j][k])%P; if(i==n-1 || a[i].b!=a[i+1].b || a[i].b==-1) { for(int j=0; j<=255; ++j) for(int k=0; k<=255; ++k) if((j&k)==0) f[j][k]=(f1[j][k]+f2[j][k]-f[j][k]+P)%P; } } ans=0; for(int j=0; j<=255; ++j) for(int k=0; k<=255; ++k) if((j&k)==0 && f[j][k]) ans=(ans+f[j][k])%P; printf(\"%lld\",ans%P); return 0; } P7519 \u66b4\u529b\u641c\u7d22 \u53ef\u4ee5\u7528\u8d2a\u5fc3\u89e3\u51b3\u6bcf\u4e2a\u961f\u4f0d\u7684\u8fc7\u9898\u6570$b[i]$\uff0c\u5373$b[j]=a[i]+b[i]+(i<j)-a[j]$. \u8fd9\u6837\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053\u5269\u4f59\u7684\u9898\u6570$m$,\u4e0a\u4e00\u4e2a\u961f\u4f0d\u7684$b[j]$\u548c\u4e0a\u4e2a\u961f\u4f0d\u7684\u7f16\u53f7$j$\u5373\u53ef\u8f6c\u79fb\u3002 #include<bits/stdc++.h> using namespace std; typedef long long ll; const int N=100,M=110; int a[N],b[N],vis[N]; int top,n,m; ll ans; bool cmp(int x,int y) { if(a[x]==a[y]) return x<y; return a[x]>a[y]; } void dfs(int dep,int res,int lst,int b) { if(res<0) return; if(dep>n) { if(res>=0) ++ans; return; } for(int i=1; i<=n; ++i) { if(vis[i]) continue; vis[i]=1; int tmp=max(b,a[lst]+b-a[i]+(i>lst)); dfs(dep+1,res-tmp,i,tmp); vis[i]=0; } } int main() { scanf(\"%d%d\",&n,&m); for(int i=1; i<=n; ++i) scanf(\"%d\",&a[i]),b[i]=i; sort(b+1,b+n+1,cmp); dfs(1,m,b[1],0); printf(\"%lld\",ans); return 0; } \u590d\u6742\u5ea6$O(nn!)$ \u66b4\u529b\u72b6\u538b \u7528$f[S][i][j][k][l]$\u8868\u793a\u5f53\u524d\u96c6\u5408\u4e3a$S$,\u8003\u8651\u5230\u7b2c$i$\u4e2a\u961f\u4f0d\uff0c\u5f53\u524d\u5269\u4f59\u9898\u6570\u4e3a$j$\uff0c\u4e0a\u4e00\u4e2a\u961f\u4f0d\u7f16\u53f7\u4e3a$k$,\u4e0a\u4e00\u4e2a\u961f\u4f0d\u8fc7\u9898\u6570\u4e3a$l$\u65f6\u7684\u65b9\u6848\u6570\u3002 \u90a3\u4e48\u6211\u4eec\u76f4\u63a5\u5c06\u4e0a\u9762\u7684\u641c\u7d22\u6539\u6210\u8bb0\u5fc6\u5316\u641c\u7d22\u5373\u53ef\u3002 \u590d\u6742\u5ea6$O(2^nn^2m^2)$ ~~\u8fd8\u4e0d\u5982\u66b4\u529b\u641c\u7d22~~ 3.\u4f18\u5316\u72b6\u538b \u663e\u7136\u5c06\u9012\u5f52\u6539\u6210\u9012\u63a8\u80fd\u4f18\u5316\u6389$i$\u90a3\u4e00\u7ef4\uff0c\u800c\u6709\u4e86\u4e0a\u9762\u7684\u601d\u8def\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u8003\u8651\u518d\u4f18\u5316\u6389$l$\u90a3\u4e00\u7ef4. \u7531\u4e8e$b[i]$\u5355\u8c03\u4e0d\u964d\uff0c\u6240\u4ee5\u5982\u679c\u4e00\u4e2a\u961f\u4f0d\u7684$b[i]$\u5df2\u7ecf\u786e\u5b9a\uff0c\u90a3\u4e48\u540e\u9762\u7684\u961f\u4f0d$b[j]$\u90fd\u8981\u5927\u4e8e\u7b49\u4e8e$b[i]$\u3002\u6240\u4ee5\u76f8\u5f53\u4e8e\u4e00\u5c42\u4e00\u5c42\u7684\u52a0\u4e0a\u65b0\u7684\u8d21\u732e$\\Delta b=b[j]-b[i]$,\u800c\u4e2a\u6570\u4e3a$n-|S|$,\u6240\u4ee5\u6d88\u8017\u7684\u8fc7\u9898\u6570\u4e3a$\\Delta b\\times (n-|S|)$. \u6240\u4ee5\u8bb0$d[i][j]$\u8868\u793a\u5982\u679c$j$\u8981\u8d85\u8d8a$i$\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002 \u8f6c\u79fb\u5982\u4e0b\uff1a for(int i=1;i<=n;++i) for(int j=1;j<=n;++j) d[i][j]=max(0,a[i]-a[j]+(i<j)); \u8fd9\u6837\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u961f\u4f0d\u5bf9\u540e\u9762\u6240\u6709\u961f\u4f0d\u90fd\u4ea7\u751f\u5f71\u54cd\u3002 \u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u7528$f[S][i][j]$\u8868\u793a\u5f53\u524d\u96c6\u5408\u4e3a$S$,\u4e0a\u4e00\u4e2a\u961f\u4f0d\u4e3a$i$,\u5269\u4f59\u9898\u6570\u4e3a$j$\u65f6\u7684\u65b9\u6848\u6570\u3002 \u8f6c\u79fb\u65b9\u7a0b\uff1a $$ \u5bf9\u4e8ei,j\\in S,i\\not \\in A,j\\in A,k\\in [d[j][i]\\times(n-|A|),m],\u6709\\ f[S][i][k]+=f[A][j][k-d[j][i]\\times(n-|A|)] $$ \u5bf9\u4e8e\u521d\u59cb\u8fb9\u754c\uff0c\u56e0\u4e3a\u8981\u4fdd\u8bc1\u7b2c\u4e00\u4e2a\u6570\u7684$b[i]$\u80fd\u591f\u8d85\u8d8a$a_{\\max}$,\u6240\u4ee5 $f[1<<(i-1)][i][d[pos][i]\\times n]=1$ \u6700\u7ec8\u7b54\u6848\u4e3a$\\sum_{i=1}^n \\sum_{j=1}^{m}f[T][i][j]$,$T$\u8868\u793a\u5168\u96c6\u3002 #include<bits/stdc++.h> #define int long long using namespace std; const int N=14,M=550; int a[N],d[N][N],popcnt[1<<N],s[N]; int ans,n,m,T,tmp; int f[1<<N][N][M]; void init(){ int pos=0,maxn=0; T=(1<<n)-1; for(int i=1;i<=n;++i){ for(int j=1;j<=n;++j) d[i][j]=max(0ll,a[i]-a[j]+(i<j)); if(maxn<a[i] || (maxn==a[i] && pos>i)) maxn=a[i],pos=i; } for(int i=1;i<=T;++i) popcnt[i]=popcnt[i>>1]+(i&1); for(int i=1;i<=n;++i){ int tmp=d[pos][i]*n; if(tmp<=m) f[1<<(i-1)][i][tmp]=1; } } void dp(){ for(int S=0;S<=T;++S){ for(int i=1;i<=n;++i){ if(S&(1<<(i-1))){ int A=S^(1<<(i-1)); for(int j=1;j<=n;++j){ if((i!=j) && (S&(1<<(j-1)))){ int tmp=d[j][i]*(n-popcnt[A]); for(int k=tmp;k<=m;++k) f[S][i][k]+=f[A][j][k-tmp]; } } } } } for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) ans+=f[T][i][j]; printf(\"%lld\",ans); } signed main() { scanf(\"%lld%lld\",&n,&m); for(int i=1; i<=n; ++i) scanf(\"%lld\",&a[i]); init(); dp(); return 0; }","title":"\u6700\u4f18\u89e3\u7c7b"},{"location":"my%20past/OI/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/","text":"\u77e9\u9635\u4e58\u6cd5 P3328 \u795e\u9898\uff0c\u7ebf\u6bb5\u6811+\u77e9\u9635\u4e58\u6cd5 1. \u77e9\u9635\u4e58\u6cd5\u9884\u5904\u7406 \u9996\u5148\uff0c\u8bbe$f[i]=F[a[i]]$\uff0c\u800c\u8fd9\u4e2a\u53ef\u4ee5\u7528$3\\times 3$\u77e9\u9635\u9884\u5904\u7406\u51fa\u6765\u3002 \u5177\u4f53\u5730\uff0c\u8bbe\u4e09\u5143\u5411\u91cf$[f_{k+2},f_{k+1},1]$\uff0c\u5219\u6709\u9012\u63a8\u5f0f $$[f_{k+2},f_{k+1},1]=[f_{k+1},f_k,1]\\times\\left[ \\begin{array}{lll}1 & 1& 0\\a & 0 & 0\\b& 0 & 1 \\end{array} \\right]$$ \u5219 $$[f_{k+2},f_{k+1},1]=[2,1,1]\\times\\left[ \\begin{array}{lll}1 & 1& 0\\a & 0 & 0\\b& 0 & 1 \\end{array} \\right]^k$$ 2. \u7ebf\u6bb5\u6811\u7ef4\u62a4 \u6709\u4e86$f[i]$\u6570\u7ec4\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e86\u3002 \u6bcf\u4e2a\u7ebf\u6bb5\u6811\u8282\u70b9\u5efa\u4e24\u4e2a\u4e8c\u7ef4$3\\times 3$\u6570\u7ec4\uff0c$sum$\u548c$data$,\u5206\u522b\u7ef4\u62a4\uff1a $$sum: \\left[\\begin{array}{l}f_{a_{i-1}-1} & f_{a_{i-1}}& f_{a_{i-1}+1}\\ f_{a_{i+1}-1}& f_{a_{i+1}}& f_{a_{i+1}+1}\\end{array}\\right] \\ data:\\left[\\begin{array}{l}f_{a_{i-1}-1}\\times f_{a_{i+1}-1}& f_{a_{i-1}-1}\\times f_{a_{i+1}}& f_{a_{i-1}-1}\\times f_{a_{i+1}+1}\\ f_{a_{i-1}}\\times f_{a_{i+1}-1}& f_{a_{i}-1}\\times f_{a_{i+1}}& f_{a_{i-1}}\\times f_{a_{i+1}+1}\\ f_{a_{i-1}+1}\\times f_{a_{i+1}-1}& f_{a_{i-1}+1}\\times f_{a_{i+1}}& f_{a_{i-1}+1}\\times f_{a_{i+1}+1}\\ \\end{array}\\right] $$ \u8fd9\u6837\uff0c\u6bcf\u6b21\u9047\u5230$+1,-1$\u64cd\u4f5c\u65f6\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528\u73b0\u6709\u7684\u503c\u6c42\u51fa\u672a\u77e5\u91cf\u3002 \u540c\u65f6\uff0c\u56e0\u4e3a\u540c\u4e00\u4e2a\u533a\u95f4\u5bf9$a_{i-1},a_{i+1}$\u7684\u5f71\u54cd\u4e0d\u540c\uff0c\u6bcf\u4e2a$[l,r]$\u66f4\u6539\u4f1a\u5bf9$[l+1,r+1]$\u7684$a_{i-1}$\u8fdb\u884c\u66f4\u6539\uff0c\u800c\u5bf9$[l-1,r-1]$\u7684$a_{i+1}$\u8fdb\u884c\u66f4\u6539\u3002 \u6240\u4ee5\u6211\u4eec\u6bcf\u6b21\u66f4\u6539\u4e24\u6b21\uff0c\u8bb0\u5f55\u4e00\u4e2a$t$\uff0c\u8868\u793a\u662f\u6539$a_{i-1}$\u8fd8\u662f$a_{i+1}$. \u5bf9\u4e8e\u52a0\u64cd\u4f5c\uff0c\u6709$f_{k+2}=f_{k+1}+a\\times f_k+b$: void add(int i,int t) { int l=tre[i].l,r=tre[i].r;ll w=r-l+1; for(int k=0; k<=1; ++k) _s(i,t,k)=_s(i,t,k+1); _s(i,t,2)=(_s(i,t,1)+a*_s(i,t,0)%P+b*w%P)%P; if(t==0) { //a[i-1] for(int k=0; k<=2; ++k) for(int j=0; j<=1; ++j) _d(i,j,k)=_d(i,j+1,k); for(int k=0; k<=2; ++k) _d(i,2,k)=(_d(i,1,k)+_d(i,0,k)*a%P+b*_s(i,1,k)%P)%P; } else { for(int j=0; j<=2; ++j) for(int k=0; k<=1; ++k) _d(i,j,k)=_d(i,j,k+1); for(int j=0; j<=2; ++j) _d(i,j,2)=(_d(i,j,1)+a*_d(i,j,0)%P+b*_s(i,0,j)%P)%P; }//a[i+1] return; } \u6ce8\u610f\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\uff0c\u6240\u4ee5$b$\u8981\u4e58\u4ee5\u533a\u95f4\u957f$r-l+1$ \u5bf9\u4e8e\u51cf\u64cd\u4f5c\u9700\u8981\u89e3\u65b9\u7a0b\u6c42\u51fa$f_k$\u3002 $f_k=\\left{\\begin{array}{r}\\frac{f_{k+2}-f_{k+1}-b}{a} (a\\not =0) \\ f_{k+1}-b (a=0) \\end{array} \\right.$ \u5219\u5bf9\u4e8e$a$\u7279\u5224\uff0c\u6709\uff1a void del(int i,int t) { int l=tre[i].l,r=tre[i].r;ll w=r-l+1; if(a==0){ for(int k=2;k>=1;--k) _s(i,t,k)=_s(i,t,k-1); _s(i,t,0)=(_s(i,t,1)-b*w%P+P)%P; if(t==0){//a[i-1] for(int k=0;k<=2;++k) for(int j=2;j>=1;--j) _d(i,j,k)=_d(i,j-1,k); for(int k=0;k<=2;++k) _d(i,0,k)=(_d(i,1,k)-b*_s(i,1,k)%P+P)%P; }else{//a[i+1] for(int j=0;j<=2;++j) for(int k=2;k>=1;--k) _d(i,j,k)=_d(i,j,k-1); for(int j=0;j<=2;++j) _d(i,j,0)=(_d(i,j,1)-b*_s(i,0,j)%P+P)%P; } }else{ for(int k=2;k>=1;--k) _s(i,t,k)=_s(i,t,k-1); _s(i,t,0)=(_s(i,t,2)-_s(i,t,1)+P-b*w%P+P)%P*inva%P; if(t==0){//a[i-1] for(int k=0;k<=2;++k) for(int j=2;j>=1;--j) _d(i,j,k)=_d(i,j-1,k); for(int k=0;k<=2;++k) _d(i,0,k)=(_d(i,2,k)-_d(i,1,k)+P-b*_s(i,1,k)%P+P)%P*inva%P; }else{//a[i+1] for(int j=0;j<=2;++j) for(int k=2;k>=1;--k) _d(i,j,k)=_d(i,j,k-1); for(int j=0;j<=2;++j) _d(i,j,0)=(_d(i,j,2)-_d(i,j,1)+P-b*_s(i,0,j)%P+P)%P*inva%P; } } } \u90a3\u4e48\u6211\u4eec\u9700\u8981\u4e24\u4e2a$lazytag$\uff0c\u5206\u522b\u8868\u793a$a_{i-1}$\u548c$a_{i+1}$\u7684\u53d8\u5316\u91cf\u3002 $pushup$\u76f4\u63a5\u66b4\u529b\u5408\u5e76\uff0c$pushdown$\u4e5f\u76f4\u63a5\u8ba1\u7b97\u5373\u53ef\u3002 $change$\u9700\u8981\u533a\u5206$t$\uff0c$query$\u8fd4\u56de$data[2][0]$\u5373\u53ef\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u5b8c\u6574\u7684\u8fc7\u4e86\u4e00\u904d\u4e3b\u8981\u6d41\u7a0b\u3002 ~~\u5361\u5e38\u4e00\u76f4\u662f\u6211\u7684\u75db\uff0c\u6240\u4ee5\u4e00\u4e0b\u4ee3\u7801\u8981\u5438\u6c27\u624d\u80fd\u8fc7~~ #include<iostream> #include<cstdio> #include<cstring> #include<ctime> #define ls (i<<1) #define rs (i<<1|1) #define mid (l+r>>1) #define _s(i,j,k) tre[i].sum[j][k] #define _d(i,j,k) tre[i].data[j][k] #define ll long long using namespace std; const int N=3e5+10,P=1e9+7; struct ma { ll f[3][3]; int n,m; ma() { memset(f,0,sizeof f);n=m=0; } } s,t; int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(ll x){ if(x>9) write1(x/10); putchar(x%10+'0');return; } ma operator *(ma x,ma y) { ma z=ma(); int n=x.n,m=x.m,p=y.m; z.n=n,z.m=p; for(int i=0; i<n; ++i) for(int j=0; j<p; ++j) for(int k=0; k<m; ++k) z.f[i][j]=(z.f[i][j]+x.f[i][k]*y.f[k][j]%P)%P; return z; } struct tree { int l,r,tag[2]; ll sum[3][3],data[3][3]; } tre[N<<2]; int n,q,_l,_r,x,y; ll inva,a,b; ll f[N][3]; int A[N]; char ch[10],_c; ll kp(ll x,int p) { if(p==0) return 1; if(p==1) return x%P; if(p&1) return x*kp(x*x%P,p>>1)%P; else return kp(x*x%P,p>>1)%P; } ma Kp(ma x,int p) { if(p==1) return x; if(p&1) return x*Kp(x*x,p>>1); else return Kp(x*x,p>>1); } void initf() { inva=kp(a,P-2)%P; s.n=s.m=3; s.f[0][0]=s.f[0][1]=s.f[2][2]=1;s.f[1][0]=a;s.f[2][0]=b; t.n=1,t.m=3; t.f[0][0]=2;t.f[0][1]=t.f[0][2]=1; for(int i=1; i<=n; ++i) { if(A[i]==1) { f[i][0]=-P,f[i][1]=1,f[i][2]=2; } else if(A[i]==2) { f[i][0]=1,f[i][1]=2; f[i][2]=(f[i][1]+a*f[i][0]%P+b)%P; } else { ma tmp=t*Kp(s,A[i]-2); f[i][0]=tmp.f[0][1]; f[i][1]=tmp.f[0][0]; f[i][2]=(f[i][1]+a*f[i][0]%P+b)%P; } } } void pushup(int i) { for(int j=0; j<=1; ++j) for(int k=0; k<=2; ++k) _s(i,j,k)=(_s(ls,j,k)+_s(rs,j,k))%P; for(int j=0; j<=2; ++j) for(int k=0; k<=2; ++k) _d(i,j,k)=(_d(ls,j,k)+_d(rs,j,k))%P; } void build(int i,int l,int r) { tre[i].l=l,tre[i].r=r; if(l==r) { for(int k=0; k<=2; ++k) _s(i,0,k)=f[l-1][k]; for(int k=0; k<=2; ++k) _s(i,1,k)=f[l+1][k]; for(int j=0; j<=2; ++j) for(int k=0; k<=2; ++k) _d(i,j,k)=_s(i,0,j)*_s(i,1,k)%P; return; } int mid=l+r>>1; build(ls,l,mid); build(rs,mid+1,r); pushup(i);return; } void add(int i,int t) { int l=tre[i].l,r=tre[i].r;ll w=r-l+1; for(int k=0; k<=1; ++k) _s(i,t,k)=_s(i,t,k+1); _s(i,t,2)=(_s(i,t,1)+a*_s(i,t,0)%P+b*w%P)%P; if(t==0) { //a[i-1] for(int k=0; k<=2; ++k) for(int j=0; j<=1; ++j) _d(i,j,k)=_d(i,j+1,k); for(int k=0; k<=2; ++k) _d(i,2,k)=(_d(i,1,k)+_d(i,0,k)*a%P+b*_s(i,1,k)%P)%P; } else { for(int j=0; j<=2; ++j) for(int k=0; k<=1; ++k) _d(i,j,k)=_d(i,j,k+1); for(int j=0; j<=2; ++j) _d(i,j,2)=(_d(i,j,1)+a*_d(i,j,0)%P+b*_s(i,0,j)%P)%P; }//a[i+1] return; } void del(int i,int t) { int l=tre[i].l,r=tre[i].r;ll w=r-l+1; if(a==0){ for(int k=2;k>=1;--k) _s(i,t,k)=_s(i,t,k-1); _s(i,t,0)=(_s(i,t,1)-b*w%P+P)%P; if(t==0){//a[i-1] for(int k=0;k<=2;++k) for(int j=2;j>=1;--j) _d(i,j,k)=_d(i,j-1,k); for(int k=0;k<=2;++k) _d(i,0,k)=(_d(i,1,k)-b*_s(i,1,k)%P+P)%P; }else{//a[i+1] for(int j=0;j<=2;++j) for(int k=2;k>=1;--k) _d(i,j,k)=_d(i,j,k-1); for(int j=0;j<=2;++j) _d(i,j,0)=(_d(i,j,1)-b*_s(i,0,j)%P+P)%P; } }else{ for(int k=2;k>=1;--k) _s(i,t,k)=_s(i,t,k-1); _s(i,t,0)=(_s(i,t,2)-_s(i,t,1)+P-b*w%P+P)%P*inva%P; if(t==0){//a[i-1] for(int k=0;k<=2;++k) for(int j=2;j>=1;--j) _d(i,j,k)=_d(i,j-1,k); for(int k=0;k<=2;++k) _d(i,0,k)=(_d(i,2,k)-_d(i,1,k)+P-b*_s(i,1,k)%P+P)%P*inva%P; }else{//a[i+1] for(int j=0;j<=2;++j) for(int k=2;k>=1;--k) _d(i,j,k)=_d(i,j,k-1); for(int j=0;j<=2;++j) _d(i,j,0)=(_d(i,j,2)-_d(i,j,1)+P-b*_s(i,0,j)%P+P)%P*inva%P; } } } void calc(int i,int t,int c) { if(!c) return; if(c>0) for(int k=1; k<=c; ++k) add(i,t); else for(int k=1; k<=-c; ++k) del(i,t); } void pushdown(int i) { int l=tre[i].l,r=tre[i].r,c=tre[i].tag[0],d=tre[i].tag[1]; if(!c && !d) return; tre[ls].tag[0]+=c;tre[ls].tag[1]+=d; tre[rs].tag[0]+=c;tre[rs].tag[1]+=d; calc(ls,0,c);calc(ls,1,d); calc(rs,0,c);calc(rs,1,d); tre[i].tag[0]=tre[i].tag[1]=0; } void change(int i,int el,int er,int t,int c) { int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) { tre[i].tag[t]+=c; calc(i,t,c); return; } pushdown(i); if(el<=mid) change(ls,el,er,t,c); if(er>mid) change(rs,el,er,t,c); pushup(i); return; } ll query(int i,int el,int er) { int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) return _d(i,2,0); ll ans=0; pushdown(i); if(el<=mid) ans=(ans+query(ls,el,er))%P; if(er>mid) ans=(ans+query(rs,el,er))%P; return ans; } int main() { n=read1(),q=read1(),a=(long long)read1(),b=(long long)read1(); for(int i=1; i<=n; ++i) A[i]=read1(); initf(); build(1,1,n); for(int i=1; i<=q; ++i) { scanf(\"%s\",ch);_l=read1(),_r=read1(); if(ch[0]=='q') { if(_l+1<=_r-1) write1(query(1,_l+1,_r-1)),putchar('\\n'); else putchar('0'),putchar('\\n'); } else if(ch[0]=='p') { x=_l+1,y=_r+1<n?_r+1:n;change(1,x,y,0,1); x=_l-1>1?_l-1:1,y=_r-1;change(1,x,y,1,1); } else { //m x=_l+1,y=_r+1<n?_r+1:n;change(1,x,y,0,-1); x=_l-1>1?_l-1:1,y=_r-1;change(1,x,y,1,-1); } } return 0; } ~~\u5b66\u6d41\u7a0b\u7528\u4e86\u4e00\u5929\u534a\uff0c\u5199\u4ee3\u7801\u4e0d\u5230\u4e24\u5c0f\u65f6\u5199\u4e86\u4e24\u767e\u884c\uff0c\u6240\u4ee5\u601d\u8def\u6e05\u6670\u662f\u975e\u5e38\u91cd\u8981\u7684\u3002~~","title":"\u77e9\u9635\u4e58\u6cd5"},{"location":"my%20past/OI/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/#_1","text":"P3328 \u795e\u9898\uff0c\u7ebf\u6bb5\u6811+\u77e9\u9635\u4e58\u6cd5 1. \u77e9\u9635\u4e58\u6cd5\u9884\u5904\u7406 \u9996\u5148\uff0c\u8bbe$f[i]=F[a[i]]$\uff0c\u800c\u8fd9\u4e2a\u53ef\u4ee5\u7528$3\\times 3$\u77e9\u9635\u9884\u5904\u7406\u51fa\u6765\u3002 \u5177\u4f53\u5730\uff0c\u8bbe\u4e09\u5143\u5411\u91cf$[f_{k+2},f_{k+1},1]$\uff0c\u5219\u6709\u9012\u63a8\u5f0f $$[f_{k+2},f_{k+1},1]=[f_{k+1},f_k,1]\\times\\left[ \\begin{array}{lll}1 & 1& 0\\a & 0 & 0\\b& 0 & 1 \\end{array} \\right]$$ \u5219 $$[f_{k+2},f_{k+1},1]=[2,1,1]\\times\\left[ \\begin{array}{lll}1 & 1& 0\\a & 0 & 0\\b& 0 & 1 \\end{array} \\right]^k$$ 2. \u7ebf\u6bb5\u6811\u7ef4\u62a4 \u6709\u4e86$f[i]$\u6570\u7ec4\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e86\u3002 \u6bcf\u4e2a\u7ebf\u6bb5\u6811\u8282\u70b9\u5efa\u4e24\u4e2a\u4e8c\u7ef4$3\\times 3$\u6570\u7ec4\uff0c$sum$\u548c$data$,\u5206\u522b\u7ef4\u62a4\uff1a $$sum: \\left[\\begin{array}{l}f_{a_{i-1}-1} & f_{a_{i-1}}& f_{a_{i-1}+1}\\ f_{a_{i+1}-1}& f_{a_{i+1}}& f_{a_{i+1}+1}\\end{array}\\right] \\ data:\\left[\\begin{array}{l}f_{a_{i-1}-1}\\times f_{a_{i+1}-1}& f_{a_{i-1}-1}\\times f_{a_{i+1}}& f_{a_{i-1}-1}\\times f_{a_{i+1}+1}\\ f_{a_{i-1}}\\times f_{a_{i+1}-1}& f_{a_{i}-1}\\times f_{a_{i+1}}& f_{a_{i-1}}\\times f_{a_{i+1}+1}\\ f_{a_{i-1}+1}\\times f_{a_{i+1}-1}& f_{a_{i-1}+1}\\times f_{a_{i+1}}& f_{a_{i-1}+1}\\times f_{a_{i+1}+1}\\ \\end{array}\\right] $$ \u8fd9\u6837\uff0c\u6bcf\u6b21\u9047\u5230$+1,-1$\u64cd\u4f5c\u65f6\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528\u73b0\u6709\u7684\u503c\u6c42\u51fa\u672a\u77e5\u91cf\u3002 \u540c\u65f6\uff0c\u56e0\u4e3a\u540c\u4e00\u4e2a\u533a\u95f4\u5bf9$a_{i-1},a_{i+1}$\u7684\u5f71\u54cd\u4e0d\u540c\uff0c\u6bcf\u4e2a$[l,r]$\u66f4\u6539\u4f1a\u5bf9$[l+1,r+1]$\u7684$a_{i-1}$\u8fdb\u884c\u66f4\u6539\uff0c\u800c\u5bf9$[l-1,r-1]$\u7684$a_{i+1}$\u8fdb\u884c\u66f4\u6539\u3002 \u6240\u4ee5\u6211\u4eec\u6bcf\u6b21\u66f4\u6539\u4e24\u6b21\uff0c\u8bb0\u5f55\u4e00\u4e2a$t$\uff0c\u8868\u793a\u662f\u6539$a_{i-1}$\u8fd8\u662f$a_{i+1}$. \u5bf9\u4e8e\u52a0\u64cd\u4f5c\uff0c\u6709$f_{k+2}=f_{k+1}+a\\times f_k+b$: void add(int i,int t) { int l=tre[i].l,r=tre[i].r;ll w=r-l+1; for(int k=0; k<=1; ++k) _s(i,t,k)=_s(i,t,k+1); _s(i,t,2)=(_s(i,t,1)+a*_s(i,t,0)%P+b*w%P)%P; if(t==0) { //a[i-1] for(int k=0; k<=2; ++k) for(int j=0; j<=1; ++j) _d(i,j,k)=_d(i,j+1,k); for(int k=0; k<=2; ++k) _d(i,2,k)=(_d(i,1,k)+_d(i,0,k)*a%P+b*_s(i,1,k)%P)%P; } else { for(int j=0; j<=2; ++j) for(int k=0; k<=1; ++k) _d(i,j,k)=_d(i,j,k+1); for(int j=0; j<=2; ++j) _d(i,j,2)=(_d(i,j,1)+a*_d(i,j,0)%P+b*_s(i,0,j)%P)%P; }//a[i+1] return; } \u6ce8\u610f\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\uff0c\u6240\u4ee5$b$\u8981\u4e58\u4ee5\u533a\u95f4\u957f$r-l+1$ \u5bf9\u4e8e\u51cf\u64cd\u4f5c\u9700\u8981\u89e3\u65b9\u7a0b\u6c42\u51fa$f_k$\u3002 $f_k=\\left{\\begin{array}{r}\\frac{f_{k+2}-f_{k+1}-b}{a} (a\\not =0) \\ f_{k+1}-b (a=0) \\end{array} \\right.$ \u5219\u5bf9\u4e8e$a$\u7279\u5224\uff0c\u6709\uff1a void del(int i,int t) { int l=tre[i].l,r=tre[i].r;ll w=r-l+1; if(a==0){ for(int k=2;k>=1;--k) _s(i,t,k)=_s(i,t,k-1); _s(i,t,0)=(_s(i,t,1)-b*w%P+P)%P; if(t==0){//a[i-1] for(int k=0;k<=2;++k) for(int j=2;j>=1;--j) _d(i,j,k)=_d(i,j-1,k); for(int k=0;k<=2;++k) _d(i,0,k)=(_d(i,1,k)-b*_s(i,1,k)%P+P)%P; }else{//a[i+1] for(int j=0;j<=2;++j) for(int k=2;k>=1;--k) _d(i,j,k)=_d(i,j,k-1); for(int j=0;j<=2;++j) _d(i,j,0)=(_d(i,j,1)-b*_s(i,0,j)%P+P)%P; } }else{ for(int k=2;k>=1;--k) _s(i,t,k)=_s(i,t,k-1); _s(i,t,0)=(_s(i,t,2)-_s(i,t,1)+P-b*w%P+P)%P*inva%P; if(t==0){//a[i-1] for(int k=0;k<=2;++k) for(int j=2;j>=1;--j) _d(i,j,k)=_d(i,j-1,k); for(int k=0;k<=2;++k) _d(i,0,k)=(_d(i,2,k)-_d(i,1,k)+P-b*_s(i,1,k)%P+P)%P*inva%P; }else{//a[i+1] for(int j=0;j<=2;++j) for(int k=2;k>=1;--k) _d(i,j,k)=_d(i,j,k-1); for(int j=0;j<=2;++j) _d(i,j,0)=(_d(i,j,2)-_d(i,j,1)+P-b*_s(i,0,j)%P+P)%P*inva%P; } } } \u90a3\u4e48\u6211\u4eec\u9700\u8981\u4e24\u4e2a$lazytag$\uff0c\u5206\u522b\u8868\u793a$a_{i-1}$\u548c$a_{i+1}$\u7684\u53d8\u5316\u91cf\u3002 $pushup$\u76f4\u63a5\u66b4\u529b\u5408\u5e76\uff0c$pushdown$\u4e5f\u76f4\u63a5\u8ba1\u7b97\u5373\u53ef\u3002 $change$\u9700\u8981\u533a\u5206$t$\uff0c$query$\u8fd4\u56de$data[2][0]$\u5373\u53ef\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u5b8c\u6574\u7684\u8fc7\u4e86\u4e00\u904d\u4e3b\u8981\u6d41\u7a0b\u3002 ~~\u5361\u5e38\u4e00\u76f4\u662f\u6211\u7684\u75db\uff0c\u6240\u4ee5\u4e00\u4e0b\u4ee3\u7801\u8981\u5438\u6c27\u624d\u80fd\u8fc7~~ #include<iostream> #include<cstdio> #include<cstring> #include<ctime> #define ls (i<<1) #define rs (i<<1|1) #define mid (l+r>>1) #define _s(i,j,k) tre[i].sum[j][k] #define _d(i,j,k) tre[i].data[j][k] #define ll long long using namespace std; const int N=3e5+10,P=1e9+7; struct ma { ll f[3][3]; int n,m; ma() { memset(f,0,sizeof f);n=m=0; } } s,t; int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(ll x){ if(x>9) write1(x/10); putchar(x%10+'0');return; } ma operator *(ma x,ma y) { ma z=ma(); int n=x.n,m=x.m,p=y.m; z.n=n,z.m=p; for(int i=0; i<n; ++i) for(int j=0; j<p; ++j) for(int k=0; k<m; ++k) z.f[i][j]=(z.f[i][j]+x.f[i][k]*y.f[k][j]%P)%P; return z; } struct tree { int l,r,tag[2]; ll sum[3][3],data[3][3]; } tre[N<<2]; int n,q,_l,_r,x,y; ll inva,a,b; ll f[N][3]; int A[N]; char ch[10],_c; ll kp(ll x,int p) { if(p==0) return 1; if(p==1) return x%P; if(p&1) return x*kp(x*x%P,p>>1)%P; else return kp(x*x%P,p>>1)%P; } ma Kp(ma x,int p) { if(p==1) return x; if(p&1) return x*Kp(x*x,p>>1); else return Kp(x*x,p>>1); } void initf() { inva=kp(a,P-2)%P; s.n=s.m=3; s.f[0][0]=s.f[0][1]=s.f[2][2]=1;s.f[1][0]=a;s.f[2][0]=b; t.n=1,t.m=3; t.f[0][0]=2;t.f[0][1]=t.f[0][2]=1; for(int i=1; i<=n; ++i) { if(A[i]==1) { f[i][0]=-P,f[i][1]=1,f[i][2]=2; } else if(A[i]==2) { f[i][0]=1,f[i][1]=2; f[i][2]=(f[i][1]+a*f[i][0]%P+b)%P; } else { ma tmp=t*Kp(s,A[i]-2); f[i][0]=tmp.f[0][1]; f[i][1]=tmp.f[0][0]; f[i][2]=(f[i][1]+a*f[i][0]%P+b)%P; } } } void pushup(int i) { for(int j=0; j<=1; ++j) for(int k=0; k<=2; ++k) _s(i,j,k)=(_s(ls,j,k)+_s(rs,j,k))%P; for(int j=0; j<=2; ++j) for(int k=0; k<=2; ++k) _d(i,j,k)=(_d(ls,j,k)+_d(rs,j,k))%P; } void build(int i,int l,int r) { tre[i].l=l,tre[i].r=r; if(l==r) { for(int k=0; k<=2; ++k) _s(i,0,k)=f[l-1][k]; for(int k=0; k<=2; ++k) _s(i,1,k)=f[l+1][k]; for(int j=0; j<=2; ++j) for(int k=0; k<=2; ++k) _d(i,j,k)=_s(i,0,j)*_s(i,1,k)%P; return; } int mid=l+r>>1; build(ls,l,mid); build(rs,mid+1,r); pushup(i);return; } void add(int i,int t) { int l=tre[i].l,r=tre[i].r;ll w=r-l+1; for(int k=0; k<=1; ++k) _s(i,t,k)=_s(i,t,k+1); _s(i,t,2)=(_s(i,t,1)+a*_s(i,t,0)%P+b*w%P)%P; if(t==0) { //a[i-1] for(int k=0; k<=2; ++k) for(int j=0; j<=1; ++j) _d(i,j,k)=_d(i,j+1,k); for(int k=0; k<=2; ++k) _d(i,2,k)=(_d(i,1,k)+_d(i,0,k)*a%P+b*_s(i,1,k)%P)%P; } else { for(int j=0; j<=2; ++j) for(int k=0; k<=1; ++k) _d(i,j,k)=_d(i,j,k+1); for(int j=0; j<=2; ++j) _d(i,j,2)=(_d(i,j,1)+a*_d(i,j,0)%P+b*_s(i,0,j)%P)%P; }//a[i+1] return; } void del(int i,int t) { int l=tre[i].l,r=tre[i].r;ll w=r-l+1; if(a==0){ for(int k=2;k>=1;--k) _s(i,t,k)=_s(i,t,k-1); _s(i,t,0)=(_s(i,t,1)-b*w%P+P)%P; if(t==0){//a[i-1] for(int k=0;k<=2;++k) for(int j=2;j>=1;--j) _d(i,j,k)=_d(i,j-1,k); for(int k=0;k<=2;++k) _d(i,0,k)=(_d(i,1,k)-b*_s(i,1,k)%P+P)%P; }else{//a[i+1] for(int j=0;j<=2;++j) for(int k=2;k>=1;--k) _d(i,j,k)=_d(i,j,k-1); for(int j=0;j<=2;++j) _d(i,j,0)=(_d(i,j,1)-b*_s(i,0,j)%P+P)%P; } }else{ for(int k=2;k>=1;--k) _s(i,t,k)=_s(i,t,k-1); _s(i,t,0)=(_s(i,t,2)-_s(i,t,1)+P-b*w%P+P)%P*inva%P; if(t==0){//a[i-1] for(int k=0;k<=2;++k) for(int j=2;j>=1;--j) _d(i,j,k)=_d(i,j-1,k); for(int k=0;k<=2;++k) _d(i,0,k)=(_d(i,2,k)-_d(i,1,k)+P-b*_s(i,1,k)%P+P)%P*inva%P; }else{//a[i+1] for(int j=0;j<=2;++j) for(int k=2;k>=1;--k) _d(i,j,k)=_d(i,j,k-1); for(int j=0;j<=2;++j) _d(i,j,0)=(_d(i,j,2)-_d(i,j,1)+P-b*_s(i,0,j)%P+P)%P*inva%P; } } } void calc(int i,int t,int c) { if(!c) return; if(c>0) for(int k=1; k<=c; ++k) add(i,t); else for(int k=1; k<=-c; ++k) del(i,t); } void pushdown(int i) { int l=tre[i].l,r=tre[i].r,c=tre[i].tag[0],d=tre[i].tag[1]; if(!c && !d) return; tre[ls].tag[0]+=c;tre[ls].tag[1]+=d; tre[rs].tag[0]+=c;tre[rs].tag[1]+=d; calc(ls,0,c);calc(ls,1,d); calc(rs,0,c);calc(rs,1,d); tre[i].tag[0]=tre[i].tag[1]=0; } void change(int i,int el,int er,int t,int c) { int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) { tre[i].tag[t]+=c; calc(i,t,c); return; } pushdown(i); if(el<=mid) change(ls,el,er,t,c); if(er>mid) change(rs,el,er,t,c); pushup(i); return; } ll query(int i,int el,int er) { int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) return _d(i,2,0); ll ans=0; pushdown(i); if(el<=mid) ans=(ans+query(ls,el,er))%P; if(er>mid) ans=(ans+query(rs,el,er))%P; return ans; } int main() { n=read1(),q=read1(),a=(long long)read1(),b=(long long)read1(); for(int i=1; i<=n; ++i) A[i]=read1(); initf(); build(1,1,n); for(int i=1; i<=q; ++i) { scanf(\"%s\",ch);_l=read1(),_r=read1(); if(ch[0]=='q') { if(_l+1<=_r-1) write1(query(1,_l+1,_r-1)),putchar('\\n'); else putchar('0'),putchar('\\n'); } else if(ch[0]=='p') { x=_l+1,y=_r+1<n?_r+1:n;change(1,x,y,0,1); x=_l-1>1?_l-1:1,y=_r-1;change(1,x,y,1,1); } else { //m x=_l+1,y=_r+1<n?_r+1:n;change(1,x,y,0,-1); x=_l-1>1?_l-1:1,y=_r-1;change(1,x,y,1,-1); } } return 0; } ~~\u5b66\u6d41\u7a0b\u7528\u4e86\u4e00\u5929\u534a\uff0c\u5199\u4ee3\u7801\u4e0d\u5230\u4e24\u5c0f\u65f6\u5199\u4e86\u4e24\u767e\u884c\uff0c\u6240\u4ee5\u601d\u8def\u6e05\u6670\u662f\u975e\u5e38\u91cd\u8981\u7684\u3002~~","title":"\u77e9\u9635\u4e58\u6cd5"},{"location":"my%20past/OI/%E7%A6%BB%E6%95%A3%E5%8C%96_%E5%93%88%E5%B8%8C/","text":"\u79bb\u6563\u4f18\u5316 \u5e94\u7528 \u89e3\u51b3\u6709\u5df2\u77e5\u7684\u56fa\u5b9a\u8f93\u5165(\u5373\u6ca1\u6709\u5728\u7ebf\u63d2\u5165\uff0c\u79bb\u7ebf\u63d2\u5165\u6240\u6709\u6570\u636e\uff0c\u8ba1\u7b97\u8fc7\u7a0b\u4e0d\u4ea7\u751f\u6570\u636e)\uff0c\u4e14\u8303\u56f4\u8f83\u5927\u7684\u60c5\u51b5\uff0c\u901a\u5e38\u9700\u8981\u7684\u662f\u6392\u540d\u800c\u4e0d\u662f\u5177\u4f53\u6570\u503c\uff0c\u56e0\u6b64\u76f4\u63a5\u6309\u5927\u5c0f\u91cd\u65b0\u8d4b\u4e88\u6bcf\u4e2a\u6570\u4e00\u4e2a\u65b0\u503c\u3002 \u6a21\u677f for(int i=1;i<=n;++i){ scanf(\"%d\",&a[i]); b[i]=a[i]; } sort(b+1,b+n+1);//\u6392\u5e8f int tot=unique(b+1,b+n+1)-b-1;//\u53bb\u91cd for(int i=1;i<=n;++i)a[i]=lower_bound(b+1,b+tot+1,a[i])-b;//\u91cd\u5b9a\u4e49\u4f4d\u7f6e \u54c8\u5e0c\u4f18\u5316 \u5e94\u7528 \u89e3\u51b3\u6709\u67e5\u8be2\u4e14\u8303\u56f4\u6bd4\u8f83\u5927\u7684\u60c5\u51b5\uff0c\u4f1a\u9700\u8981\u5177\u4f53\u6570\u503c\u3002 \u5f53\u89e3\u51b3\u52a8\u6001\u5728\u7ebf\u95ee\u9898\u65f6(\u53ef\u80fd\u662f\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\u4ea7\u751f\u6570\u636e)\u9700\u8981\u5efa\u7acb\u53ef\u63d2\u5165\u7684hash\u94fe\u8868\uff0c\u79bb\u7ebf\u95ee\u9898\u53ef\u4ee5\u76f4\u63a5\u7528\u6570\u7ec4\u5b58\u50a8\uff0c\u4ece\u5934\u5230\u5c3e\u626b\u4e00\u904d\u5224\u91cd\u3002 \u672c\u8d28\u5c31\u662f\u5c06\u7279\u522b\u5927\u7684\u6570\u901a\u8fc7h(k)\u7684\u65b9\u5f0f\u6620\u5c04\u4e3a\u65b0\u7684\u5c0f\u6570\u503c\uff0c\u5e76\u5b58\u50a8\u5230\u94fe\u8868\u6216\u6570\u7ec4\u4e2d\u3002(\u82e5\u662f\u94fe\u8868\u5219\u8303\u56f4\u662f\u94fe\u5934\u6570\u7ec4\u5927\u5c0f\u7684\u8303\u56f4\uff1b\u82e5\u662f\u6570\u7ec4\u5219\u8303\u56f4\u662fint(long long)\u7684\u8303\u56f4\u3002) \u4e0d\u662f\u666e\u901a\u6570\u7684\u4e5f\u53ef\u4ee5\u8fdb\u884chash\u4f18\u5316\uff0c\u4f8b\u5982\u6570\u5b57\u5b57\u7b26\u4e32\u5c31\u53ef\u4ee5\u7528hash\u4f18\u5316\u5b58\u50a8\u3002\uff08\u5c24\u5176\u662f\u5b57\u7b26\u4e32\u4e2d\u6570\u5b57\u7279\u522b\u5927\u7684\u60c5\u51b5\uff0cASCII\u7801\u5b58\u4e0d\u4e0b\uff09 ~~\u5728\u52a8\u6001\u67e5\u8be2\u4e0a\u56e0\u4e3a\u7801\u91cf\u800c\u5b8c\u80dc\u5e73\u8861\u6811~~ P2852 \u901a\u8fc7p\u548cP\u89e3\u51b3\u95ee\u9898\u3002 \u5b9a\u4e49p=1000017(10007\u4e5f\u884c\uff0c\u5c31\u662f1e6\u4e0d\u9700\u8981\u8fdb\u4f4d\uff0c\u66f4\u76f4\u89c2),P=1000000007,\u53d6\u4e86\u4e24\u4e2a\u8d28\u6570\u9632\u6b62\u51b2\u7a81\u3002 \u56e0\u6b64\u5c06\u95ee\u9898\u8f6c\u5316\u4e3a\uff1a\u5c06\u5b57\u7b26\u4e32\u4ee5p\u8fdb\u5236\u6570\u7684\u65b9\u5f0f\u5b58\u50a8\u4e3a\u5c0f\u4e8eP\u7684\u6570\u3002(\u8fd9\u4e2a\u8fc7\u7a0b\u5c31\u662fhash\u7684\u6838\u5fc3\uff1a\u5c06\u7279\u522b\u5927\u7684\u6570\u901a\u8fc7h(k)\u7684\u65b9\u5f0f\u6620\u5c04\u4e3a\u65b0\u7684\u5c0f\u6570\u503c\uff0c\u5e76\u5b58\u50a8\u3002) \u6ce8\u610f\u5b58\u50a8\u7684\u662fp\u8fdb\u5236\u6570\u572810\u8fdb\u5236\u8868\u793a\u4e0b mod P\u7684\u7ed3\u679c\u3002 \u5224\u65ad\u662f\u6392\u4e2a\u5e8f\u5c31\u884c\u3002 \u7136\u540e\u4e8c\u5206,\u6ca1\u4e86\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=3e4+10,p=10007,P=1000000007; int a[N],b[N],c[N],d[N]; int n,k; void init(){ b[0]=0; c[0]=1; for(int i=1;i<=n;++i){ b[i]=(b[i-1]*p+a[i])%P; } for(int i=1;i<=n;++i){ c[i]=(c[i-1]*p)%P; } return; } bool cmp(int a,int b){ return a<b;//:) } bool check(int x){ memset(d,0,sizeof d); int top=0; for(int i=x;i<=n;++i){ d[++top]=(b[i]-b[i-x]*c[x])%P; if(d[top]<0)d[top]+=P; } sort(d+1,d+top+1,cmp); int cnt=0,ans=0; for(int i=1;i<=top;++i){ cnt++; if(d[i+1]!=d[i] || i==top){ ans=max(ans,cnt); cnt=0; } } return ans>=k; } int solve(){ int l=0,r=n+1,ans=0; while(l<r){ int mid=l+r>>1; if(check(mid)){ ans=max(ans,mid); l=mid+1; }else r=mid; } return ans; } signed main(){ scanf(\"%lld%lld\",&n,&k); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]); init(); int ans=solve(); printf(\"%lld\",ans); return 0; } \u5eb7\u6258\u5c55\u5f00 \u672c\u8d28\u4e5f\u662f\u4e00\u79cdhash\u4f18\u5316\uff0c\u8fd9\u6b21\u7684\u6620\u5c04\u51fd\u6570\u4e3acantor(k)\u3002\u5bf9\u4e8e\u4e00\u4e2a \u5168\u6392\u5217 ,\u5176\u5eb7\u6258\u5c55\u5f00\u4e3a $$ cantor(k)=\\sum_{k=n}^1 f(a[k])* (k-1)!$$ f(a[k])\u6307\u6bd4a[k]\u5c0f\u7684\uff0c\u672a\u51fa\u73b0\u7684\u6570\u7684\u4e2a\u6570\u3002 \u4f8b\u598234512\u503c\u4e3a61,\u6240\u4ee5\u662f\u7b2c62\u4e2a\u3002 P1379 \u56e0\u4e3a\u603b\u5171\u7684\u72b6\u6001\u4e00\u51719!=362880\u79cd\uff0c\u4e14\u540e\u8fdb\u961f\u7684\u91cd\u590d\u72b6\u6001\u4e00\u5b9a\u6ca1\u6709\u4e4b\u524d\u7684\u754c\u66f4\u4f18\uff0c\u6240\u4ee5\u76f4\u63a5\u526a\u679dbfs\u5373\u53ef\uff0c\u7528cantor(k)\u5224\u65ad\u662f\u5426\u5165\u961f\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=4e5+10; int tmp[3][3],d[3][3]={1,2,3,8,0,4,7,6,5}; int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1}; int vis[9],vist[N]; int l[10]; int n,goal; struct node{ int v; int step; int d[3][3]; node(int vv,int s,int dd[3][3]){ v=vv; step=s; for(int i=0;i<3;++i){ for(int j=0;j<3;++j)d[i][j]=dd[i][j]; } } }; int cantor(int d[3][3]){//3x3->cantor memset(vis,0,sizeof vis); int ans=0; for(int i=0;i<3;++i){ for(int j=0;j<3;++j){ int cnt=0; for(int k=0;k<d[i][j];++k)if(vis[k])cnt++; ans+=(d[i][j]-cnt)*l[9-i*3-j-1]; vis[d[i][j]]=1; } } return ans; } void get1(int n){//int->3x3 for(int i=2;i>=0;--i){ for(int j=2;j>=0;--j){ d[i][j]=n%10; n/=10; } } return; } void init(){ l[0]=l[1]=1; for(int i=2;i<=9;++i)l[i]=l[i-1]*i; goal=cantor(d); return; } int bfs(){ memset(vist,0,sizeof vist); queue<node> q; get1(n); while(!q.empty())q.pop(); int a=cantor(d); q.push(node(a,0,d)); vist[a]=1; while(!q.empty()){ memcpy(d,q.front().d,sizeof q.front().d); int step=q.front().step; int a=cantor(d); if(a==goal)return step; int x=0,y=0; for(int i=0;i<3;++i){ for(int j=0;j<3;++j){ if(d[i][j]==0){ x=i,y=j; break; } } } q.pop(); for(int i=0;i<4;++i){ int xx=dx[i]+x,yy=y+dy[i]; if(xx>=0 && xx<3 && yy>=0 && yy<3){ memcpy(tmp,d,sizeof d); swap(tmp[x][y],tmp[xx][yy]); int a=cantor(tmp); if(a==goal)return step+1; if(!vist[a]){ vist[a]=1; q.push(node(a,step+1,tmp)); } } } } return -1; } signed main(){ init(); if(goal!=46685)goal=46685; scanf(\"%lld\",&n); printf(\"%lld\",bfs()); return 0; }","title":"\u79bb\u6563\u4f18\u5316"},{"location":"my%20past/OI/%E7%A6%BB%E6%95%A3%E5%8C%96_%E5%93%88%E5%B8%8C/#_1","text":"","title":"\u79bb\u6563\u4f18\u5316"},{"location":"my%20past/OI/%E7%A6%BB%E6%95%A3%E5%8C%96_%E5%93%88%E5%B8%8C/#_2","text":"\u89e3\u51b3\u6709\u5df2\u77e5\u7684\u56fa\u5b9a\u8f93\u5165(\u5373\u6ca1\u6709\u5728\u7ebf\u63d2\u5165\uff0c\u79bb\u7ebf\u63d2\u5165\u6240\u6709\u6570\u636e\uff0c\u8ba1\u7b97\u8fc7\u7a0b\u4e0d\u4ea7\u751f\u6570\u636e)\uff0c\u4e14\u8303\u56f4\u8f83\u5927\u7684\u60c5\u51b5\uff0c\u901a\u5e38\u9700\u8981\u7684\u662f\u6392\u540d\u800c\u4e0d\u662f\u5177\u4f53\u6570\u503c\uff0c\u56e0\u6b64\u76f4\u63a5\u6309\u5927\u5c0f\u91cd\u65b0\u8d4b\u4e88\u6bcf\u4e2a\u6570\u4e00\u4e2a\u65b0\u503c\u3002 \u6a21\u677f for(int i=1;i<=n;++i){ scanf(\"%d\",&a[i]); b[i]=a[i]; } sort(b+1,b+n+1);//\u6392\u5e8f int tot=unique(b+1,b+n+1)-b-1;//\u53bb\u91cd for(int i=1;i<=n;++i)a[i]=lower_bound(b+1,b+tot+1,a[i])-b;//\u91cd\u5b9a\u4e49\u4f4d\u7f6e","title":"\u5e94\u7528"},{"location":"my%20past/OI/%E7%A6%BB%E6%95%A3%E5%8C%96_%E5%93%88%E5%B8%8C/#_3","text":"","title":"\u54c8\u5e0c\u4f18\u5316"},{"location":"my%20past/OI/%E7%A6%BB%E6%95%A3%E5%8C%96_%E5%93%88%E5%B8%8C/#_4","text":"\u89e3\u51b3\u6709\u67e5\u8be2\u4e14\u8303\u56f4\u6bd4\u8f83\u5927\u7684\u60c5\u51b5\uff0c\u4f1a\u9700\u8981\u5177\u4f53\u6570\u503c\u3002 \u5f53\u89e3\u51b3\u52a8\u6001\u5728\u7ebf\u95ee\u9898\u65f6(\u53ef\u80fd\u662f\u8ba1\u7b97\u8fc7\u7a0b\u4e2d\u4ea7\u751f\u6570\u636e)\u9700\u8981\u5efa\u7acb\u53ef\u63d2\u5165\u7684hash\u94fe\u8868\uff0c\u79bb\u7ebf\u95ee\u9898\u53ef\u4ee5\u76f4\u63a5\u7528\u6570\u7ec4\u5b58\u50a8\uff0c\u4ece\u5934\u5230\u5c3e\u626b\u4e00\u904d\u5224\u91cd\u3002 \u672c\u8d28\u5c31\u662f\u5c06\u7279\u522b\u5927\u7684\u6570\u901a\u8fc7h(k)\u7684\u65b9\u5f0f\u6620\u5c04\u4e3a\u65b0\u7684\u5c0f\u6570\u503c\uff0c\u5e76\u5b58\u50a8\u5230\u94fe\u8868\u6216\u6570\u7ec4\u4e2d\u3002(\u82e5\u662f\u94fe\u8868\u5219\u8303\u56f4\u662f\u94fe\u5934\u6570\u7ec4\u5927\u5c0f\u7684\u8303\u56f4\uff1b\u82e5\u662f\u6570\u7ec4\u5219\u8303\u56f4\u662fint(long long)\u7684\u8303\u56f4\u3002) \u4e0d\u662f\u666e\u901a\u6570\u7684\u4e5f\u53ef\u4ee5\u8fdb\u884chash\u4f18\u5316\uff0c\u4f8b\u5982\u6570\u5b57\u5b57\u7b26\u4e32\u5c31\u53ef\u4ee5\u7528hash\u4f18\u5316\u5b58\u50a8\u3002\uff08\u5c24\u5176\u662f\u5b57\u7b26\u4e32\u4e2d\u6570\u5b57\u7279\u522b\u5927\u7684\u60c5\u51b5\uff0cASCII\u7801\u5b58\u4e0d\u4e0b\uff09 ~~\u5728\u52a8\u6001\u67e5\u8be2\u4e0a\u56e0\u4e3a\u7801\u91cf\u800c\u5b8c\u80dc\u5e73\u8861\u6811~~ P2852 \u901a\u8fc7p\u548cP\u89e3\u51b3\u95ee\u9898\u3002 \u5b9a\u4e49p=1000017(10007\u4e5f\u884c\uff0c\u5c31\u662f1e6\u4e0d\u9700\u8981\u8fdb\u4f4d\uff0c\u66f4\u76f4\u89c2),P=1000000007,\u53d6\u4e86\u4e24\u4e2a\u8d28\u6570\u9632\u6b62\u51b2\u7a81\u3002 \u56e0\u6b64\u5c06\u95ee\u9898\u8f6c\u5316\u4e3a\uff1a\u5c06\u5b57\u7b26\u4e32\u4ee5p\u8fdb\u5236\u6570\u7684\u65b9\u5f0f\u5b58\u50a8\u4e3a\u5c0f\u4e8eP\u7684\u6570\u3002(\u8fd9\u4e2a\u8fc7\u7a0b\u5c31\u662fhash\u7684\u6838\u5fc3\uff1a\u5c06\u7279\u522b\u5927\u7684\u6570\u901a\u8fc7h(k)\u7684\u65b9\u5f0f\u6620\u5c04\u4e3a\u65b0\u7684\u5c0f\u6570\u503c\uff0c\u5e76\u5b58\u50a8\u3002) \u6ce8\u610f\u5b58\u50a8\u7684\u662fp\u8fdb\u5236\u6570\u572810\u8fdb\u5236\u8868\u793a\u4e0b mod P\u7684\u7ed3\u679c\u3002 \u5224\u65ad\u662f\u6392\u4e2a\u5e8f\u5c31\u884c\u3002 \u7136\u540e\u4e8c\u5206,\u6ca1\u4e86\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=3e4+10,p=10007,P=1000000007; int a[N],b[N],c[N],d[N]; int n,k; void init(){ b[0]=0; c[0]=1; for(int i=1;i<=n;++i){ b[i]=(b[i-1]*p+a[i])%P; } for(int i=1;i<=n;++i){ c[i]=(c[i-1]*p)%P; } return; } bool cmp(int a,int b){ return a<b;//:) } bool check(int x){ memset(d,0,sizeof d); int top=0; for(int i=x;i<=n;++i){ d[++top]=(b[i]-b[i-x]*c[x])%P; if(d[top]<0)d[top]+=P; } sort(d+1,d+top+1,cmp); int cnt=0,ans=0; for(int i=1;i<=top;++i){ cnt++; if(d[i+1]!=d[i] || i==top){ ans=max(ans,cnt); cnt=0; } } return ans>=k; } int solve(){ int l=0,r=n+1,ans=0; while(l<r){ int mid=l+r>>1; if(check(mid)){ ans=max(ans,mid); l=mid+1; }else r=mid; } return ans; } signed main(){ scanf(\"%lld%lld\",&n,&k); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]); init(); int ans=solve(); printf(\"%lld\",ans); return 0; }","title":"\u5e94\u7528"},{"location":"my%20past/OI/%E7%A6%BB%E6%95%A3%E5%8C%96_%E5%93%88%E5%B8%8C/#_5","text":"\u672c\u8d28\u4e5f\u662f\u4e00\u79cdhash\u4f18\u5316\uff0c\u8fd9\u6b21\u7684\u6620\u5c04\u51fd\u6570\u4e3acantor(k)\u3002\u5bf9\u4e8e\u4e00\u4e2a \u5168\u6392\u5217 ,\u5176\u5eb7\u6258\u5c55\u5f00\u4e3a $$ cantor(k)=\\sum_{k=n}^1 f(a[k])* (k-1)!$$ f(a[k])\u6307\u6bd4a[k]\u5c0f\u7684\uff0c\u672a\u51fa\u73b0\u7684\u6570\u7684\u4e2a\u6570\u3002 \u4f8b\u598234512\u503c\u4e3a61,\u6240\u4ee5\u662f\u7b2c62\u4e2a\u3002 P1379 \u56e0\u4e3a\u603b\u5171\u7684\u72b6\u6001\u4e00\u51719!=362880\u79cd\uff0c\u4e14\u540e\u8fdb\u961f\u7684\u91cd\u590d\u72b6\u6001\u4e00\u5b9a\u6ca1\u6709\u4e4b\u524d\u7684\u754c\u66f4\u4f18\uff0c\u6240\u4ee5\u76f4\u63a5\u526a\u679dbfs\u5373\u53ef\uff0c\u7528cantor(k)\u5224\u65ad\u662f\u5426\u5165\u961f\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=4e5+10; int tmp[3][3],d[3][3]={1,2,3,8,0,4,7,6,5}; int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1}; int vis[9],vist[N]; int l[10]; int n,goal; struct node{ int v; int step; int d[3][3]; node(int vv,int s,int dd[3][3]){ v=vv; step=s; for(int i=0;i<3;++i){ for(int j=0;j<3;++j)d[i][j]=dd[i][j]; } } }; int cantor(int d[3][3]){//3x3->cantor memset(vis,0,sizeof vis); int ans=0; for(int i=0;i<3;++i){ for(int j=0;j<3;++j){ int cnt=0; for(int k=0;k<d[i][j];++k)if(vis[k])cnt++; ans+=(d[i][j]-cnt)*l[9-i*3-j-1]; vis[d[i][j]]=1; } } return ans; } void get1(int n){//int->3x3 for(int i=2;i>=0;--i){ for(int j=2;j>=0;--j){ d[i][j]=n%10; n/=10; } } return; } void init(){ l[0]=l[1]=1; for(int i=2;i<=9;++i)l[i]=l[i-1]*i; goal=cantor(d); return; } int bfs(){ memset(vist,0,sizeof vist); queue<node> q; get1(n); while(!q.empty())q.pop(); int a=cantor(d); q.push(node(a,0,d)); vist[a]=1; while(!q.empty()){ memcpy(d,q.front().d,sizeof q.front().d); int step=q.front().step; int a=cantor(d); if(a==goal)return step; int x=0,y=0; for(int i=0;i<3;++i){ for(int j=0;j<3;++j){ if(d[i][j]==0){ x=i,y=j; break; } } } q.pop(); for(int i=0;i<4;++i){ int xx=dx[i]+x,yy=y+dy[i]; if(xx>=0 && xx<3 && yy>=0 && yy<3){ memcpy(tmp,d,sizeof d); swap(tmp[x][y],tmp[xx][yy]); int a=cantor(tmp); if(a==goal)return step+1; if(!vist[a]){ vist[a]=1; q.push(node(a,step+1,tmp)); } } } } return -1; } signed main(){ init(); if(goal!=46685)goal=46685; scanf(\"%lld\",&n); printf(\"%lld\",bfs()); return 0; }","title":"\u5eb7\u6258\u5c55\u5f00"},{"location":"my%20past/OI/%E7%BA%BF%E6%80%A7dp/","text":"\u7ebf\u6027dp/\u666e\u901adp \u5750\u6807dp P7074 \u7531\u4e8e\u4ece\u4e0a\u5f80\u4e0b\u6709\u540e\u6548\u6027\uff0c\u6240\u4ee5\u65cb\u8f6c90\u5ea6\u540e\u518d\u505adp \u5bf9\u4e8e\u6bcf\u4e2a\u5750\u6807\uff0c\u90fd\u6709\u4e24\u79cd\u65b9\u5411\uff0c\u5411\u5de6\u548c\u5411\u53f3\u3002 \u6240\u4ee5\u8bbef[i][j][0/1]\u8868\u793a\u5de6/\u53f3\u65b9\u5411\u65f6\u7684\u6700\u5927\u503c\u3002 \u6b64\u65f6\u6709\u8f6c\u79fb\u65b9\u7a0b\uff1a $$ f[i][j][0]=max(f[i][j][0],max(f[i][j-1][0],f[i][j-1][1])+c[i][j]);(i=1\\to n)\\ f[i][j][1]=max(f[i][j][1],max(f[i][j-1][0],f[i][j-1][1])+c[i][j]);(i=1\\to n)\\ f[i][j][0]=max(f[i][j][0],f[i-1][j][0]+c[i][j]);(i=1\\to n)\\ f[i][j][1]=max(f[i][j][1],f[i+1][j][1]+c[i][j]);(i=n\\to 1) $$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e3+10,INF=1e12; int n,m; int c[N][N],f[N][N][2]; signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i){ for(int j=1;j<=m;++j){ scanf(\"%lld\",&c[i][j]); } } for(int i=0;i<=n+1;++i){ for(int j=0;j<=m+1;++j){ f[i][j][0]=-INF; f[i][j][1]=-INF; } } f[1][1][0]=f[1][1][1]=c[1][1]; for(int j=1;j<=m;++j){ for(int i=1;i<=n;++i){ f[i][j][0]=max(f[i][j][0],max(f[i][j-1][0],f[i][j-1][1])+c[i][j]); f[i][j][1]=max(f[i][j][1],max(f[i][j-1][0],f[i][j-1][1])+c[i][j]); f[i][j][0]=max(f[i][j][0],f[i-1][j][0]+c[i][j]); } for(int i=n;i>=1;--i){ f[i][j][1]=max(f[i][j][1],f[i+1][j][1]+c[i][j]); } } printf(\"%lld\",max(f[n][m][0],f[n][m][1])); return 0; } P1437 \u56e0\u4e3a\u4ece\u4e0a\u5f80\u4e0b\u641c\u4f1a\u5b58\u5728\u540e\u6548\u6027\uff0c\u6240\u4ee5\u8981\u4ece\u53f3\u5f80\u5de6\u641c\u3002 \u8bbef[i][j][k]\u8868\u793a\u7b2ci\u5217\u53bb\u4e86j\u4e2a\u7816\u5757\u4e14\u603b\u5171\u53bb\u53d6\u4e86k\u4e2a\u7816\u5757\u7684\u72b6\u6001\u3002 \u8f6c\u79fb\u65b9\u7a0b+code\uff1a #include<iostream> #include<cstring> #include<cstdio> using namespace std; const int N=55,M=N*N; int n,m; int a[N][N]; int f[N][N][M]; int t[N][N]; int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i){ for(int j=1;j<=n-i+1;++j){ scanf(\"%d\",&a[i][j]); } } memset(f,-0x3f,sizeof f); //\u907f\u514d\u4e0d\u5408\u6cd5\u72b6\u6001\u7684\u8f6c\u79fb\u3002\u56e0\u4e3a\u6709v\u6bd4k-j\u5927\u7684\u60c5\u51b5\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0d\u5408\u6cd5\uff0c\u56e0\u6b64\u5e94\u8be5\u4e3a\u8d1f\u65e0\u7a77 f[n+1][0][0]=0;//\u521d\u59cb\u5316 int ans=0; for(int i=n;i>=1;--i){ for(int j=0,sum=0;j<=n-i+1;++j,sum+=a[j][i]){ for(int v=max(j-1,0)/*\u9632\u6ea2\u51fa*/;v<=n-i;++v){//\u8868\u793a\u4e0a\u4e00\u5217\u81f3\u5c11\u8981\u53d6j-1\u4e2a\uff0c\u6700\u591a\uff08n-i+1\uff09-1\u4e2a for(int k=j;k<=m;++k){ f[i][j][k]=max(f[i][j][k],f[i+1][v][k-j]+sum); } } } } for(int i=1;i<=n;++i){ for(int j=1;j<=n-i+1;++j)ans=max(ans,f[i][j][m]); } printf(\"%d\",ans); return 0; } /* 4 6 2 2 3 4 8 2 7 2 3 49 */ CF360B ~~\u6211\u662f\u50bb\u903c~~ \u4e8c\u5206+dp \u8bbedp[i]\u8868\u793a$a_i$\u4e0d\u6539\u65f61~i\u6700\u591a\u4e0d\u6539\u7684\u4e2a\u6570\u3002 \u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a for(int i=2;i<=n;++i){ for(int j=1;j<i;++j){ if(x*(i-j)>=abs1(a[i]-a[j])){ dp[i]=max(dp[i],dp[j]+1); } } } \u6761\u4ef6\u662f\u53ea\u8981\u4e24\u4e2a\u6570\u76f8\u5dee\u5728\u5f53\u524d\u4e8c\u5206\u7684\u957f\u5ea6\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u5c31\u5c06i\u5230j\u4e4b\u95f4\u505a\u66f4\u6539\uff0ci\u548cj\u4fdd\u6301\u4e0d\u53d8\uff0c\u770b\u6700\u591a\u7559\u4e0b\u51e0\u4e2a\u6570\u4e0d\u6539\u3002 \u6b63\u786e\u6027\u662f\u56e0\u4e3a\u5982\u679ci\u5230j\u4e4b\u95f4\u6709\u5176\u4ed6\u4e0ei\u7b26\u5408\u8fd9\u4e2a\u6761\u4ef6\u7684\u6570k\uff0c\u90a3\u4e48k\u4e00\u5b9a\u4f1a\u88abi\u641c\u5230\uff0c\u53ef\u80fd\u5b58\u5728\u66f4\u4f18\u7684\u7ed3\u679c\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=2200,INF=0x7fffffff; int a[N],dp[N]; int n,k; int abs1(int x){ return x>0?x:-x; } bool check(int x){ int cnt=0; for(int i=1;i<=n;++i)dp[i]=1; for(int i=2;i<=n;++i){ for(int j=1;j<i;++j){ if(x*(i-j)>=abs1(a[i]-a[j])){ dp[i]=max(dp[i],dp[j]+1); } } } for(int i=1;i<=n;++i){ if(i-dp[i]+n-i<=k)return true; } return false; } signed main(){ scanf(\"%lld%lld\",&n,&k); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]); int l=0,r=INF,ans=INF; while(l<r){ int mid=l+r>>1; if(check(mid)){ r=mid; ans=mid; }else l=mid+1; } printf(\"%lld\",ans); return 0; } UVA1025 \u8bbe$f[i][j]$\u8868\u793a\u5728\u7b2c$j$\u79d2\u5230\u8fbe\u7b2c$i$\u4e2a\u8f66\u7ad9\u65f6\u7684\u6700\u5c0f\u7b49\u5f85\u65f6\u95f4\u3002 \u90a3\u4e48\u6bcf\u6b21\u7531\u4e09\u79cd\u51b3\u7b56\uff1a 1) \u5982\u679c\u4e0d\u662f1\u53f7\u8f66\u7ad9\u5e76\u4e14\u6b64\u65f6\u6709\u5411\u5de6\u7684\u8f66\uff0c\u5c31\u5411\u5de6\u8fb9\u3002 2) \u5982\u679c\u4e0d\u662fn\u53f7\u8f66\u7ad9\u5e76\u4e14\u6b64\u65f6\u6709\u5411\u53f3\u7684\u8f66\uff0c\u5c31\u5411\u53f3\u8fb9\u3002 3) \u5728\u8fd9\u4e2a\u8f66\u7ad9\u7b49\u5f851\u79d2\u3002 \u5224\u65ad\u6b64\u65f6\u6709\u6ca1\u6709\u5411\u5de6\u5411\u53f3\u7684\u8f66\u53ef\u4ee5\u9884\u5904\u7406\u51fa$g[i][j][0/1]$ #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=55,T=220,INF=0x3f3f3f3f; int f[N][T],g[N][T][2]; int u[T],v[T],a[N],b[N],s[N]; int n,t,M1,M2,cnt; void init() { memset(u,0,sizeof u);memset(v,0,sizeof v);memset(g,0,sizeof g);memset(f,0x3f,sizeof f); scanf(\"%d\",&t); for(int i=1;i<n;++i)scanf(\"%d\",&s[i]); a[1]=0;b[n]=0; for(int i=2;i<=n;++i)a[i]=a[i-1]+s[i-1]; for(int i=n-1;i>=1;--i)b[i]=b[i+1]+s[i]; scanf(\"%d\",&M1); for(int i=1,tmp; i<=M1; ++i)scanf(\"%d\",&tmp),u[tmp]=1; scanf(\"%d\",&M2); for(int i=1,tmp; i<=M2; ++i)scanf(\"%d\",&tmp),v[tmp]=1; for(int i=1;i<=n;++i) for(int j=0;j<=t;++j) if(j>=a[i] && u[j-a[i]])g[i][j][1]=1; if(j>=b[i] && v[j-b[i]])g[i][j][0]=1; f[1][0]=0; } void dp(){ for(int j=0;j<=t;++j) for(int i=1;i<=n;++i) if(g[i][j][0] && i>1)f[i-1][j+s[i-1]]=min(f[i-1][j+s[i-1]],f[i][j]); if(g[i][j][1] && i<n)f[i+1][j+s[i]]=min(f[i+1][j+s[i]],f[i][j]); f[i][j+1]=min(f[i][j+1],f[i][j]+1); } int main() { while(1) { scanf(\"%d\",&n); if(!n)return 0; ++cnt; init(); dp(); printf(\"Case Number %d: \",cnt); if(f[n][t]==INF)printf(\"impossible\\n\"); else printf(\"%d\\n\",f[n][t]); } return 0; } \u7ed3\u8bba\uff1a\u5c06\u51b3\u7b56\u5bf9\u5e94\u72b6\u6001\u8bbe\u6210\u8f6c\u79fb\u65b9\u7a0b\u3002 P5017 \u5f00\u59cb\u60f3\u5230\u8bbe$f[i][j]$\u8868\u793a\u6709$i$\u4e2a\u4eba\u7b49\u5f85\uff0c\u5728\u7b2c$j$\u5206\u949f\u7684\u60c5\u51b5\u3002 ~~\u540e\u6765\u53d1\u73b0\u76f4\u63a5\u7206\u70b8~~ \u53d1\u73b0\u6211\u4eec\u65e0\u6cd5\u8bb0\u5f55\u7b49\u5f85\u7684\u4eba\u90fd\u662f\u8c01\uff0c\u6240\u4ee5\u5c31\u4e0d\u8bb0\u5f55\uff0c\u5728\u8f6c\u79fb\u65f6\u7b97\u51fa\u6765\u3002 \u6240\u4ee5\u8bbe$f[i][j]$\u8868\u793a\u8003\u8651\u5230\u7b2c$i$\u4e2a\u4eba\uff0c\u7b2c$j$\u5206\u949f\u7684\u60c5\u51b5\uff0c\u5c06$f[i][j]$\u8f6c\u79fb\u5230$f[i+k][j+m]$\u548c$f[i][j+1]$,\u8868\u793a\u7acb\u523b\u53d1\u8f66\u548c\u7b49\u5f85\u4e00\u5206\u949f\u7684\u60c5\u51b5\u3002 ~~\u7ed3\u679c\u8fd8\u662f\u7206\u70b8~~ \u6b63\u786e\u505a\u6cd5\u662f\uff1a \u6211\u4eec\u53d1\u73b0\u6709\u4e2a\u6027\u8d28\uff0c\u5c31\u662f\u6bcf\u4e2a\u4eba\u7b49\u5f85\u65f6\u95f4\u4e0d\u8d85\u8fc7$m-1$\uff0c\u56e0\u4e3a\u5c31\u7b97\u8fd9\u4e2a\u4eba\u5230\u8fbe\u7684\u524d\u4e00\u79d2\u949f\u53d1\u8f66\uff0c\u8fd8\u662f\u80fd\u5728$m-1$\u79d2\u540e\u4e0a\u8f66\u3002 \u6b64\u65f6\u5047\u8bbe\u7b2c$i$\u4e2a\u4eba\u5728$t[i]+j$\u79d2\u4e0a\u8f66\uff0c\u90a3\u4e48\u5728$[t[i]+j+1,t[i]+j+m]$\u79d2\u5185\u7684\u4eba\u7684\u7b49\u5f85\u65f6\u95f4\u5c31\u662f\u8fd9\u6b21\u8f6c\u79fb\u7684\u6240\u6709\u8d21\u732e\uff0c\u800c\u4e0d\u7528\u52a0\u4e0a$[t[i]+j-m+1,t[i]+j+m]$\u79d2\u5185\u7684\u8d21\u732e\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u5728\u4e0a\u4e00\u8f6e\u5df2\u7ecf\u8ba1\u7b97\u8fc7\u4e86\u3002 \u6b64\u65f6\u6211\u4eec\u53ea\u8003\u8651\u7b2c$i$\u4e2a\u4eba\u7b49\u5f85$\\min(m-1,t[i+1]-t[i])$\u79d2\u7684\u65f6\u95f4\u5373\u53ef\u3002 \u8bbe$f[i][j]$\u8868\u793a\u7b2c$i$\u4e2a\u4eba\u53ca\u4e4b\u524d\u7684\u6240\u6709\u4eba\u8981\u4e48\u5df2\u7ecf\u5230\u8fbe\u4e86\u76ee\u7684\u5730\uff0c\u8981\u4e48\u5df2\u7ecf\u5728\u8f66\u4e0a\u65f6\uff0c\u4e14$i$\u6070\u597d\u7b49\u4e86$j$\u79d2\u624d\u4e0a\u8f66\u7684\u6700\u4f18\u89e3\u3002 \u56e0\u4e3a\u7b2c$i+1$\u4e2a\u4eba\u5230\u7b2c$k$\u4e2a\u4eba\u90fd\u4e0d\u4f1a\u4e0a\u8f66\uff0c\u90fd\u8981\u7b49\u5230$t[i]+j+m=tmp+t[i+k]$\u79d2\uff0c\u6240\u4ee5\u4ed6\u4eec\u7b49\u5f85\u7684\u603b\u65f6\u95f4\u4e3a$\\sum_{v=i+1}^{i+k} tmp+t[i+k]-t[v]$,\u56e0\u4e3a$tmp+t[i+k]$\u4e3a\u5b9a\u503c\uff0c\u6240\u4ee5\u539f\u5f0f\u4e3a$k* (tmp+t[i+k])-(s[i+k]-s[i]) $ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=550,INF=0x3f3f3f3f; int f[N][N]; int t[N],s[N]; int n,m; bool cmp(int a,int b){return a<b;} int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%d\",&t[i]); sort(t+1,t+n+1,cmp); for(int i=1;i<=n;++i)s[i]=s[i-1]+t[i]; memset(f,0x3f,sizeof f); t[0]=-INF; f[0][0]=0; for(int i=0;i<=n;++i){ int maxn=min(m-1,t[i+1]-t[i]); for(int j=0;j<=maxn;++j){ if(f[i][j]>=INF)continue; for(int k=1;i+k<=n;++k){ int tmp=max(t[i]+j+m-t[i+k],0); f[i+k][tmp]=min(f[i+k][tmp],f[i][j]+(tmp+t[i+k])*k-(s[i+k]-s[i])); } } } int ans=INF; for(int i=0;i<m;++i)ans=min(ans,f[n][i]); printf(\"%d\",ans); return 0; } P3957 \u6bcf\u6b21\u7684$dp$\u5c31\u662f\u53d6$[i-R,i-L]$\u5185\u7684$f[j]_ { \\max } $,\u800c\u8fd9\u4e2a\u4e1c\u897f\u663e\u7136\u53ef\u4ee5\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u3002 \u6ce8\u610f\u6bcf\u6b21\u7684\u64cd\u4f5c\u5e94\u8be5\u5148\u4ece\u53f3\u52a0\u5165\u5143\u7d20\uff0c\u5728\u4ece\u5de6\u5220\u9664\uff0c\u5426\u5219\u4f1a\u51fa\u9519~~\u8fd9\u662f\u4e2a\u672a\u89e3\u4e4b\u8c1c\uff1f~~ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=5e5+10,INF=1e18; int n,d,k; int x[N],s[N],f[N]; int q[N]; bool check(int g) { int L=max(d-g,1ll),R=d+g,ans=-INF,l=1,r=0,tot=0;//\u6ce8\u610f\u51fa\u89c6\u72b6\u6001\u7684\u8bbe\u5b9a memset(f,-0x3f,sizeof f); f[0]=0; memset(q,0,sizeof q);//\u5b58\u50a8\u7684\u662f\u6700\u4f18\u89e3\u7684\u6807\u53f71~n for(int i=1; i<=n; ++i) { while(x[tot]<=x[i]-L && tot<i) {//1,\u4e0e2\u7684\u987a\u5e8f if(f[tot]>-INF) {//\u9632\u6b62\u975e\u6cd5\u72b6\u6001\u8f6c\u79fb while(r>=l && f[tot]>f[q[r]])--r; q[++r]=tot; } ++tot; } while(r>=l && x[i]-R>x[q[l]])++l;//2\uff0c\u88ab\u5751\u6b7b\uff0c\u6ce8\u610f\u4e0e1\u7684\u987a\u5e8f\u4e0d\u8981\u98a0\u5012 if(r>=l){ f[i]=max(f[i],f[q[l]]+s[i]); } ans=max(ans,f[i]); } return ans>=k; } signed main() { scanf(\"%lld%lld%lld\",&n,&d,&k); for(int i=1; i<=n; ++i)scanf(\"%lld%lld\",&x[i],&s[i]); int l=0,r=INF,ans=-1; while(l<r) { int mid=l+r>>1; if(check(mid)) { ans=mid; r=mid; } else l=mid+1; } if(l>=N) { printf(\"-1\"); } else printf(\"%lld\",ans); return 0; } \u987a\u4fbf\u7ec3\u7ec3\u53cc\u7aef\u961f\u5217$deque$\u6765\u5b9e\u73b0\u5355\u8c03\u961f\u5217 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=5e5+10,INF=1e18; int n,d,k; int x[N],s[N],f[N]; int read1(){int x=0,f=1;char ch=getchar();while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}while(ch<='9' && ch>='0'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}return x*f;} bool check(int g) { int L=max(d-g,1ll),R=d+g,ans=-INF,tot=0; memset(f,-0x3f,sizeof f); f[0]=0; deque<int> q; for(int i=1; i<=n; ++i) { while(x[tot]<=x[i]-L && tot<i) { if(f[tot]>-INF) { while(!q.empty() && f[tot]>f[q.back()])q.pop_back(); q.push_back(tot); } ++tot; } while(!q.empty() && x[i]-R>x[q.front()])q.pop_front(); if(!q.empty()){ f[i]=max(f[i],f[q.front()]+s[i]); } ans=max(ans,f[i]); } return ans>=k; } signed main() { n=read1(),d=read1(),k=read1(); for(int i=1; i<=n; ++i)x[i]=read1(),s[i]=read1(); int l=0,r=INF,ans=-1; while(l<r) { int mid=l+r>>1; if(check(mid)) { ans=mid; r=mid; } else l=mid+1; } if(l>=N) { printf(\"-1\"); } else printf(\"%lld\",ans); return 0; } ~~\u5b9e\u6d4bSTL\u662f\u771f\u7684\u6162\uff0c\u5feb\u8bfb\u5438\u6c27\u90fd\u62ef\u6551\u4e0d\u4e86~~","title":"\u7ebf\u6027dp/\u666e\u901adp"},{"location":"my%20past/OI/%E7%BA%BF%E6%80%A7dp/#dpdp","text":"","title":"\u7ebf\u6027dp/\u666e\u901adp"},{"location":"my%20past/OI/%E7%BA%BF%E6%80%A7dp/#dp","text":"P7074 \u7531\u4e8e\u4ece\u4e0a\u5f80\u4e0b\u6709\u540e\u6548\u6027\uff0c\u6240\u4ee5\u65cb\u8f6c90\u5ea6\u540e\u518d\u505adp \u5bf9\u4e8e\u6bcf\u4e2a\u5750\u6807\uff0c\u90fd\u6709\u4e24\u79cd\u65b9\u5411\uff0c\u5411\u5de6\u548c\u5411\u53f3\u3002 \u6240\u4ee5\u8bbef[i][j][0/1]\u8868\u793a\u5de6/\u53f3\u65b9\u5411\u65f6\u7684\u6700\u5927\u503c\u3002 \u6b64\u65f6\u6709\u8f6c\u79fb\u65b9\u7a0b\uff1a $$ f[i][j][0]=max(f[i][j][0],max(f[i][j-1][0],f[i][j-1][1])+c[i][j]);(i=1\\to n)\\ f[i][j][1]=max(f[i][j][1],max(f[i][j-1][0],f[i][j-1][1])+c[i][j]);(i=1\\to n)\\ f[i][j][0]=max(f[i][j][0],f[i-1][j][0]+c[i][j]);(i=1\\to n)\\ f[i][j][1]=max(f[i][j][1],f[i+1][j][1]+c[i][j]);(i=n\\to 1) $$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e3+10,INF=1e12; int n,m; int c[N][N],f[N][N][2]; signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i){ for(int j=1;j<=m;++j){ scanf(\"%lld\",&c[i][j]); } } for(int i=0;i<=n+1;++i){ for(int j=0;j<=m+1;++j){ f[i][j][0]=-INF; f[i][j][1]=-INF; } } f[1][1][0]=f[1][1][1]=c[1][1]; for(int j=1;j<=m;++j){ for(int i=1;i<=n;++i){ f[i][j][0]=max(f[i][j][0],max(f[i][j-1][0],f[i][j-1][1])+c[i][j]); f[i][j][1]=max(f[i][j][1],max(f[i][j-1][0],f[i][j-1][1])+c[i][j]); f[i][j][0]=max(f[i][j][0],f[i-1][j][0]+c[i][j]); } for(int i=n;i>=1;--i){ f[i][j][1]=max(f[i][j][1],f[i+1][j][1]+c[i][j]); } } printf(\"%lld\",max(f[n][m][0],f[n][m][1])); return 0; } P1437 \u56e0\u4e3a\u4ece\u4e0a\u5f80\u4e0b\u641c\u4f1a\u5b58\u5728\u540e\u6548\u6027\uff0c\u6240\u4ee5\u8981\u4ece\u53f3\u5f80\u5de6\u641c\u3002 \u8bbef[i][j][k]\u8868\u793a\u7b2ci\u5217\u53bb\u4e86j\u4e2a\u7816\u5757\u4e14\u603b\u5171\u53bb\u53d6\u4e86k\u4e2a\u7816\u5757\u7684\u72b6\u6001\u3002 \u8f6c\u79fb\u65b9\u7a0b+code\uff1a #include<iostream> #include<cstring> #include<cstdio> using namespace std; const int N=55,M=N*N; int n,m; int a[N][N]; int f[N][N][M]; int t[N][N]; int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i){ for(int j=1;j<=n-i+1;++j){ scanf(\"%d\",&a[i][j]); } } memset(f,-0x3f,sizeof f); //\u907f\u514d\u4e0d\u5408\u6cd5\u72b6\u6001\u7684\u8f6c\u79fb\u3002\u56e0\u4e3a\u6709v\u6bd4k-j\u5927\u7684\u60c5\u51b5\uff0c\u8fd9\u79cd\u60c5\u51b5\u4e0d\u5408\u6cd5\uff0c\u56e0\u6b64\u5e94\u8be5\u4e3a\u8d1f\u65e0\u7a77 f[n+1][0][0]=0;//\u521d\u59cb\u5316 int ans=0; for(int i=n;i>=1;--i){ for(int j=0,sum=0;j<=n-i+1;++j,sum+=a[j][i]){ for(int v=max(j-1,0)/*\u9632\u6ea2\u51fa*/;v<=n-i;++v){//\u8868\u793a\u4e0a\u4e00\u5217\u81f3\u5c11\u8981\u53d6j-1\u4e2a\uff0c\u6700\u591a\uff08n-i+1\uff09-1\u4e2a for(int k=j;k<=m;++k){ f[i][j][k]=max(f[i][j][k],f[i+1][v][k-j]+sum); } } } } for(int i=1;i<=n;++i){ for(int j=1;j<=n-i+1;++j)ans=max(ans,f[i][j][m]); } printf(\"%d\",ans); return 0; } /* 4 6 2 2 3 4 8 2 7 2 3 49 */ CF360B ~~\u6211\u662f\u50bb\u903c~~ \u4e8c\u5206+dp \u8bbedp[i]\u8868\u793a$a_i$\u4e0d\u6539\u65f61~i\u6700\u591a\u4e0d\u6539\u7684\u4e2a\u6570\u3002 \u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff1a for(int i=2;i<=n;++i){ for(int j=1;j<i;++j){ if(x*(i-j)>=abs1(a[i]-a[j])){ dp[i]=max(dp[i],dp[j]+1); } } } \u6761\u4ef6\u662f\u53ea\u8981\u4e24\u4e2a\u6570\u76f8\u5dee\u5728\u5f53\u524d\u4e8c\u5206\u7684\u957f\u5ea6\u8303\u56f4\u5185\uff0c\u90a3\u4e48\u5c31\u5c06i\u5230j\u4e4b\u95f4\u505a\u66f4\u6539\uff0ci\u548cj\u4fdd\u6301\u4e0d\u53d8\uff0c\u770b\u6700\u591a\u7559\u4e0b\u51e0\u4e2a\u6570\u4e0d\u6539\u3002 \u6b63\u786e\u6027\u662f\u56e0\u4e3a\u5982\u679ci\u5230j\u4e4b\u95f4\u6709\u5176\u4ed6\u4e0ei\u7b26\u5408\u8fd9\u4e2a\u6761\u4ef6\u7684\u6570k\uff0c\u90a3\u4e48k\u4e00\u5b9a\u4f1a\u88abi\u641c\u5230\uff0c\u53ef\u80fd\u5b58\u5728\u66f4\u4f18\u7684\u7ed3\u679c\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=2200,INF=0x7fffffff; int a[N],dp[N]; int n,k; int abs1(int x){ return x>0?x:-x; } bool check(int x){ int cnt=0; for(int i=1;i<=n;++i)dp[i]=1; for(int i=2;i<=n;++i){ for(int j=1;j<i;++j){ if(x*(i-j)>=abs1(a[i]-a[j])){ dp[i]=max(dp[i],dp[j]+1); } } } for(int i=1;i<=n;++i){ if(i-dp[i]+n-i<=k)return true; } return false; } signed main(){ scanf(\"%lld%lld\",&n,&k); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]); int l=0,r=INF,ans=INF; while(l<r){ int mid=l+r>>1; if(check(mid)){ r=mid; ans=mid; }else l=mid+1; } printf(\"%lld\",ans); return 0; } UVA1025 \u8bbe$f[i][j]$\u8868\u793a\u5728\u7b2c$j$\u79d2\u5230\u8fbe\u7b2c$i$\u4e2a\u8f66\u7ad9\u65f6\u7684\u6700\u5c0f\u7b49\u5f85\u65f6\u95f4\u3002 \u90a3\u4e48\u6bcf\u6b21\u7531\u4e09\u79cd\u51b3\u7b56\uff1a 1) \u5982\u679c\u4e0d\u662f1\u53f7\u8f66\u7ad9\u5e76\u4e14\u6b64\u65f6\u6709\u5411\u5de6\u7684\u8f66\uff0c\u5c31\u5411\u5de6\u8fb9\u3002 2) \u5982\u679c\u4e0d\u662fn\u53f7\u8f66\u7ad9\u5e76\u4e14\u6b64\u65f6\u6709\u5411\u53f3\u7684\u8f66\uff0c\u5c31\u5411\u53f3\u8fb9\u3002 3) \u5728\u8fd9\u4e2a\u8f66\u7ad9\u7b49\u5f851\u79d2\u3002 \u5224\u65ad\u6b64\u65f6\u6709\u6ca1\u6709\u5411\u5de6\u5411\u53f3\u7684\u8f66\u53ef\u4ee5\u9884\u5904\u7406\u51fa$g[i][j][0/1]$ #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=55,T=220,INF=0x3f3f3f3f; int f[N][T],g[N][T][2]; int u[T],v[T],a[N],b[N],s[N]; int n,t,M1,M2,cnt; void init() { memset(u,0,sizeof u);memset(v,0,sizeof v);memset(g,0,sizeof g);memset(f,0x3f,sizeof f); scanf(\"%d\",&t); for(int i=1;i<n;++i)scanf(\"%d\",&s[i]); a[1]=0;b[n]=0; for(int i=2;i<=n;++i)a[i]=a[i-1]+s[i-1]; for(int i=n-1;i>=1;--i)b[i]=b[i+1]+s[i]; scanf(\"%d\",&M1); for(int i=1,tmp; i<=M1; ++i)scanf(\"%d\",&tmp),u[tmp]=1; scanf(\"%d\",&M2); for(int i=1,tmp; i<=M2; ++i)scanf(\"%d\",&tmp),v[tmp]=1; for(int i=1;i<=n;++i) for(int j=0;j<=t;++j) if(j>=a[i] && u[j-a[i]])g[i][j][1]=1; if(j>=b[i] && v[j-b[i]])g[i][j][0]=1; f[1][0]=0; } void dp(){ for(int j=0;j<=t;++j) for(int i=1;i<=n;++i) if(g[i][j][0] && i>1)f[i-1][j+s[i-1]]=min(f[i-1][j+s[i-1]],f[i][j]); if(g[i][j][1] && i<n)f[i+1][j+s[i]]=min(f[i+1][j+s[i]],f[i][j]); f[i][j+1]=min(f[i][j+1],f[i][j]+1); } int main() { while(1) { scanf(\"%d\",&n); if(!n)return 0; ++cnt; init(); dp(); printf(\"Case Number %d: \",cnt); if(f[n][t]==INF)printf(\"impossible\\n\"); else printf(\"%d\\n\",f[n][t]); } return 0; } \u7ed3\u8bba\uff1a\u5c06\u51b3\u7b56\u5bf9\u5e94\u72b6\u6001\u8bbe\u6210\u8f6c\u79fb\u65b9\u7a0b\u3002 P5017 \u5f00\u59cb\u60f3\u5230\u8bbe$f[i][j]$\u8868\u793a\u6709$i$\u4e2a\u4eba\u7b49\u5f85\uff0c\u5728\u7b2c$j$\u5206\u949f\u7684\u60c5\u51b5\u3002 ~~\u540e\u6765\u53d1\u73b0\u76f4\u63a5\u7206\u70b8~~ \u53d1\u73b0\u6211\u4eec\u65e0\u6cd5\u8bb0\u5f55\u7b49\u5f85\u7684\u4eba\u90fd\u662f\u8c01\uff0c\u6240\u4ee5\u5c31\u4e0d\u8bb0\u5f55\uff0c\u5728\u8f6c\u79fb\u65f6\u7b97\u51fa\u6765\u3002 \u6240\u4ee5\u8bbe$f[i][j]$\u8868\u793a\u8003\u8651\u5230\u7b2c$i$\u4e2a\u4eba\uff0c\u7b2c$j$\u5206\u949f\u7684\u60c5\u51b5\uff0c\u5c06$f[i][j]$\u8f6c\u79fb\u5230$f[i+k][j+m]$\u548c$f[i][j+1]$,\u8868\u793a\u7acb\u523b\u53d1\u8f66\u548c\u7b49\u5f85\u4e00\u5206\u949f\u7684\u60c5\u51b5\u3002 ~~\u7ed3\u679c\u8fd8\u662f\u7206\u70b8~~ \u6b63\u786e\u505a\u6cd5\u662f\uff1a \u6211\u4eec\u53d1\u73b0\u6709\u4e2a\u6027\u8d28\uff0c\u5c31\u662f\u6bcf\u4e2a\u4eba\u7b49\u5f85\u65f6\u95f4\u4e0d\u8d85\u8fc7$m-1$\uff0c\u56e0\u4e3a\u5c31\u7b97\u8fd9\u4e2a\u4eba\u5230\u8fbe\u7684\u524d\u4e00\u79d2\u949f\u53d1\u8f66\uff0c\u8fd8\u662f\u80fd\u5728$m-1$\u79d2\u540e\u4e0a\u8f66\u3002 \u6b64\u65f6\u5047\u8bbe\u7b2c$i$\u4e2a\u4eba\u5728$t[i]+j$\u79d2\u4e0a\u8f66\uff0c\u90a3\u4e48\u5728$[t[i]+j+1,t[i]+j+m]$\u79d2\u5185\u7684\u4eba\u7684\u7b49\u5f85\u65f6\u95f4\u5c31\u662f\u8fd9\u6b21\u8f6c\u79fb\u7684\u6240\u6709\u8d21\u732e\uff0c\u800c\u4e0d\u7528\u52a0\u4e0a$[t[i]+j-m+1,t[i]+j+m]$\u79d2\u5185\u7684\u8d21\u732e\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u5728\u4e0a\u4e00\u8f6e\u5df2\u7ecf\u8ba1\u7b97\u8fc7\u4e86\u3002 \u6b64\u65f6\u6211\u4eec\u53ea\u8003\u8651\u7b2c$i$\u4e2a\u4eba\u7b49\u5f85$\\min(m-1,t[i+1]-t[i])$\u79d2\u7684\u65f6\u95f4\u5373\u53ef\u3002 \u8bbe$f[i][j]$\u8868\u793a\u7b2c$i$\u4e2a\u4eba\u53ca\u4e4b\u524d\u7684\u6240\u6709\u4eba\u8981\u4e48\u5df2\u7ecf\u5230\u8fbe\u4e86\u76ee\u7684\u5730\uff0c\u8981\u4e48\u5df2\u7ecf\u5728\u8f66\u4e0a\u65f6\uff0c\u4e14$i$\u6070\u597d\u7b49\u4e86$j$\u79d2\u624d\u4e0a\u8f66\u7684\u6700\u4f18\u89e3\u3002 \u56e0\u4e3a\u7b2c$i+1$\u4e2a\u4eba\u5230\u7b2c$k$\u4e2a\u4eba\u90fd\u4e0d\u4f1a\u4e0a\u8f66\uff0c\u90fd\u8981\u7b49\u5230$t[i]+j+m=tmp+t[i+k]$\u79d2\uff0c\u6240\u4ee5\u4ed6\u4eec\u7b49\u5f85\u7684\u603b\u65f6\u95f4\u4e3a$\\sum_{v=i+1}^{i+k} tmp+t[i+k]-t[v]$,\u56e0\u4e3a$tmp+t[i+k]$\u4e3a\u5b9a\u503c\uff0c\u6240\u4ee5\u539f\u5f0f\u4e3a$k* (tmp+t[i+k])-(s[i+k]-s[i]) $ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=550,INF=0x3f3f3f3f; int f[N][N]; int t[N],s[N]; int n,m; bool cmp(int a,int b){return a<b;} int main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%d\",&t[i]); sort(t+1,t+n+1,cmp); for(int i=1;i<=n;++i)s[i]=s[i-1]+t[i]; memset(f,0x3f,sizeof f); t[0]=-INF; f[0][0]=0; for(int i=0;i<=n;++i){ int maxn=min(m-1,t[i+1]-t[i]); for(int j=0;j<=maxn;++j){ if(f[i][j]>=INF)continue; for(int k=1;i+k<=n;++k){ int tmp=max(t[i]+j+m-t[i+k],0); f[i+k][tmp]=min(f[i+k][tmp],f[i][j]+(tmp+t[i+k])*k-(s[i+k]-s[i])); } } } int ans=INF; for(int i=0;i<m;++i)ans=min(ans,f[n][i]); printf(\"%d\",ans); return 0; } P3957 \u6bcf\u6b21\u7684$dp$\u5c31\u662f\u53d6$[i-R,i-L]$\u5185\u7684$f[j]_ { \\max } $,\u800c\u8fd9\u4e2a\u4e1c\u897f\u663e\u7136\u53ef\u4ee5\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u3002 \u6ce8\u610f\u6bcf\u6b21\u7684\u64cd\u4f5c\u5e94\u8be5\u5148\u4ece\u53f3\u52a0\u5165\u5143\u7d20\uff0c\u5728\u4ece\u5de6\u5220\u9664\uff0c\u5426\u5219\u4f1a\u51fa\u9519~~\u8fd9\u662f\u4e2a\u672a\u89e3\u4e4b\u8c1c\uff1f~~ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=5e5+10,INF=1e18; int n,d,k; int x[N],s[N],f[N]; int q[N]; bool check(int g) { int L=max(d-g,1ll),R=d+g,ans=-INF,l=1,r=0,tot=0;//\u6ce8\u610f\u51fa\u89c6\u72b6\u6001\u7684\u8bbe\u5b9a memset(f,-0x3f,sizeof f); f[0]=0; memset(q,0,sizeof q);//\u5b58\u50a8\u7684\u662f\u6700\u4f18\u89e3\u7684\u6807\u53f71~n for(int i=1; i<=n; ++i) { while(x[tot]<=x[i]-L && tot<i) {//1,\u4e0e2\u7684\u987a\u5e8f if(f[tot]>-INF) {//\u9632\u6b62\u975e\u6cd5\u72b6\u6001\u8f6c\u79fb while(r>=l && f[tot]>f[q[r]])--r; q[++r]=tot; } ++tot; } while(r>=l && x[i]-R>x[q[l]])++l;//2\uff0c\u88ab\u5751\u6b7b\uff0c\u6ce8\u610f\u4e0e1\u7684\u987a\u5e8f\u4e0d\u8981\u98a0\u5012 if(r>=l){ f[i]=max(f[i],f[q[l]]+s[i]); } ans=max(ans,f[i]); } return ans>=k; } signed main() { scanf(\"%lld%lld%lld\",&n,&d,&k); for(int i=1; i<=n; ++i)scanf(\"%lld%lld\",&x[i],&s[i]); int l=0,r=INF,ans=-1; while(l<r) { int mid=l+r>>1; if(check(mid)) { ans=mid; r=mid; } else l=mid+1; } if(l>=N) { printf(\"-1\"); } else printf(\"%lld\",ans); return 0; } \u987a\u4fbf\u7ec3\u7ec3\u53cc\u7aef\u961f\u5217$deque$\u6765\u5b9e\u73b0\u5355\u8c03\u961f\u5217 #include<iostream> #include<cstdio> #include<cstring> #include<queue> #define int long long using namespace std; const int N=5e5+10,INF=1e18; int n,d,k; int x[N],s[N],f[N]; int read1(){int x=0,f=1;char ch=getchar();while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}while(ch<='9' && ch>='0'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}return x*f;} bool check(int g) { int L=max(d-g,1ll),R=d+g,ans=-INF,tot=0; memset(f,-0x3f,sizeof f); f[0]=0; deque<int> q; for(int i=1; i<=n; ++i) { while(x[tot]<=x[i]-L && tot<i) { if(f[tot]>-INF) { while(!q.empty() && f[tot]>f[q.back()])q.pop_back(); q.push_back(tot); } ++tot; } while(!q.empty() && x[i]-R>x[q.front()])q.pop_front(); if(!q.empty()){ f[i]=max(f[i],f[q.front()]+s[i]); } ans=max(ans,f[i]); } return ans>=k; } signed main() { n=read1(),d=read1(),k=read1(); for(int i=1; i<=n; ++i)x[i]=read1(),s[i]=read1(); int l=0,r=INF,ans=-1; while(l<r) { int mid=l+r>>1; if(check(mid)) { ans=mid; r=mid; } else l=mid+1; } if(l>=N) { printf(\"-1\"); } else printf(\"%lld\",ans); return 0; } ~~\u5b9e\u6d4bSTL\u662f\u771f\u7684\u6162\uff0c\u5feb\u8bfb\u5438\u6c27\u90fd\u62ef\u6551\u4e0d\u4e86~~","title":"\u5750\u6807dp"},{"location":"my%20past/OI/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/","text":"\u7ebf\u6027\u4ee3\u6570 \u7ebf\u6027\u57fa \u5b9a\u4e49 \u5b9a\u4e49\u4e00\u4e2ap\u6570\u7ec4\uff0c\u6ee1\u8db3\u5bf9\u4e8e\u4efb\u610fa\u6570\u7ec4\u4e2d\u7684\u6570\uff0c\u90fd\u80fd\u7531p\u4e2d\u4e00\u4e9b\u5143\u7d20\u5f02\u6216\u5f97\u6765\uff0c\u5e76\u4e14\u4fdd\u8bc1p\u5143\u7d20\u4e2a\u6570\u6700\u5c11\u3002 \u5176\u4e2da\u6570\u7ec4\u4e2d\u6570\u7684\u4e2a\u6570\u4e3an\uff0c\u6700\u5927\u503c\u7ea6\u4e3a$2^N$\uff0c\u5219p\u6570\u7ec4\u7684\u5927\u5c0f\u4e3a$\\Theta(N)$\uff0c\u5373\u5c06a\u4e2d\u7684\u6570\u770b\u62102\u8fdb\u5236\u6570\uff0cp\u53ea\u7531N\u4e2a\u7b2ci\u4f4d\u662f\u6700\u9ad8\u4f4d1\u7684\u6570\u7ec4\u6210\uff0c1<=i<=N\u3002 \u81f3\u4e8e\u4e3a\u4ec0\u4e48\u4e0d\u4f7f\u7528\u6700\u9ad8\u4f4d\u4e3a1\uff0c\u5176\u4ed6\u4f4d\u5168\u4e3a0\u7684\u6570\u4f5c\u4e3a\u57fa\uff0c\u56e0\u4e3a\u5982\u679c\u8d2a\u5fc3\u5730\uff0c\u53ea\u8981$a$\u6570\u7ec4\u7b2c$i$\u4f4d\u67091\uff0c\u5c31\u52a0\u5165$2^{i-1}$\u4f5c\u4e3a\u57fa\uff0c\u4f46\u662f\u53ef\u80fd\u6709\u4e00\u4e2a\u57fa\u7b2c$i$\u4f4d\u662f1\uff0c\u53ef\u4ee5\u8868\u793a\u8fd9\u4e2a\u6570\uff0c\u90a3\u4e48\u5c31\u4e0d\u9700\u8981$2^{i-1}$\uff0c\u5373\u6c42\u51fa\u7684\u57fa\u4e0d\u4e00\u5b9a\u662f\u6700\u5c11\u7684\u3002 \u6784\u9020\u65b9\u5f0f void add(int x){ for(int i=N-1;i>=0;--i){ if(x&(1ll<<i)){//\u53ef\u4ee5\u75311<<i\u6d88\u53bb\u6700\u9ad8\u4f4d\u76841\uff0c\u7ee7\u7eed\u5339\u914d\u4f4e\u4f4d\u76841,\u6ce8\u610f1ll if(!p[i]){//\u6ca1\u6709\u5bf9\u5e94\u7684p[i]\uff0c\u5c31\u521b\u9020\u4e00\u4e2a p[i]=x;cnt++;break;//cnt\u8868\u793ap\u4e2d\u5143\u7d20\u4e2a\u6570 } x^=p[i];//\u6709\u5bf9\u5e94\u7684p[i]\u5c31\u6d88\u53bb } } return; } \u89e3\u91ca\uff1a\u56e0\u4e3aa[i]\u53ef\u4ee5\u7531p\u9010\u6e10\u6d88\u53bb\u6700\u9ad8\u4f4d1\uff0c\u6700\u7ec8\u5f97\u52300\uff0c\u6240\u4ee5 \u6700\u591a \u53ea\u9700\u8981N\u4e2a\"\u6700\u9ad8\u4f4d1\"\u6570 3812 \u771f.\u6a21\u677f \u4e3a\u4ec0\u4e48\u7531\u7ebf\u6027\u57fa\u4ece\u9ad8\u4f4d\u5230\u4f4e\u4f4d\u8d2a\u5fc3\u5f02\u6216\u51fa\u6765\u7684\u5c31\u662f\u6700\u5927\u503c\uff1f \u56e0\u4e3a\u5373\u4fbf1011111^111111\u540e\u4f1a\u4f7f\u540e\u4e94\u4f4d\u53d8\u4e3a\u96f6\uff0c\u4f46\u662f\u7b2c\u516d\u4f4d\u4f1a\u53d81\uff0c\u6240\u4ee5\u8d2a\u5fc3\u662f\u6b63\u786e\u6ef4\u30021011111^111111=1100000 \u4f1a\u4e0d\u4f1a\u6700\u5927\u503c\u4e0d\u80fd\u7531\u7ebf\u6027\u57fa\u6784\u9020\u51fa\u6765\uff1f \u4e0d\u53ef\u80fd\uff0c\u56e0\u4e3ax1^x1=0,0^x1=x1,\u5c31\u662f\u8bf4\uff0c\u540c\u4e00\u4e2a\u6570x1\u5f02\u6216\u4efb\u610f\u6b21\u53ea\u80fd\u4e3ax1\u62160\u3002 \u5982\u679c\u5b58\u5728\u6700\u5927\u503c\uff0c\u90a3\u4e48\u5b83\u662fa1^a2^...^an\u5f97\u6765,\u5c31\u662f(x1^x2)^(x1^x3)^...^(x2^x3),\u800c\u6700\u540e\u4e00\u5b9a\u80fd\u5316\u4e3ax1^x2^...^xn. \u4f1a\u4e0d\u4f1a\u7ebf\u6027\u57fa\u5f02\u6216\u51fa\u7684\u6700\u5927\u503c\u4e0d\u80fd\u7531\u539f\u6570\u7ec4\u5f97\u51fa\uff1f \u4e0d\u53ef\u80fd\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u7ebf\u6027\u57fa\u81f3\u5c11\u7531\u4e00\u4e2a\u539f\u6570\u7ec4\u4e2d\u7684\u6570\u5f97\u51fa\u3002 1.\u5047\u8bbe\u4e00\u4e2a\u539f\u6570a\u5305\u542b\u6700\u9ad8\u4f4d\u7ebf\u6027\u57fax1\u548c\u5f53\u524d\u7ebf\u6027\u57fax3\uff0c\u4e00\u4e2a\u539f\u6570b\u5305\u542b\u6b21\u9ad8\u4f4d\u7ebf\u6027\u57fax2\u548c\u5f53\u524d\u7ebf\u6027\u57fax3\uff0c\u90a3\u4e48\uff1a \u82e5\u5148a\uff0c\u5219\u4e0d\u53ef\u80fd\u6709x3\u51fa\u73b0 \u82e5\u5148b\uff0c\u5219\u4e0d\u53ef\u80fd\u6709x3\u51fa\u73b0 \u6240\u4ee5\u4e0d\u4f1a\u51fa\u73b0x3\u62b5\u6d88x3\u7684\u60c5\u51b5\uff0c\u56e0\u4e3ax3\u4e0d\u53ef\u80fd\u5b58\u5728\u3002 2.\u5047\u8bbe\u4e00\u4e2a\u6570a\u5305\u542b\u9ad8\u4f4dx1\u548c\u4f4e\u4f4dx2,\u4e00\u4e2a\u6570b\u5305\u542b\u4f4e\u4f4dx2,\u663e\u7136a\u5c31\u662f\u6700\u5927\u503c. 2.\u5047\u8bbe\u4e00\u4e2a\u6570a\u5305\u542b\u9ad8\u4f4dx1,\u4e00\u4e2a\u6570b\u5305\u542b\u4f4e\u4f4dx2,\u663e\u7136a^b\u5c31\u662f\u6700\u5927\u503c \u6240\u4ee5\u4e0d\u53ef\u80fd\u4f1a\u6709\u6700\u5927\u503c\u4e0d\u80fd\u7531\u539f\u6570\u7ec4\u5f97\u51fa\u7684\u60c5\u51b5\u3002 P3857 TJOI \u6a21\u677f\u9898\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5f00\u5173\u90fd\u662f\u4e00\u4e2a2\u8fdb\u5236\u6570\uff0c\u4ee4p\u4e3a\u7ec4\u6210a\u6240\u6709\u6570\u7684\u7ebf\u6027\u57fa\uff0c\u56e0\u4e3a\u6ca1\u8bf4\u4e00\u4e2a\u6570\u53ea\u7528\u4e00\u6b21\uff0c\u90a3\u4e48\u6bcf\u4e2ap[i]\u7531\u88ab\u9009\u548c\u4e0d\u88ab\u9009\u4e24\u79cd\u53ef\u80fd\uff0c\u7b54\u6848\u4e3a$2^N$ #include<iostream> #include<cstring> #include<cstdio> #define int long long using namespace std; const int N=55; int a[N<<2],p[N<<2]; int n,m,cnt; int read1(){ int x=0; char ch=getchar(); while(ch!='O' && ch!='X'){ ch=getchar(); } while(ch=='O' || ch=='X'){ int f=0; if(ch=='O')f=1; x=(x<<1)+f; ch=getchar(); } return x; } void add(int x){ for(int i=N-1;i>=0;--i){ if(x&(1ll<<i)){ if(!p[i]){ p[i]=x;cnt++;break; } x^=p[i]; } } return; } int kp(int x,int p){ if(p<=1)return x; if(p%2==0)return kp(x*x,p>>1); else return x*kp(x*x,p>>1); } signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=m;++i){ a[i]=read1(); } cnt=0; for(int i=1;i<=m;++i){ add(a[i]); } printf(\"%lld\",(1ll<<cnt)%2008); return 0; } P4570 BJWC ~~\u6211\u662f\u50bb\u903c~~ \u8fd9\u9053\u9898\u6709\u4e00\u4e2a\u91cd\u8981\u6761\u4ef6\uff0c~~\u4e5f\u662f\u6211\u6ca1\u770b\u89c1\u7684~~\uff0c\u5c31\u662f \u4e00\u4e2a\u77ff\u77f3\u7ec4\u5408\u4f1a\u4ea7\u751f\u201c\u9b54\u6cd5\u62b5\u6d88\u201d\u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u4e00\u4e2a\u975e\u7a7a\u5b50\u96c6\uff0c\u90a3\u4e9b\u77ff\u77f3\u7684\u5143\u7d20\u5e8f\u53f7\u6309\u4f4d\u5f02\u6216\u8d77\u6765\u4e3a\u96f6 \u610f\u601d\u662f\u8bf4\uff0c\u4efb\u4f55\u9b54\u6cd5\u77f3\u4e0d\u80fd\u5f02\u6216\u4e24\u904d\u53ca\u4ee5\u4e0a\uff0c\u6bcf\u4e2a\u7ebf\u6027\u57fa\u53ea\u80fd\u7528\u4e00\u6b21\uff0c\u4e0d\u7ba1\u5b83\u5728\u6bcf\u4e2a\u6570\u4e2d\u51fa\u73b0\u591a\u5c11\u6b21\uff0c\u90a3\u4e48\u6bcf\u4e2a\u7ebf\u6027\u57fa\u7684\u8d21\u732e\u5c31\u662f\u5b83\u7b2c\u4e00\u6b21\u5728\u9b54\u6cd5\u77f3\u4e2d\u51fa\u73b0\u65f6\u7684\u503c\u3002\u8981\u4f7f\u503c\u6700\u5927\uff0c\u5c31\u628a\u9b54\u6cd5\u77f3\u6309\u8d21\u732e\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2100,K=63; int n,x,y,ans; int p[N]; struct node{ int x,y; }q[N]; bool cmp(node a,node b){ return a.y>b.y; } void add(int i){ int x=q[i].x,y=q[i].y; for(int i=K-1;i>=0;--i){ if(x&(1ll<<i)){//1ll \u6ce8\u610f if(!p[i]){ p[i]=x; ans+=y; break; } x^=p[i]; } } return; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i){ scanf(\"%lld%lld\",&q[i].x,&q[i].y); } sort(q+1,q+n+1,cmp); for(int i=1;i<=n;++i){ add(i); } printf(\"%lld\",ans); return 0; }","title":"\u7ebf\u6027\u4ee3\u6570"},{"location":"my%20past/OI/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#_1","text":"","title":"\u7ebf\u6027\u4ee3\u6570"},{"location":"my%20past/OI/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#_2","text":"","title":"\u7ebf\u6027\u57fa"},{"location":"my%20past/OI/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#_3","text":"\u5b9a\u4e49\u4e00\u4e2ap\u6570\u7ec4\uff0c\u6ee1\u8db3\u5bf9\u4e8e\u4efb\u610fa\u6570\u7ec4\u4e2d\u7684\u6570\uff0c\u90fd\u80fd\u7531p\u4e2d\u4e00\u4e9b\u5143\u7d20\u5f02\u6216\u5f97\u6765\uff0c\u5e76\u4e14\u4fdd\u8bc1p\u5143\u7d20\u4e2a\u6570\u6700\u5c11\u3002 \u5176\u4e2da\u6570\u7ec4\u4e2d\u6570\u7684\u4e2a\u6570\u4e3an\uff0c\u6700\u5927\u503c\u7ea6\u4e3a$2^N$\uff0c\u5219p\u6570\u7ec4\u7684\u5927\u5c0f\u4e3a$\\Theta(N)$\uff0c\u5373\u5c06a\u4e2d\u7684\u6570\u770b\u62102\u8fdb\u5236\u6570\uff0cp\u53ea\u7531N\u4e2a\u7b2ci\u4f4d\u662f\u6700\u9ad8\u4f4d1\u7684\u6570\u7ec4\u6210\uff0c1<=i<=N\u3002 \u81f3\u4e8e\u4e3a\u4ec0\u4e48\u4e0d\u4f7f\u7528\u6700\u9ad8\u4f4d\u4e3a1\uff0c\u5176\u4ed6\u4f4d\u5168\u4e3a0\u7684\u6570\u4f5c\u4e3a\u57fa\uff0c\u56e0\u4e3a\u5982\u679c\u8d2a\u5fc3\u5730\uff0c\u53ea\u8981$a$\u6570\u7ec4\u7b2c$i$\u4f4d\u67091\uff0c\u5c31\u52a0\u5165$2^{i-1}$\u4f5c\u4e3a\u57fa\uff0c\u4f46\u662f\u53ef\u80fd\u6709\u4e00\u4e2a\u57fa\u7b2c$i$\u4f4d\u662f1\uff0c\u53ef\u4ee5\u8868\u793a\u8fd9\u4e2a\u6570\uff0c\u90a3\u4e48\u5c31\u4e0d\u9700\u8981$2^{i-1}$\uff0c\u5373\u6c42\u51fa\u7684\u57fa\u4e0d\u4e00\u5b9a\u662f\u6700\u5c11\u7684\u3002","title":"\u5b9a\u4e49"},{"location":"my%20past/OI/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/#_4","text":"void add(int x){ for(int i=N-1;i>=0;--i){ if(x&(1ll<<i)){//\u53ef\u4ee5\u75311<<i\u6d88\u53bb\u6700\u9ad8\u4f4d\u76841\uff0c\u7ee7\u7eed\u5339\u914d\u4f4e\u4f4d\u76841,\u6ce8\u610f1ll if(!p[i]){//\u6ca1\u6709\u5bf9\u5e94\u7684p[i]\uff0c\u5c31\u521b\u9020\u4e00\u4e2a p[i]=x;cnt++;break;//cnt\u8868\u793ap\u4e2d\u5143\u7d20\u4e2a\u6570 } x^=p[i];//\u6709\u5bf9\u5e94\u7684p[i]\u5c31\u6d88\u53bb } } return; } \u89e3\u91ca\uff1a\u56e0\u4e3aa[i]\u53ef\u4ee5\u7531p\u9010\u6e10\u6d88\u53bb\u6700\u9ad8\u4f4d1\uff0c\u6700\u7ec8\u5f97\u52300\uff0c\u6240\u4ee5 \u6700\u591a \u53ea\u9700\u8981N\u4e2a\"\u6700\u9ad8\u4f4d1\"\u6570 3812 \u771f.\u6a21\u677f \u4e3a\u4ec0\u4e48\u7531\u7ebf\u6027\u57fa\u4ece\u9ad8\u4f4d\u5230\u4f4e\u4f4d\u8d2a\u5fc3\u5f02\u6216\u51fa\u6765\u7684\u5c31\u662f\u6700\u5927\u503c\uff1f \u56e0\u4e3a\u5373\u4fbf1011111^111111\u540e\u4f1a\u4f7f\u540e\u4e94\u4f4d\u53d8\u4e3a\u96f6\uff0c\u4f46\u662f\u7b2c\u516d\u4f4d\u4f1a\u53d81\uff0c\u6240\u4ee5\u8d2a\u5fc3\u662f\u6b63\u786e\u6ef4\u30021011111^111111=1100000 \u4f1a\u4e0d\u4f1a\u6700\u5927\u503c\u4e0d\u80fd\u7531\u7ebf\u6027\u57fa\u6784\u9020\u51fa\u6765\uff1f \u4e0d\u53ef\u80fd\uff0c\u56e0\u4e3ax1^x1=0,0^x1=x1,\u5c31\u662f\u8bf4\uff0c\u540c\u4e00\u4e2a\u6570x1\u5f02\u6216\u4efb\u610f\u6b21\u53ea\u80fd\u4e3ax1\u62160\u3002 \u5982\u679c\u5b58\u5728\u6700\u5927\u503c\uff0c\u90a3\u4e48\u5b83\u662fa1^a2^...^an\u5f97\u6765,\u5c31\u662f(x1^x2)^(x1^x3)^...^(x2^x3),\u800c\u6700\u540e\u4e00\u5b9a\u80fd\u5316\u4e3ax1^x2^...^xn. \u4f1a\u4e0d\u4f1a\u7ebf\u6027\u57fa\u5f02\u6216\u51fa\u7684\u6700\u5927\u503c\u4e0d\u80fd\u7531\u539f\u6570\u7ec4\u5f97\u51fa\uff1f \u4e0d\u53ef\u80fd\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u7ebf\u6027\u57fa\u81f3\u5c11\u7531\u4e00\u4e2a\u539f\u6570\u7ec4\u4e2d\u7684\u6570\u5f97\u51fa\u3002 1.\u5047\u8bbe\u4e00\u4e2a\u539f\u6570a\u5305\u542b\u6700\u9ad8\u4f4d\u7ebf\u6027\u57fax1\u548c\u5f53\u524d\u7ebf\u6027\u57fax3\uff0c\u4e00\u4e2a\u539f\u6570b\u5305\u542b\u6b21\u9ad8\u4f4d\u7ebf\u6027\u57fax2\u548c\u5f53\u524d\u7ebf\u6027\u57fax3\uff0c\u90a3\u4e48\uff1a \u82e5\u5148a\uff0c\u5219\u4e0d\u53ef\u80fd\u6709x3\u51fa\u73b0 \u82e5\u5148b\uff0c\u5219\u4e0d\u53ef\u80fd\u6709x3\u51fa\u73b0 \u6240\u4ee5\u4e0d\u4f1a\u51fa\u73b0x3\u62b5\u6d88x3\u7684\u60c5\u51b5\uff0c\u56e0\u4e3ax3\u4e0d\u53ef\u80fd\u5b58\u5728\u3002 2.\u5047\u8bbe\u4e00\u4e2a\u6570a\u5305\u542b\u9ad8\u4f4dx1\u548c\u4f4e\u4f4dx2,\u4e00\u4e2a\u6570b\u5305\u542b\u4f4e\u4f4dx2,\u663e\u7136a\u5c31\u662f\u6700\u5927\u503c. 2.\u5047\u8bbe\u4e00\u4e2a\u6570a\u5305\u542b\u9ad8\u4f4dx1,\u4e00\u4e2a\u6570b\u5305\u542b\u4f4e\u4f4dx2,\u663e\u7136a^b\u5c31\u662f\u6700\u5927\u503c \u6240\u4ee5\u4e0d\u53ef\u80fd\u4f1a\u6709\u6700\u5927\u503c\u4e0d\u80fd\u7531\u539f\u6570\u7ec4\u5f97\u51fa\u7684\u60c5\u51b5\u3002 P3857 TJOI \u6a21\u677f\u9898\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5f00\u5173\u90fd\u662f\u4e00\u4e2a2\u8fdb\u5236\u6570\uff0c\u4ee4p\u4e3a\u7ec4\u6210a\u6240\u6709\u6570\u7684\u7ebf\u6027\u57fa\uff0c\u56e0\u4e3a\u6ca1\u8bf4\u4e00\u4e2a\u6570\u53ea\u7528\u4e00\u6b21\uff0c\u90a3\u4e48\u6bcf\u4e2ap[i]\u7531\u88ab\u9009\u548c\u4e0d\u88ab\u9009\u4e24\u79cd\u53ef\u80fd\uff0c\u7b54\u6848\u4e3a$2^N$ #include<iostream> #include<cstring> #include<cstdio> #define int long long using namespace std; const int N=55; int a[N<<2],p[N<<2]; int n,m,cnt; int read1(){ int x=0; char ch=getchar(); while(ch!='O' && ch!='X'){ ch=getchar(); } while(ch=='O' || ch=='X'){ int f=0; if(ch=='O')f=1; x=(x<<1)+f; ch=getchar(); } return x; } void add(int x){ for(int i=N-1;i>=0;--i){ if(x&(1ll<<i)){ if(!p[i]){ p[i]=x;cnt++;break; } x^=p[i]; } } return; } int kp(int x,int p){ if(p<=1)return x; if(p%2==0)return kp(x*x,p>>1); else return x*kp(x*x,p>>1); } signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=m;++i){ a[i]=read1(); } cnt=0; for(int i=1;i<=m;++i){ add(a[i]); } printf(\"%lld\",(1ll<<cnt)%2008); return 0; } P4570 BJWC ~~\u6211\u662f\u50bb\u903c~~ \u8fd9\u9053\u9898\u6709\u4e00\u4e2a\u91cd\u8981\u6761\u4ef6\uff0c~~\u4e5f\u662f\u6211\u6ca1\u770b\u89c1\u7684~~\uff0c\u5c31\u662f \u4e00\u4e2a\u77ff\u77f3\u7ec4\u5408\u4f1a\u4ea7\u751f\u201c\u9b54\u6cd5\u62b5\u6d88\u201d\u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u4e00\u4e2a\u975e\u7a7a\u5b50\u96c6\uff0c\u90a3\u4e9b\u77ff\u77f3\u7684\u5143\u7d20\u5e8f\u53f7\u6309\u4f4d\u5f02\u6216\u8d77\u6765\u4e3a\u96f6 \u610f\u601d\u662f\u8bf4\uff0c\u4efb\u4f55\u9b54\u6cd5\u77f3\u4e0d\u80fd\u5f02\u6216\u4e24\u904d\u53ca\u4ee5\u4e0a\uff0c\u6bcf\u4e2a\u7ebf\u6027\u57fa\u53ea\u80fd\u7528\u4e00\u6b21\uff0c\u4e0d\u7ba1\u5b83\u5728\u6bcf\u4e2a\u6570\u4e2d\u51fa\u73b0\u591a\u5c11\u6b21\uff0c\u90a3\u4e48\u6bcf\u4e2a\u7ebf\u6027\u57fa\u7684\u8d21\u732e\u5c31\u662f\u5b83\u7b2c\u4e00\u6b21\u5728\u9b54\u6cd5\u77f3\u4e2d\u51fa\u73b0\u65f6\u7684\u503c\u3002\u8981\u4f7f\u503c\u6700\u5927\uff0c\u5c31\u628a\u9b54\u6cd5\u77f3\u6309\u8d21\u732e\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2100,K=63; int n,x,y,ans; int p[N]; struct node{ int x,y; }q[N]; bool cmp(node a,node b){ return a.y>b.y; } void add(int i){ int x=q[i].x,y=q[i].y; for(int i=K-1;i>=0;--i){ if(x&(1ll<<i)){//1ll \u6ce8\u610f if(!p[i]){ p[i]=x; ans+=y; break; } x^=p[i]; } } return; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i){ scanf(\"%lld%lld\",&q[i].x,&q[i].y); } sort(q+1,q+n+1,cmp); for(int i=1;i<=n;++i){ add(i); } printf(\"%lld\",ans); return 0; }","title":"\u6784\u9020\u65b9\u5f0f"},{"location":"my%20past/OI/%E7%BA%BF%E6%80%A7%E7%AD%9B/","text":"\u6b27\u62c9\u7b5b m=0; for(int i=2;i<=n;++i)vis[i]=1;//\u5047\u8bbe\u6240\u6709\u6570\u4e3a\u8d28\u6570 for(int i=2;i<=n;++i){ if(vis[i])p[++m]=i;//\u5f53\u524d\u662f\u8d28\u6570 for(int j=1;j<=m && p[j]*i<=n;++j){//\u4ece\u6240\u6709\u5df2\u77e5\u8d28\u6570\u4e2d\u4ece\u5c0f\u5230\u5927\u679a\u4e3e vis[p[j]*i]=0;//\u5f53\u524d\u4e3a\u7d20\u6570 if(i%p[j]==0)break;//\u82e5\u5f53\u524d\u7684i\u7684\u56e0\u6570\u5305\u542bp[j]\uff0c\u5219\u5982\u679c\u4e0d\u505c\uff0c\u90a3\u4e48i\u4e0d\u4f5c\u4e3a\u6700\u5c0f\u8d28\u56e0\u6570\u7b5b\u4e86\u4e0b\u4e00\u4e2a\u6570\uff0c\u4e0d\u6ee1\u8db3\u7ebf\u6027\u590d\u6742\u5ea6\uff0c\u5982,(3,4)\u4e0d\u80fd\u7b5b12,\u53ea\u6709(2,6)\u80fd } }","title":"\u6b27\u62c9\u7b5b"},{"location":"my%20past/OI/%E7%BA%BF%E6%80%A7%E7%AD%9B/#_1","text":"m=0; for(int i=2;i<=n;++i)vis[i]=1;//\u5047\u8bbe\u6240\u6709\u6570\u4e3a\u8d28\u6570 for(int i=2;i<=n;++i){ if(vis[i])p[++m]=i;//\u5f53\u524d\u662f\u8d28\u6570 for(int j=1;j<=m && p[j]*i<=n;++j){//\u4ece\u6240\u6709\u5df2\u77e5\u8d28\u6570\u4e2d\u4ece\u5c0f\u5230\u5927\u679a\u4e3e vis[p[j]*i]=0;//\u5f53\u524d\u4e3a\u7d20\u6570 if(i%p[j]==0)break;//\u82e5\u5f53\u524d\u7684i\u7684\u56e0\u6570\u5305\u542bp[j]\uff0c\u5219\u5982\u679c\u4e0d\u505c\uff0c\u90a3\u4e48i\u4e0d\u4f5c\u4e3a\u6700\u5c0f\u8d28\u56e0\u6570\u7b5b\u4e86\u4e0b\u4e00\u4e2a\u6570\uff0c\u4e0d\u6ee1\u8db3\u7ebf\u6027\u590d\u6742\u5ea6\uff0c\u5982,(3,4)\u4e0d\u80fd\u7b5b12,\u53ea\u6709(2,6)\u80fd } }","title":"\u6b27\u62c9\u7b5b"},{"location":"my%20past/OI/%E7%BA%BF%E6%AE%B5%E6%A0%91/","text":"\u7ebf\u6bb5\u6811 1) \u7ebf\u6bb5\u6811\u4e2d\u7684\u4f18\u5148\u7ea7\uff1a \u4e58\u6cd5\u5927\u4e8e\u52a0\u6cd5(P3373\u6a21\u677f),\u63a8\u5e73\u5927\u4e8e\u52a0\u6cd5,\u6ce8\u610f\u7ef4\u62a4\u4e24\u4e2a$lazytag$ 2) \u7ebf\u6bb5\u6811\u6700\u91cd\u8981\u7684\u662f\u53f6\u8282\u70b9\uff0c\u6709\u65f6\u7236\u8282\u70b9\u53ef\u4ee5\u4e3a0,\u53ea\u6709\u53f6\u8282\u70b9\u6709\u503c\uff0c\u5982\u679c\u6709\u64cd\u4f5c\u5c06\u7236\u8282\u70b9\u7684\u503c\u5206\u88c2\uff0c\u5c31\u4f20\u9012\u7ed9\u53f6\u8282\u70b9\u3002\u8fd9\u4e0d\u662f\u4f20\u7edf\u7ebf\u6bb5\u6811\uff0c\u800c\u662f\u5229\u7528\u4e86\u7ebf\u6bb5\u6811\u7684\u7ed3\u6784\uff0c\u56e0\u6b64\u6ce8\u610f\u7ebf\u6bb5\u6811\u7684\u7075\u6d3b\u6027\u3002(P1558) SP2713 GGS4 \u8fd9\u9053\u9898\u7528\u4e86\u4e00\u4e2a$_{\u5c0f\u6280\u5de7}$ \u56e0\u4e3a\u6570\u636e\u8303\u56f4\u662f1e18\uff0c\u6700\u591a\u516d\u6b21\u5c31\u4f1a\u5f97\u52301,\u800c1\u548c0\u5f00\u5e73\u65b9\u540e\u8fd8\u662f\u81ea\u8eab\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u5bf9\u4e0d\u7b49\u4e8e\u4e00\u7684\u6570\u66b4\u529b\u4fee\u6539\uff0c\u82e5\u533a\u95f4\u548c\u5c0f\u4e8e\u7b49\u4e8e\u533a\u95f4\u957f\u5ea6\uff0c\u5219\u53ea\u52691\u62160\uff0c\u4e0d\u9700\u518d\u4fee\u6539\u3002\u603b\u7684\u4fee\u6539\u6b21\u6570$\\Theta(6nlogn)$,\u53c8\u56e0\u4e3a\u6bcf\u6b21\u90fd\u8981\u67e5\u8be2\uff0c\u7528\u4e8e\u5224\u65ad\u6216\u8f93\u51fa\u7b54\u6848\uff0c\u6240\u4ee5$\\Theta(nlogn)$ \u603b\u590d\u6742\u5ea6$\\Theta(6nlogn)$ P1856 & P5490 \u626b\u63cf\u7ebf(\u79bb\u6563\u5316+\u7ebf\u6bb5\u6811\uff09 \u5c06\u6bcf\u4e2a\u77e9\u5f62\u90fd\u79bb\u6563\u6210\u8fb9\uff0c\u5728\u52a0\u5165\u7ebf\u6bb5\u6811\u4e2d\u3002 \u7edf\u8ba1\u7684\u65b9\u5f0f\uff1a \u7528cover\u548clen\u6570\u7ec4\u5206\u522b\u8bb0\u5f55\u8be5\u533a\u95f4\u88ab\u8986\u76d6\u7684\u6b21\u6570\u548c\u88ab\u8986\u76d6\u7684\u957f\u5ea6\u3002 \u5982\u679ccover>0\uff0c\u8bf4\u660e\u81f3\u5c11\u88ab\u5168\u8986\u76d6\u4e86\u4e00\u6b21\uff0clen=r-l+1 \u5982\u679ccover==0\uff0c\u8bf4\u660e\u6ca1\u6709\u5168\u8986\u76d6\uff0c\u53ef\u80fd\u662f\u8fde\u7eed\u7684\u533a\u95f4\u3002\u6240\u4ee5\u7ee7\u627f\u5b50\u8282\u70b9\u7684\u4fe1\u606f\uff0c\u76f4\u63a5pushup\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> //#define int long long using namespace std; const int N=2e5+10,INF=1e4; struct node{ int i,j,x,y; }q[N]; struct edge{ int l; int r; int z; int t; }e[N]; struct tree{ int len,cover; }tre[N]; int n,ans; bool cmp1(edge a,edge b){ if(a.z==b.z)return a.t>b.t; else return a.z<b.z; } bool cmp2(edge a,edge b){ if(a.z==b.z)return a.t>b.t; else a.z>b.z; } void pushup(int i,int l,int r){ if(tre[i].cover>0){ tre[i].len=r-l+1; }else{ tre[i].len=tre[i<<1].len+tre[i<<1|1].len; } } void change(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tre[i].cover+=k; if(tre[i].cover>0){ tre[i].len=r-l+1; }else{ tre[i].len=tre[i<<1].len+tre[i<<1|1].len; } return; } int mid=l+r>>1; if(el<=mid)change(i<<1,l,mid,el,er,k); if(er>mid)change(i<<1|1,mid+1,r,el,er,k); pushup(i,l,r); return; } void ins(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ tre[i].cover++; tre[i].len=r-l+1; return; } //if(l+1==r)return; int mid=l+r>>1; if(el<=mid)ins(i<<1,l,mid,el,er); if(er>mid)ins(i<<1|1,mid+1,r,el,er); pushup(i,l,r); return; } void del(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ tre[i].cover--; if(tre[i].cover>0)tre[i].len=r-l+1; else tre[i].len=tre[i<<1].len+tre[i<<1|1].len; return; } //if(l+1==r)return; int mid=l+r>>1; if(el<=mid)del(i<<1,l,mid,el,er); if(er>mid)del(i<<1|1,mid+1,r,el,er); pushup(i,l,r); return; } int abs1(int a){ return a>0?a:-a; } void build(int i,int l,int r){ if(l==r){ tre[i].len=0; tre[i].cover=0; return; } int mid=l+r>>1; build(i<<1,l,mid); build(i<<1|1,mid+1,r); //pushup(i,l,r); tre[i].len=0; tre[i].cover=0; return; } void work3(){ int cnt=0; for(int i=1;i<=n;++i){ e[++cnt].l=q[i].i; e[cnt].r=q[i].x; e[cnt].z=q[i].j; e[cnt].t=1; e[++cnt].l=q[i].i; e[cnt].r=q[i].x; e[cnt].z=q[i].y; e[cnt].t=-1; } sort(e+1,e+cnt+1,cmp1); build(1,-INF,INF); for(int i=1;i<=cnt;++i){ int l=e[i].l,r=e[i].r,t=e[i].t; int lst=tre[1].len; change(1,-INF,INF,l,r-1,t); ans+=abs1(lst-tre[1].len); } //cout<<ans<<endl; return; } void work4(){ int cnt=0; for(int i=1;i<=n;++i){ e[++cnt].l=q[i].j; e[cnt].r=q[i].y; e[cnt].z=q[i].i; e[cnt].t=1; e[++cnt].l=q[i].j; e[cnt].r=q[i].y; e[cnt].z=q[i].x; e[cnt].t=-1; } sort(e+1,e+cnt+1,cmp1); //memset(tre,0,sizeof tre); build(1,-INF,INF); for(int i=1;i<=cnt;++i){ int l=e[i].l,r=e[i].r,t=e[i].t; int lst=tre[1].len; change(1,-INF,INF,l,r-1,t); ans+=abs1(lst-tre[1].len); } return; } void work1(){ int cnt=0; for(int i=1;i<=n;++i){ e[++cnt].l=q[i].i; e[cnt].r=q[i].x; e[cnt].z=q[i].j; e[cnt].t=1; e[++cnt].l=q[i].i; e[cnt].r=q[i].x; e[cnt].z=q[i].y; e[cnt].t=-1; } sort(e+1,e+cnt+1,cmp1); build(1,-INF,INF); for(int i=1;i<=cnt;++i){ int l=e[i].l,r=e[i].r,t=e[i].t; int lst=tre[1].len; if(t==1) ins(1,-INF,INF,l,r-1); else del(1,-INF,INF,l,r-1);//cout<<lst<<\" \"<<tre[1].len<<endl; ans+=abs1(lst-tre[1].len); } //cout<<ans<<endl; return; } void work2(){ int cnt=0; for(int i=1;i<=n;++i){ e[++cnt].l=q[i].j; e[cnt].r=q[i].y; e[cnt].z=q[i].i; e[cnt].t=1; e[++cnt].l=q[i].j; e[cnt].r=q[i].y; e[cnt].z=q[i].x; e[cnt].t=-1; } sort(e+1,e+cnt+1,cmp1); //memset(tre,0,sizeof tre); build(1,-INF,INF); for(int i=1;i<=cnt;++i){ int l=e[i].l,r=e[i].r,t=e[i].t; int lst=tre[1].len; if(t==1) ins(1,-INF,INF,l,r-1); else del(1,-INF,INF,l,r-1); ans+=abs1(lst-tre[1].len); } return; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i){ scanf(\"%d%d%d%d\",&q[i].i,&q[i].j,&q[i].x,&q[i].y); } ans=0; work3(); work4(); printf(\"%d\",ans); return 0; } /* 2 0 0 4 4 0 4 4 8 */ \u7ebf\u6bb5\u6811\u7684\u7279\u70b9\uff1a\u53ea\u6709\u7528\u5f53\u524d\u533a\u95f4\u65f6\u624d\u7528pushdown\u8ba1\u7b97\u503c,\u4fdd\u8bc1$O(nlogn)$\uff1b\u5f53\u524d\u533a\u95f4\u4e00\u5b9a\u53ea\u5305\u542b\u5c0f\u533a\u95f4\u548c\u81ea\u5df1\uff0c\u4e0d\u4f1a\u6709\u67d0\u4e2a\u533a\u95f4\u7684\u4e00\u90e8\u5206\u3002 SP1043 GSS1 \u7ebf\u6bb5\u6811\u3002 \u7528\u7ed3\u6784\u4f53tre\u4f5c\u4e3a\u8282\u70b9\u7ef4\u62a4\u56db\u4e2a\u503c\uff1a \u533a\u95f4\u548c s\uff0c\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c t\uff0c\u533a\u95f4\u4ece\u5de6\u7aef\u70b9\u5f00\u59cb\u7684\u6700\u5927\u524d\u7f00\u548c l\uff0c\u533a\u95f4\u4ece\u53f3\u7aef\u70b9\u5f00\u59cb\u7684\u6700\u5927\u540e\u7f00\u548c r\u3002 \u5982\u4f55\u5408\u5e76\u4e24\u4e2a\u5c0f\u533a\u95f4 ls , rs\uff0c\u5f97\u5230\u5927\u533a\u95f4 i \u7684\u5b50\u6bb5\u548c\uff1f \u8003\u8651\u5b50\u6bb5\u548c\u7684\u6700\u5927\u503c\u4ece\u4f55\u800c\u6765\uff1a 1\uff09\u7531\u4e24\u4e2a\u5c0f\u533a\u95f4\u81ea\u8eab\u5185\u90e8\u4ea7\u751f\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662fmax(tre[ls].t , tre[rs].t) 2)\u7531\u4e24\u4e2a\u5c0f\u533a\u95f4\u5408\u5e76\u5f97\u51fa\uff0c\u5219\u7528\u5230\u7684\u5c31\u662f\u5de6\u533a\u95f4\u7684\u540e\u7f00\u548c\u52a0\u6709\u533a\u95f4\u7684\u524d\u7f00\u548c\uff0c\u5408\u5e76\u51fa\u8986\u76d6\u4e24\u4e2a\u5c0f\u533a\u95f4\u7684\u5927\u533a\u95f4\u3002\u6b32\u4f7f\u5176\u503c\u6700\u5927\uff0c\u5219\u53d6\u6700\u5927\u524d\u7f00\u540e\u7f00\u548ctre[ls].r + tre[rs].l\u3002 \u56e0\u6b64 tre[i].t=max(max(tre[i<<1].t,tre[i<<1|1].t),tre[i<<1].r+tre[i<<1|1].l); \u8fd9\u91ccls=i<<1 ,rs=i<<1|1. 2.\u5982\u4f55\u7ef4\u62a4\u5f53\u524d\u8282\u70b9\u7684\u6700\u5927\u524d\u7f00\uff0c\u540e\u7f00\u548c\uff1f \u5f53\u524d\u5927\u533a\u95f4\u7684\u524d\u7f00\u548c\u662f\u957f\u77ed\u4e24\u79cd\u60c5\u51b5\u53d6max\uff0c\u5373\u5de6\u8fb9\u5c0f\u533a\u95f4\u7684\u6700\u5927\u524d\u7f00\u548c\u7684\u503c\uff0c\u548c\u8986\u76d6\u6574\u4e2a\u5de6\u8fb9\u5c0f\u533a\u95f4\u548c\u53f3\u8fb9\u5c0f\u533a\u95f4\u7684\u6700\u5927\u524d\u7f00\u548c\u7684\u503c \u53d6max\u3002 \u540e\u7f00\u548c\u540c\u7406\u3002 tre[i].l=max(tre[i<<1].l,tre[i<<1].s+tre[i<<1|1].l); tre[i].r=max(tre[i<<1|1].r,tre[i<<1|1].s+tre[i<<1].r); \u6700\u540e\u533a\u95f4\u548c\u5c31\u662f\u5de6\u53f3\u533a\u95f4\u76f8\u52a0\u3002 \u4e0d\u9700\u8981\u4fee\u6539\uff0c\u53ea\u7528\u67e5\u8be2\u3002 \u5177\u4f53\u7684\u770b\u6ce8\u91ca\u548c\u4ee3\u7801\u5427QwQ Code Time\uff1a #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e5+10,INF=15007+5; struct node{ int l,r,t,s; node(){//\u521d\u59cb\u5316\uff0c\u9632\u6b62\u968f\u673a\u6570\u636e\u9020\u6210\u5e72\u6270 l=-INF,r=-INF,t=-INF,s=-INF; } }tre[N<<2];//\u522b\u95ee\u6211\u4e3a\u4ec0\u4e48\u5148\u5f00\u4e24\u500d\u7a7a\u95f4\u518d\u4e584 int n,m,l,r; int a[N]; void pushup(int i){ tre[i].t=max(max(tre[i<<1].t,tre[i<<1|1].t),tre[i<<1].r+tre[i<<1|1].l); tre[i].l=max(tre[i<<1].l,tre[i<<1].s+tre[i<<1|1].l); tre[i].r=max(tre[i<<1|1].r,tre[i<<1|1].s+tre[i<<1].r); tre[i].s=tre[i<<1].s+tre[i<<1|1].s; return; } void build(int i,int l,int r){//\u5efa\u6811 if(l==r){ tre[i].t=a[l]; tre[i].l=a[l]; tre[i].r=a[l]; tre[i].s=a[l]; return; } int mid=l+r>>1; build(i<<1,l,mid); build(i<<1|1,mid+1,r); pushup(i); return; } node query(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ return tre[i]; } int mid=l+r>>1; node ans=node(),x=node(),y=node(); if(el<=mid)x=query(i<<1,l,mid,el,er); if(er>mid)y=query(i<<1|1,mid+1,r,el,er); ans.t=max(max(x.t,y.t),x.r+y.l);//pushup ans.l=max(x.l,x.s+y.l); ans.r=max(y.r,y.s+x.r); ans.s=x.s+y.s; return ans; } signed main(){ memset(tre,0,sizeof tre); scanf(\"%lld\",&n); for(int i=1;i<=n;++i){ scanf(\"%lld\",&a[i]); } build(1,1,n); scanf(\"%lld\",&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&l,&r); node res=node(); res=query(1,1,n,l,r); printf(\"%lld\\n\",res.t); } return 0; } /* \u6570\u636e >>>input 8 -1 2 3 1 -1 1 1 -1 4 1 8 2 7 4 5 3 4 >>>output 7 7 1 4 */ Orz CF833B \u8bbe$f[i][j]$\u8868\u793a\u524d$i$\u4e2a\u989c\u8272\u5206\u6210$j$\u7aef\u7684\u6700\u5927\u8d21\u732e\uff0c$col[i][j]$\u8868\u793a\u4ece$i$\u5230$j$\u7684\u8d21\u732e\u3002 \u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a $$ f[i][j]=\\max_{k=0}^{i-1}(f[k][j-1]+col[k+1][i]) $$ \u8fd9\u6837\u505a\u590d\u6742\u5ea6$O(n^2k)$,\u80af\u5b9a\u7206\u70b8\u3002 \u7531\u4e8e\u6bcf\u6b21\u9700\u8981\u679a\u4e3e$k$\u800c\u803d\u8bef\u65f6\u95f4\uff0c\u6240\u4ee5\u8003\u8651\u628a\u4e0a\u4e00\u8f6e\u6240\u6709\u7684$f[k][j-1]$\u4e22\u8fdb\u7ebf\u6bb5\u6811\u91cc\u7ef4\u62a4\u3002 \u7528\u5230\u4e86\u53bb\u91cd\u7684\u5e38\u7528$_ {trick} $,\u5c31\u662f\u5c06\u6bcf\u4e2a\u989c\u8272\u4e0a\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u8bb0\u5f55\u4e0b\u6765\u3002\u4e4b\u540e\uff0c\u7528\u7ebf\u6bb5\u6811\u7684\u533a\u95f4\u52a0\u6765\u66f4\u65b0\u5f53\u524d\u7684\u989c\u8272\u5bf9\u4e4b\u524d\u54ea\u4e9b\u4f4d\u7f6e\u7531\u8d21\u732e\u3002 \u7ebf\u6bb5\u6811\u4e2d\u4f4d\u7f6e$k$\u7ef4\u62a4\u7684\u5c31\u662f\u4ece$k$\u5230$i$\u7684\u8d21\u732e$col[k][i]$\u52a0\u4e0a$f[k-1][j-1]$\u7684\u603b\u8d21\u732e\u3002 \u8fd9\u6837\u6bcf\u6b21\u53ea\u9700\u8981\u53d6$query(1,1,n,1,j)$\u5373\u53ef\u66f4\u65b0$f[i][j]$. ~~\u6ce8\u610f\u7ebf\u6bb5\u6811\u7684\u6e05\u96f6\u64cd\u4f5c(lazytag)\uff0c\u6211\u5df2\u7ecf\u88ab\u5751\u7684\u89c1\u7956\u5b97\u4e86,\u89c1\u6ce8\u91ca~~ code time: #include<iostream> #include<cstdio> #include<cstring> #define ls i<<1 #define rs i<<1|1 #define int long long using namespace std; const int N=4e4+10,K=55; int f[K][N],pos[N],pre[N],tre[N<<2],tag[N<<2]; int n,k,t; void pushup(int i){ tre[i]=max(tre[ls],tre[rs]); } void pushdown(int i,int l,int r){ int k=tag[i]; if(!k)return; tag[ls]+=k;tag[rs]+=k;tre[ls]+=k;tre[rs]+=k; tag[i]=0; } void build(int i,int l,int r,int now){ tag[i]=0;//\u4e00\u5b9a\u8981\u6e05\u96f6\uff0c\u5e76\u4e14\u8981\u5199\u5728\u5916\u9762 if(l==r){ tre[i]=f[now][l-1]; return; } int mid=(l+r)>>1; build(ls,l,mid,now); build(rs,mid+1,r,now); pushup(i); } void change(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tag[i]+=k;tre[i]+=k; return; } pushdown(i,l,r); int mid=(l+r)>>1; if(el<=mid) change(ls,l,mid,el,er,k); if(er>mid) change(rs,mid+1,r,el,er,k); pushup(i); } int query(int i,int l,int r,int el,int er){ if(el<=l && r<=er) return tre[i]; pushdown(i,l,r); int mid=(l+r)>>1,ans=0; if(el<=mid)ans=max(ans,query(ls,l,mid,el,er)); if(er>mid)ans=max(ans,query(rs,mid+1,r,el,er)); return ans; } signed main(){ scanf(\"%lld%lld\",&n,&k); for(int i=1;i<=n;++i)scanf(\"%lld\",&t),pre[i]=pos[t]+1,pos[t]=i; for(int i=1;i<=k;++i){ build(1,1,n,i-1); for(int j=1;j<=n;++j){ change(1,1,n,pre[j],j,1); f[i][j]=query(1,1,n,1,j); } } printf(\"%lld\",f[k][n]); } SP1557 GSS2 ~~OrzOrzOrz~~ \u597d\u9898\uff0c\u662fGSS1\u7684\u8d85\u7ea7\u52a0\u5f3a\u3002 \u5bf9\u4e8e\u533a\u95f4\u53bb\u91cd\u53ef\u4ee5\u79bb\u7ebf\u5c06r\u6392\u5e8f\uff0c\u9010\u4e2a\u52a0\u5165a[i]\uff0c\u8ba1\u7b97\u5f53\u524d\u4ee5r\u4e3a\u53f3\u7aef\u70b9\u7684\u6240\u6709\u5b50\u533a\u95f4\u4e2d\u7684\u6700\u5927\u548c\uff0c\u90a3\u4e48\u5b83\u5c31\u662f\u6700\u5927\u5b50\u6bb5\u548c\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\u7ef4\u62a4\u56db\u4e2a\u503c\uff1a s \u8868\u793a\u5f53\u524d\u70b9\u7684\u6700\u5927\u5b50\u6bb5\u548c m \u8868\u793a\u5f53\u524d\u70b9\u5386\u53f2\u6700\u5927 stag \u8868\u793a\u5f53\u524d\u61d2\u6807\u8bb0 mtag \u8868\u793a\u5386\u53f2\u6700\u5927\u61d2\u6807\u8bb0 mtag\u5b58\u5728\u7684\u610f\u4e49\uff1a stag\u5728\u540c\u65f6\u9047\u5230\u8bb8\u591a\u64cd\u4f5c\u65f6\u4f1a\u5c06\u6240\u6709\u64cd\u4f5c\u8986\u76d6\u6210\u4e00\u4e2a\u64cd\u4f5c\uff0c\u800c\u5386\u53f2\u6700\u5927\u9700\u8981stag\u4e2d\u7684\u6700\u5927\u72b6\u6001\uff0c\u8fd9\u53ea\u7528stag\u8868\u793a\u4e0d\u51fa\u6765\uff0c\u6240\u4ee5\u7528\u4e00\u4e2amtag. \u8fd9\u6837\uff0c\u6bcf\u6b21\u67e5\u8be2[l,r]\u7684tre[i].m\u5373\u53ef #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2e5+10; struct node{ int m,s,mtag,stag; }tre[N<<2]; struct que{ int l,r,id; }q[N]; int n,m; int pre[N],vis[N<<1],a[N],ans[N]; bool cmp(que a,que b){ return a.r<b.r; } void pushup(int i){ tre[i].s=max(tre[i<<1].s,tre[i<<1|1].s); tre[i].m=max(tre[i<<1].m,tre[i<<1|1].m); } void pushdown(int i,int l,int r){ int ls=i<<1,rs=i<<1|1,mid=l+r>>1; tre[ls].m=max(tre[ls].m,tre[ls].s+tre[i].mtag); tre[rs].m=max(tre[rs].m,tre[rs].s+tre[i].mtag); tre[ls].s+=tre[i].stag; tre[rs].s+=tre[i].stag; tre[ls].mtag=max(tre[ls].mtag,tre[i].mtag+tre[ls].stag); tre[rs].mtag=max(tre[rs].mtag,tre[i].mtag+tre[rs].stag); tre[ls].stag+=tre[i].stag; tre[rs].stag+=tre[i].stag; tre[i].stag=0; tre[i].mtag=0; return; } void add(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tre[i].s+=k; tre[i].m=max(tre[i].m,tre[i].s); tre[i].stag+=k; tre[i].mtag=max(tre[i].mtag,tre[i].stag); return; } pushdown(i,l,r); int mid=l+r>>1; if(el<=mid)add(i<<1,l,mid,el,er,k); if(er>mid)add(i<<1|1,mid+1,r,el,er,k); pushup(i); return; } int query(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ return tre[i].m; } pushdown(i,l,r); int mid=l+r>>1,ans=0; if(el<=mid)ans=max(ans,query(i<<1,l,mid,el,er)); if(er>mid)ans=max(ans,query(i<<1|1,mid+1,r,el,er)); return ans; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]); scanf(\"%lld\",&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&q[i].l,&q[i].r); q[i].id=i; } sort(q+1,q+m+1,cmp); for(int i=1;i<=n;++i){ pre[i]=vis[a[i]+N]; vis[a[i]+N]=i; } /*for(int i=1;i<=n;++i){ cout<<pre[i]<<\" \"; } cout<<endl;*/ for(int i=1,j=1;i<=n;++i){ int ll=pre[i]+1,rr=i; add(1,1,n,ll,rr,a[i]); for(j;j<=m && q[j].r<=i;++j){ ans[q[j].id]=query(1,1,n,q[j].l,q[j].r); } } for(int i=1;i<=m;++i){ printf(\"%lld\\n\",ans[i]); } return 0; } /* 8 -1 2 3 1 -1 1 1 -1 3 1 2 2 4 1 8 */ \u6ce8\u610f\u4e0b\u9762\u6ca1\u6709mtag\u7684\u9519\u8bef\u4ee3\u7801: #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2e5+10; struct node{ int m,s,stag; }tre[N<<2]; struct que{ int l,r,id; }q[N]; int n,m; int pre[N],vis[N<<1],a[N],ans[N]; bool cmp(que a,que b){ return a.r<b.r; } void pushup(int i){ tre[i].s=max(tre[i<<1].s,tre[i<<1|1].s); tre[i].m=max(tre[i<<1].m,tre[i<<1|1].m); tre[i].m=max(tre[i].m,tre[i].s);// } void pushdown(int i,int l,int r){ int ls=i<<1,rs=i<<1|1,mid=l+r>>1; tre[ls].m=max(tre[ls].m,tre[ls].s+tre[i].stag); tre[rs].m=max(tre[rs].m,tre[rs].s+tre[i].stag); tre[ls].s+=tre[i].stag; tre[rs].s+=tre[i].stag; tre[ls].stag+=tre[i].stag; tre[rs].stag+=tre[i].stag; tre[i].stag=0; return; } void add(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tre[i].s+=k; tre[i].stag+=k; tre[i].m=max(tre[i].m,tre[i].s); return; } pushdown(i,l,r); int mid=l+r>>1; if(el<=mid)add(i<<1,l,mid,el,er,k); if(er>mid)add(i<<1|1,mid+1,r,el,er,k); pushup(i); return; } int query(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ return tre[i].m; } pushdown(i,l,r); int mid=l+r>>1,ans=0; if(el<=mid)ans=max(ans,query(i<<1,l,mid,el,er)); if(er>mid)ans=max(ans,query(i<<1|1,mid+1,r,el,er)); return ans; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]); scanf(\"%lld\",&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&q[i].l,&q[i].r); q[i].id=i; } sort(q+1,q+m+1,cmp); for(int i=1;i<=n;++i){ pre[i]=vis[a[i]+N]; vis[a[i]+N]=i; } /*for(int i=1;i<=n;++i){ cout<<pre[i]<<\" \"; } cout<<endl;*/ for(int i=1,j=1;i<=n;++i){ int ll=pre[i]+1,rr=i; add(1,1,n,ll,rr,a[i]); for(j;j<=m && q[j].r<=i;++j){ ans[q[j].id]=query(1,1,n,q[j].l,q[j].r); } } for(int i=1;i<=m;++i){ printf(\"%lld\\n\",ans[i]); } return 0; } /* 9 4 -2 -2 3 -1 -4 2 2 -6 4 1 2 1 5 4 9 2 8 */ P3924 \u8fd9\u9053\u9898\u7684\u5173\u952e\u5c31\u662f\uff0c\u5bf9\u4e8e\u6bcf\u6b21\u4fee\u6539\uff0c\u6709\u6548\u4ea7\u751f\u8d21\u732e\u7684\u53ea\u6709\u53f6\u5b50\u8282\u70b9\uff0c\u6240\u4ee5\u76f4\u63a5\u901a\u8fc7\u6df1\u5ea6\u7ef4\u62a4\u6bcf\u4e2a\u53f6\u5b50\u8282\u70b9\u5230\u6839\u4e0a\u7684\u6982\u7387\u603b\u548c\uff0c\u56e0\u4e3a\u6bcf\u6b21\u4fee\u6539\u7684\u6570\u76f8\u540c\uff0c\u6240\u4ee5\u76f4\u63a5\u524d\u7f00\u548c\u7d2f\u52a0\u3002\u5f00\u59cbO\uff08n\uff09\u6c42\u51fa\u521d\u59cb\u503c\uff0c\u6bcf\u6b21\u518d\u52a0\u3002 P4588 \u5bf9\u4e8e\u6bcf\u6b21\u64cd\u4f5c\uff0c\u5982\u679c\u76f4\u63a5\u9006\u5143\u80af\u5b9a\u4e0d\u884c\u3002 \u8003\u8651\u7ebf\u6bb5\u6811\uff0c\u6bcf\u6b21\u7684\u64cd\u4f5c\u5c31\u662f\u5355\u70b9\u4fee\u6539\u3002 \u6ce8\u610f$pushup$\u4e00\u76f4\u8981$modM$ #include<iostream> #include<cstdio> #include<cstring> #define int long long #define ls i<<1 #define rs i<<1|1 using namespace std; const int N=2e5+10; int tre[N<<2]; int Q,t,M,op,m; void pushup(int i){ tre[i]=(tre[ls]*tre[rs])%M; } void build(int i,int l,int r){ if(l==r){ tre[i]=1; return; } int mid=l+r>>1; build(ls,l,mid); build(rs,mid+1,r); pushup(i); } void change(int i,int l,int r,int pos,int k){ if(l==r){ tre[i]=k; return; } int mid=l+r>>1; if(pos<=mid)change(ls,l,mid,pos,k); else change(rs,mid+1,r,pos,k); pushup(i); } signed main(){ scanf(\"%lld\",&t); while(t--){ scanf(\"%lld%lld\",&Q,&M); build(1,1,Q); for(int i=1;i<=Q;++i){ scanf(\"%lld%lld\",&op,&m); if(op==1){ change(1,1,Q,i,m); }else{ change(1,1,Q,m,1); } printf(\"%lld\\n\",tre[1]%M); } } return 0; } ~~\u7ebf\u6bb5\u6811\u601d\u7ef4\u9898\u771f\u591a~~ P1712 \u5c3a\u53d6\u6cd5\u7ebf\u6bb5\u6811\u3002 \u5148\u5c06\u533a\u95f4\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u4f9d\u6b21\u53f3\u79fb$r$. \u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5f53\u524d\u7684\u533a\u95f4\u6709\u54ea\u4e9b\u91cd\u5408\u7684\u5730\u65b9\uff0c\u5982\u679c\u6709\u4e00\u4e2a\u70b9\u91cd\u5408\u5ea6$\\geq m$,\u5c31\u53f3\u79fb$l$\u5e76\u7edf\u8ba1\u7b54\u6848\u3002 CF1042D \u7ef4\u62a4\u6bcf\u4e2a\u7aef\u70b9$i$\u524d\u9762\u6709\u591a\u5c11\u4e2a\u7aef\u70b9$j$\u6ee1\u8db3$sum[i]-sum[j-1]<t$\u3002 \u56e0\u4e3a\u6bcf\u6b21\u505a\u5b8c\u90fd\u4f1a\u52a0\u5165$sum[i]$\uff0c\u6240\u4ee5\u4fdd\u8bc1$sum[j-1],1 \\leq j \\leq i-1 $\u5728\u4e4b\u524d\u5df2\u7ecf\u6c42\u51fa\u6765\u4e86\uff0c\u56e0\u6b64\u53ef\u4ee5\u6743\u503c\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u4e4b\u524d\u6ee1\u8db3\u6761\u4ef6\u7684\u7aef\u70b9\u4e2a\u6570,\u5373$>sum[i]-t$\u7684\u4e2a\u6570\u3002 P5482 \u7ec6\u8282\u7279\u591a\u7684\u4e00\u9053\u9898\u3002 \u6ce8\u610f\u6bcf\u4e2a\u7b49\u5f0f\u7684$a$\u6709\u4e09\u79cd\u60c5\u51b5\uff1a 1) $a>0$,\u6b64\u65f6\u6b63\u5e38\u8ba8\u8bba 2) $a=0$,\u9700\u8981\u7279\u6b8a\u8ba8\u8bba\uff0c\u4e0d\u80fd\u9664\uff0c\u4e0d\u7136\u5c31$RE$\u4e86. 3) $a<0$,\u8fd9\u662f\u9700\u8981\u5c06\u7b49\u5f0f\u53cd\u8f6c\uff1a$-x>-\\frac{c-b}{a}$,\u6240\u4ee5\u65b0\u7684\u89e3$t=-x$,\u6ee1\u8db3$-at+b>c$ \u8fd8\u6709\u5c31\u662f\u9700\u8981\u5224\u65ad$x$\u548c$t$\u7684\u51fa\u754c\u60c5\u51b5\uff0c\u5982\u679c\u5c0f\u4e8e$-1e6$\uff0c\u5c31\u5728\u6811\u72b6\u6570\u7ec4$1$\u7684\u4f4d\u7f6e\u52a0$1$;\u5982\u679c\u5927\u4e8e$1e6$,\u5c31\u4e0d\u80fd\u505a\u4efb\u4f55\u5904\u7406\u3002 \u518d\u6709\u5c31\u662f\u91cd\u590d\u5220\u9664\uff0c\u6bcf\u6b21\u5220\u9664\u540e\u8981\u6253\u4e0a\u6807\u8bb0\u3002 ~~\u5751\u7239\u6bd2\u7624\u9898~~ #include<iostream> #include<cstdio> #include<cstring> #define int long long #define lowbit(x) x&-x using namespace std; const int N=2e6+100,M=2e5+10,C=1e6+1,LIM=2e6+1; struct node{ int a,b,k,type,res; }op[M]; int c[N],d[N]; int n,cnt,a,b,k; char ch[10]; void change1(int x,int k) { while(x<=N-1) { c[x]+=k; x+=lowbit(x); } } int sum1(int x) { int ans=0; while(x>0) { ans+=c[x]; x-=lowbit(x); } return ans; } void change2(int x,int k){ while(x<=N-1){ d[x]+=k; x+=lowbit(x); } } int sum2(int x){ int ans=0; while(x>0){ ans+=d[x]; x-=lowbit(x); } return ans; } signed main() { scanf(\"%lld\",&n); for(int i=1; i<=n; ++i) { scanf(\"%s\",ch); if(ch[0]=='A') { ++cnt; scanf(\"%lld%lld%lld\",&op[cnt].a,&op[cnt].b,&op[cnt].k); a=op[cnt].a,b=op[cnt].b,k=op[cnt].k; if(a==0){ if(b>k){ op[cnt].type=0,change1(1,1);// \u4e00\u5b9a\u6709\u89e3 }else{ op[cnt].type=1;//\u65e0\u89e3 } }else if(a>0){ int tmp=(k-b)/a; if(a*tmp+b<=k)tmp++; if(tmp+C<1)op[cnt].type=2,change1(1,1);//\u4e00\u5b9a\u6709\u89e3 else if(tmp+C>LIM)op[cnt].type=3;//\u4e00\u5b9a\u65e0\u89e3 else op[cnt].res=tmp+C,op[cnt].type=4,change1(tmp+C,1); }else{//a<0 int tmp=(b-k)/a; if(-a*tmp+b<=k)tmp++; if(tmp+C<1)op[cnt].type=5,change2(1,1); else if(tmp+C>LIM)op[cnt].type=6; else op[cnt].res=tmp+C,op[cnt].type=7,change2(tmp+C,1); } }else if(ch[0]=='D'){ scanf(\"%lld\",&k); if(op[k].type==0 || op[k].type==2)change1(1,-1); if(op[k].type==5)change2(1,-1); if(op[k].type==4)change1(op[k].res,-1); if(op[k].type==7)change2(op[k].res,-1); op[k].type=8;//\u5df2\u5220\u9664 }else{ scanf(\"%lld\",&k); int tmp1=sum1(k+C); int tmp2=sum2(-k+C); printf(\"%lld\\n\",tmp1+tmp2); } } return 0; } P4243 \u7b2c\u4e00\u9053\u9ed1\u9898! ~~\u867d\u7136\u53ea\u6709\u7d2b\u9898\u7684\u96be\u5ea6~~ \u5f53\u770b\u89c1\u7b49\u5dee\u6570\u5217\uff0c\u6709\u4e2a\u5e38\u7528\u7684\u5c0f$_ {Trick}$,\u5c31\u662f\u5c06\u7b49\u5dee\u6570\u5217\u8f6c\u6362\u6210\u5dee\u5206\u6570\u5217\uff0c\u5373$b[i]=a[i+1]-a[i]$\uff0c\u8fd9\u6837\uff0c\u53ea\u9700\u8981\u7ef4\u62a4\u8fde\u7eed\u7684\u76f8\u540c\u7684\u503c\u6709\u591a\u5c11\u6bb5\u5373\u53ef\u3002 \u6bcf\u6b21\u7684$A$\u64cd\u4f5c\u53ef\u4ee5\u770b\u6210\u5728$s-1$\u5904\u52a0\u4e0a$a$,\u5728$[s,t-1]$\u8fd9\u4e00\u6bb5\u52a0\u4e0a$b$\uff0c\u518d\u5728\u6700\u540e\u7684$t+1$\u5904\u52a0\u4e0a$-a+b*(t-s)$\u5373\u53ef\u3002 \u800c$B$\u64cd\u4f5c\u590d\u6742\uff0c\u9700\u8981$nlrc,lrc,lc,rc$\u5206\u522b\u8868\u793a$(l,r),[l,r],[l,r),(l,r]$\u7684\u56db\u79cd\u60c5\u51b5\u3002 \u6b64\u65f6\uff0c\u770b\u8d77\u6765\u597d\u50cf\u53ea\u9700\u8981$lrc$,\u5408\u5e76\u65f6\u5224\u65ad\u4e00\u4e0b\u5de6\u53f3\u7aef\u70b9\u662f\u5426\u76f8\u7b49\u5c31\u884c\u4e86\u554a\u3002 \u4e3a\u4ec0\u4e48\u4f1a\u9700\u8981$lc,rc,nlrc$\u5462\uff1f \u8003\u8651\u4e0b\u9762\u8fd9\u7ec4\u6570\u636e\uff1a s:0 1 2 4 5 7 9 x: 1 1 2 1 2 2 \u6b64\u65f6\uff0c\u5de6\u53f3\u533a\u95f4\u7684$lrc$\u5206\u522b\u662f\uff1a s:[0 1 2 [4] 5 7 9] x: [1 1 2] [1 2 2] ans: [2] [2] \u5408\u5e76\uff1aans=2+2-(2==1)=4 \u6b63\u786e\u7b54\u6848=3 \u6211\u4eec\u53d1\u73b0\uff0c\u5bf9\u4e8e$4$\uff0c\u5b83\u7b97\u4e86\u4e24\u904d\u3002 \u6240\u4ee5\u9700\u8981\u8fd9\u79cd\u5408\u5e76\u65b9\u5f0f\uff1a s:[0 1 2 )[4 5 7 9] x: [1 1 2) [1 2 2] ans: [1) [2] \u5408\u5e76\uff1aans=3\uff0c\u6b63\u786e \u8fd9\u89e3\u91ca\u4e86\u53e6\u5916\u4e09\u4e2a\u503c\u7684\u5fc5\u8981\u6027\u3002 \u6ce8\u610f\uff0c\u53ea\u6709$(...[x]...)$\uff0c\u5373\u4e24\u4e2a\u533a\u95f4\u5305\u542b\u539f\u5e8f\u5217\u7684\u540c\u4e00\u4e2a\u6570,\u8fd9\u79cd\u60c5\u51b5\u624d\u80fd\u5c06\u5e8f\u5217\u5408\u5e76\u540e\u5224\u65ad$-1$\uff0c\u5373\u539f\u6570\u5217\u4e2d\u6709\u4e00\u4e2a\u6570\u5728\u4e24\u4e2a\u516c\u5dee\u76f8\u7b49\u7684\u7b49\u5dee\u6570\u5217\u4e2d\u90fd\u6709\uff0c\u624d\u80fd\u5408\u5e76\u6210\u4e00\u4e2a\u7b49\u5dee\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\uff0c\u5728\u4fee\u6539\u65f6\u7528$push_down$\u5411\u4e0b\u4fee\u6539$lval$\u548c$rval$,\u518d\u5728\u56de\u6eaf\u65f6\u7528$pushup$\u7ef4\u62a4\u90a3\u56db\u4e2a\u503c\u5373\u53ef\u3002 \u56e0\u4e3a\u672c\u4f53\u4e2d\u7684\u7ed3\u6784\u4f53\u4e0d\u597d\u6e05\u96f6\uff0c\u6e05\u96f6\u4e86\u4e5f\u4e0d\u597d\u5408\u5e76\uff0c\u6240\u4ee5\u5c31\u4e0d\u4fdd\u5b58\u76f4\u63a5\u8fd4\u56de\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #define ls i<<1 #define rs i<<1|1 #define int long long using namespace std; const int N=1e5+10; int n,q,s,t,a,b; int v[N],w[N]; char chh[200]; struct node{ int lc,rc,nlrc,lrc,lval,rval; }tre[N<<2]; int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); return; } node operator +(const node &a,const node &b){//\u91cd\u8981\u7684\u91cd\u8f7d\u8fd0\u7b97\u7b26 node c; c.lval=a.lval; c.rval=b.rval; c.nlrc=a.rc+b.lc-(a.rval==b.lval);//\u5c06pushup\u4e2d\u7684\u5185\u5bb9\u642c\u8fd0\u5230\u8fd9\u91cc\u5373\u53ef\u3002 c.nlrc=min(c.nlrc,min(a.nlrc+b.lc,a.rc+b.nlrc));//\u5176\u5b9e\u5c31\u662f\u4e09\u79cd\u60c5\u51b5\u53d6min c.lc=a.lrc+b.lc-(a.rval==b.lval);//\u6ce8\u610f\uff0c\u53ea\u6709[]\u8fd9\u79cd\u60c5\u51b5\u624d\u80fd\u5c06\u5e8f\u5217\u5408\u5e76\u540e\u5224\u65ad-1\uff0c\u5373\u539f\u6570\u5217\u4e2d\u6709\u4e00\u4e2a\u6570\u5728\u4e24\u4e2a\u516c\u5dee\u76f8\u7b49\u7684\u7b49\u5dee\u6570\u5217\u4e2d\u90fd\u6709\u3002 c.lc=min(c.lc,min(a.lc+b.lc,a.lrc+b.nlrc)); c.rc=a.rc+b.lrc-(a.rval==b.lval); c.rc=min(c.rc,min(a.rc+b.rc,a.nlrc+b.lrc)); c.lrc=a.lrc+b.lrc-(a.rval==b.lval); c.lrc=min(c.lrc,min(a.lrc+b.rc,a.lc+b.lrc)); return c; } int tag[N<<2]; void pushdown(int i,int l,int r){ if(!tag[i])return;//\u6ce8\u610f1:\u61d2\u6807\u8bb0\u4e3a\u7a7a\u76f4\u63a5\u8df3\u8fc7\u3002 int k=tag[i]; tag[ls]+=k; tag[rs]+=k; tre[ls].lval+=k; tre[ls].rval+=k; tre[rs].lval+=k; tre[rs].rval+=k; tag[i]=0; return; } void build(int i,int l,int r){ if(l>=r){//\u6ce8\u610f2:\u4e0d\u8981\u8ba9l>r tre[i].lc=tre[i].rc=tre[i].lrc=1; tre[i].lval=tre[i].rval=w[l]; return; } int mid=(l+r)>>1; build(ls,l,mid); build(rs,mid+1,r); tre[i]=tre[ls]+tre[rs]; return; } void change(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tre[i].lval+=k; tre[i].rval+=k; tag[i]+=k; return; } pushdown(i,l,r); int mid=(l+r)>>1; if(el<=mid)change(ls,l,mid,el,er,k); if(er>mid)change(rs,mid+1,r,el,er,k); tre[i]=tre[ls]+tre[rs]; return; } node query(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ return tre[i]; } pushdown(i,l,r); int mid=(l+r)>>1; if(er<=mid)return query(ls,l,mid,el,er);//\u8fd9\u91cc\u8fd9\u4e48\u5199\u53ea\u662f\u56e0\u4e3a\u672c\u4f53\u4e2d\u7684\u7ed3\u6784\u4f53\u4e0d\u597d\u6e05\u96f6\uff0c\u6e05\u96f6\u4e86\u4e5f\u4e0d\u597d\u5408\u5e76\uff0c\u6240\u4ee5\u5c31\u4e0d\u4fdd\u5b58\u76f4\u63a5\u8fd4\u56de\u3002 else if(el>mid)return query(rs,mid+1,r,el,er);//\u6ce8\u610f3:\u4e0d\u7528\u4fdd\u5b58\u76f4\u63a5\u8fd4\u56de\u7ed3\u6784\u4f53 else return query(ls,l,mid,el,mid)+query(rs,mid+1,r,mid+1,er); } signed main(){ //freopen(\"1558/1.in\",\"r\",stdin); n=read1(); for(int i=1;i<=n;++i)v[i]=read1(); for(int i=1;i<n;++i)w[i]=v[i+1]-v[i]; build(1,1,n-1); q=read1(); for(int i=1;i<=q;++i){ scanf(\"%s\",chh); if(chh[0]=='A'){ s=read1(),t=read1(),a=read1(),b=read1(); if(s != 1) change(1, 1, n-1, s-1, s-1, a); //\u6ce8\u610f4:\u4e0d\u8981\u8d8a\u754c if(t != n) change(1, 1, n-1, t, t, -(a+b*(t-s))); if(s != t) change(1, 1, n-1, s, t-1, b); }else{ s=read1(),t=read1(); if(s==t){//\u6ce8\u610f5:\u4e0d\u8981\u8d8a\u754c putchar('1');putchar('\\n'); }else write1(query(1,1,n-1,s,t-1).lrc),putchar('\\n'); } } return 0; } \u6ce8\u610f:\u672c\u4f53\u4ee3\u7801\u5305\u542b\u4e86\u9664\u5386\u53f2\u6700\u5927\u503c\uff0c\u4f18\u5148\u7ea7\u4e4b\u5916\u7684\u6240\u6709\u7ebf\u6bb5\u6811\u5e38\u7528\u7684\u6280\u5de7\uff0c\u5305\u62ec\u91cd\u8f7d\u8fd0\u7b97\u7b26\uff0c$lazytag$\uff0c\u8be2\u95ee\u65f6\u7684\u5de6\u53f3\u533a\u95f4\u5206\u7c7b\u8ba8\u8bba\u4ee5\u53ca\u8fd4\u56de\u7ed3\u6784\u4f53\u7b49\u7b49\u3002 P4064 \u5bf9\u4e8e\u6700\u5c0f\u503c\u6700\u5927\u5316\uff0c\u6211\u4eec\u60f3\u5230\u4e8c\u5206\u3002 \u5047\u8bbe\u5f53\u524d\u679a\u4e3e\u7684\u7b54\u6848\u4e3a$mid$\uff0c\u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u5fc5\u987b\u8981\u52a0$\\max(\\lceil\\frac{mid-a_i}{d}\\rceil,0)$\u6b21\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8d2a\u5fc3\u5730\u6309\u7167\u53f3\u7aef\u70b9\u4ece\u8fdc\u5230\u8fd1\u5730\u53d6\u3002 \u9996\u5148\u8981\u5c06\u533a\u95f4\u6309\u5de6\u7aef\u70b9\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u3002 \u5c06\u6240\u6709\u5de6\u7aef\u70b9\u5c0f\u4e8e$i$\u7684\u533a\u95f4\u4e22\u8fdb\u4f18\u5148\u961f\u5217\u91cc\uff0c\u6309\u4e0a\u6587\u8981\u6c42\u7ef4\u62a4\u53f3\u7aef\u70b9\u3002 \u5982\u679c\u6709\u5f53\u524d\u70b9\u672a\u6ee1\u8db3\u6761\u4ef6\uff0c\u5e76\u4e14\u961f\u5217\u4e3a\u7a7a\u6216\u5f53\u524d\u533a\u95f4\u53f3\u7aef\u70b9\u5df2\u7ecf\u5c0f\u4e8e$i$\uff0c\u8bf4\u660e\u65e0\u6cd5\u6ee1\u8db3\u6761\u4ef6\u3002\u5426\u5219\u53ef\u4ee5\u6ee1\u8db3\u3002 \u8fd9\u6837\u4e8c\u5206\u5373\u5f97\u7b54\u6848\u3002 \u6ce8\u610f\u6e05\u96f6\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<queue> #define int long long #define lowbit(x) (x&-x) using namespace std; const int N=4e5+10,INF=0x3f3f3f3f; int a[N],b[N],c[N],vis[N]; int n,m,T,k,d,minn; struct query { int l,r,id; } f[N]; struct node{ int num,r; node(int numm,int rr){ num=numm,r=rr; } bool operator <(const node &x)const{ return x.r>r; } }; bool cmp(query a,query b) { return a.l<b.l; } void add(int x,int d) { while(x<=n)c[x]+=d,x+=lowbit(x); } int sum(int x){ int ans=0; while(x>0)ans+=c[x],x-=lowbit(x); return ans; } void init(){ for(int i=1; i<=n; ++i) add(i,b[i]); } void clear1() { for(int i=1;i<=m;++i){ if(vis[i]){ if(f[i].l>0)add(f[i].l,-d); if(f[i].r<n)add(f[i].r+1,d); vis[i]=0; } } } bool check(int x) { priority_queue<node> q; int l=1,cnt=0; for(int i=1; i<=n; ++i) { if(cnt>k)return false; while(f[l].l<=i && l<=m)q.push(node(l,f[l].r)),++l; int delta=x-sum(i); while(delta>0){ if(q.empty())return false; int tmp=q.top().num;q.pop(); if(f[tmp].r<i)return false; if(f[tmp].l>0)add(f[tmp].l,d); if(f[tmp].r<n)add(f[tmp].r+1,-d); vis[tmp]=1; delta-=d; ++cnt; } } return cnt<=k; } signed main() { scanf(\"%lld\",&T); while(T--) { memset(c,0,sizeof c); scanf(\"%lld%lld%lld%lld\",&n,&m,&k,&d); minn=INF;a[0]=0; for(int i=1; i<=n; ++i)scanf(\"%lld\",&a[i]),minn=min(minn,a[i]); for(int i=1; i<=n; ++i)b[i]=a[i]-a[i-1]; for(int i=1; i<=m; ++i)scanf(\"%lld%lld\",&f[i].l,&f[i].r),f[i].id=i; sort(f+1,f+m+1,cmp); int l=minn-1,r=minn+k*d+1,ans=0; memset(vis,0,sizeof vis); init(); while(l<r) { int mid=l+r>>1; if(check(mid)) { ans=mid; l=mid+1; } else r=mid; clear1(); } printf(\"%lld\\n\",ans); } return 0; } \u6811\u72b6\u6570\u7ec4\u533a\u95f4\u4fee\u6539&\u5355\u70b9\u67e5\u8be2 \u5bf9\u4e8e\u533a\u95f4\u4fee\u6539\u5e76\u4e14\u53ea\u6709\u5355\u70b9\u67e5\u8be2\u5f97\u9898\u76ee\uff0c\u53ef\u4ee5\u7528\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u5dee\u5206\u6570\u5217\u3002 ~~\u5dee\u5206\u771f\u7684\u5f3a~~ \u5bf9\u4e8e\u5df2\u6709\u7684\u5dee\u5206\u6570\u5217\uff0c\u5c06$1 \\to i$\u6240\u6709$c[i]$\u52a0\u8d77\u6765\uff0c\u5c31\u5f97\u5230\u539f\u6570\u5217\u5f97$a[i]$\uff0c\u800c\u5c06\u533a\u95f4$[l,r]$\u52a0\u4e0a$d$\u5c31\u76f8\u5f53\u4e8e\u4e24\u4e2a\u5355\u70b9\u4fee\u6539\uff1a if(l>0)add(l,d); if(r<n)add(r+1,-d); \u9006\u5e8f\u5bf9 \u8bb8\u591a\u95ee\u9898\uff0c\u50cf\u5c06\u4e0d\u540c\u5168\u6392\u5217\u4e2d\u76f8\u540c\u7684\u6570\u5b57\u4e24\u4e24\u914d\u5bf9\uff0c\u53ea\u80fd\u4ea4\u6362\u4e00\u4e2a\u6570\u5b57\u548c\u5b83\u76f8\u90bb\u7684\u6570\u5b57\u7684\u6700\u5c11\u6b65\u6570\u8fd9\u79cd\u95ee\u9898\uff0c\u5c31\u53ef\u4ee5\u8f6c\u5316\u6210\u9006\u5e8f\u5bf9\u6c42\u89e3\u3002 P1966 \u9996\u5148\u662f\u4e00\u4e2a\u8d2a\u5fc3\u6027\u8d28\u8bc1\u660e\uff1a \u5bf9\u4e8e$a[],b[]$\u6392\u5e8f\u540e\uff0c\u4e00\u5b9a\u662f\u4e00\u4e00\u5bf9\u5e94\uff0c\u5373$a[1]\\to b[1],a[2]\\to b[2],...,a[n]\\to b[n]$ \u8bc1\u660e\uff1a \u5047\u8bbe\u5df2\u7ecf\u5bf9\u5e94\u597d\u524d$n-2$\u7ec4\uff0c\u4fdd\u8bc1\u7b54\u6848\u6700\u5c0f\uff0c\u6b64\u65f6\u5269\u4f59$a$\u7ec4\u7684$a,b$,$b$\u7ec4\u7684$c,d$ x x x x a b x x x x c d \u90a3\u4e48\u6709\u4e24\u79cd\u65b9\u5f0f\uff1a$(a-c)^2+(b-d)^2$\u548c$(a-d)^2+(b-c)^2$. \u5047\u8bbe\u7b2c\u4e00\u79cd\u6700\u4f18\u3002 \u5219\uff1a $$ -2ac-2bd<-2ad-2bc\\ ac+bd>ad+bc\\ a(c-d)>b(c-d)\\ \u5f53c<d\u65f6\u6709:\\a< b $$ \u8bc1\u6bd5\u3002 \u90a3\u4e48\u5c31\u8f6c\u5316\u6210\u5c06$a[],b[]$\u4e00\u4e00\u5bf9\u5e94\u7684\u95ee\u9898\uff1b \u8bbe$q[a[i]]=b[i]$\uff0c\u90a3\u4e48\u7b54\u6848\u5e94\u6ee1\u8db3$q[a[i]]=a[i]$,\u5373$q[i]=i$ \u6240\u4ee5\u95ee\u9898\u8f6c\u5316\u6210\u6c42\u5c06$q$\u6570\u7ec4\u5347\u5e8f\u6392\u5217\u7684\u6700\u5c11\u4ea4\u6362\u6b65\u6570\uff0c\u5373\u9006\u5e8f\u5bf9\u6570\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<map> #include<algorithm> #define int long long #define lowbit(x) (x&-x) using namespace std; const int N=2e5+10,P=1e8-3; struct node{ int h,id; }a[N],b[N]; int p[N],c[N]; int n,m; bool cmp(node a,node b){ return a.h<b.h; } void add(int x,int d){ while(x<=n)c[x]+=d,x+=lowbit(x); } int sum(int x){ int ans=0; while(x>0){ ans+=c[x]; x-=lowbit(x); } return ans; } signed main(){ //freopen(\"P1966_2.in\",\"r\",stdin); scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i].h),a[i].id=i; for(int i=1;i<=n;++i)scanf(\"%lld\",&b[i].h),b[i].id=i; sort(a+1,a+n+1,cmp); sort(b+1,b+n+1,cmp); for(int i=1;i<=n;++i)p[a[i].id]=b[i].id; int ans=0; for(int i=n;i>=1;--i){ ans=(ans+sum(p[i]))%P; add(p[i],1); } printf(\"%lld\",(ans+P)%P); return 0; } P6186 \u5047\u8bbe\u6bcf\u4e2a\u6570\u524d\u9762\u6bd4\u4ed6\u5927\u7684\u6570\u7684\u4e2a\u6570\u4e3a$b[i]$ \u9700\u8981\u6ce8\u610f\u5230$k$\u8f6e\u5192\u6ce1\u6392\u5e8f\u7684\u7279\u6027\u662f\uff0c\u5bf9\u4e8e$b[i]>k$\u7684\u60c5\u51b5\uff0c\u5168\u90e8$-k$,\u5426\u5219\u5c31\u53d8\u4e3a$0$. \u56e0\u4e3a\u6bcf\u4e00\u8f6e\u4e2d\uff0c\u6bcf\u4e2a\u6570\u4e4b\u524d\u7684\u6700\u5927\u6570$x$\u4e00\u5b9a\u4f1a\u88ab\u79fb\u52a8\u5230\u6bd4$x$\u5927\u7684\u7b2c\u4e00\u4e2a\u6570$y$\u4e4b\u524d\uff0c\u5373\u8fd9\u4e2a\u6570\u4e4b\u540e\u3002 \u6240\u4ee5\u6240\u6709\u8f83\u5c0f\u6570\u7684$b[i]$\u90fd\u4f1a\u56e0\u4e3a\u6709\u4e00\u4e2a\u6700\u5927\u6570\u79fb\u52a8\u5230\u6240\u6709\u5c0f\u6570\u7684\u540e\u9762\u800c$-1$. \u800c\u6bcf\u6b21\u79fb\u52a8\u7684\u6700\u5927\u6570\u4e00\u5b9a\u6ee1\u8db3$b[i]=0$,\u79fb\u52a8\u540e\u4e5f\u4e0d\u4f1a\u6539\u53d8\uff0c\u6240\u4ee5\u5047\u8bbe\u6bcf\u8f6e\u7684\u6700\u5927\u6570\u6709$p$\u4e2a\uff0c\u6bcf\u8f6e\u5192\u6ce1\u6392\u5e8f\u7684\u8d21\u732e\u5c31\u662f$n-p$. \u6240\u4ee5\u6700\u7ec8\u7b54\u6848\u4e3a\uff1a $$\\sum_{b[i]>k}(b[i]-k) \\=(\\sum_{b[i]>k}b[i])-\\sum_{b[i]>k}k $$ \u6240\u4ee5\u7528\u4e00\u4e2a\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u6240\u6709$b[i]$\u4e3a$j$\u7684\u6570\u7684\u8d21\u732e,\u8be2\u95ee\u51fa$t_1=sum(n)-sum(k)$\uff1b \u4e00\u4e2a\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u6240\u6709$b[i]$\u4e3a$j$\u7684\u6570\u7684\u4e2a\u6570\uff0c\u8be2\u95ee\u51fa$t_2=sum(n)-sum(k)$\uff1b \u6700\u540e\u8be2\u95ee\u7684\u7b54\u6848\u4e3a$t_2-k* t_1$ #include<iostream> #include<cstdio> #include<cstring> #define lowbit(x) (x&-x) #define int long long using namespace std; const int N=3e5+10; int n,m,tmp,t,k; int a[N],b[N],c[N],d[N]; void add(int* C,int x,int d) { if(x==0)return; while(x<=n)C[x]+=d,x+=lowbit(x); } int sum(int* C,int x) { int ans=0; while(x>0)ans+=C[x],x-=lowbit(x); return ans; } signed main() { scanf(\"%lld%lld\",&n,&m); for(int i=1; i<=n; ++i)scanf(\"%lld\",&a[i]); for(int i=1;i<=n;++i) { b[i]=i-1-sum(c,a[i]); add(c,a[i],1); } memset(c,0,sizeof c); for(int i=1; i<=n; ++i)add(c,b[i],1),add(d,b[i],b[i]); for(int i=1; i<=m; ++i) { scanf(\"%lld%lld\",&t,&k); if(t==1) { add(c,b[k],-1),add(d,b[k],-b[k]);add(c,b[k+1],-1),add(d,b[k+1],-b[k+1]); if(a[k]<a[k+1])++b[k];else --b[k+1]; swap(b[k],b[k+1]),swap(a[k],a[k+1]); add(c,b[k],1),add(d,b[k],b[k]);add(c,b[k+1],1),add(d,b[k+1],b[k+1]); } else { if(k>=n) { printf(\"0\\n\"); continue; } int t1=sum(c,n)-sum(c,k),t2=sum(d,n)-sum(d,k); printf(\"%lld\\n\",t2-k*t1); } } return 0; } P1442 \u5f88\u597d\u7684\u7ebf\u6bb5\u6811+dp #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define mid ((l+r)>>1) #define ls i<<1 #define rs i<<1|1 using namespace std; const int N=2e5+10; struct plane { int l,r,h,kl,kr; } q[N]; int n,h,x,y,cnt,num,m; int a[N],tre[N<<2],tag[N<<2],nxtl[N],nxtr[N],f[N][2]; bool cmp(int a,int b) { return a<b; } bool Cmp(plane a,plane b) { return a.h<b.h; } void lsh() { sort(a+1,a+cnt+1,cmp); int tot=unique(a+1,a+cnt+1)-a-1; for(int i=1; i<=n+1; ++i) q[i].l=lower_bound(a+1,a+tot+1,q[i].l)-a,q[i].r=lower_bound(a+1,a+tot+1,q[i].r)-a; x=q[1].l; } void pushup(int i) { tre[i]=tre[ls]+tre[rs]; } void pushdown(int i,int l,int r) { int k=tag[i]; if(!k)return; tag[ls]=k; tag[rs]=k; tre[ls]=(mid-l+1)*k; tre[rs]=(r-mid)*k; tag[i]=0; } void change(int i,int l,int r,int el,int er,int k) { if(el<=l && r<=er) { tag[i]=k; tre[i]=(r-l+1)*k; return; } pushdown(i,l,r); if(el<=mid)change(ls,l,mid,el,er,k); if(er> mid)change(rs,mid+1,r,el,er,k); pushup(i); } int query(int i,int l,int r,int pos) { if(l==r) return tre[i]; pushdown(i,l,r); if(pos<=mid)return query(ls,l,mid,pos); else return query(rs,mid+1,r,pos); } int main() { scanf(\"%d%d%d%d\",&n,&h,&x,&y); cnt=0; q[1].l=q[1].r=q[1].kl=q[1].kr=x,q[1].h=y; a[++cnt]=x; for(int i=2; i<=n+1; ++i)scanf(\"%d%d%d\",&q[i].h,&q[i].l,&q[i].r),a[++cnt]=q[i].kl=q[i].l,a[++cnt]=q[i].kr=q[i].r; lsh(); sort(q+1,q+n+2,Cmp); num=1; while((q[num].l!=x || q[num].h!=y) && num<n+1) ++num; m=n+n+2; for(int i=1; i<=n+1; ++i) { int L=query(1,1,m,q[i].l),R=query(1,1,m,q[i].r); if(q[i].h-q[L].h>h)nxtl[i]=-1; else nxtl[i]=L; if(q[i].h-q[R].h>h)nxtr[i]=-1; else nxtr[i]=R; if(q[i].l+1<=q[i].r-1)change(1,1,m,q[i].l+1,q[i].r-1,i); } memset(f,0x3f,sizeof f); f[0][0]=f[0][1]=0; for(int i=1; i<=n+1; ++i) { if(nxtl[i]!=-1) { if(nxtl[i]==0) f[i][0]=q[i].h; else f[i][0]=min(f[nxtl[i]][0]+(q[i].kl-q[nxtl[i]].kl),f[nxtl[i]][1]+(q[nxtl[i]].kr-q[i].kl))+q[i].h-q[nxtl[i]].h; } if(nxtr[i]!=-1) { if(nxtr[i]==0) f[i][1]=q[i].h; else f[i][1]=min(f[nxtr[i]][0]+(q[i].kr-q[nxtr[i]].kl),f[nxtr[i]][1]+(q[nxtr[i]].kr-q[i].kr))+q[i].h-q[nxtr[i]].h; } } printf(\"%d\",f[num][0]); return 0; } P2221 \u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\uff0c\u4ee4$r=r-1$,\u7b54\u6848\u90fd\u662f: $$ans=\\sum_{i=l}^ra[i]* (r-i+1)(i-l+1)\\\u5c55\u5f00\u5f97\\ ans=-\\sum_{i=l}^ra[i]i^2+(r+l)\\sum_{i=l}^ra[i]i+(-rl+r-l+1)\\sum_{i=l}^ra[i]\\ =-s_3+(r+l)s_2+(-rl+r-l+1)s_1 $$ \u90a3\u4e48$s_1,s_2,s_3$\u90fd\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 \u5bf9\u4e8e\u4fee\u6539\uff0c$s_1$\u76f4\u63a5\u52a0\u4e0a\u533a\u95f4\u957f\u4e58$v$,$s_2,s_3$\u9700\u8981\u7528\u524d\u7f00\u548c\u6c42\u51fa$i$\u548c$i^2$\u7684\u548c\uff0c\u5728\u4e58\u4ee5$v$\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #define mid ((l+r)>>1) #define ls (i<<1) #define rs (i<<1|1) #define int long long using namespace std; const int N=2e5+10; int n,m,L,R,v,ans,res,a; int s4[N],s5[N]; struct tree{ int l,r,tag,s1,s2,s3; tree(){ l=r=tag=s1=s2=s3=0; } }tre[N<<2]; char ch[10]; int gcd(int a,int b){ if(a<b)swap(a,b); return !b?a:gcd(b,a%b); } tree operator +(const tree a,const tree b){ tree c=tree(); c.s1=a.s1+b.s1; c.s2=a.s2+b.s2; c.s3=a.s3+b.s3; c.l=a.l;c.r=b.r; c.tag=0; return c; } void init(){ for(int i=1;i<=n-1;++i)s4[i]=s4[i-1]+i,s5[i]=s5[i-1]+i*i; } void pushup(int i){ tre[i]=tre[ls]+tre[rs]; } void pushdown(int i){ int l=tre[i].l,r=tre[i].r,v=tre[i].tag; if(!v)return; tre[ls].tag+=v; tre[rs].tag+=v; tre[ls].s1+=(mid-(l-1))*v; tre[ls].s2+=(s4[mid]-s4[l-1])*v; tre[ls].s3+=(s5[mid]-s5[l-1])*v; tre[rs].s1+=(r-(mid))*v; tre[rs].s2+=(s4[r]-s4[mid])*v; tre[rs].s3+=(s5[r]-s5[mid])*v; tre[i].tag=0; } void build(int i,int l,int r){ tre[i].l=l;tre[i].r=r; if(l==r) return; build(ls,l,mid); build(rs,mid+1,r); pushup(i); } void change(int i,int el,int er,int v){ int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er){ tre[i].s1+=(r-(l-1))*v; tre[i].s2+=(s4[r]-s4[l-1])*v; tre[i].s3+=(s5[r]-s5[l-1])*v; tre[i].tag+=v; return; } pushdown(i); if(el<=mid)change(ls,el,er,v); if(er> mid)change(rs,el,er,v); pushup(i); } tree query(int i,int el,int er){ int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) return tre[i]; pushdown(i); if(er<=mid) return query(ls,el,er); else if(el>mid) return query(rs,el,er); else return query(ls,el,mid)+query(rs,mid+1,er); } signed main(){ scanf(\"%lld%lld\",&n,&m); init(); build(1,1,n-1); for(int i=1;i<=m;++i){ scanf(\"%s\",ch); if(ch[0]=='C'){ scanf(\"%lld%lld%lld\",&L,&R,&v);--R; if(L<=R) change(1,L,R,v); }else{ scanf(\"%lld%lld\",&L,&R); a=(R-L+1); if(L==R){ printf(\"0/1\\n\"); continue; } --R; tree tmp=query(1,L,R); ans=2*(-tmp.s3+(R+L)*tmp.s2+(-R*L+R-L+1)*tmp.s1),res=a*(a-1); int Gcd=gcd(ans,res); printf(\"%lld/%lld\\n\",ans/Gcd,res/Gcd); } } return 0; } P2572 \u8003\u8651\u5bf9\u4e8e\u4e00\u4e2a\u533a\u95f4\uff0c\u7ef4\u62a4\u8fd9\u4e9b\u91cf\uff1a $l,r$\uff0c\u8868\u793a\u7ebf\u6bb5\u6811\u8282\u70b9\u5bf9\u5e94\u7684\u5de6\u53f3\u7aef\u70b9 $sum$,\u8868\u793a\u533a\u95f4\u548c $L[0/1],R[0/1],S[0/1]$,\u8868\u793a$0/1$\u7684\u524d\u7f00\u6700\u5927\u5b50\u6bb5\uff0c\u540e\u7f00\u6700\u5927\u5b50\u6bb5\u548c\u6700\u5927\u5b50\u6bb5 $tag,frc$\uff0c\u8868\u793a\u533a\u95f4\u8986\u76d6\u548c\u53cd\u8f6c\u7684$lazytag$ ($frc$\u662f\u9996\u597d\u542c\u7684$bgm$\uff0c\u6765\u81ea\u300a\u58f0\u4e4b\u5f62\u300b,~~\u5899\u88c2\u63a8\u8350~~) \u90a3\u4e48$pushup$\u5c31\u662f\u6700\u5927\u5b50\u6bb5\u548c\u7684\u65b9\u5f0f\u3002 $pushdown$\u6ce8\u610f$tag$\u4f18\u5148\u7ea7\u5927\u4e8e$frc$,\u6240\u4ee5\u8986\u76d6\u662f\u5c06$frc$\u6e05\u96f6\u3002 #include<iostream> #include<cstdio> #include<cstring> #define ls (i<<1) #define rs (i<<1|1) #define mid (l+r>>1) using namespace std; const int N=1e5+10; struct tree { int L[2],S[2],R[2],sum,tag,l,r,frc; tree() { l=r=sum=frc=L[0]=L[1]=R[0]=R[1]=S[0]=S[1]=0,tag=-1; } } tre[N<<2]; int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x){ if(x>9) write1(x/10); putchar(x%10+'0'); } int n,m,op,l,r; int a[N]; tree operator +(tree a,tree b) { tree c=tree(); int la=a.l,ra=a.r,lb=b.l,rb=b.r,xa=ra-la+1,xb=rb-lb+1; for(int k=0; k<=1; ++k) c.L[k]=(a.L[k]==xa?xa+b.L[k]:a.L[k]),c.R[k]=(b.R[k]==xb?xb+a.R[k]:b.R[k]),c.S[k]=max(max(a.S[k],b.S[k]),a.R[k]+b.L[k]); c.sum=a.sum+b.sum; c.l=a.l,c.r=b.r; return c; } void pushup(int i) { tre[i]=tre[ls]+tre[rs]; } void pushdown(int i) { int l=tre[i].l,r=tre[i].r,k=tre[i].tag,v=tre[i].frc; if(k!=-1) { tre[ls].tag=tre[rs].tag=k; tre[ls].frc=tre[rs].frc=0; tre[ls].sum=(mid-l+1)*k; tre[ls].S[k]=tre[ls].L[k]=tre[ls].R[k]=(mid-l+1); tre[ls].S[k^1]=tre[ls].L[k^1]=tre[ls].R[k^1]=0; tre[rs].sum=(r-mid)*k; tre[rs].S[k]=tre[rs].L[k]=tre[rs].R[k]=(r-mid); tre[rs].S[k^1]=tre[rs].L[k^1]=tre[rs].R[k^1]=0; tre[i].tag=-1; } if(v!=0) { tre[ls].frc^=v,tre[rs].frc^=v; tre[ls].sum=(mid-l+1)-tre[ls].sum; swap(tre[ls].L[0],tre[ls].L[1]); swap(tre[ls].R[0],tre[ls].R[1]); swap(tre[ls].S[0],tre[ls].S[1]); tre[rs].sum=(r-mid)-tre[rs].sum; swap(tre[rs].L[0],tre[rs].L[1]); swap(tre[rs].R[0],tre[rs].R[1]); swap(tre[rs].S[0],tre[rs].S[1]); tre[i].frc=0; } } void build(int i,int l,int r) { tre[i].l=l,tre[i].r=r,tre[i].tag=-1,tre[i].frc=0; if(l==r) { tre[i].sum=a[l]; tre[i].L[a[l]]=tre[i].R[a[l]]=tre[i].S[a[l]]=1; return; } build(ls,l,mid); build(rs,mid+1,r); pushup(i); } void change(int i,int el,int er,int k) { int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) { tre[i].tag=k,tre[i].frc=0; tre[i].sum=(r-l+1)*k; tre[i].S[k]=tre[i].L[k]=tre[i].R[k]=(r-l+1); tre[i].S[k^1]=tre[i].L[k^1]=tre[i].R[k^1]=0; return; } pushdown(i); if(el<=mid) change(ls,el,er,k); if(er> mid) change(rs,el,er,k); pushup(i); } void reverse(int i,int el,int er) { int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) { tre[i].frc^=1; tre[i].sum=(r-l+1)-tre[i].sum; swap(tre[i].L[0],tre[i].L[1]); swap(tre[i].R[0],tre[i].R[1]); swap(tre[i].S[0],tre[i].S[1]); return; } pushdown(i); if(el<=mid) reverse(ls,el,er); if(er> mid) reverse(rs,el,er); pushup(i); } tree query(int i,int el,int er) { int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) return tre[i]; pushdown(i); if(er<=mid) return query(ls,el,er); else if(el> mid) return query(rs,el,er); else return query(ls,el,mid)+query(rs,mid+1,er); } int main() { //freopen(\"1.in\",\"r\",stdin); n=read1(),m=read1(); for(int i=1; i<=n; ++i) a[i]=read1(); build(1,1,n); for(int i=1; i<=m; ++i) { op=read1(),l=read1(),r=read1(),++l,++r; if(op==0) { change(1,l,r,0); } else if(op==1) { change(1,l,r,1); } else if(op==2) { reverse(1,l,r); } else if(op==3) { write1(query(1,l,r).sum),putchar('\\n'); } else { write1(query(1,l,r).S[1]),putchar('\\n'); } } return 0; }","title":"\u7ebf\u6bb5\u6811"},{"location":"my%20past/OI/%E7%BA%BF%E6%AE%B5%E6%A0%91/#_1","text":"1) \u7ebf\u6bb5\u6811\u4e2d\u7684\u4f18\u5148\u7ea7\uff1a \u4e58\u6cd5\u5927\u4e8e\u52a0\u6cd5(P3373\u6a21\u677f),\u63a8\u5e73\u5927\u4e8e\u52a0\u6cd5,\u6ce8\u610f\u7ef4\u62a4\u4e24\u4e2a$lazytag$ 2) \u7ebf\u6bb5\u6811\u6700\u91cd\u8981\u7684\u662f\u53f6\u8282\u70b9\uff0c\u6709\u65f6\u7236\u8282\u70b9\u53ef\u4ee5\u4e3a0,\u53ea\u6709\u53f6\u8282\u70b9\u6709\u503c\uff0c\u5982\u679c\u6709\u64cd\u4f5c\u5c06\u7236\u8282\u70b9\u7684\u503c\u5206\u88c2\uff0c\u5c31\u4f20\u9012\u7ed9\u53f6\u8282\u70b9\u3002\u8fd9\u4e0d\u662f\u4f20\u7edf\u7ebf\u6bb5\u6811\uff0c\u800c\u662f\u5229\u7528\u4e86\u7ebf\u6bb5\u6811\u7684\u7ed3\u6784\uff0c\u56e0\u6b64\u6ce8\u610f\u7ebf\u6bb5\u6811\u7684\u7075\u6d3b\u6027\u3002(P1558) SP2713 GGS4 \u8fd9\u9053\u9898\u7528\u4e86\u4e00\u4e2a$_{\u5c0f\u6280\u5de7}$ \u56e0\u4e3a\u6570\u636e\u8303\u56f4\u662f1e18\uff0c\u6700\u591a\u516d\u6b21\u5c31\u4f1a\u5f97\u52301,\u800c1\u548c0\u5f00\u5e73\u65b9\u540e\u8fd8\u662f\u81ea\u8eab\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u5bf9\u4e0d\u7b49\u4e8e\u4e00\u7684\u6570\u66b4\u529b\u4fee\u6539\uff0c\u82e5\u533a\u95f4\u548c\u5c0f\u4e8e\u7b49\u4e8e\u533a\u95f4\u957f\u5ea6\uff0c\u5219\u53ea\u52691\u62160\uff0c\u4e0d\u9700\u518d\u4fee\u6539\u3002\u603b\u7684\u4fee\u6539\u6b21\u6570$\\Theta(6nlogn)$,\u53c8\u56e0\u4e3a\u6bcf\u6b21\u90fd\u8981\u67e5\u8be2\uff0c\u7528\u4e8e\u5224\u65ad\u6216\u8f93\u51fa\u7b54\u6848\uff0c\u6240\u4ee5$\\Theta(nlogn)$ \u603b\u590d\u6742\u5ea6$\\Theta(6nlogn)$ P1856 & P5490 \u626b\u63cf\u7ebf(\u79bb\u6563\u5316+\u7ebf\u6bb5\u6811\uff09 \u5c06\u6bcf\u4e2a\u77e9\u5f62\u90fd\u79bb\u6563\u6210\u8fb9\uff0c\u5728\u52a0\u5165\u7ebf\u6bb5\u6811\u4e2d\u3002 \u7edf\u8ba1\u7684\u65b9\u5f0f\uff1a \u7528cover\u548clen\u6570\u7ec4\u5206\u522b\u8bb0\u5f55\u8be5\u533a\u95f4\u88ab\u8986\u76d6\u7684\u6b21\u6570\u548c\u88ab\u8986\u76d6\u7684\u957f\u5ea6\u3002 \u5982\u679ccover>0\uff0c\u8bf4\u660e\u81f3\u5c11\u88ab\u5168\u8986\u76d6\u4e86\u4e00\u6b21\uff0clen=r-l+1 \u5982\u679ccover==0\uff0c\u8bf4\u660e\u6ca1\u6709\u5168\u8986\u76d6\uff0c\u53ef\u80fd\u662f\u8fde\u7eed\u7684\u533a\u95f4\u3002\u6240\u4ee5\u7ee7\u627f\u5b50\u8282\u70b9\u7684\u4fe1\u606f\uff0c\u76f4\u63a5pushup\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> //#define int long long using namespace std; const int N=2e5+10,INF=1e4; struct node{ int i,j,x,y; }q[N]; struct edge{ int l; int r; int z; int t; }e[N]; struct tree{ int len,cover; }tre[N]; int n,ans; bool cmp1(edge a,edge b){ if(a.z==b.z)return a.t>b.t; else return a.z<b.z; } bool cmp2(edge a,edge b){ if(a.z==b.z)return a.t>b.t; else a.z>b.z; } void pushup(int i,int l,int r){ if(tre[i].cover>0){ tre[i].len=r-l+1; }else{ tre[i].len=tre[i<<1].len+tre[i<<1|1].len; } } void change(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tre[i].cover+=k; if(tre[i].cover>0){ tre[i].len=r-l+1; }else{ tre[i].len=tre[i<<1].len+tre[i<<1|1].len; } return; } int mid=l+r>>1; if(el<=mid)change(i<<1,l,mid,el,er,k); if(er>mid)change(i<<1|1,mid+1,r,el,er,k); pushup(i,l,r); return; } void ins(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ tre[i].cover++; tre[i].len=r-l+1; return; } //if(l+1==r)return; int mid=l+r>>1; if(el<=mid)ins(i<<1,l,mid,el,er); if(er>mid)ins(i<<1|1,mid+1,r,el,er); pushup(i,l,r); return; } void del(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ tre[i].cover--; if(tre[i].cover>0)tre[i].len=r-l+1; else tre[i].len=tre[i<<1].len+tre[i<<1|1].len; return; } //if(l+1==r)return; int mid=l+r>>1; if(el<=mid)del(i<<1,l,mid,el,er); if(er>mid)del(i<<1|1,mid+1,r,el,er); pushup(i,l,r); return; } int abs1(int a){ return a>0?a:-a; } void build(int i,int l,int r){ if(l==r){ tre[i].len=0; tre[i].cover=0; return; } int mid=l+r>>1; build(i<<1,l,mid); build(i<<1|1,mid+1,r); //pushup(i,l,r); tre[i].len=0; tre[i].cover=0; return; } void work3(){ int cnt=0; for(int i=1;i<=n;++i){ e[++cnt].l=q[i].i; e[cnt].r=q[i].x; e[cnt].z=q[i].j; e[cnt].t=1; e[++cnt].l=q[i].i; e[cnt].r=q[i].x; e[cnt].z=q[i].y; e[cnt].t=-1; } sort(e+1,e+cnt+1,cmp1); build(1,-INF,INF); for(int i=1;i<=cnt;++i){ int l=e[i].l,r=e[i].r,t=e[i].t; int lst=tre[1].len; change(1,-INF,INF,l,r-1,t); ans+=abs1(lst-tre[1].len); } //cout<<ans<<endl; return; } void work4(){ int cnt=0; for(int i=1;i<=n;++i){ e[++cnt].l=q[i].j; e[cnt].r=q[i].y; e[cnt].z=q[i].i; e[cnt].t=1; e[++cnt].l=q[i].j; e[cnt].r=q[i].y; e[cnt].z=q[i].x; e[cnt].t=-1; } sort(e+1,e+cnt+1,cmp1); //memset(tre,0,sizeof tre); build(1,-INF,INF); for(int i=1;i<=cnt;++i){ int l=e[i].l,r=e[i].r,t=e[i].t; int lst=tre[1].len; change(1,-INF,INF,l,r-1,t); ans+=abs1(lst-tre[1].len); } return; } void work1(){ int cnt=0; for(int i=1;i<=n;++i){ e[++cnt].l=q[i].i; e[cnt].r=q[i].x; e[cnt].z=q[i].j; e[cnt].t=1; e[++cnt].l=q[i].i; e[cnt].r=q[i].x; e[cnt].z=q[i].y; e[cnt].t=-1; } sort(e+1,e+cnt+1,cmp1); build(1,-INF,INF); for(int i=1;i<=cnt;++i){ int l=e[i].l,r=e[i].r,t=e[i].t; int lst=tre[1].len; if(t==1) ins(1,-INF,INF,l,r-1); else del(1,-INF,INF,l,r-1);//cout<<lst<<\" \"<<tre[1].len<<endl; ans+=abs1(lst-tre[1].len); } //cout<<ans<<endl; return; } void work2(){ int cnt=0; for(int i=1;i<=n;++i){ e[++cnt].l=q[i].j; e[cnt].r=q[i].y; e[cnt].z=q[i].i; e[cnt].t=1; e[++cnt].l=q[i].j; e[cnt].r=q[i].y; e[cnt].z=q[i].x; e[cnt].t=-1; } sort(e+1,e+cnt+1,cmp1); //memset(tre,0,sizeof tre); build(1,-INF,INF); for(int i=1;i<=cnt;++i){ int l=e[i].l,r=e[i].r,t=e[i].t; int lst=tre[1].len; if(t==1) ins(1,-INF,INF,l,r-1); else del(1,-INF,INF,l,r-1); ans+=abs1(lst-tre[1].len); } return; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i){ scanf(\"%d%d%d%d\",&q[i].i,&q[i].j,&q[i].x,&q[i].y); } ans=0; work3(); work4(); printf(\"%d\",ans); return 0; } /* 2 0 0 4 4 0 4 4 8 */ \u7ebf\u6bb5\u6811\u7684\u7279\u70b9\uff1a\u53ea\u6709\u7528\u5f53\u524d\u533a\u95f4\u65f6\u624d\u7528pushdown\u8ba1\u7b97\u503c,\u4fdd\u8bc1$O(nlogn)$\uff1b\u5f53\u524d\u533a\u95f4\u4e00\u5b9a\u53ea\u5305\u542b\u5c0f\u533a\u95f4\u548c\u81ea\u5df1\uff0c\u4e0d\u4f1a\u6709\u67d0\u4e2a\u533a\u95f4\u7684\u4e00\u90e8\u5206\u3002 SP1043 GSS1 \u7ebf\u6bb5\u6811\u3002 \u7528\u7ed3\u6784\u4f53tre\u4f5c\u4e3a\u8282\u70b9\u7ef4\u62a4\u56db\u4e2a\u503c\uff1a \u533a\u95f4\u548c s\uff0c\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c t\uff0c\u533a\u95f4\u4ece\u5de6\u7aef\u70b9\u5f00\u59cb\u7684\u6700\u5927\u524d\u7f00\u548c l\uff0c\u533a\u95f4\u4ece\u53f3\u7aef\u70b9\u5f00\u59cb\u7684\u6700\u5927\u540e\u7f00\u548c r\u3002 \u5982\u4f55\u5408\u5e76\u4e24\u4e2a\u5c0f\u533a\u95f4 ls , rs\uff0c\u5f97\u5230\u5927\u533a\u95f4 i \u7684\u5b50\u6bb5\u548c\uff1f \u8003\u8651\u5b50\u6bb5\u548c\u7684\u6700\u5927\u503c\u4ece\u4f55\u800c\u6765\uff1a 1\uff09\u7531\u4e24\u4e2a\u5c0f\u533a\u95f4\u81ea\u8eab\u5185\u90e8\u4ea7\u751f\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662fmax(tre[ls].t , tre[rs].t) 2)\u7531\u4e24\u4e2a\u5c0f\u533a\u95f4\u5408\u5e76\u5f97\u51fa\uff0c\u5219\u7528\u5230\u7684\u5c31\u662f\u5de6\u533a\u95f4\u7684\u540e\u7f00\u548c\u52a0\u6709\u533a\u95f4\u7684\u524d\u7f00\u548c\uff0c\u5408\u5e76\u51fa\u8986\u76d6\u4e24\u4e2a\u5c0f\u533a\u95f4\u7684\u5927\u533a\u95f4\u3002\u6b32\u4f7f\u5176\u503c\u6700\u5927\uff0c\u5219\u53d6\u6700\u5927\u524d\u7f00\u540e\u7f00\u548ctre[ls].r + tre[rs].l\u3002 \u56e0\u6b64 tre[i].t=max(max(tre[i<<1].t,tre[i<<1|1].t),tre[i<<1].r+tre[i<<1|1].l); \u8fd9\u91ccls=i<<1 ,rs=i<<1|1. 2.\u5982\u4f55\u7ef4\u62a4\u5f53\u524d\u8282\u70b9\u7684\u6700\u5927\u524d\u7f00\uff0c\u540e\u7f00\u548c\uff1f \u5f53\u524d\u5927\u533a\u95f4\u7684\u524d\u7f00\u548c\u662f\u957f\u77ed\u4e24\u79cd\u60c5\u51b5\u53d6max\uff0c\u5373\u5de6\u8fb9\u5c0f\u533a\u95f4\u7684\u6700\u5927\u524d\u7f00\u548c\u7684\u503c\uff0c\u548c\u8986\u76d6\u6574\u4e2a\u5de6\u8fb9\u5c0f\u533a\u95f4\u548c\u53f3\u8fb9\u5c0f\u533a\u95f4\u7684\u6700\u5927\u524d\u7f00\u548c\u7684\u503c \u53d6max\u3002 \u540e\u7f00\u548c\u540c\u7406\u3002 tre[i].l=max(tre[i<<1].l,tre[i<<1].s+tre[i<<1|1].l); tre[i].r=max(tre[i<<1|1].r,tre[i<<1|1].s+tre[i<<1].r); \u6700\u540e\u533a\u95f4\u548c\u5c31\u662f\u5de6\u53f3\u533a\u95f4\u76f8\u52a0\u3002 \u4e0d\u9700\u8981\u4fee\u6539\uff0c\u53ea\u7528\u67e5\u8be2\u3002 \u5177\u4f53\u7684\u770b\u6ce8\u91ca\u548c\u4ee3\u7801\u5427QwQ Code Time\uff1a #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e5+10,INF=15007+5; struct node{ int l,r,t,s; node(){//\u521d\u59cb\u5316\uff0c\u9632\u6b62\u968f\u673a\u6570\u636e\u9020\u6210\u5e72\u6270 l=-INF,r=-INF,t=-INF,s=-INF; } }tre[N<<2];//\u522b\u95ee\u6211\u4e3a\u4ec0\u4e48\u5148\u5f00\u4e24\u500d\u7a7a\u95f4\u518d\u4e584 int n,m,l,r; int a[N]; void pushup(int i){ tre[i].t=max(max(tre[i<<1].t,tre[i<<1|1].t),tre[i<<1].r+tre[i<<1|1].l); tre[i].l=max(tre[i<<1].l,tre[i<<1].s+tre[i<<1|1].l); tre[i].r=max(tre[i<<1|1].r,tre[i<<1|1].s+tre[i<<1].r); tre[i].s=tre[i<<1].s+tre[i<<1|1].s; return; } void build(int i,int l,int r){//\u5efa\u6811 if(l==r){ tre[i].t=a[l]; tre[i].l=a[l]; tre[i].r=a[l]; tre[i].s=a[l]; return; } int mid=l+r>>1; build(i<<1,l,mid); build(i<<1|1,mid+1,r); pushup(i); return; } node query(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ return tre[i]; } int mid=l+r>>1; node ans=node(),x=node(),y=node(); if(el<=mid)x=query(i<<1,l,mid,el,er); if(er>mid)y=query(i<<1|1,mid+1,r,el,er); ans.t=max(max(x.t,y.t),x.r+y.l);//pushup ans.l=max(x.l,x.s+y.l); ans.r=max(y.r,y.s+x.r); ans.s=x.s+y.s; return ans; } signed main(){ memset(tre,0,sizeof tre); scanf(\"%lld\",&n); for(int i=1;i<=n;++i){ scanf(\"%lld\",&a[i]); } build(1,1,n); scanf(\"%lld\",&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&l,&r); node res=node(); res=query(1,1,n,l,r); printf(\"%lld\\n\",res.t); } return 0; } /* \u6570\u636e >>>input 8 -1 2 3 1 -1 1 1 -1 4 1 8 2 7 4 5 3 4 >>>output 7 7 1 4 */ Orz CF833B \u8bbe$f[i][j]$\u8868\u793a\u524d$i$\u4e2a\u989c\u8272\u5206\u6210$j$\u7aef\u7684\u6700\u5927\u8d21\u732e\uff0c$col[i][j]$\u8868\u793a\u4ece$i$\u5230$j$\u7684\u8d21\u732e\u3002 \u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a $$ f[i][j]=\\max_{k=0}^{i-1}(f[k][j-1]+col[k+1][i]) $$ \u8fd9\u6837\u505a\u590d\u6742\u5ea6$O(n^2k)$,\u80af\u5b9a\u7206\u70b8\u3002 \u7531\u4e8e\u6bcf\u6b21\u9700\u8981\u679a\u4e3e$k$\u800c\u803d\u8bef\u65f6\u95f4\uff0c\u6240\u4ee5\u8003\u8651\u628a\u4e0a\u4e00\u8f6e\u6240\u6709\u7684$f[k][j-1]$\u4e22\u8fdb\u7ebf\u6bb5\u6811\u91cc\u7ef4\u62a4\u3002 \u7528\u5230\u4e86\u53bb\u91cd\u7684\u5e38\u7528$_ {trick} $,\u5c31\u662f\u5c06\u6bcf\u4e2a\u989c\u8272\u4e0a\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\u8bb0\u5f55\u4e0b\u6765\u3002\u4e4b\u540e\uff0c\u7528\u7ebf\u6bb5\u6811\u7684\u533a\u95f4\u52a0\u6765\u66f4\u65b0\u5f53\u524d\u7684\u989c\u8272\u5bf9\u4e4b\u524d\u54ea\u4e9b\u4f4d\u7f6e\u7531\u8d21\u732e\u3002 \u7ebf\u6bb5\u6811\u4e2d\u4f4d\u7f6e$k$\u7ef4\u62a4\u7684\u5c31\u662f\u4ece$k$\u5230$i$\u7684\u8d21\u732e$col[k][i]$\u52a0\u4e0a$f[k-1][j-1]$\u7684\u603b\u8d21\u732e\u3002 \u8fd9\u6837\u6bcf\u6b21\u53ea\u9700\u8981\u53d6$query(1,1,n,1,j)$\u5373\u53ef\u66f4\u65b0$f[i][j]$. ~~\u6ce8\u610f\u7ebf\u6bb5\u6811\u7684\u6e05\u96f6\u64cd\u4f5c(lazytag)\uff0c\u6211\u5df2\u7ecf\u88ab\u5751\u7684\u89c1\u7956\u5b97\u4e86,\u89c1\u6ce8\u91ca~~ code time: #include<iostream> #include<cstdio> #include<cstring> #define ls i<<1 #define rs i<<1|1 #define int long long using namespace std; const int N=4e4+10,K=55; int f[K][N],pos[N],pre[N],tre[N<<2],tag[N<<2]; int n,k,t; void pushup(int i){ tre[i]=max(tre[ls],tre[rs]); } void pushdown(int i,int l,int r){ int k=tag[i]; if(!k)return; tag[ls]+=k;tag[rs]+=k;tre[ls]+=k;tre[rs]+=k; tag[i]=0; } void build(int i,int l,int r,int now){ tag[i]=0;//\u4e00\u5b9a\u8981\u6e05\u96f6\uff0c\u5e76\u4e14\u8981\u5199\u5728\u5916\u9762 if(l==r){ tre[i]=f[now][l-1]; return; } int mid=(l+r)>>1; build(ls,l,mid,now); build(rs,mid+1,r,now); pushup(i); } void change(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tag[i]+=k;tre[i]+=k; return; } pushdown(i,l,r); int mid=(l+r)>>1; if(el<=mid) change(ls,l,mid,el,er,k); if(er>mid) change(rs,mid+1,r,el,er,k); pushup(i); } int query(int i,int l,int r,int el,int er){ if(el<=l && r<=er) return tre[i]; pushdown(i,l,r); int mid=(l+r)>>1,ans=0; if(el<=mid)ans=max(ans,query(ls,l,mid,el,er)); if(er>mid)ans=max(ans,query(rs,mid+1,r,el,er)); return ans; } signed main(){ scanf(\"%lld%lld\",&n,&k); for(int i=1;i<=n;++i)scanf(\"%lld\",&t),pre[i]=pos[t]+1,pos[t]=i; for(int i=1;i<=k;++i){ build(1,1,n,i-1); for(int j=1;j<=n;++j){ change(1,1,n,pre[j],j,1); f[i][j]=query(1,1,n,1,j); } } printf(\"%lld\",f[k][n]); } SP1557 GSS2 ~~OrzOrzOrz~~ \u597d\u9898\uff0c\u662fGSS1\u7684\u8d85\u7ea7\u52a0\u5f3a\u3002 \u5bf9\u4e8e\u533a\u95f4\u53bb\u91cd\u53ef\u4ee5\u79bb\u7ebf\u5c06r\u6392\u5e8f\uff0c\u9010\u4e2a\u52a0\u5165a[i]\uff0c\u8ba1\u7b97\u5f53\u524d\u4ee5r\u4e3a\u53f3\u7aef\u70b9\u7684\u6240\u6709\u5b50\u533a\u95f4\u4e2d\u7684\u6700\u5927\u548c\uff0c\u90a3\u4e48\u5b83\u5c31\u662f\u6700\u5927\u5b50\u6bb5\u548c\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\u7ef4\u62a4\u56db\u4e2a\u503c\uff1a s \u8868\u793a\u5f53\u524d\u70b9\u7684\u6700\u5927\u5b50\u6bb5\u548c m \u8868\u793a\u5f53\u524d\u70b9\u5386\u53f2\u6700\u5927 stag \u8868\u793a\u5f53\u524d\u61d2\u6807\u8bb0 mtag \u8868\u793a\u5386\u53f2\u6700\u5927\u61d2\u6807\u8bb0 mtag\u5b58\u5728\u7684\u610f\u4e49\uff1a stag\u5728\u540c\u65f6\u9047\u5230\u8bb8\u591a\u64cd\u4f5c\u65f6\u4f1a\u5c06\u6240\u6709\u64cd\u4f5c\u8986\u76d6\u6210\u4e00\u4e2a\u64cd\u4f5c\uff0c\u800c\u5386\u53f2\u6700\u5927\u9700\u8981stag\u4e2d\u7684\u6700\u5927\u72b6\u6001\uff0c\u8fd9\u53ea\u7528stag\u8868\u793a\u4e0d\u51fa\u6765\uff0c\u6240\u4ee5\u7528\u4e00\u4e2amtag. \u8fd9\u6837\uff0c\u6bcf\u6b21\u67e5\u8be2[l,r]\u7684tre[i].m\u5373\u53ef #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2e5+10; struct node{ int m,s,mtag,stag; }tre[N<<2]; struct que{ int l,r,id; }q[N]; int n,m; int pre[N],vis[N<<1],a[N],ans[N]; bool cmp(que a,que b){ return a.r<b.r; } void pushup(int i){ tre[i].s=max(tre[i<<1].s,tre[i<<1|1].s); tre[i].m=max(tre[i<<1].m,tre[i<<1|1].m); } void pushdown(int i,int l,int r){ int ls=i<<1,rs=i<<1|1,mid=l+r>>1; tre[ls].m=max(tre[ls].m,tre[ls].s+tre[i].mtag); tre[rs].m=max(tre[rs].m,tre[rs].s+tre[i].mtag); tre[ls].s+=tre[i].stag; tre[rs].s+=tre[i].stag; tre[ls].mtag=max(tre[ls].mtag,tre[i].mtag+tre[ls].stag); tre[rs].mtag=max(tre[rs].mtag,tre[i].mtag+tre[rs].stag); tre[ls].stag+=tre[i].stag; tre[rs].stag+=tre[i].stag; tre[i].stag=0; tre[i].mtag=0; return; } void add(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tre[i].s+=k; tre[i].m=max(tre[i].m,tre[i].s); tre[i].stag+=k; tre[i].mtag=max(tre[i].mtag,tre[i].stag); return; } pushdown(i,l,r); int mid=l+r>>1; if(el<=mid)add(i<<1,l,mid,el,er,k); if(er>mid)add(i<<1|1,mid+1,r,el,er,k); pushup(i); return; } int query(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ return tre[i].m; } pushdown(i,l,r); int mid=l+r>>1,ans=0; if(el<=mid)ans=max(ans,query(i<<1,l,mid,el,er)); if(er>mid)ans=max(ans,query(i<<1|1,mid+1,r,el,er)); return ans; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]); scanf(\"%lld\",&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&q[i].l,&q[i].r); q[i].id=i; } sort(q+1,q+m+1,cmp); for(int i=1;i<=n;++i){ pre[i]=vis[a[i]+N]; vis[a[i]+N]=i; } /*for(int i=1;i<=n;++i){ cout<<pre[i]<<\" \"; } cout<<endl;*/ for(int i=1,j=1;i<=n;++i){ int ll=pre[i]+1,rr=i; add(1,1,n,ll,rr,a[i]); for(j;j<=m && q[j].r<=i;++j){ ans[q[j].id]=query(1,1,n,q[j].l,q[j].r); } } for(int i=1;i<=m;++i){ printf(\"%lld\\n\",ans[i]); } return 0; } /* 8 -1 2 3 1 -1 1 1 -1 3 1 2 2 4 1 8 */ \u6ce8\u610f\u4e0b\u9762\u6ca1\u6709mtag\u7684\u9519\u8bef\u4ee3\u7801: #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2e5+10; struct node{ int m,s,stag; }tre[N<<2]; struct que{ int l,r,id; }q[N]; int n,m; int pre[N],vis[N<<1],a[N],ans[N]; bool cmp(que a,que b){ return a.r<b.r; } void pushup(int i){ tre[i].s=max(tre[i<<1].s,tre[i<<1|1].s); tre[i].m=max(tre[i<<1].m,tre[i<<1|1].m); tre[i].m=max(tre[i].m,tre[i].s);// } void pushdown(int i,int l,int r){ int ls=i<<1,rs=i<<1|1,mid=l+r>>1; tre[ls].m=max(tre[ls].m,tre[ls].s+tre[i].stag); tre[rs].m=max(tre[rs].m,tre[rs].s+tre[i].stag); tre[ls].s+=tre[i].stag; tre[rs].s+=tre[i].stag; tre[ls].stag+=tre[i].stag; tre[rs].stag+=tre[i].stag; tre[i].stag=0; return; } void add(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tre[i].s+=k; tre[i].stag+=k; tre[i].m=max(tre[i].m,tre[i].s); return; } pushdown(i,l,r); int mid=l+r>>1; if(el<=mid)add(i<<1,l,mid,el,er,k); if(er>mid)add(i<<1|1,mid+1,r,el,er,k); pushup(i); return; } int query(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ return tre[i].m; } pushdown(i,l,r); int mid=l+r>>1,ans=0; if(el<=mid)ans=max(ans,query(i<<1,l,mid,el,er)); if(er>mid)ans=max(ans,query(i<<1|1,mid+1,r,el,er)); return ans; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]); scanf(\"%lld\",&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&q[i].l,&q[i].r); q[i].id=i; } sort(q+1,q+m+1,cmp); for(int i=1;i<=n;++i){ pre[i]=vis[a[i]+N]; vis[a[i]+N]=i; } /*for(int i=1;i<=n;++i){ cout<<pre[i]<<\" \"; } cout<<endl;*/ for(int i=1,j=1;i<=n;++i){ int ll=pre[i]+1,rr=i; add(1,1,n,ll,rr,a[i]); for(j;j<=m && q[j].r<=i;++j){ ans[q[j].id]=query(1,1,n,q[j].l,q[j].r); } } for(int i=1;i<=m;++i){ printf(\"%lld\\n\",ans[i]); } return 0; } /* 9 4 -2 -2 3 -1 -4 2 2 -6 4 1 2 1 5 4 9 2 8 */ P3924 \u8fd9\u9053\u9898\u7684\u5173\u952e\u5c31\u662f\uff0c\u5bf9\u4e8e\u6bcf\u6b21\u4fee\u6539\uff0c\u6709\u6548\u4ea7\u751f\u8d21\u732e\u7684\u53ea\u6709\u53f6\u5b50\u8282\u70b9\uff0c\u6240\u4ee5\u76f4\u63a5\u901a\u8fc7\u6df1\u5ea6\u7ef4\u62a4\u6bcf\u4e2a\u53f6\u5b50\u8282\u70b9\u5230\u6839\u4e0a\u7684\u6982\u7387\u603b\u548c\uff0c\u56e0\u4e3a\u6bcf\u6b21\u4fee\u6539\u7684\u6570\u76f8\u540c\uff0c\u6240\u4ee5\u76f4\u63a5\u524d\u7f00\u548c\u7d2f\u52a0\u3002\u5f00\u59cbO\uff08n\uff09\u6c42\u51fa\u521d\u59cb\u503c\uff0c\u6bcf\u6b21\u518d\u52a0\u3002 P4588 \u5bf9\u4e8e\u6bcf\u6b21\u64cd\u4f5c\uff0c\u5982\u679c\u76f4\u63a5\u9006\u5143\u80af\u5b9a\u4e0d\u884c\u3002 \u8003\u8651\u7ebf\u6bb5\u6811\uff0c\u6bcf\u6b21\u7684\u64cd\u4f5c\u5c31\u662f\u5355\u70b9\u4fee\u6539\u3002 \u6ce8\u610f$pushup$\u4e00\u76f4\u8981$modM$ #include<iostream> #include<cstdio> #include<cstring> #define int long long #define ls i<<1 #define rs i<<1|1 using namespace std; const int N=2e5+10; int tre[N<<2]; int Q,t,M,op,m; void pushup(int i){ tre[i]=(tre[ls]*tre[rs])%M; } void build(int i,int l,int r){ if(l==r){ tre[i]=1; return; } int mid=l+r>>1; build(ls,l,mid); build(rs,mid+1,r); pushup(i); } void change(int i,int l,int r,int pos,int k){ if(l==r){ tre[i]=k; return; } int mid=l+r>>1; if(pos<=mid)change(ls,l,mid,pos,k); else change(rs,mid+1,r,pos,k); pushup(i); } signed main(){ scanf(\"%lld\",&t); while(t--){ scanf(\"%lld%lld\",&Q,&M); build(1,1,Q); for(int i=1;i<=Q;++i){ scanf(\"%lld%lld\",&op,&m); if(op==1){ change(1,1,Q,i,m); }else{ change(1,1,Q,m,1); } printf(\"%lld\\n\",tre[1]%M); } } return 0; } ~~\u7ebf\u6bb5\u6811\u601d\u7ef4\u9898\u771f\u591a~~ P1712 \u5c3a\u53d6\u6cd5\u7ebf\u6bb5\u6811\u3002 \u5148\u5c06\u533a\u95f4\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u4f9d\u6b21\u53f3\u79fb$r$. \u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5f53\u524d\u7684\u533a\u95f4\u6709\u54ea\u4e9b\u91cd\u5408\u7684\u5730\u65b9\uff0c\u5982\u679c\u6709\u4e00\u4e2a\u70b9\u91cd\u5408\u5ea6$\\geq m$,\u5c31\u53f3\u79fb$l$\u5e76\u7edf\u8ba1\u7b54\u6848\u3002 CF1042D \u7ef4\u62a4\u6bcf\u4e2a\u7aef\u70b9$i$\u524d\u9762\u6709\u591a\u5c11\u4e2a\u7aef\u70b9$j$\u6ee1\u8db3$sum[i]-sum[j-1]<t$\u3002 \u56e0\u4e3a\u6bcf\u6b21\u505a\u5b8c\u90fd\u4f1a\u52a0\u5165$sum[i]$\uff0c\u6240\u4ee5\u4fdd\u8bc1$sum[j-1],1 \\leq j \\leq i-1 $\u5728\u4e4b\u524d\u5df2\u7ecf\u6c42\u51fa\u6765\u4e86\uff0c\u56e0\u6b64\u53ef\u4ee5\u6743\u503c\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u4e4b\u524d\u6ee1\u8db3\u6761\u4ef6\u7684\u7aef\u70b9\u4e2a\u6570,\u5373$>sum[i]-t$\u7684\u4e2a\u6570\u3002 P5482 \u7ec6\u8282\u7279\u591a\u7684\u4e00\u9053\u9898\u3002 \u6ce8\u610f\u6bcf\u4e2a\u7b49\u5f0f\u7684$a$\u6709\u4e09\u79cd\u60c5\u51b5\uff1a 1) $a>0$,\u6b64\u65f6\u6b63\u5e38\u8ba8\u8bba 2) $a=0$,\u9700\u8981\u7279\u6b8a\u8ba8\u8bba\uff0c\u4e0d\u80fd\u9664\uff0c\u4e0d\u7136\u5c31$RE$\u4e86. 3) $a<0$,\u8fd9\u662f\u9700\u8981\u5c06\u7b49\u5f0f\u53cd\u8f6c\uff1a$-x>-\\frac{c-b}{a}$,\u6240\u4ee5\u65b0\u7684\u89e3$t=-x$,\u6ee1\u8db3$-at+b>c$ \u8fd8\u6709\u5c31\u662f\u9700\u8981\u5224\u65ad$x$\u548c$t$\u7684\u51fa\u754c\u60c5\u51b5\uff0c\u5982\u679c\u5c0f\u4e8e$-1e6$\uff0c\u5c31\u5728\u6811\u72b6\u6570\u7ec4$1$\u7684\u4f4d\u7f6e\u52a0$1$;\u5982\u679c\u5927\u4e8e$1e6$,\u5c31\u4e0d\u80fd\u505a\u4efb\u4f55\u5904\u7406\u3002 \u518d\u6709\u5c31\u662f\u91cd\u590d\u5220\u9664\uff0c\u6bcf\u6b21\u5220\u9664\u540e\u8981\u6253\u4e0a\u6807\u8bb0\u3002 ~~\u5751\u7239\u6bd2\u7624\u9898~~ #include<iostream> #include<cstdio> #include<cstring> #define int long long #define lowbit(x) x&-x using namespace std; const int N=2e6+100,M=2e5+10,C=1e6+1,LIM=2e6+1; struct node{ int a,b,k,type,res; }op[M]; int c[N],d[N]; int n,cnt,a,b,k; char ch[10]; void change1(int x,int k) { while(x<=N-1) { c[x]+=k; x+=lowbit(x); } } int sum1(int x) { int ans=0; while(x>0) { ans+=c[x]; x-=lowbit(x); } return ans; } void change2(int x,int k){ while(x<=N-1){ d[x]+=k; x+=lowbit(x); } } int sum2(int x){ int ans=0; while(x>0){ ans+=d[x]; x-=lowbit(x); } return ans; } signed main() { scanf(\"%lld\",&n); for(int i=1; i<=n; ++i) { scanf(\"%s\",ch); if(ch[0]=='A') { ++cnt; scanf(\"%lld%lld%lld\",&op[cnt].a,&op[cnt].b,&op[cnt].k); a=op[cnt].a,b=op[cnt].b,k=op[cnt].k; if(a==0){ if(b>k){ op[cnt].type=0,change1(1,1);// \u4e00\u5b9a\u6709\u89e3 }else{ op[cnt].type=1;//\u65e0\u89e3 } }else if(a>0){ int tmp=(k-b)/a; if(a*tmp+b<=k)tmp++; if(tmp+C<1)op[cnt].type=2,change1(1,1);//\u4e00\u5b9a\u6709\u89e3 else if(tmp+C>LIM)op[cnt].type=3;//\u4e00\u5b9a\u65e0\u89e3 else op[cnt].res=tmp+C,op[cnt].type=4,change1(tmp+C,1); }else{//a<0 int tmp=(b-k)/a; if(-a*tmp+b<=k)tmp++; if(tmp+C<1)op[cnt].type=5,change2(1,1); else if(tmp+C>LIM)op[cnt].type=6; else op[cnt].res=tmp+C,op[cnt].type=7,change2(tmp+C,1); } }else if(ch[0]=='D'){ scanf(\"%lld\",&k); if(op[k].type==0 || op[k].type==2)change1(1,-1); if(op[k].type==5)change2(1,-1); if(op[k].type==4)change1(op[k].res,-1); if(op[k].type==7)change2(op[k].res,-1); op[k].type=8;//\u5df2\u5220\u9664 }else{ scanf(\"%lld\",&k); int tmp1=sum1(k+C); int tmp2=sum2(-k+C); printf(\"%lld\\n\",tmp1+tmp2); } } return 0; } P4243 \u7b2c\u4e00\u9053\u9ed1\u9898! ~~\u867d\u7136\u53ea\u6709\u7d2b\u9898\u7684\u96be\u5ea6~~ \u5f53\u770b\u89c1\u7b49\u5dee\u6570\u5217\uff0c\u6709\u4e2a\u5e38\u7528\u7684\u5c0f$_ {Trick}$,\u5c31\u662f\u5c06\u7b49\u5dee\u6570\u5217\u8f6c\u6362\u6210\u5dee\u5206\u6570\u5217\uff0c\u5373$b[i]=a[i+1]-a[i]$\uff0c\u8fd9\u6837\uff0c\u53ea\u9700\u8981\u7ef4\u62a4\u8fde\u7eed\u7684\u76f8\u540c\u7684\u503c\u6709\u591a\u5c11\u6bb5\u5373\u53ef\u3002 \u6bcf\u6b21\u7684$A$\u64cd\u4f5c\u53ef\u4ee5\u770b\u6210\u5728$s-1$\u5904\u52a0\u4e0a$a$,\u5728$[s,t-1]$\u8fd9\u4e00\u6bb5\u52a0\u4e0a$b$\uff0c\u518d\u5728\u6700\u540e\u7684$t+1$\u5904\u52a0\u4e0a$-a+b*(t-s)$\u5373\u53ef\u3002 \u800c$B$\u64cd\u4f5c\u590d\u6742\uff0c\u9700\u8981$nlrc,lrc,lc,rc$\u5206\u522b\u8868\u793a$(l,r),[l,r],[l,r),(l,r]$\u7684\u56db\u79cd\u60c5\u51b5\u3002 \u6b64\u65f6\uff0c\u770b\u8d77\u6765\u597d\u50cf\u53ea\u9700\u8981$lrc$,\u5408\u5e76\u65f6\u5224\u65ad\u4e00\u4e0b\u5de6\u53f3\u7aef\u70b9\u662f\u5426\u76f8\u7b49\u5c31\u884c\u4e86\u554a\u3002 \u4e3a\u4ec0\u4e48\u4f1a\u9700\u8981$lc,rc,nlrc$\u5462\uff1f \u8003\u8651\u4e0b\u9762\u8fd9\u7ec4\u6570\u636e\uff1a s:0 1 2 4 5 7 9 x: 1 1 2 1 2 2 \u6b64\u65f6\uff0c\u5de6\u53f3\u533a\u95f4\u7684$lrc$\u5206\u522b\u662f\uff1a s:[0 1 2 [4] 5 7 9] x: [1 1 2] [1 2 2] ans: [2] [2] \u5408\u5e76\uff1aans=2+2-(2==1)=4 \u6b63\u786e\u7b54\u6848=3 \u6211\u4eec\u53d1\u73b0\uff0c\u5bf9\u4e8e$4$\uff0c\u5b83\u7b97\u4e86\u4e24\u904d\u3002 \u6240\u4ee5\u9700\u8981\u8fd9\u79cd\u5408\u5e76\u65b9\u5f0f\uff1a s:[0 1 2 )[4 5 7 9] x: [1 1 2) [1 2 2] ans: [1) [2] \u5408\u5e76\uff1aans=3\uff0c\u6b63\u786e \u8fd9\u89e3\u91ca\u4e86\u53e6\u5916\u4e09\u4e2a\u503c\u7684\u5fc5\u8981\u6027\u3002 \u6ce8\u610f\uff0c\u53ea\u6709$(...[x]...)$\uff0c\u5373\u4e24\u4e2a\u533a\u95f4\u5305\u542b\u539f\u5e8f\u5217\u7684\u540c\u4e00\u4e2a\u6570,\u8fd9\u79cd\u60c5\u51b5\u624d\u80fd\u5c06\u5e8f\u5217\u5408\u5e76\u540e\u5224\u65ad$-1$\uff0c\u5373\u539f\u6570\u5217\u4e2d\u6709\u4e00\u4e2a\u6570\u5728\u4e24\u4e2a\u516c\u5dee\u76f8\u7b49\u7684\u7b49\u5dee\u6570\u5217\u4e2d\u90fd\u6709\uff0c\u624d\u80fd\u5408\u5e76\u6210\u4e00\u4e2a\u7b49\u5dee\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\uff0c\u5728\u4fee\u6539\u65f6\u7528$push_down$\u5411\u4e0b\u4fee\u6539$lval$\u548c$rval$,\u518d\u5728\u56de\u6eaf\u65f6\u7528$pushup$\u7ef4\u62a4\u90a3\u56db\u4e2a\u503c\u5373\u53ef\u3002 \u56e0\u4e3a\u672c\u4f53\u4e2d\u7684\u7ed3\u6784\u4f53\u4e0d\u597d\u6e05\u96f6\uff0c\u6e05\u96f6\u4e86\u4e5f\u4e0d\u597d\u5408\u5e76\uff0c\u6240\u4ee5\u5c31\u4e0d\u4fdd\u5b58\u76f4\u63a5\u8fd4\u56de\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #define ls i<<1 #define rs i<<1|1 #define int long long using namespace std; const int N=1e5+10; int n,q,s,t,a,b; int v[N],w[N]; char chh[200]; struct node{ int lc,rc,nlrc,lrc,lval,rval; }tre[N<<2]; int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); return; } node operator +(const node &a,const node &b){//\u91cd\u8981\u7684\u91cd\u8f7d\u8fd0\u7b97\u7b26 node c; c.lval=a.lval; c.rval=b.rval; c.nlrc=a.rc+b.lc-(a.rval==b.lval);//\u5c06pushup\u4e2d\u7684\u5185\u5bb9\u642c\u8fd0\u5230\u8fd9\u91cc\u5373\u53ef\u3002 c.nlrc=min(c.nlrc,min(a.nlrc+b.lc,a.rc+b.nlrc));//\u5176\u5b9e\u5c31\u662f\u4e09\u79cd\u60c5\u51b5\u53d6min c.lc=a.lrc+b.lc-(a.rval==b.lval);//\u6ce8\u610f\uff0c\u53ea\u6709[]\u8fd9\u79cd\u60c5\u51b5\u624d\u80fd\u5c06\u5e8f\u5217\u5408\u5e76\u540e\u5224\u65ad-1\uff0c\u5373\u539f\u6570\u5217\u4e2d\u6709\u4e00\u4e2a\u6570\u5728\u4e24\u4e2a\u516c\u5dee\u76f8\u7b49\u7684\u7b49\u5dee\u6570\u5217\u4e2d\u90fd\u6709\u3002 c.lc=min(c.lc,min(a.lc+b.lc,a.lrc+b.nlrc)); c.rc=a.rc+b.lrc-(a.rval==b.lval); c.rc=min(c.rc,min(a.rc+b.rc,a.nlrc+b.lrc)); c.lrc=a.lrc+b.lrc-(a.rval==b.lval); c.lrc=min(c.lrc,min(a.lrc+b.rc,a.lc+b.lrc)); return c; } int tag[N<<2]; void pushdown(int i,int l,int r){ if(!tag[i])return;//\u6ce8\u610f1:\u61d2\u6807\u8bb0\u4e3a\u7a7a\u76f4\u63a5\u8df3\u8fc7\u3002 int k=tag[i]; tag[ls]+=k; tag[rs]+=k; tre[ls].lval+=k; tre[ls].rval+=k; tre[rs].lval+=k; tre[rs].rval+=k; tag[i]=0; return; } void build(int i,int l,int r){ if(l>=r){//\u6ce8\u610f2:\u4e0d\u8981\u8ba9l>r tre[i].lc=tre[i].rc=tre[i].lrc=1; tre[i].lval=tre[i].rval=w[l]; return; } int mid=(l+r)>>1; build(ls,l,mid); build(rs,mid+1,r); tre[i]=tre[ls]+tre[rs]; return; } void change(int i,int l,int r,int el,int er,int k){ if(el<=l && r<=er){ tre[i].lval+=k; tre[i].rval+=k; tag[i]+=k; return; } pushdown(i,l,r); int mid=(l+r)>>1; if(el<=mid)change(ls,l,mid,el,er,k); if(er>mid)change(rs,mid+1,r,el,er,k); tre[i]=tre[ls]+tre[rs]; return; } node query(int i,int l,int r,int el,int er){ if(el<=l && r<=er){ return tre[i]; } pushdown(i,l,r); int mid=(l+r)>>1; if(er<=mid)return query(ls,l,mid,el,er);//\u8fd9\u91cc\u8fd9\u4e48\u5199\u53ea\u662f\u56e0\u4e3a\u672c\u4f53\u4e2d\u7684\u7ed3\u6784\u4f53\u4e0d\u597d\u6e05\u96f6\uff0c\u6e05\u96f6\u4e86\u4e5f\u4e0d\u597d\u5408\u5e76\uff0c\u6240\u4ee5\u5c31\u4e0d\u4fdd\u5b58\u76f4\u63a5\u8fd4\u56de\u3002 else if(el>mid)return query(rs,mid+1,r,el,er);//\u6ce8\u610f3:\u4e0d\u7528\u4fdd\u5b58\u76f4\u63a5\u8fd4\u56de\u7ed3\u6784\u4f53 else return query(ls,l,mid,el,mid)+query(rs,mid+1,r,mid+1,er); } signed main(){ //freopen(\"1558/1.in\",\"r\",stdin); n=read1(); for(int i=1;i<=n;++i)v[i]=read1(); for(int i=1;i<n;++i)w[i]=v[i+1]-v[i]; build(1,1,n-1); q=read1(); for(int i=1;i<=q;++i){ scanf(\"%s\",chh); if(chh[0]=='A'){ s=read1(),t=read1(),a=read1(),b=read1(); if(s != 1) change(1, 1, n-1, s-1, s-1, a); //\u6ce8\u610f4:\u4e0d\u8981\u8d8a\u754c if(t != n) change(1, 1, n-1, t, t, -(a+b*(t-s))); if(s != t) change(1, 1, n-1, s, t-1, b); }else{ s=read1(),t=read1(); if(s==t){//\u6ce8\u610f5:\u4e0d\u8981\u8d8a\u754c putchar('1');putchar('\\n'); }else write1(query(1,1,n-1,s,t-1).lrc),putchar('\\n'); } } return 0; } \u6ce8\u610f:\u672c\u4f53\u4ee3\u7801\u5305\u542b\u4e86\u9664\u5386\u53f2\u6700\u5927\u503c\uff0c\u4f18\u5148\u7ea7\u4e4b\u5916\u7684\u6240\u6709\u7ebf\u6bb5\u6811\u5e38\u7528\u7684\u6280\u5de7\uff0c\u5305\u62ec\u91cd\u8f7d\u8fd0\u7b97\u7b26\uff0c$lazytag$\uff0c\u8be2\u95ee\u65f6\u7684\u5de6\u53f3\u533a\u95f4\u5206\u7c7b\u8ba8\u8bba\u4ee5\u53ca\u8fd4\u56de\u7ed3\u6784\u4f53\u7b49\u7b49\u3002 P4064 \u5bf9\u4e8e\u6700\u5c0f\u503c\u6700\u5927\u5316\uff0c\u6211\u4eec\u60f3\u5230\u4e8c\u5206\u3002 \u5047\u8bbe\u5f53\u524d\u679a\u4e3e\u7684\u7b54\u6848\u4e3a$mid$\uff0c\u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u5fc5\u987b\u8981\u52a0$\\max(\\lceil\\frac{mid-a_i}{d}\\rceil,0)$\u6b21\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8d2a\u5fc3\u5730\u6309\u7167\u53f3\u7aef\u70b9\u4ece\u8fdc\u5230\u8fd1\u5730\u53d6\u3002 \u9996\u5148\u8981\u5c06\u533a\u95f4\u6309\u5de6\u7aef\u70b9\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u3002 \u5c06\u6240\u6709\u5de6\u7aef\u70b9\u5c0f\u4e8e$i$\u7684\u533a\u95f4\u4e22\u8fdb\u4f18\u5148\u961f\u5217\u91cc\uff0c\u6309\u4e0a\u6587\u8981\u6c42\u7ef4\u62a4\u53f3\u7aef\u70b9\u3002 \u5982\u679c\u6709\u5f53\u524d\u70b9\u672a\u6ee1\u8db3\u6761\u4ef6\uff0c\u5e76\u4e14\u961f\u5217\u4e3a\u7a7a\u6216\u5f53\u524d\u533a\u95f4\u53f3\u7aef\u70b9\u5df2\u7ecf\u5c0f\u4e8e$i$\uff0c\u8bf4\u660e\u65e0\u6cd5\u6ee1\u8db3\u6761\u4ef6\u3002\u5426\u5219\u53ef\u4ee5\u6ee1\u8db3\u3002 \u8fd9\u6837\u4e8c\u5206\u5373\u5f97\u7b54\u6848\u3002 \u6ce8\u610f\u6e05\u96f6\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<queue> #define int long long #define lowbit(x) (x&-x) using namespace std; const int N=4e5+10,INF=0x3f3f3f3f; int a[N],b[N],c[N],vis[N]; int n,m,T,k,d,minn; struct query { int l,r,id; } f[N]; struct node{ int num,r; node(int numm,int rr){ num=numm,r=rr; } bool operator <(const node &x)const{ return x.r>r; } }; bool cmp(query a,query b) { return a.l<b.l; } void add(int x,int d) { while(x<=n)c[x]+=d,x+=lowbit(x); } int sum(int x){ int ans=0; while(x>0)ans+=c[x],x-=lowbit(x); return ans; } void init(){ for(int i=1; i<=n; ++i) add(i,b[i]); } void clear1() { for(int i=1;i<=m;++i){ if(vis[i]){ if(f[i].l>0)add(f[i].l,-d); if(f[i].r<n)add(f[i].r+1,d); vis[i]=0; } } } bool check(int x) { priority_queue<node> q; int l=1,cnt=0; for(int i=1; i<=n; ++i) { if(cnt>k)return false; while(f[l].l<=i && l<=m)q.push(node(l,f[l].r)),++l; int delta=x-sum(i); while(delta>0){ if(q.empty())return false; int tmp=q.top().num;q.pop(); if(f[tmp].r<i)return false; if(f[tmp].l>0)add(f[tmp].l,d); if(f[tmp].r<n)add(f[tmp].r+1,-d); vis[tmp]=1; delta-=d; ++cnt; } } return cnt<=k; } signed main() { scanf(\"%lld\",&T); while(T--) { memset(c,0,sizeof c); scanf(\"%lld%lld%lld%lld\",&n,&m,&k,&d); minn=INF;a[0]=0; for(int i=1; i<=n; ++i)scanf(\"%lld\",&a[i]),minn=min(minn,a[i]); for(int i=1; i<=n; ++i)b[i]=a[i]-a[i-1]; for(int i=1; i<=m; ++i)scanf(\"%lld%lld\",&f[i].l,&f[i].r),f[i].id=i; sort(f+1,f+m+1,cmp); int l=minn-1,r=minn+k*d+1,ans=0; memset(vis,0,sizeof vis); init(); while(l<r) { int mid=l+r>>1; if(check(mid)) { ans=mid; l=mid+1; } else r=mid; clear1(); } printf(\"%lld\\n\",ans); } return 0; } \u6811\u72b6\u6570\u7ec4\u533a\u95f4\u4fee\u6539&\u5355\u70b9\u67e5\u8be2 \u5bf9\u4e8e\u533a\u95f4\u4fee\u6539\u5e76\u4e14\u53ea\u6709\u5355\u70b9\u67e5\u8be2\u5f97\u9898\u76ee\uff0c\u53ef\u4ee5\u7528\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u5dee\u5206\u6570\u5217\u3002 ~~\u5dee\u5206\u771f\u7684\u5f3a~~ \u5bf9\u4e8e\u5df2\u6709\u7684\u5dee\u5206\u6570\u5217\uff0c\u5c06$1 \\to i$\u6240\u6709$c[i]$\u52a0\u8d77\u6765\uff0c\u5c31\u5f97\u5230\u539f\u6570\u5217\u5f97$a[i]$\uff0c\u800c\u5c06\u533a\u95f4$[l,r]$\u52a0\u4e0a$d$\u5c31\u76f8\u5f53\u4e8e\u4e24\u4e2a\u5355\u70b9\u4fee\u6539\uff1a if(l>0)add(l,d); if(r<n)add(r+1,-d); \u9006\u5e8f\u5bf9 \u8bb8\u591a\u95ee\u9898\uff0c\u50cf\u5c06\u4e0d\u540c\u5168\u6392\u5217\u4e2d\u76f8\u540c\u7684\u6570\u5b57\u4e24\u4e24\u914d\u5bf9\uff0c\u53ea\u80fd\u4ea4\u6362\u4e00\u4e2a\u6570\u5b57\u548c\u5b83\u76f8\u90bb\u7684\u6570\u5b57\u7684\u6700\u5c11\u6b65\u6570\u8fd9\u79cd\u95ee\u9898\uff0c\u5c31\u53ef\u4ee5\u8f6c\u5316\u6210\u9006\u5e8f\u5bf9\u6c42\u89e3\u3002 P1966 \u9996\u5148\u662f\u4e00\u4e2a\u8d2a\u5fc3\u6027\u8d28\u8bc1\u660e\uff1a \u5bf9\u4e8e$a[],b[]$\u6392\u5e8f\u540e\uff0c\u4e00\u5b9a\u662f\u4e00\u4e00\u5bf9\u5e94\uff0c\u5373$a[1]\\to b[1],a[2]\\to b[2],...,a[n]\\to b[n]$ \u8bc1\u660e\uff1a \u5047\u8bbe\u5df2\u7ecf\u5bf9\u5e94\u597d\u524d$n-2$\u7ec4\uff0c\u4fdd\u8bc1\u7b54\u6848\u6700\u5c0f\uff0c\u6b64\u65f6\u5269\u4f59$a$\u7ec4\u7684$a,b$,$b$\u7ec4\u7684$c,d$ x x x x a b x x x x c d \u90a3\u4e48\u6709\u4e24\u79cd\u65b9\u5f0f\uff1a$(a-c)^2+(b-d)^2$\u548c$(a-d)^2+(b-c)^2$. \u5047\u8bbe\u7b2c\u4e00\u79cd\u6700\u4f18\u3002 \u5219\uff1a $$ -2ac-2bd<-2ad-2bc\\ ac+bd>ad+bc\\ a(c-d)>b(c-d)\\ \u5f53c<d\u65f6\u6709:\\a< b $$ \u8bc1\u6bd5\u3002 \u90a3\u4e48\u5c31\u8f6c\u5316\u6210\u5c06$a[],b[]$\u4e00\u4e00\u5bf9\u5e94\u7684\u95ee\u9898\uff1b \u8bbe$q[a[i]]=b[i]$\uff0c\u90a3\u4e48\u7b54\u6848\u5e94\u6ee1\u8db3$q[a[i]]=a[i]$,\u5373$q[i]=i$ \u6240\u4ee5\u95ee\u9898\u8f6c\u5316\u6210\u6c42\u5c06$q$\u6570\u7ec4\u5347\u5e8f\u6392\u5217\u7684\u6700\u5c11\u4ea4\u6362\u6b65\u6570\uff0c\u5373\u9006\u5e8f\u5bf9\u6570\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<map> #include<algorithm> #define int long long #define lowbit(x) (x&-x) using namespace std; const int N=2e5+10,P=1e8-3; struct node{ int h,id; }a[N],b[N]; int p[N],c[N]; int n,m; bool cmp(node a,node b){ return a.h<b.h; } void add(int x,int d){ while(x<=n)c[x]+=d,x+=lowbit(x); } int sum(int x){ int ans=0; while(x>0){ ans+=c[x]; x-=lowbit(x); } return ans; } signed main(){ //freopen(\"P1966_2.in\",\"r\",stdin); scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i].h),a[i].id=i; for(int i=1;i<=n;++i)scanf(\"%lld\",&b[i].h),b[i].id=i; sort(a+1,a+n+1,cmp); sort(b+1,b+n+1,cmp); for(int i=1;i<=n;++i)p[a[i].id]=b[i].id; int ans=0; for(int i=n;i>=1;--i){ ans=(ans+sum(p[i]))%P; add(p[i],1); } printf(\"%lld\",(ans+P)%P); return 0; } P6186 \u5047\u8bbe\u6bcf\u4e2a\u6570\u524d\u9762\u6bd4\u4ed6\u5927\u7684\u6570\u7684\u4e2a\u6570\u4e3a$b[i]$ \u9700\u8981\u6ce8\u610f\u5230$k$\u8f6e\u5192\u6ce1\u6392\u5e8f\u7684\u7279\u6027\u662f\uff0c\u5bf9\u4e8e$b[i]>k$\u7684\u60c5\u51b5\uff0c\u5168\u90e8$-k$,\u5426\u5219\u5c31\u53d8\u4e3a$0$. \u56e0\u4e3a\u6bcf\u4e00\u8f6e\u4e2d\uff0c\u6bcf\u4e2a\u6570\u4e4b\u524d\u7684\u6700\u5927\u6570$x$\u4e00\u5b9a\u4f1a\u88ab\u79fb\u52a8\u5230\u6bd4$x$\u5927\u7684\u7b2c\u4e00\u4e2a\u6570$y$\u4e4b\u524d\uff0c\u5373\u8fd9\u4e2a\u6570\u4e4b\u540e\u3002 \u6240\u4ee5\u6240\u6709\u8f83\u5c0f\u6570\u7684$b[i]$\u90fd\u4f1a\u56e0\u4e3a\u6709\u4e00\u4e2a\u6700\u5927\u6570\u79fb\u52a8\u5230\u6240\u6709\u5c0f\u6570\u7684\u540e\u9762\u800c$-1$. \u800c\u6bcf\u6b21\u79fb\u52a8\u7684\u6700\u5927\u6570\u4e00\u5b9a\u6ee1\u8db3$b[i]=0$,\u79fb\u52a8\u540e\u4e5f\u4e0d\u4f1a\u6539\u53d8\uff0c\u6240\u4ee5\u5047\u8bbe\u6bcf\u8f6e\u7684\u6700\u5927\u6570\u6709$p$\u4e2a\uff0c\u6bcf\u8f6e\u5192\u6ce1\u6392\u5e8f\u7684\u8d21\u732e\u5c31\u662f$n-p$. \u6240\u4ee5\u6700\u7ec8\u7b54\u6848\u4e3a\uff1a $$\\sum_{b[i]>k}(b[i]-k) \\=(\\sum_{b[i]>k}b[i])-\\sum_{b[i]>k}k $$ \u6240\u4ee5\u7528\u4e00\u4e2a\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u6240\u6709$b[i]$\u4e3a$j$\u7684\u6570\u7684\u8d21\u732e,\u8be2\u95ee\u51fa$t_1=sum(n)-sum(k)$\uff1b \u4e00\u4e2a\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u6240\u6709$b[i]$\u4e3a$j$\u7684\u6570\u7684\u4e2a\u6570\uff0c\u8be2\u95ee\u51fa$t_2=sum(n)-sum(k)$\uff1b \u6700\u540e\u8be2\u95ee\u7684\u7b54\u6848\u4e3a$t_2-k* t_1$ #include<iostream> #include<cstdio> #include<cstring> #define lowbit(x) (x&-x) #define int long long using namespace std; const int N=3e5+10; int n,m,tmp,t,k; int a[N],b[N],c[N],d[N]; void add(int* C,int x,int d) { if(x==0)return; while(x<=n)C[x]+=d,x+=lowbit(x); } int sum(int* C,int x) { int ans=0; while(x>0)ans+=C[x],x-=lowbit(x); return ans; } signed main() { scanf(\"%lld%lld\",&n,&m); for(int i=1; i<=n; ++i)scanf(\"%lld\",&a[i]); for(int i=1;i<=n;++i) { b[i]=i-1-sum(c,a[i]); add(c,a[i],1); } memset(c,0,sizeof c); for(int i=1; i<=n; ++i)add(c,b[i],1),add(d,b[i],b[i]); for(int i=1; i<=m; ++i) { scanf(\"%lld%lld\",&t,&k); if(t==1) { add(c,b[k],-1),add(d,b[k],-b[k]);add(c,b[k+1],-1),add(d,b[k+1],-b[k+1]); if(a[k]<a[k+1])++b[k];else --b[k+1]; swap(b[k],b[k+1]),swap(a[k],a[k+1]); add(c,b[k],1),add(d,b[k],b[k]);add(c,b[k+1],1),add(d,b[k+1],b[k+1]); } else { if(k>=n) { printf(\"0\\n\"); continue; } int t1=sum(c,n)-sum(c,k),t2=sum(d,n)-sum(d,k); printf(\"%lld\\n\",t2-k*t1); } } return 0; } P1442 \u5f88\u597d\u7684\u7ebf\u6bb5\u6811+dp #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define mid ((l+r)>>1) #define ls i<<1 #define rs i<<1|1 using namespace std; const int N=2e5+10; struct plane { int l,r,h,kl,kr; } q[N]; int n,h,x,y,cnt,num,m; int a[N],tre[N<<2],tag[N<<2],nxtl[N],nxtr[N],f[N][2]; bool cmp(int a,int b) { return a<b; } bool Cmp(plane a,plane b) { return a.h<b.h; } void lsh() { sort(a+1,a+cnt+1,cmp); int tot=unique(a+1,a+cnt+1)-a-1; for(int i=1; i<=n+1; ++i) q[i].l=lower_bound(a+1,a+tot+1,q[i].l)-a,q[i].r=lower_bound(a+1,a+tot+1,q[i].r)-a; x=q[1].l; } void pushup(int i) { tre[i]=tre[ls]+tre[rs]; } void pushdown(int i,int l,int r) { int k=tag[i]; if(!k)return; tag[ls]=k; tag[rs]=k; tre[ls]=(mid-l+1)*k; tre[rs]=(r-mid)*k; tag[i]=0; } void change(int i,int l,int r,int el,int er,int k) { if(el<=l && r<=er) { tag[i]=k; tre[i]=(r-l+1)*k; return; } pushdown(i,l,r); if(el<=mid)change(ls,l,mid,el,er,k); if(er> mid)change(rs,mid+1,r,el,er,k); pushup(i); } int query(int i,int l,int r,int pos) { if(l==r) return tre[i]; pushdown(i,l,r); if(pos<=mid)return query(ls,l,mid,pos); else return query(rs,mid+1,r,pos); } int main() { scanf(\"%d%d%d%d\",&n,&h,&x,&y); cnt=0; q[1].l=q[1].r=q[1].kl=q[1].kr=x,q[1].h=y; a[++cnt]=x; for(int i=2; i<=n+1; ++i)scanf(\"%d%d%d\",&q[i].h,&q[i].l,&q[i].r),a[++cnt]=q[i].kl=q[i].l,a[++cnt]=q[i].kr=q[i].r; lsh(); sort(q+1,q+n+2,Cmp); num=1; while((q[num].l!=x || q[num].h!=y) && num<n+1) ++num; m=n+n+2; for(int i=1; i<=n+1; ++i) { int L=query(1,1,m,q[i].l),R=query(1,1,m,q[i].r); if(q[i].h-q[L].h>h)nxtl[i]=-1; else nxtl[i]=L; if(q[i].h-q[R].h>h)nxtr[i]=-1; else nxtr[i]=R; if(q[i].l+1<=q[i].r-1)change(1,1,m,q[i].l+1,q[i].r-1,i); } memset(f,0x3f,sizeof f); f[0][0]=f[0][1]=0; for(int i=1; i<=n+1; ++i) { if(nxtl[i]!=-1) { if(nxtl[i]==0) f[i][0]=q[i].h; else f[i][0]=min(f[nxtl[i]][0]+(q[i].kl-q[nxtl[i]].kl),f[nxtl[i]][1]+(q[nxtl[i]].kr-q[i].kl))+q[i].h-q[nxtl[i]].h; } if(nxtr[i]!=-1) { if(nxtr[i]==0) f[i][1]=q[i].h; else f[i][1]=min(f[nxtr[i]][0]+(q[i].kr-q[nxtr[i]].kl),f[nxtr[i]][1]+(q[nxtr[i]].kr-q[i].kr))+q[i].h-q[nxtr[i]].h; } } printf(\"%d\",f[num][0]); return 0; } P2221 \u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\uff0c\u4ee4$r=r-1$,\u7b54\u6848\u90fd\u662f: $$ans=\\sum_{i=l}^ra[i]* (r-i+1)(i-l+1)\\\u5c55\u5f00\u5f97\\ ans=-\\sum_{i=l}^ra[i]i^2+(r+l)\\sum_{i=l}^ra[i]i+(-rl+r-l+1)\\sum_{i=l}^ra[i]\\ =-s_3+(r+l)s_2+(-rl+r-l+1)s_1 $$ \u90a3\u4e48$s_1,s_2,s_3$\u90fd\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 \u5bf9\u4e8e\u4fee\u6539\uff0c$s_1$\u76f4\u63a5\u52a0\u4e0a\u533a\u95f4\u957f\u4e58$v$,$s_2,s_3$\u9700\u8981\u7528\u524d\u7f00\u548c\u6c42\u51fa$i$\u548c$i^2$\u7684\u548c\uff0c\u5728\u4e58\u4ee5$v$\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #define mid ((l+r)>>1) #define ls (i<<1) #define rs (i<<1|1) #define int long long using namespace std; const int N=2e5+10; int n,m,L,R,v,ans,res,a; int s4[N],s5[N]; struct tree{ int l,r,tag,s1,s2,s3; tree(){ l=r=tag=s1=s2=s3=0; } }tre[N<<2]; char ch[10]; int gcd(int a,int b){ if(a<b)swap(a,b); return !b?a:gcd(b,a%b); } tree operator +(const tree a,const tree b){ tree c=tree(); c.s1=a.s1+b.s1; c.s2=a.s2+b.s2; c.s3=a.s3+b.s3; c.l=a.l;c.r=b.r; c.tag=0; return c; } void init(){ for(int i=1;i<=n-1;++i)s4[i]=s4[i-1]+i,s5[i]=s5[i-1]+i*i; } void pushup(int i){ tre[i]=tre[ls]+tre[rs]; } void pushdown(int i){ int l=tre[i].l,r=tre[i].r,v=tre[i].tag; if(!v)return; tre[ls].tag+=v; tre[rs].tag+=v; tre[ls].s1+=(mid-(l-1))*v; tre[ls].s2+=(s4[mid]-s4[l-1])*v; tre[ls].s3+=(s5[mid]-s5[l-1])*v; tre[rs].s1+=(r-(mid))*v; tre[rs].s2+=(s4[r]-s4[mid])*v; tre[rs].s3+=(s5[r]-s5[mid])*v; tre[i].tag=0; } void build(int i,int l,int r){ tre[i].l=l;tre[i].r=r; if(l==r) return; build(ls,l,mid); build(rs,mid+1,r); pushup(i); } void change(int i,int el,int er,int v){ int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er){ tre[i].s1+=(r-(l-1))*v; tre[i].s2+=(s4[r]-s4[l-1])*v; tre[i].s3+=(s5[r]-s5[l-1])*v; tre[i].tag+=v; return; } pushdown(i); if(el<=mid)change(ls,el,er,v); if(er> mid)change(rs,el,er,v); pushup(i); } tree query(int i,int el,int er){ int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) return tre[i]; pushdown(i); if(er<=mid) return query(ls,el,er); else if(el>mid) return query(rs,el,er); else return query(ls,el,mid)+query(rs,mid+1,er); } signed main(){ scanf(\"%lld%lld\",&n,&m); init(); build(1,1,n-1); for(int i=1;i<=m;++i){ scanf(\"%s\",ch); if(ch[0]=='C'){ scanf(\"%lld%lld%lld\",&L,&R,&v);--R; if(L<=R) change(1,L,R,v); }else{ scanf(\"%lld%lld\",&L,&R); a=(R-L+1); if(L==R){ printf(\"0/1\\n\"); continue; } --R; tree tmp=query(1,L,R); ans=2*(-tmp.s3+(R+L)*tmp.s2+(-R*L+R-L+1)*tmp.s1),res=a*(a-1); int Gcd=gcd(ans,res); printf(\"%lld/%lld\\n\",ans/Gcd,res/Gcd); } } return 0; } P2572 \u8003\u8651\u5bf9\u4e8e\u4e00\u4e2a\u533a\u95f4\uff0c\u7ef4\u62a4\u8fd9\u4e9b\u91cf\uff1a $l,r$\uff0c\u8868\u793a\u7ebf\u6bb5\u6811\u8282\u70b9\u5bf9\u5e94\u7684\u5de6\u53f3\u7aef\u70b9 $sum$,\u8868\u793a\u533a\u95f4\u548c $L[0/1],R[0/1],S[0/1]$,\u8868\u793a$0/1$\u7684\u524d\u7f00\u6700\u5927\u5b50\u6bb5\uff0c\u540e\u7f00\u6700\u5927\u5b50\u6bb5\u548c\u6700\u5927\u5b50\u6bb5 $tag,frc$\uff0c\u8868\u793a\u533a\u95f4\u8986\u76d6\u548c\u53cd\u8f6c\u7684$lazytag$ ($frc$\u662f\u9996\u597d\u542c\u7684$bgm$\uff0c\u6765\u81ea\u300a\u58f0\u4e4b\u5f62\u300b,~~\u5899\u88c2\u63a8\u8350~~) \u90a3\u4e48$pushup$\u5c31\u662f\u6700\u5927\u5b50\u6bb5\u548c\u7684\u65b9\u5f0f\u3002 $pushdown$\u6ce8\u610f$tag$\u4f18\u5148\u7ea7\u5927\u4e8e$frc$,\u6240\u4ee5\u8986\u76d6\u662f\u5c06$frc$\u6e05\u96f6\u3002 #include<iostream> #include<cstdio> #include<cstring> #define ls (i<<1) #define rs (i<<1|1) #define mid (l+r>>1) using namespace std; const int N=1e5+10; struct tree { int L[2],S[2],R[2],sum,tag,l,r,frc; tree() { l=r=sum=frc=L[0]=L[1]=R[0]=R[1]=S[0]=S[1]=0,tag=-1; } } tre[N<<2]; int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x){ if(x>9) write1(x/10); putchar(x%10+'0'); } int n,m,op,l,r; int a[N]; tree operator +(tree a,tree b) { tree c=tree(); int la=a.l,ra=a.r,lb=b.l,rb=b.r,xa=ra-la+1,xb=rb-lb+1; for(int k=0; k<=1; ++k) c.L[k]=(a.L[k]==xa?xa+b.L[k]:a.L[k]),c.R[k]=(b.R[k]==xb?xb+a.R[k]:b.R[k]),c.S[k]=max(max(a.S[k],b.S[k]),a.R[k]+b.L[k]); c.sum=a.sum+b.sum; c.l=a.l,c.r=b.r; return c; } void pushup(int i) { tre[i]=tre[ls]+tre[rs]; } void pushdown(int i) { int l=tre[i].l,r=tre[i].r,k=tre[i].tag,v=tre[i].frc; if(k!=-1) { tre[ls].tag=tre[rs].tag=k; tre[ls].frc=tre[rs].frc=0; tre[ls].sum=(mid-l+1)*k; tre[ls].S[k]=tre[ls].L[k]=tre[ls].R[k]=(mid-l+1); tre[ls].S[k^1]=tre[ls].L[k^1]=tre[ls].R[k^1]=0; tre[rs].sum=(r-mid)*k; tre[rs].S[k]=tre[rs].L[k]=tre[rs].R[k]=(r-mid); tre[rs].S[k^1]=tre[rs].L[k^1]=tre[rs].R[k^1]=0; tre[i].tag=-1; } if(v!=0) { tre[ls].frc^=v,tre[rs].frc^=v; tre[ls].sum=(mid-l+1)-tre[ls].sum; swap(tre[ls].L[0],tre[ls].L[1]); swap(tre[ls].R[0],tre[ls].R[1]); swap(tre[ls].S[0],tre[ls].S[1]); tre[rs].sum=(r-mid)-tre[rs].sum; swap(tre[rs].L[0],tre[rs].L[1]); swap(tre[rs].R[0],tre[rs].R[1]); swap(tre[rs].S[0],tre[rs].S[1]); tre[i].frc=0; } } void build(int i,int l,int r) { tre[i].l=l,tre[i].r=r,tre[i].tag=-1,tre[i].frc=0; if(l==r) { tre[i].sum=a[l]; tre[i].L[a[l]]=tre[i].R[a[l]]=tre[i].S[a[l]]=1; return; } build(ls,l,mid); build(rs,mid+1,r); pushup(i); } void change(int i,int el,int er,int k) { int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) { tre[i].tag=k,tre[i].frc=0; tre[i].sum=(r-l+1)*k; tre[i].S[k]=tre[i].L[k]=tre[i].R[k]=(r-l+1); tre[i].S[k^1]=tre[i].L[k^1]=tre[i].R[k^1]=0; return; } pushdown(i); if(el<=mid) change(ls,el,er,k); if(er> mid) change(rs,el,er,k); pushup(i); } void reverse(int i,int el,int er) { int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) { tre[i].frc^=1; tre[i].sum=(r-l+1)-tre[i].sum; swap(tre[i].L[0],tre[i].L[1]); swap(tre[i].R[0],tre[i].R[1]); swap(tre[i].S[0],tre[i].S[1]); return; } pushdown(i); if(el<=mid) reverse(ls,el,er); if(er> mid) reverse(rs,el,er); pushup(i); } tree query(int i,int el,int er) { int l=tre[i].l,r=tre[i].r; if(el<=l && r<=er) return tre[i]; pushdown(i); if(er<=mid) return query(ls,el,er); else if(el> mid) return query(rs,el,er); else return query(ls,el,mid)+query(rs,mid+1,er); } int main() { //freopen(\"1.in\",\"r\",stdin); n=read1(),m=read1(); for(int i=1; i<=n; ++i) a[i]=read1(); build(1,1,n); for(int i=1; i<=m; ++i) { op=read1(),l=read1(),r=read1(),++l,++r; if(op==0) { change(1,l,r,0); } else if(op==1) { change(1,l,r,1); } else if(op==2) { reverse(1,l,r); } else if(op==3) { write1(query(1,l,r).sum),putchar('\\n'); } else { write1(query(1,l,r).S[1]),putchar('\\n'); } } return 0; }","title":"\u7ebf\u6bb5\u6811"},{"location":"my%20past/OI/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/","text":"\u7ebf\u6bb5\u6811\u5408\u5e76 update 2023.10.18 ~~\u7237\u590d\u6d3b\u4e86\uff0c\u56de\u6765\u5199\u603b\u7ed3\u4e86~~ \u6a21\u677fP4556 \u96e8\u5929\u7684\u5c3e\u5df4 \u8981\u6c42\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u8865\u7ed9\u3002 \u53ef\u4ee5\u60f3\u5230\uff0c\u7ed9\u6bcf\u4e2a\u8282\u70b9\u5f00\u4e00\u4e2a$[1,10^5]$\u7684\u6876\u6765\u50a8\u5b58\u6bcf\u79cd\u8865\u7ed9\u7684\u51fa\u73b0\u6b21\u6570\u3002 \u7136\u540e\u5c06\u6bcf\u6b21\u64cd\u4f5c\u8f6c\u5316\u4e3a\u5dee\u5206\uff1a1-u\uff0c1-v\u8def\u5f84+1\uff0c1-lca,1-fa[lca]\u8def\u5f84-1. \u6700\u540e\u4ece\u4e0b\u5230\u4e0adfs\uff0c\u5c06\u6570\u7ec4\u52a0\u8d77\u6765\uff0c\u5373$cnt[u][i]=\\sum_{v\\in son[u]} cnt[v][i]$\uff0c\u5c31\u53ef\u4ee5\u5f97\u5230\u7b54\u6848\u3002 \u4f46\u662f\uff0c$cnt$\u6570\u7ec4\u592a\u5927\uff0c\u6ca1\u6cd5\u5b58\u50a8\u3002 \u6545\u6211\u4eec\u6709\u4e86\u7ebf\u6bb5\u6811\u5408\u5e76\u3002 \u6bcf\u4e2a\u8282\u70b9\u52a8\u6001\u5f00\u70b9\uff0c\u7ef4\u62a4\u4e00\u4e2a$[1,10^5]$\u7684\u6743\u503c\u7ebf\u6bb5\u6811\u3002 \u53ef\u4ee5\u77e5\u9053\uff0c\u6bcf\u6b21\u64cd\u4f5c\u4f1a\u8ba94\u4e2a\u70b9\u5206\u522b\u589e\u52a0$O(logn)$\u4e2a\u70b9\u3002 \u7136\u540e\uff0c\u5bf9\u4e8e\u5408\u5e76\u64cd\u4f5c\uff0c\u6211\u4eec\u5206\u522b\u904d\u5386\u4e24\u4e2a\u7ebf\u6bb5\u6811\u3002 \u5982\u679c\u4e24\u4e2a\u7ebf\u6bb5\u6811\u90fd\u62e5\u6709\u5de6\u5b50\u8282\u70b9\uff0c\u5219\u7ee7\u7eed\u904d\u5386\u4e24\u4e2a\u5de6\u513f\u5b50\uff1b\u5426\u5219\uff0c\u5c31\u8ba9\u7b2c\u4e00\u4e2a\u7ebf\u6bb5\u6811\u7684\u5de6\u513f\u5b50\u6307\u5411\u8fd9\u4e2a\u513f\u5b50\uff1b\u5982\u679c\u5230\u8fbe\u53f6\u5b50\u8282\u70b9\uff0c\u5c31\u5c06\u4e24\u4e2a\u53f6\u5b50\u7684\u503c\u76f8\u52a0;\u53f3\u513f\u5b50\u540c\u7406\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u5b8c\u6210\u5408\u5e76\u4e86\u3002 \u53ef\u4ee5\u8bc1\u660e\uff0c\u6bcf\u6b21\u5408\u5e76\u65f6\u7ebf\u6bb5\u68112\u4e2d\u904d\u5386\u5230\u7684\u8282\u70b9\u88ab\u5408\u5e76\u5230\u4e86\u65b0\u7ebf\u6bb5\u6811(\u7ebf\u6bb5\u68111)\u4e2d\uff0c\u5219\u65b0\u7ebf\u6bb5\u6811\u4e2d\u8fd9\u4e9b\u5c5e\u4e8e2\u7684\u70b9\u4e0d\u4f1a\u518d\u88ab\u904d\u5386\u5230\uff1b\u800c\u6ca1\u904d\u5386\u5230\u7684\u70b9\u88ab\u63a5\u5728\u4e86\u7ebf\u6bb5\u68111\u4e0a\uff0c\u7ec4\u6210\u4e86\u4e00\u4e2a\u8239\u65b0\u7684\u3001\u6ca1\u6709\u904d\u5386\u8fc7\u7684\u7ebf\u6bb5\u6811\u3002\u6240\u4ee5\u6bcf\u4e2a\u70b9\u6700\u591a\u88ab\u904d\u5386\u4e00\u6b21\u3002 \u800c\u6bcf\u6b21\u5408\u5e76\u4e0d\u4f1a\u589e\u52a0\u65b0\u8282\u70b9\uff0c\u6240\u4ee5\u7a7a\u95f4\u4e0e\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u4e3a$O(nlogn)$\u3002 \u81f3\u4e8e\u6700\u5927\u503c\uff0c\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e2a\u7ebf\u6bb5\u6811\u8282\u70b9\u7ef4\u62a4\u4e00\u4e2a\u79cd\u7c7b$tre[i]$\u548c\u51fa\u73b0\u6b21\u6570$sum[i]$\u5373\u53ef\u3002 #include<iostream> #include<cstring> #define mid (l+r>>1) using namespace std; const int N=1e5+10,K=30,NN=1e5; struct edge{ int v,nxt; }e[N<<1]; int cnt,u,v,z,n,m,tot; int head[N],fa[N][K],dep[N],sum[N<<6],tre[N<<6],ls[N<<6],rs[N<<6],rt[N],ans[N]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void pushup(int x){ if(sum[ls[x]]>=sum[rs[x]]){ sum[x]=sum[ls[x]]; tre[x]=tre[ls[x]]; }else{ sum[x]=sum[rs[x]]; tre[x]=tre[rs[x]]; } } void change(int &x,int l,int r,int pos,int k){ if(!x) x=++tot; if(l==r){ sum[x]+=k; tre[x]=pos; return; } if(pos<=mid) change(ls[x],l,mid,pos,k); else change(rs[x],mid+1,r,pos,k); pushup(x); } int merge(int a,int b,int l,int r){ if(!a || !b) return a+b; if(l==r){ sum[a]+=sum[b]; return a; } ls[a]=merge(ls[a],ls[b],l,mid); rs[a]=merge(rs[a],rs[b],mid+1,r); pushup(a); return a; } void dfs(int u,int p){ fa[u][0]=p; for(int i=1;i<K;++i){ fa[u][i]=fa[fa[u][i-1]][i-1]; } for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; dep[v]=dep[u]+1; dfs(v,u); } } int getlca(int u,int v){ if(u==v) return u; if(dep[u]<dep[v]) swap(u,v); int k=dep[u]-dep[v]; for(int i=0;i<K;++i){ if(k&(1<<i)) u=fa[u][i]; } if(u==v) return u; for(int i=K-1;i>=0;--i){ if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; } return fa[u][0]; } void DFS(int u,int p){ for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; DFS(v,u); rt[u]=merge(rt[u],rt[v],1,NN); } if(sum[rt[u]]) ans[u]=tre[rt[u]]; } int main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<n;++i){ scanf(\"%d%d\",&u,&v); add(u,v); add(v,u); } dfs(1,0); for(int i=1;i<=m;++i){ scanf(\"%d%d%d\",&u,&v,&z); int lca=getlca(u,v); change(rt[u],1,NN,z,1); change(rt[v],1,NN,z,1); change(rt[lca],1,NN,z,-1); change(rt[fa[lca][0]],1,NN,z,-1); } DFS(1,0); for(int i=1;i<=n;++i) printf(\"%d\\n\",ans[i]); return 0; } /* 10 10 2 1 3 2 4 3 5 3 6 3 7 4 8 5 9 8 10 3 6 2 6 3 2 6 3 3 2 6 6 6 10 3 3 10 7 1 3 7 4 7 9 5 4 2 4 3 3 6 */ P5298 \u8bbe$f_{i,j}$\u4e3a\u7b2ci\u4e2a\u8282\u70b9\u51fa\u73b0j\u7684\u6982\u7387\uff0cl,r\u4e3a\u5de6\u53f3\u513f\u5b50\uff0cm\u4e3ai\u5b50\u6811\u4e2d\u53f6\u5b50\u8282\u70b9\u7684\u4e2a\u6570\u3002\u5219\uff1a $f_{i,j}=f_{l,j} \\times (p_i\\times\\sum_{k=1}^{j-1}f_{r,k}+(1-p_i)\\times \\sum_{k=j+1}^{m}f_{r,k})+f_{r,j} \\times (p_i\\times\\sum_{k=1}^{j-1}f_{l,k}+(1-p_i)\\times \\sum_{k=j+1}^{m}f_{l,k})$ \u8fd9\u4e2a$f$\u6570\u7ec4\u5c31\u662f\u8981\u7ef4\u62a4\u7684\u6876\u3002 \u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u6bcf\u4e2a\u8282\u70b9\u4e0a\uff0c\u5bf9\u4e8e\u6743\u503c\u7684\u603b\u4e2a\u6570\u5f00\u4e00\u4e2a\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u6bcf\u79cd\u6743\u503c\u7684\u51fa\u73b0\u6982\u7387\u3002 \u7531\u4e8e\u6982\u7387\u662f\u5206\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u7528$ax\\equiv b(\\mod p)$\u6765\u6c42\u51fa$x=\\frac{b}{a}$\u5728\u6a21\u610f\u4e49\u4e0b\u7684\u503c\u3002 \u8fd9\u4e2a\u5f0f\u5b50\u53ef\u4ee5\u7528\u6269\u5c55\u6b27\u51e0\u91cc\u5f97(exgcd)\u6c42\uff0c\u4e5f\u53ef\u4ee5\u6839\u636e\u5c0f\u8d39\u9a6c\u5b9a\u7406:$a^{p-1}\\equiv 1(\\mod p)$\u5f97\u51fa\u7b49\u4ef7\u5173\u7cfb$a^{p-2}\\equiv a^{-1}(\\mod p)$ \u8003\u8651\u5de6\u8fb9\uff0c\u90a3\u4e48\u5bf9\u4e8e\u62ec\u53f7\u91cc\u7684\u90a3\u4e00\u5768\uff0c\u53ef\u4ee5\u5728\u5408\u5e76\u8fc7\u7a0b\u4e2d\u7ef4\u62a4\u3002 \u5047\u8bbe$xmul$\u662f\u90a3\u4e00\u5768\u7684\u503c\uff0c\u90a3\u4e48\u6bcf\u4e00\u641c\u7d22\u5de6\u8282\u70b9,\u6211\u4eec\u5c31\u53ef\u4ee5\u66f4\u65b0$(1-p_i)\\times \\sum_{k=j+1}^{m}f_{r,k}$\u7684\u503c\uff0c\u56e0\u4e3a\u5373\u5c06\u641c\u7d22\u7684\u5de6\u8282\u70b9\u7684\u6743\u503c\u4e00\u5b9a\u5c0f\u4e8e\u5168\u90e8\u53f3\u8282\u70b9\u7684\u6743\u503c\u3002\u641c\u7d22\u53f3\u8282\u70b9\u540c\u7406\u3002 \u8fd9\u6837\uff0c\u6211\u4eec\u5728\u6700\u540e\u5bf9\u7ebf\u6bb5\u6811\u8fdb\u884c\u4e00\u4e2adfs,\u8bb0\u5f55\u6bcf\u4e2a\u53f6\u5b50\u8282\u70b9\u7684\u503c\uff0c\u5373\u53ef\u5f97\u5230\u6700\u7ec8\u7b54\u6848\u3002 #include<iostream> #include<algorithm> #include<cstring> #define mid (l+r>>1) using namespace std; const int N=3e5+10,P=998244353,PP=796898467; int tre[N<<5],multag[N<<5],ls[N<<5],rs[N<<5],rt[N],ch[N][2],val[N],b[N],cnt[N],ans[N]; int n,fa,tot,id; int build(){ int x=++id; ls[x]=rs[x]=tre[x]=0,multag[x]=1; return x; } void pushup(int x){ tre[x]=(tre[ls[x]]+tre[rs[x]])%P; } void cal(int x,int v){ tre[x]=(1ll*tre[x]*v)%P; multag[x]=(1ll*multag[x]*v)%P; } void pushdown(int x){ int k=multag[x]; if(ls[x]) cal(ls[x],k); if(rs[x]) cal(rs[x],k); multag[x]=1; } void change(int &x,int l,int r,int pos,int k){ if(!x) x=build(); if(l==r){ tre[x]+=k; return; } pushdown(x); if(pos<=mid) change(ls[x],l,mid,pos,k); else change(rs[x],mid+1,r,pos,k); pushup(x); } int merge(int x,int y,int l,int r,int xmul,int ymul,int p){ //if(!x && !y) return 0; if(!x){ cal(y,ymul); return y; } if(!y){ cal(x,xmul); return x; } pushdown(x),pushdown(y); int lsx=tre[ls[x]],lsy=tre[ls[y]],rsx=tre[rs[x]],rsy=tre[rs[y]]; ls[x]=merge(ls[x],ls[y],l,mid,(xmul+(1ll*rsy%P*(1-p+P)%P))%P,(ymul+(1ll*rsx%P*(1-p+P)%P))%P,p); rs[x]=merge(rs[x],rs[y],mid+1,r,(xmul+(1ll*lsy*p%P))%P,(ymul+(1ll*lsx*p%P))%P,p); pushup(x); return x; } void dfs(int u){ if(!cnt[u]) change(rt[u],1,tot,val[u],1); else if(cnt[u]==1) dfs(ch[u][0]),rt[u]=rt[ch[u][0]]; else if(cnt[u]==2) dfs(ch[u][0]),dfs(ch[u][1]),rt[u]=merge(rt[ch[u][0]],rt[ch[u][1]],1,tot,0,0,val[u]); } void work(int x,int l,int r){ if(l==r){ ans[l]=tre[x]; return; } pushdown(x); work(ls[x],l,mid); work(rs[x],mid+1,r); } int main(){ id=tot=0; scanf(\"%d\",&n); for(int i=1;i<=n;++i){ scanf(\"%d\",&fa); if(fa) ch[fa][cnt[fa]++]=i; } for(int i=1;i<=n;++i) scanf(\"%d\",&val[i]); for(int i=1;i<=n;++i){ if(cnt[i]){ val[i]=(1ll*val[i]*PP)%P; }else{ b[++tot]=val[i]; } } sort(b+1,b+tot+1); for(int i=1;i<=n;++i) if(!cnt[i]) val[i]=lower_bound(b+1,b+tot+1,val[i])-b; dfs(1); work(rt[1],1,tot); int res=0; for(int i=1;i<=tot;++i) res=(res+1ll*ans[i]%P*ans[i]%P*i%P*b[i]%P)%P; printf(\"%d\\n\",res); return 0; }","title":"\u7ebf\u6bb5\u6811\u5408\u5e76"},{"location":"my%20past/OI/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/#_1","text":"update 2023.10.18 ~~\u7237\u590d\u6d3b\u4e86\uff0c\u56de\u6765\u5199\u603b\u7ed3\u4e86~~","title":"\u7ebf\u6bb5\u6811\u5408\u5e76"},{"location":"my%20past/OI/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6/#p4556","text":"\u8981\u6c42\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u8865\u7ed9\u3002 \u53ef\u4ee5\u60f3\u5230\uff0c\u7ed9\u6bcf\u4e2a\u8282\u70b9\u5f00\u4e00\u4e2a$[1,10^5]$\u7684\u6876\u6765\u50a8\u5b58\u6bcf\u79cd\u8865\u7ed9\u7684\u51fa\u73b0\u6b21\u6570\u3002 \u7136\u540e\u5c06\u6bcf\u6b21\u64cd\u4f5c\u8f6c\u5316\u4e3a\u5dee\u5206\uff1a1-u\uff0c1-v\u8def\u5f84+1\uff0c1-lca,1-fa[lca]\u8def\u5f84-1. \u6700\u540e\u4ece\u4e0b\u5230\u4e0adfs\uff0c\u5c06\u6570\u7ec4\u52a0\u8d77\u6765\uff0c\u5373$cnt[u][i]=\\sum_{v\\in son[u]} cnt[v][i]$\uff0c\u5c31\u53ef\u4ee5\u5f97\u5230\u7b54\u6848\u3002 \u4f46\u662f\uff0c$cnt$\u6570\u7ec4\u592a\u5927\uff0c\u6ca1\u6cd5\u5b58\u50a8\u3002 \u6545\u6211\u4eec\u6709\u4e86\u7ebf\u6bb5\u6811\u5408\u5e76\u3002 \u6bcf\u4e2a\u8282\u70b9\u52a8\u6001\u5f00\u70b9\uff0c\u7ef4\u62a4\u4e00\u4e2a$[1,10^5]$\u7684\u6743\u503c\u7ebf\u6bb5\u6811\u3002 \u53ef\u4ee5\u77e5\u9053\uff0c\u6bcf\u6b21\u64cd\u4f5c\u4f1a\u8ba94\u4e2a\u70b9\u5206\u522b\u589e\u52a0$O(logn)$\u4e2a\u70b9\u3002 \u7136\u540e\uff0c\u5bf9\u4e8e\u5408\u5e76\u64cd\u4f5c\uff0c\u6211\u4eec\u5206\u522b\u904d\u5386\u4e24\u4e2a\u7ebf\u6bb5\u6811\u3002 \u5982\u679c\u4e24\u4e2a\u7ebf\u6bb5\u6811\u90fd\u62e5\u6709\u5de6\u5b50\u8282\u70b9\uff0c\u5219\u7ee7\u7eed\u904d\u5386\u4e24\u4e2a\u5de6\u513f\u5b50\uff1b\u5426\u5219\uff0c\u5c31\u8ba9\u7b2c\u4e00\u4e2a\u7ebf\u6bb5\u6811\u7684\u5de6\u513f\u5b50\u6307\u5411\u8fd9\u4e2a\u513f\u5b50\uff1b\u5982\u679c\u5230\u8fbe\u53f6\u5b50\u8282\u70b9\uff0c\u5c31\u5c06\u4e24\u4e2a\u53f6\u5b50\u7684\u503c\u76f8\u52a0;\u53f3\u513f\u5b50\u540c\u7406\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u5b8c\u6210\u5408\u5e76\u4e86\u3002 \u53ef\u4ee5\u8bc1\u660e\uff0c\u6bcf\u6b21\u5408\u5e76\u65f6\u7ebf\u6bb5\u68112\u4e2d\u904d\u5386\u5230\u7684\u8282\u70b9\u88ab\u5408\u5e76\u5230\u4e86\u65b0\u7ebf\u6bb5\u6811(\u7ebf\u6bb5\u68111)\u4e2d\uff0c\u5219\u65b0\u7ebf\u6bb5\u6811\u4e2d\u8fd9\u4e9b\u5c5e\u4e8e2\u7684\u70b9\u4e0d\u4f1a\u518d\u88ab\u904d\u5386\u5230\uff1b\u800c\u6ca1\u904d\u5386\u5230\u7684\u70b9\u88ab\u63a5\u5728\u4e86\u7ebf\u6bb5\u68111\u4e0a\uff0c\u7ec4\u6210\u4e86\u4e00\u4e2a\u8239\u65b0\u7684\u3001\u6ca1\u6709\u904d\u5386\u8fc7\u7684\u7ebf\u6bb5\u6811\u3002\u6240\u4ee5\u6bcf\u4e2a\u70b9\u6700\u591a\u88ab\u904d\u5386\u4e00\u6b21\u3002 \u800c\u6bcf\u6b21\u5408\u5e76\u4e0d\u4f1a\u589e\u52a0\u65b0\u8282\u70b9\uff0c\u6240\u4ee5\u7a7a\u95f4\u4e0e\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u4e3a$O(nlogn)$\u3002 \u81f3\u4e8e\u6700\u5927\u503c\uff0c\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e2a\u7ebf\u6bb5\u6811\u8282\u70b9\u7ef4\u62a4\u4e00\u4e2a\u79cd\u7c7b$tre[i]$\u548c\u51fa\u73b0\u6b21\u6570$sum[i]$\u5373\u53ef\u3002 #include<iostream> #include<cstring> #define mid (l+r>>1) using namespace std; const int N=1e5+10,K=30,NN=1e5; struct edge{ int v,nxt; }e[N<<1]; int cnt,u,v,z,n,m,tot; int head[N],fa[N][K],dep[N],sum[N<<6],tre[N<<6],ls[N<<6],rs[N<<6],rt[N],ans[N]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void pushup(int x){ if(sum[ls[x]]>=sum[rs[x]]){ sum[x]=sum[ls[x]]; tre[x]=tre[ls[x]]; }else{ sum[x]=sum[rs[x]]; tre[x]=tre[rs[x]]; } } void change(int &x,int l,int r,int pos,int k){ if(!x) x=++tot; if(l==r){ sum[x]+=k; tre[x]=pos; return; } if(pos<=mid) change(ls[x],l,mid,pos,k); else change(rs[x],mid+1,r,pos,k); pushup(x); } int merge(int a,int b,int l,int r){ if(!a || !b) return a+b; if(l==r){ sum[a]+=sum[b]; return a; } ls[a]=merge(ls[a],ls[b],l,mid); rs[a]=merge(rs[a],rs[b],mid+1,r); pushup(a); return a; } void dfs(int u,int p){ fa[u][0]=p; for(int i=1;i<K;++i){ fa[u][i]=fa[fa[u][i-1]][i-1]; } for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; dep[v]=dep[u]+1; dfs(v,u); } } int getlca(int u,int v){ if(u==v) return u; if(dep[u]<dep[v]) swap(u,v); int k=dep[u]-dep[v]; for(int i=0;i<K;++i){ if(k&(1<<i)) u=fa[u][i]; } if(u==v) return u; for(int i=K-1;i>=0;--i){ if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; } return fa[u][0]; } void DFS(int u,int p){ for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(v==p) continue; DFS(v,u); rt[u]=merge(rt[u],rt[v],1,NN); } if(sum[rt[u]]) ans[u]=tre[rt[u]]; } int main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<n;++i){ scanf(\"%d%d\",&u,&v); add(u,v); add(v,u); } dfs(1,0); for(int i=1;i<=m;++i){ scanf(\"%d%d%d\",&u,&v,&z); int lca=getlca(u,v); change(rt[u],1,NN,z,1); change(rt[v],1,NN,z,1); change(rt[lca],1,NN,z,-1); change(rt[fa[lca][0]],1,NN,z,-1); } DFS(1,0); for(int i=1;i<=n;++i) printf(\"%d\\n\",ans[i]); return 0; } /* 10 10 2 1 3 2 4 3 5 3 6 3 7 4 8 5 9 8 10 3 6 2 6 3 2 6 3 3 2 6 6 6 10 3 3 10 7 1 3 7 4 7 9 5 4 2 4 3 3 6 */ P5298 \u8bbe$f_{i,j}$\u4e3a\u7b2ci\u4e2a\u8282\u70b9\u51fa\u73b0j\u7684\u6982\u7387\uff0cl,r\u4e3a\u5de6\u53f3\u513f\u5b50\uff0cm\u4e3ai\u5b50\u6811\u4e2d\u53f6\u5b50\u8282\u70b9\u7684\u4e2a\u6570\u3002\u5219\uff1a $f_{i,j}=f_{l,j} \\times (p_i\\times\\sum_{k=1}^{j-1}f_{r,k}+(1-p_i)\\times \\sum_{k=j+1}^{m}f_{r,k})+f_{r,j} \\times (p_i\\times\\sum_{k=1}^{j-1}f_{l,k}+(1-p_i)\\times \\sum_{k=j+1}^{m}f_{l,k})$ \u8fd9\u4e2a$f$\u6570\u7ec4\u5c31\u662f\u8981\u7ef4\u62a4\u7684\u6876\u3002 \u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u6bcf\u4e2a\u8282\u70b9\u4e0a\uff0c\u5bf9\u4e8e\u6743\u503c\u7684\u603b\u4e2a\u6570\u5f00\u4e00\u4e2a\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u6bcf\u79cd\u6743\u503c\u7684\u51fa\u73b0\u6982\u7387\u3002 \u7531\u4e8e\u6982\u7387\u662f\u5206\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u7528$ax\\equiv b(\\mod p)$\u6765\u6c42\u51fa$x=\\frac{b}{a}$\u5728\u6a21\u610f\u4e49\u4e0b\u7684\u503c\u3002 \u8fd9\u4e2a\u5f0f\u5b50\u53ef\u4ee5\u7528\u6269\u5c55\u6b27\u51e0\u91cc\u5f97(exgcd)\u6c42\uff0c\u4e5f\u53ef\u4ee5\u6839\u636e\u5c0f\u8d39\u9a6c\u5b9a\u7406:$a^{p-1}\\equiv 1(\\mod p)$\u5f97\u51fa\u7b49\u4ef7\u5173\u7cfb$a^{p-2}\\equiv a^{-1}(\\mod p)$ \u8003\u8651\u5de6\u8fb9\uff0c\u90a3\u4e48\u5bf9\u4e8e\u62ec\u53f7\u91cc\u7684\u90a3\u4e00\u5768\uff0c\u53ef\u4ee5\u5728\u5408\u5e76\u8fc7\u7a0b\u4e2d\u7ef4\u62a4\u3002 \u5047\u8bbe$xmul$\u662f\u90a3\u4e00\u5768\u7684\u503c\uff0c\u90a3\u4e48\u6bcf\u4e00\u641c\u7d22\u5de6\u8282\u70b9,\u6211\u4eec\u5c31\u53ef\u4ee5\u66f4\u65b0$(1-p_i)\\times \\sum_{k=j+1}^{m}f_{r,k}$\u7684\u503c\uff0c\u56e0\u4e3a\u5373\u5c06\u641c\u7d22\u7684\u5de6\u8282\u70b9\u7684\u6743\u503c\u4e00\u5b9a\u5c0f\u4e8e\u5168\u90e8\u53f3\u8282\u70b9\u7684\u6743\u503c\u3002\u641c\u7d22\u53f3\u8282\u70b9\u540c\u7406\u3002 \u8fd9\u6837\uff0c\u6211\u4eec\u5728\u6700\u540e\u5bf9\u7ebf\u6bb5\u6811\u8fdb\u884c\u4e00\u4e2adfs,\u8bb0\u5f55\u6bcf\u4e2a\u53f6\u5b50\u8282\u70b9\u7684\u503c\uff0c\u5373\u53ef\u5f97\u5230\u6700\u7ec8\u7b54\u6848\u3002 #include<iostream> #include<algorithm> #include<cstring> #define mid (l+r>>1) using namespace std; const int N=3e5+10,P=998244353,PP=796898467; int tre[N<<5],multag[N<<5],ls[N<<5],rs[N<<5],rt[N],ch[N][2],val[N],b[N],cnt[N],ans[N]; int n,fa,tot,id; int build(){ int x=++id; ls[x]=rs[x]=tre[x]=0,multag[x]=1; return x; } void pushup(int x){ tre[x]=(tre[ls[x]]+tre[rs[x]])%P; } void cal(int x,int v){ tre[x]=(1ll*tre[x]*v)%P; multag[x]=(1ll*multag[x]*v)%P; } void pushdown(int x){ int k=multag[x]; if(ls[x]) cal(ls[x],k); if(rs[x]) cal(rs[x],k); multag[x]=1; } void change(int &x,int l,int r,int pos,int k){ if(!x) x=build(); if(l==r){ tre[x]+=k; return; } pushdown(x); if(pos<=mid) change(ls[x],l,mid,pos,k); else change(rs[x],mid+1,r,pos,k); pushup(x); } int merge(int x,int y,int l,int r,int xmul,int ymul,int p){ //if(!x && !y) return 0; if(!x){ cal(y,ymul); return y; } if(!y){ cal(x,xmul); return x; } pushdown(x),pushdown(y); int lsx=tre[ls[x]],lsy=tre[ls[y]],rsx=tre[rs[x]],rsy=tre[rs[y]]; ls[x]=merge(ls[x],ls[y],l,mid,(xmul+(1ll*rsy%P*(1-p+P)%P))%P,(ymul+(1ll*rsx%P*(1-p+P)%P))%P,p); rs[x]=merge(rs[x],rs[y],mid+1,r,(xmul+(1ll*lsy*p%P))%P,(ymul+(1ll*lsx*p%P))%P,p); pushup(x); return x; } void dfs(int u){ if(!cnt[u]) change(rt[u],1,tot,val[u],1); else if(cnt[u]==1) dfs(ch[u][0]),rt[u]=rt[ch[u][0]]; else if(cnt[u]==2) dfs(ch[u][0]),dfs(ch[u][1]),rt[u]=merge(rt[ch[u][0]],rt[ch[u][1]],1,tot,0,0,val[u]); } void work(int x,int l,int r){ if(l==r){ ans[l]=tre[x]; return; } pushdown(x); work(ls[x],l,mid); work(rs[x],mid+1,r); } int main(){ id=tot=0; scanf(\"%d\",&n); for(int i=1;i<=n;++i){ scanf(\"%d\",&fa); if(fa) ch[fa][cnt[fa]++]=i; } for(int i=1;i<=n;++i) scanf(\"%d\",&val[i]); for(int i=1;i<=n;++i){ if(cnt[i]){ val[i]=(1ll*val[i]*PP)%P; }else{ b[++tot]=val[i]; } } sort(b+1,b+tot+1); for(int i=1;i<=n;++i) if(!cnt[i]) val[i]=lower_bound(b+1,b+tot+1,val[i])-b; dfs(1); work(rt[1],1,tot); int res=0; for(int i=1;i<=tot;++i) res=(res+1ll*ans[i]%P*ans[i]%P*i%P*b[i]%P)%P; printf(\"%d\\n\",res); return 0; }","title":"\u6a21\u677fP4556 \u96e8\u5929\u7684\u5c3e\u5df4"},{"location":"my%20past/OI/%E7%BB%93%E6%9E%84%E4%BD%93/","text":"\u7ed3\u6784\u4f53 1.1 \u6784\u9020\u51fd\u6570 struct node{ int data; string str; char x; //\u81ea\u5df1\u5199\u7684\u521d\u59cb\u5316\u51fd\u6570 void init(int a, string b, char c){ this->data = a; this->str = b; this->x = c; } node() :x(), str(), data(){} node(int a, string b, char c) :x(c), str(b), data(a){} }; 1.2 \u91cd\u7f6e\u8fd0\u7b97\u7b26 //1.this\u5199\u6cd5 struct point { int elem; bool operator==(const point b) const { return this->elem == b.elem; } bool operator!=(const point b) const { return this->elem != b.elem; } bool operator<=(const point b) const { return this->elem <= b.elem; } bool operator<(const point b) const { return this->elem < b.elem; } bool operator>=(const point b) const { return this->elem >= b.elem; } bool operator>(const point b) const { return this->elem > b.elem; } }; //2.&\u5199\u6cd5 struct node{ int dis,pos; bool operator <(const node &x)const{ return x.dis<dis; } }; \u5e94\u7528\uff1adijkstra\u5806\u4f18\u5316 struct node{ int dis,pos; bool operator <(const node &x)const{ return x.dis<dis; } bool node(int d,int x){ dis=d;pos=x; } };","title":"\u7ed3\u6784\u4f53"},{"location":"my%20past/OI/%E7%BB%93%E6%9E%84%E4%BD%93/#_1","text":"","title":"\u7ed3\u6784\u4f53"},{"location":"my%20past/OI/%E7%BB%93%E6%9E%84%E4%BD%93/#11","text":"struct node{ int data; string str; char x; //\u81ea\u5df1\u5199\u7684\u521d\u59cb\u5316\u51fd\u6570 void init(int a, string b, char c){ this->data = a; this->str = b; this->x = c; } node() :x(), str(), data(){} node(int a, string b, char c) :x(c), str(b), data(a){} };","title":"1.1 \u6784\u9020\u51fd\u6570"},{"location":"my%20past/OI/%E7%BB%93%E6%9E%84%E4%BD%93/#12","text":"//1.this\u5199\u6cd5 struct point { int elem; bool operator==(const point b) const { return this->elem == b.elem; } bool operator!=(const point b) const { return this->elem != b.elem; } bool operator<=(const point b) const { return this->elem <= b.elem; } bool operator<(const point b) const { return this->elem < b.elem; } bool operator>=(const point b) const { return this->elem >= b.elem; } bool operator>(const point b) const { return this->elem > b.elem; } }; //2.&\u5199\u6cd5 struct node{ int dis,pos; bool operator <(const node &x)const{ return x.dis<dis; } }; \u5e94\u7528\uff1adijkstra\u5806\u4f18\u5316 struct node{ int dis,pos; bool operator <(const node &x)const{ return x.dis<dis; } bool node(int d,int x){ dis=d;pos=x; } };","title":"1.2 \u91cd\u7f6e\u8fd0\u7b97\u7b26"},{"location":"my%20past/OI/%E7%BC%A9%E7%82%B9/","text":"\u7f29\u70b9 \u4e3b\u8981\u4f5c\u7528\uff1a\u5c06\u6709\u5411\u6709\u73af\u56fe\u53d8\u6210\u6709\u5411\u65e0\u73af\u56fe\uff08DAG\uff09 \u6574\u4f53\u601d\u8def\u5c31\u662fdfs\uff0c\u518d\u641c\u7d22\u6811\u4e2d\u5224\u65ad\u73af\u3002 \u6709\u4e24\u79cd\u6307\u5411\u5df2\u7ecf\u641c\u7d22\u8fc7\u7684\u70b9\u7684\u8fb9\uff0c\u4e00\u79cd\u662f\u8fd4\u7956\u8fb9\uff0c\u5373\u6307\u5411\u81ea\u5df1\u7684\u7956\u5148\u8282\u70b9\uff1b \u4e00\u79cd\u662f\u6a2a\u53c9\u8fb9\uff0c\u5373\u6307\u5411\u81ea\u5df1\u7684\u975e\u7956\u5148\u8282\u70b9\u3002\u53ef\u4ee5\u8bc1\u660e\u53ea\u6709\u8fd4\u7956\u8fb9\u4f1a\u4ea7\u751f\u73af\u3002 \u6240\u4ee5\u7528\u6808\u7ef4\u62a4\u5f53\u524d\u7684\u641c\u7d22\u94fe\uff0c\u5f00\u4e24\u4e2a\u6570\u7ec4dfn\u548clow\u7ef4\u62a4\u3002\u53ea\u8981\u627e\u5230\u8fd4\u7956\u4fbf\u5c31\u9000\u6808\u5230\u7956\u5148\uff0c\u5e76\u5c06\u6240\u6709\u70b9\u4f5c\u4e3a\u4e00\u4e2a\u5f3a\u8fde\u901a\u5206\u91cf\u3002\u5426\u5219\u5c31\u65e0\u89c6\uff0c\u5728\u56de\u6eaf\u662f\u5c06\u5355\u4e2a\u70b9\u4f5c\u4e3a\u5f3a\u8fde\u901a\u5206\u91cf\u3002 \u6a21\u677f void tarjan(int u){ dfn[u]=low[u]=++tot;//low[u]\u503c\u9ed8\u8ba4\u4e3adfn[u],\u540e\u9762\u518d\u66f4\u65b0 stk[++top]=u;//\u8fdb\u6808\u6253\u6807\u8bb0 vis[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(!dfn[v]){ tarjan(v); low[u]=min(low[u],low[v]);//\u8fd9\u4e00\u6b65\u662f\u4e3a\u4e86\u66f4\u65b0\u90a3\u4e9b\u518d\u73af\u4e2d\u7684\u70b9\uff0c\u5982\u4e0a\u56fe\u76846\uff0c7 }else{ if(vis[v])low[u]=min(low[u],dfn[v]);//\u8fd4\u7956\u8fb9\uff0c\u627e\u5230\u4e86\u73af\uff0c\u90a3\u5c31\u5c06low[u]\u66f4\u65b0\u4e3a\u5f53\u524d\u6839\u8282\u70b9\u3002 //\u6a2a\u53c9\u8fb9\u59825->4\u76f4\u63a5\u5ffd\u7565 } } //\u6ce8\u610f\u53ea\u6709\u81ea\u5df1\u662f\u6839\u624d\u9000\u6808\uff0c\u5426\u5219\u8981\u4fdd\u7559\u6808\u4e2d\u4fe1\u606f\u3002 if(dfn[u]==low[u]){//\u5982\u679c\u81ea\u5df1\u53ea\u80fd\u56de\u6eaf\u5230\u81ea\u5df1\uff0c\u8bf4\u660e\u81ea\u5df1\u662f\u5f3a\u8fde\u901a\u5206\u91cf\u4e2d\u7684\u6839\u8282\u70b9\uff0c\u5c31\u9000\u6808\u5230\u81ea\u5df1\uff0c\u5c06\u6240\u6709\u70b9\u6240\u79f0\u4e00\u4e2a\u70b9\u3002 ++nod; while(1){ ans[stk[top]]=nod; vis[stk[top]]=0;//\u53bb\u9664\u6807\u8bb0 if(stk[top--]==u)break; } } } int main(){ memset(dfn,0,sizeof dfn); memset(low,0,sizeof low); memset(vis,0,sizeof vis); for(int i=1;i<=n;++i){ if(!dfn[i])tarjan(i); } } P3387 & P3627 \u4e24\u9053\u9898\u5dee\u4e0d\u591a\uff0c\u4e00\u4e2a\u662f\u5148\u7f29\u70b9\uff0c\u518d\u6839\u636e\u62d3\u6251\u6392\u5e8f\u7684\u987a\u5e8f\u53d6dp\uff0c\u8fd9\u6837\u4fdd\u8bc1\u65e0\u540e\u6548\u6027\uff0c\u6700\u540e\u8f93\u51fa\u6240\u6709\u70b9\u4e2d\u8d21\u732e\u6700\u5927\u7684\u503c\uff1b \u4e00\u4e2a\u662f\u7f29\u5b8c\u70b9\u540e\uff0c\u4ece\u65b0\u7684\u8d77\u70b9\u53d6\u7528SPFA\u6c42\u6700\u957f\u8def\uff0c\u6700\u540e\u518d\u9152\u5427\u4e2d\u62db\u6700\u957f\u7684\u5c31\u884c\u3002 ~~\u592a\u7b80\u5355\u4e0d\u653e\u4ee3\u7801\u4e86~~ P1262 \u5c06\u6240\u6709\u7684\u73af\u7f29\u6210\u4e00\u4e2a\u70b9\uff0c\u5e76\u4e14\u5f97\u5230\u65b0\u7684\u70b9\u7684\u4ee3\u4ef7\u5c31\u662f\u73af\u5185\u6240\u6709\u70b9\u7684\u6700\u5c0f\u4ef7\u94b1\u3002 \u90a3\u4e48\u5fc5\u987b\u8d3f\u8d42\u7684\u5c31\u662f\u5165\u5ea6\u4e3a\u96f6\u7684\u70b9\uff0c\u5982\u679c\u65e0\u6cd5\u8d3f\u8d42\u5c31\u65e0\u89e3\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=3010,M=8010,P=20000; int n,m,p,cnt,top,tot,nod; int a[N],w[N],head[N],dfn[N],low[N],vis[N],stk[N],ans[N],ind[N]; struct query{ int u,v; }q[M]; struct edge{ int v,nxt; }e[M<<1]; void add(int u,int v){ e[++cnt].v=v; e[cnt].nxt=head[u]; head[u]=cnt; } void tarjan(int u){ dfn[u]=low[u]=++tot; stk[++top]=u; vis[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(!dfn[v]){ tarjan(v); low[u]=min(low[u],low[v]); }else{ if(vis[v])low[u]=min(low[u],dfn[v]); } } if(dfn[u]==low[u]){ ++nod; while(1){ ans[stk[top]]=nod; vis[stk[top]]=0; if(stk[top--]==u)break; } } } int main(){ memset(head,-1,sizeof head); cnt=-1; memset(w,0x3f,sizeof w); memset(a,0x3f,sizeof a); scanf(\"%d%d\",&n,&p); for(int i=1,tmp,pos;i<=p;++i)scanf(\"%d%d\",&pos,&tmp),a[pos]=tmp; scanf(\"%d\",&m); for(int i=1;i<=m;++i){ scanf(\"%d%d\",&q[i].u,&q[i].v); add(q[i].u,q[i].v); } memset(vis,0,sizeof vis); for(int i=1;i<=n;++i)if(!dfn[i])tarjan(i); for(int i=1;i<=n;++i){ w[ans[i]]=min(w[ans[i]],a[i]); } for(int i=1;i<=m;++i){ int uu=ans[q[i].u],vv=ans[q[i].v]; if(uu==vv)continue; ind[vv]++; } memset(vis,0,sizeof vis); int res=0; bool flag=true; for(int i=1;i<=nod;++i){ if(!ind[i]){ if(w[i]<=P){ res+=w[i]; }else{ vis[i]=1; flag=false; } } } if(flag){ printf(\"YES\\n%d\",res); }else{ int minn=N+N; for(int i=1;i<=n;++i){ if(vis[ans[i]])minn=min(minn,i); } printf(\"NO\\n%d\",minn); } return 0; } /* 7 6 5 100 1 99 2 98 3 101 4 102 7 200 7 5 1 1 2 2 6 1 4 4 5 2 3 3 1 */ tarjan\u6c42\u5272\u70b9 \u540c\u6837\u662f\u5229\u7528$low$\u548c$dfn$\u6570\u7ec4\u3002 \u5bf9\u4e8etarjan\u7684\u4e00\u6b21\u641c\u7d22\uff0c\u7531\u4e8e\u4e0d\u4f1a\u5230$dfn$\u6570\u7ec4\u4e0d\u4e3a0\u7684\u70b9\u7ee7\u7eed\u641c\u7d22\uff0c\u56e0\u6b64\uff0c\u6574\u4e2a\u8fc7\u7a0b\u5f62\u6210\u4e00\u9897\u641c\u7d22\u6811\u3002\u5bf9\u8fd9\u4e2a\u641c\u7d22\u6811\u4e2d\uff0c\u53ef\u80fd\u4e3a\u5272\u70b9\u67092\u79cd\u60c5\u51b5: \u6839\u8282\u70b9\uff0c\u4e14\u513f\u5b50\u5927\u4e8e\u7b49\u4e8e2 $dfn[u]\\leq low[v]$\u7684\u70b9\u3002 \u56e0\u4e3a$v$\u53ef\u80fd\u56de\u6eaf\u5230\u7684\u6700\u9760\u524d\u7684\u70b9\u90fd\u5927\u4e8e$u$\uff0c\u8bf4\u660e$v$\u4e0d\u80fd\u901a\u8fc7\u9664\u4e86$u$\u4ee5\u5916\u7684\u70b9\u4e0e\u5269\u4f59\u6bd4$dfn[u]$\u5c0f\u7684\u70b9\u8054\u901a\uff0c\u6240\u4ee5$u$\u662f\u5272\u70b9\u3002 #include<iostream> #include<cstring> using namespace std; const int N=2e4+10,M=1e5+10; struct edge{ int v,nxt; }e[M<<1]; int n,m,u,v,tot,cnt; int dfn[N],low[N],cut[N],head[N]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void tarjan(int u,int p){ dfn[u]=low[u]=++tot; int son=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(!dfn[v]){ tarjan(v,p); low[u]=min(low[u],low[v]); if(low[v]>=dfn[u] && u!=p) cut[u]=1; if(u==p) ++son; }else low[u]=min(low[u],dfn[v]); } if(son>=2 && u==p) cut[u]=1; } int main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<=m;++i){ scanf(\"%d%d\",&u,&v); add(u,v),add(v,u); } for(int i=1;i<=n;++i){ if(!dfn[i]) tarjan(i,i); } int ans=0; for(int i=1;i<=n;++i){ if(cut[i]) ++ans; } printf(\"%d\\n\",ans); for(int i=1;i<=n;++i){ if(cut[i]) printf(\"%d \",i); } return 0; } P3469 \u7531\u4e8e\u641c\u7d22\u65f6\u4e00\u68f5\u6811\uff0c\u6240\u4ee5\u53ef\u4ee5\u7ef4\u62a4$sz$\u6570\u7ec4\u3002\u7b54\u6848\u5373\u4e3a$\\sum sz[v]*(n-sz[v])$\uff0c$sz[v]$\u53ef\u4ee5\u5728\u641c\u7d22\u4e2d\u5f97\u5230\u3002 #include<iostream> #include<cstring> #define int long long using namespace std; const int N=1e5+10,M=5e5+10; struct edge{ int v,nxt; }e[M<<1]; int head[N],dfn[N],low[N],sz[N],ans[N]; int cnt,n,m,u,v,tot; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void tarjan(int u){ dfn[u]=low[u]=++tot; int r=n-1; sz[u]=1;ans[u]=r; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(!dfn[v]){ tarjan(v),sz[u]+=sz[v],low[u]=min(low[u],low[v]); if(low[v]>=dfn[u]) ans[u]+=sz[v]*(n-sz[v]),r-=sz[v]; }else low[u]=min(low[u],dfn[v]); } ans[u]+=r*(n-r); } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&u,&v); add(u,v),add(v,u); } tarjan(1); for(int i=1;i<=n;++i){ printf(\"%lld\\n\",ans[i]); } return 0; }","title":"\u7f29\u70b9"},{"location":"my%20past/OI/%E7%BC%A9%E7%82%B9/#_1","text":"\u4e3b\u8981\u4f5c\u7528\uff1a\u5c06\u6709\u5411\u6709\u73af\u56fe\u53d8\u6210\u6709\u5411\u65e0\u73af\u56fe\uff08DAG\uff09 \u6574\u4f53\u601d\u8def\u5c31\u662fdfs\uff0c\u518d\u641c\u7d22\u6811\u4e2d\u5224\u65ad\u73af\u3002 \u6709\u4e24\u79cd\u6307\u5411\u5df2\u7ecf\u641c\u7d22\u8fc7\u7684\u70b9\u7684\u8fb9\uff0c\u4e00\u79cd\u662f\u8fd4\u7956\u8fb9\uff0c\u5373\u6307\u5411\u81ea\u5df1\u7684\u7956\u5148\u8282\u70b9\uff1b \u4e00\u79cd\u662f\u6a2a\u53c9\u8fb9\uff0c\u5373\u6307\u5411\u81ea\u5df1\u7684\u975e\u7956\u5148\u8282\u70b9\u3002\u53ef\u4ee5\u8bc1\u660e\u53ea\u6709\u8fd4\u7956\u8fb9\u4f1a\u4ea7\u751f\u73af\u3002 \u6240\u4ee5\u7528\u6808\u7ef4\u62a4\u5f53\u524d\u7684\u641c\u7d22\u94fe\uff0c\u5f00\u4e24\u4e2a\u6570\u7ec4dfn\u548clow\u7ef4\u62a4\u3002\u53ea\u8981\u627e\u5230\u8fd4\u7956\u4fbf\u5c31\u9000\u6808\u5230\u7956\u5148\uff0c\u5e76\u5c06\u6240\u6709\u70b9\u4f5c\u4e3a\u4e00\u4e2a\u5f3a\u8fde\u901a\u5206\u91cf\u3002\u5426\u5219\u5c31\u65e0\u89c6\uff0c\u5728\u56de\u6eaf\u662f\u5c06\u5355\u4e2a\u70b9\u4f5c\u4e3a\u5f3a\u8fde\u901a\u5206\u91cf\u3002","title":"\u7f29\u70b9"},{"location":"my%20past/OI/%E7%BC%A9%E7%82%B9/#_2","text":"void tarjan(int u){ dfn[u]=low[u]=++tot;//low[u]\u503c\u9ed8\u8ba4\u4e3adfn[u],\u540e\u9762\u518d\u66f4\u65b0 stk[++top]=u;//\u8fdb\u6808\u6253\u6807\u8bb0 vis[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(!dfn[v]){ tarjan(v); low[u]=min(low[u],low[v]);//\u8fd9\u4e00\u6b65\u662f\u4e3a\u4e86\u66f4\u65b0\u90a3\u4e9b\u518d\u73af\u4e2d\u7684\u70b9\uff0c\u5982\u4e0a\u56fe\u76846\uff0c7 }else{ if(vis[v])low[u]=min(low[u],dfn[v]);//\u8fd4\u7956\u8fb9\uff0c\u627e\u5230\u4e86\u73af\uff0c\u90a3\u5c31\u5c06low[u]\u66f4\u65b0\u4e3a\u5f53\u524d\u6839\u8282\u70b9\u3002 //\u6a2a\u53c9\u8fb9\u59825->4\u76f4\u63a5\u5ffd\u7565 } } //\u6ce8\u610f\u53ea\u6709\u81ea\u5df1\u662f\u6839\u624d\u9000\u6808\uff0c\u5426\u5219\u8981\u4fdd\u7559\u6808\u4e2d\u4fe1\u606f\u3002 if(dfn[u]==low[u]){//\u5982\u679c\u81ea\u5df1\u53ea\u80fd\u56de\u6eaf\u5230\u81ea\u5df1\uff0c\u8bf4\u660e\u81ea\u5df1\u662f\u5f3a\u8fde\u901a\u5206\u91cf\u4e2d\u7684\u6839\u8282\u70b9\uff0c\u5c31\u9000\u6808\u5230\u81ea\u5df1\uff0c\u5c06\u6240\u6709\u70b9\u6240\u79f0\u4e00\u4e2a\u70b9\u3002 ++nod; while(1){ ans[stk[top]]=nod; vis[stk[top]]=0;//\u53bb\u9664\u6807\u8bb0 if(stk[top--]==u)break; } } } int main(){ memset(dfn,0,sizeof dfn); memset(low,0,sizeof low); memset(vis,0,sizeof vis); for(int i=1;i<=n;++i){ if(!dfn[i])tarjan(i); } } P3387 & P3627 \u4e24\u9053\u9898\u5dee\u4e0d\u591a\uff0c\u4e00\u4e2a\u662f\u5148\u7f29\u70b9\uff0c\u518d\u6839\u636e\u62d3\u6251\u6392\u5e8f\u7684\u987a\u5e8f\u53d6dp\uff0c\u8fd9\u6837\u4fdd\u8bc1\u65e0\u540e\u6548\u6027\uff0c\u6700\u540e\u8f93\u51fa\u6240\u6709\u70b9\u4e2d\u8d21\u732e\u6700\u5927\u7684\u503c\uff1b \u4e00\u4e2a\u662f\u7f29\u5b8c\u70b9\u540e\uff0c\u4ece\u65b0\u7684\u8d77\u70b9\u53d6\u7528SPFA\u6c42\u6700\u957f\u8def\uff0c\u6700\u540e\u518d\u9152\u5427\u4e2d\u62db\u6700\u957f\u7684\u5c31\u884c\u3002 ~~\u592a\u7b80\u5355\u4e0d\u653e\u4ee3\u7801\u4e86~~ P1262 \u5c06\u6240\u6709\u7684\u73af\u7f29\u6210\u4e00\u4e2a\u70b9\uff0c\u5e76\u4e14\u5f97\u5230\u65b0\u7684\u70b9\u7684\u4ee3\u4ef7\u5c31\u662f\u73af\u5185\u6240\u6709\u70b9\u7684\u6700\u5c0f\u4ef7\u94b1\u3002 \u90a3\u4e48\u5fc5\u987b\u8d3f\u8d42\u7684\u5c31\u662f\u5165\u5ea6\u4e3a\u96f6\u7684\u70b9\uff0c\u5982\u679c\u65e0\u6cd5\u8d3f\u8d42\u5c31\u65e0\u89e3\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=3010,M=8010,P=20000; int n,m,p,cnt,top,tot,nod; int a[N],w[N],head[N],dfn[N],low[N],vis[N],stk[N],ans[N],ind[N]; struct query{ int u,v; }q[M]; struct edge{ int v,nxt; }e[M<<1]; void add(int u,int v){ e[++cnt].v=v; e[cnt].nxt=head[u]; head[u]=cnt; } void tarjan(int u){ dfn[u]=low[u]=++tot; stk[++top]=u; vis[u]=1; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(!dfn[v]){ tarjan(v); low[u]=min(low[u],low[v]); }else{ if(vis[v])low[u]=min(low[u],dfn[v]); } } if(dfn[u]==low[u]){ ++nod; while(1){ ans[stk[top]]=nod; vis[stk[top]]=0; if(stk[top--]==u)break; } } } int main(){ memset(head,-1,sizeof head); cnt=-1; memset(w,0x3f,sizeof w); memset(a,0x3f,sizeof a); scanf(\"%d%d\",&n,&p); for(int i=1,tmp,pos;i<=p;++i)scanf(\"%d%d\",&pos,&tmp),a[pos]=tmp; scanf(\"%d\",&m); for(int i=1;i<=m;++i){ scanf(\"%d%d\",&q[i].u,&q[i].v); add(q[i].u,q[i].v); } memset(vis,0,sizeof vis); for(int i=1;i<=n;++i)if(!dfn[i])tarjan(i); for(int i=1;i<=n;++i){ w[ans[i]]=min(w[ans[i]],a[i]); } for(int i=1;i<=m;++i){ int uu=ans[q[i].u],vv=ans[q[i].v]; if(uu==vv)continue; ind[vv]++; } memset(vis,0,sizeof vis); int res=0; bool flag=true; for(int i=1;i<=nod;++i){ if(!ind[i]){ if(w[i]<=P){ res+=w[i]; }else{ vis[i]=1; flag=false; } } } if(flag){ printf(\"YES\\n%d\",res); }else{ int minn=N+N; for(int i=1;i<=n;++i){ if(vis[ans[i]])minn=min(minn,i); } printf(\"NO\\n%d\",minn); } return 0; } /* 7 6 5 100 1 99 2 98 3 101 4 102 7 200 7 5 1 1 2 2 6 1 4 4 5 2 3 3 1 */","title":"\u6a21\u677f"},{"location":"my%20past/OI/%E7%BC%A9%E7%82%B9/#tarjan","text":"\u540c\u6837\u662f\u5229\u7528$low$\u548c$dfn$\u6570\u7ec4\u3002 \u5bf9\u4e8etarjan\u7684\u4e00\u6b21\u641c\u7d22\uff0c\u7531\u4e8e\u4e0d\u4f1a\u5230$dfn$\u6570\u7ec4\u4e0d\u4e3a0\u7684\u70b9\u7ee7\u7eed\u641c\u7d22\uff0c\u56e0\u6b64\uff0c\u6574\u4e2a\u8fc7\u7a0b\u5f62\u6210\u4e00\u9897\u641c\u7d22\u6811\u3002\u5bf9\u8fd9\u4e2a\u641c\u7d22\u6811\u4e2d\uff0c\u53ef\u80fd\u4e3a\u5272\u70b9\u67092\u79cd\u60c5\u51b5: \u6839\u8282\u70b9\uff0c\u4e14\u513f\u5b50\u5927\u4e8e\u7b49\u4e8e2 $dfn[u]\\leq low[v]$\u7684\u70b9\u3002 \u56e0\u4e3a$v$\u53ef\u80fd\u56de\u6eaf\u5230\u7684\u6700\u9760\u524d\u7684\u70b9\u90fd\u5927\u4e8e$u$\uff0c\u8bf4\u660e$v$\u4e0d\u80fd\u901a\u8fc7\u9664\u4e86$u$\u4ee5\u5916\u7684\u70b9\u4e0e\u5269\u4f59\u6bd4$dfn[u]$\u5c0f\u7684\u70b9\u8054\u901a\uff0c\u6240\u4ee5$u$\u662f\u5272\u70b9\u3002 #include<iostream> #include<cstring> using namespace std; const int N=2e4+10,M=1e5+10; struct edge{ int v,nxt; }e[M<<1]; int n,m,u,v,tot,cnt; int dfn[N],low[N],cut[N],head[N]; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void tarjan(int u,int p){ dfn[u]=low[u]=++tot; int son=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(!dfn[v]){ tarjan(v,p); low[u]=min(low[u],low[v]); if(low[v]>=dfn[u] && u!=p) cut[u]=1; if(u==p) ++son; }else low[u]=min(low[u],dfn[v]); } if(son>=2 && u==p) cut[u]=1; } int main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%d%d\",&n,&m); for(int i=1;i<=m;++i){ scanf(\"%d%d\",&u,&v); add(u,v),add(v,u); } for(int i=1;i<=n;++i){ if(!dfn[i]) tarjan(i,i); } int ans=0; for(int i=1;i<=n;++i){ if(cut[i]) ++ans; } printf(\"%d\\n\",ans); for(int i=1;i<=n;++i){ if(cut[i]) printf(\"%d \",i); } return 0; } P3469 \u7531\u4e8e\u641c\u7d22\u65f6\u4e00\u68f5\u6811\uff0c\u6240\u4ee5\u53ef\u4ee5\u7ef4\u62a4$sz$\u6570\u7ec4\u3002\u7b54\u6848\u5373\u4e3a$\\sum sz[v]*(n-sz[v])$\uff0c$sz[v]$\u53ef\u4ee5\u5728\u641c\u7d22\u4e2d\u5f97\u5230\u3002 #include<iostream> #include<cstring> #define int long long using namespace std; const int N=1e5+10,M=5e5+10; struct edge{ int v,nxt; }e[M<<1]; int head[N],dfn[N],low[N],sz[N],ans[N]; int cnt,n,m,u,v,tot; void add(int u,int v){ e[++cnt].v=v,e[cnt].nxt=head[u],head[u]=cnt; } void tarjan(int u){ dfn[u]=low[u]=++tot; int r=n-1; sz[u]=1;ans[u]=r; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(!dfn[v]){ tarjan(v),sz[u]+=sz[v],low[u]=min(low[u],low[v]); if(low[v]>=dfn[u]) ans[u]+=sz[v]*(n-sz[v]),r-=sz[v]; }else low[u]=min(low[u],dfn[v]); } ans[u]+=r*(n-r); } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&u,&v); add(u,v),add(v,u); } tarjan(1); for(int i=1;i<=n;++i){ printf(\"%lld\\n\",ans[i]); } return 0; }","title":"tarjan\u6c42\u5272\u70b9"},{"location":"my%20past/OI/%E7%BD%91%E7%BB%9C%E6%B5%81/","text":"\u7f51\u7edc\u6d41 Dinic bool bfs() { memset(h,-1,sizeof h); int op=0,cl=1; h[s]=0; q[1]=s; while(op<cl) { op=(op+1)%M; int u=q[op]; for(int i=head[u]; i!=-1; i=e[i].nxt) { int v=e[i].v,w=e[i].w; if(w>0 && h[v]==-1) { cl=(cl+1)%M; q[cl]=v; h[v]=h[u]+1; if(v==t)return true; } } } return h[t]!=-1; } int dfs(int u,int flow) { if(u==t)return flow; int sum=0; for(int &i=now[u]; i!=-1; i=e[i].nxt) { int v=e[i].v,w=e[i].w; if(w>0 && h[v]==h[u]+1) { int s1=dfs(v,min(flow,w)); sum+=s1; flow-=s1; e[i].w-=s1; e[i^1].w+=s1; if(flow==0)break; } } return sum; } int Dinic() { int ans=0; while(bfs()) { memcpy(now,head,sizeof head); ans+=dfs(s,INF); } return ans; } P1251 \u7ebf\u6027\u89c4\u5212 P2053 \u8bbe\u7f6en * m\u4e2a\u70b9\u6765\u8ba1\u7b97\u91cd\u53e0\u7684\u7b49\u5f85\u65f6\u95f4 P2050 \u4e3aP2053\u7684\u52a8\u6001\u5f00\u70b9\u7248\u672c P2764 \u6700\u5c0f\u5272 P2825 \u5206\u5272\u8fde\u901a\u5757 \u8d39\u7528\u6d41dijkstra\u4e0ejohnson johnson\u7684\u539f\u7406\u662f\uff1a\u7ed9\u6bcf\u4e2a\u70b9\u52a0\u4e0a\u4e00\u4e2a\u52bfh[u]\uff0c\u4f7f\u5f97\u65b0\u56fe\u4e2d\u7684\u8fb9\u6743\u975e\u8d1f\u3002 \u8bc1\u660e\uff1a\u7531\u4e09\u89d2\u5f62\u4e0d\u7b49\u5f0f,dis[u]+w>=dis[v] --> w+h[u]-h[v]>=0 \u5982\u4f55\u7ef4\u62a4\u52bf\u51fd\u6570h[]\u3002 \u521d\u59cb\u60c5\u51b5\u4e0b,\u5982\u679c\u6240\u6709\u7684\u6743\u503c\u90fd\u4e3a\u6b63,\u90a3\u4e48\u53ef\u4ee5\u7b80\u5355\u5730\u5c06\u6240\u6709h[i]\u8bbe\u7f6e\u4e3a0\uff1b\u5982\u679c\u6709\u8d1f\u6743\u503c,\u90a3\u4e48\u6211\u4eec\u505a\u4e00\u904dspfa,\u8ba9h[]\u7b49\u4e8e\u8ddd\u79bb\u51fd\u6570\u3002 \u8ba9d'[i]\u8868\u793aG'\u4e2dS\u5230\u70b9i\u7684\u8ddd\u79bb,\u5f53\u67d0\u6b21\u589e\u5e7f\u7ed3\u675f\u540e,G'\u4e2d\u4f1a\u65b0\u52a0\u5165\u67d0\u4e9b\u8fb9(j, i),\u800c\u8fd9\u4e9b(j, i)\u5fc5\u5b9a\u6ee1\u8db3d'[i] + w'[i][j] = d' j \u3002\u5bf9\u4e0a\u5f0f\u8fdb\u884c\u4e00\u4e9b\u4ee3\u6570\u53d8\u6362\uff1a $$ d'[i] + w'[i][j] = d'[j] \\d'[i] + w[i][j] + h[i]-h[j] = d'[j] \\(d'[j] + h[j])-(d'[i] + h[i])-w[i][j] = 0 \\(d'[j] + h[j])-(d'[i] + h[i]) + w[j][i] = 0 $$ (\u56e0\u4e3a\u662f\u8d39\u7528\u6d41,\u6240\u4ee5\u6709w[i][j] = -w[j][i]) \u56e0\u6b64\u8ba9\u6240\u6709h[i] += d'[i]\u540e,\u65b0\u52a0\u5165\u7684\u8fb9(j, i)\u4e5f\u4f1a\u6ee1\u8db3\u52bf\u51fd\u6570\u7684\u6027\u8d28\u3002 \u540c\u65f6\u6211\u4eec\u6709\uff1a $$ d'[i] + w'[i][j] - d'[j] >= 0\\ d'[i] + h[i] - h[j] + w[i][j] - d'[j] >= 0\\ (d'[i] + h[i]) - (d'[j] + h[j]) + w[i][j] >= 0\\ $$ P4542 \u8fd9\u9053\u9898\u56f0\u96be\u7684\u5730\u65b9\u5728\u4e8e\u6a21\u578b\u7684\u8f6c\u5316\uff0c\u5373\u5982\u4f55\u770b\u51fa\"\u6309\u987a\u5e8f\u6467\u6bc1\u6839\u636e\u5730\"\u7684\u9690\u85cf\u6761\u4ef6\u3002 \u6211\u4eec\u8bbe$d[i][j]$\u8868\u793a\u4ece$i$\u5230$j$\u4e0d\u7ecf\u8fc7\u4efb\u4f55\u7f16\u53f7\u5927\u4e8e$i,j$\u7684\u70b9\u7684\u6700\u77ed\u8def\u5f84\u3002\u8fd9\u4fdd\u8bc1\u4e86\u6211\u4eec\u4e00\u5b9a\u53ef\u4ee5\u6309\u7167\u7ed9\u5b9a\u7684\u987a\u5e8f\u8fdb\u884c\u66f4\u65b0\u3002 \u6240\u4ee5\u7528$Floyd$\u9884\u5904\u7406\u51fa$d[i][j]$\uff0c\u7136\u540e\u7528\u8d39\u7528\u6d41\u6c42\u89e3\u3002 \u81f3\u4e8e\u5efa\u56fe\uff0c\u56e0\u4e3a\u9898\u76ee\u4fdd\u8bc1\u4e00\u5b9a\u6709\u89e3\uff0c\u6240\u4ee5\u6574\u5f20\u56fe\u4e00\u5b9a\u8054\u901a\uff0c\u4e0d\u7528\u8003\u8651\u6709\u7684\u70b9\u4e0d\u88ab\u7ecf\u8fc7\uff1b\u53c8\u56e0\u4e3a\u8dd1\u7684\u662f\u6700\u5927\u6d41\uff0c\u6240\u4ee5\u6240\u6709\u70b9\u4e00\u5b9a\u90fd\u4f1a\u88ab\u7ecf\u8fc7\uff0c\u6211\u4eec\u53ea\u9700\u8981\u9650\u5236\u4e00\u4e0b\u6d41\u91cf\u4e0d\u8d85\u8fc7$K$\u5373\u53ef\u3002 \u8fd9\u6837\uff0c\u8bbe\u6e90\u6c47\u70b9\u4e3a$s,t$\uff0c\u90a3\u4e48\u5c06$1,2,...,n$\u7684\u70b9\u4e0e$s$\u8fde$w=1$\u7684\u8fb9\uff0c\u8868\u793a\u4e92\u4e0d\u76f8\u4ea4\u4e14\u53ea\u80fd\u6d41\u5411\u4e00\u4e2a\u70b9\uff1b\u5c06$0\\to n$\u8fde$w=K$\u7684\u8fb9\uff0c\u8868\u793a\u6700\u591a\u6709$K$\u6761\u8def\u5f84\uff0c\u6700\u591a\u6d41\u5411$K$\u4e2a\u70b9\u3002 \u4e4b\u540e\uff0c\u5c06$0,1,...,n$\u7684\u70b9\u62c6\u70b9\uff0c\u4e92\u76f8\u8fde$w=1$\u7684\u8fb9\uff0c\u8868\u793a\u53ea\u6d41\u5411\u4e00\u4e2a\u6ee1\u8db3\u987a\u5e8f\u7684\u70b9\u3002 \u6700\u540e\uff0c\u5c06$0',1',...,n'$\u5411$t$\u8fde$w=1$\u7684\u8fb9\uff0c\u6ca1\u6709\u5177\u4f53\u610f\u4e49\uff0c\u5c31\u662f\u5f3a\u884c\u8ba9\u4ed6\u4eec\u6709\u4e00\u4e2a\u6c47\u70b9\u3002 \u8fd9\u6837\u8dd1\u51fa\u6765\u5c31\u662f\u6700\u4f18\u89e3\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> using namespace std; const int N=440,M=4e5+10,INF=0x3f3f3f3f; struct edge{ int v,w,f,nxt; }e[M]; int head[N],pre[N],lst[N],dis[N],vis[N]; int d[N][N]; int n,m,K,cnt,s,t,D,maxflow,mincost,u,v,w; void add(int u,int v,int w,int f){e[++cnt].v=v,e[cnt].w=w,e[cnt].f=f,e[cnt].nxt=head[u],head[u]=cnt;} void init(){ for(int i=0;i<=n;++i){ d[i][i]=0; for(int j=0;j<=n;++j) if(i!=j) d[i][j]=INF; } } void floyd(){ for(int k=0;k<=n;++k) for(int i=0;i<=n;++i) for(int j=0;j<=n;++j) if(k<=max(i,j)) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); } void build(){ s=n*2+10,t=n*2+13,D=n+3; for(int i=0;i<=n;++i){ if(i==0)add(s,i,K,0),add(i,s,0,0); else add(s,i,1,0),add(i,s,0,0); add(i+D,t,1,0),add(t,i+D,0,0); for(int j=i+1;j<=n;++j)add(i,j+D,1,d[i][j]),add(j+D,i,0,-d[i][j]); } } bool SPFA(){ queue<int> q; memset(vis,0,sizeof vis); memset(dis,0x3f,sizeof dis); memset(pre,-1,sizeof pre); dis[s]=0,vis[s]=1; q.push(s); while(!q.empty()){ int u=q.front();q.pop(); vis[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w,f=e[i].f; if(w>0 && dis[v]>dis[u]+f){ dis[v]=dis[u]+f,pre[v]=u,lst[v]=i; if(!vis[v]) vis[v]=1,q.push(v); } } } return pre[t]!=-1; } void MCMF(){ maxflow=0,mincost=0; while(SPFA()){ int minn=INF; for(int i=t;i!=s;i=pre[i]) minn=min(minn,e[lst[i]].w); for(int i=t;i!=s;i=pre[i]) e[lst[i]].w-=minn,e[lst[i]^1].w+=minn; maxflow+=minn,mincost+=minn*dis[t]; } } int main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%d%d%d\",&n,&m,&K); init(); for(int i=1;i<=m;++i)scanf(\"%d%d%d\",&u,&v,&w),d[u][v]=d[v][u]=min(d[u][v],w); floyd(); build(); MCMF(); printf(\"%d\",mincost); return 0; }","title":"\u7f51\u7edc\u6d41"},{"location":"my%20past/OI/%E7%BD%91%E7%BB%9C%E6%B5%81/#_1","text":"","title":"\u7f51\u7edc\u6d41"},{"location":"my%20past/OI/%E7%BD%91%E7%BB%9C%E6%B5%81/#dinic","text":"bool bfs() { memset(h,-1,sizeof h); int op=0,cl=1; h[s]=0; q[1]=s; while(op<cl) { op=(op+1)%M; int u=q[op]; for(int i=head[u]; i!=-1; i=e[i].nxt) { int v=e[i].v,w=e[i].w; if(w>0 && h[v]==-1) { cl=(cl+1)%M; q[cl]=v; h[v]=h[u]+1; if(v==t)return true; } } } return h[t]!=-1; } int dfs(int u,int flow) { if(u==t)return flow; int sum=0; for(int &i=now[u]; i!=-1; i=e[i].nxt) { int v=e[i].v,w=e[i].w; if(w>0 && h[v]==h[u]+1) { int s1=dfs(v,min(flow,w)); sum+=s1; flow-=s1; e[i].w-=s1; e[i^1].w+=s1; if(flow==0)break; } } return sum; } int Dinic() { int ans=0; while(bfs()) { memcpy(now,head,sizeof head); ans+=dfs(s,INF); } return ans; } P1251 \u7ebf\u6027\u89c4\u5212 P2053 \u8bbe\u7f6en * m\u4e2a\u70b9\u6765\u8ba1\u7b97\u91cd\u53e0\u7684\u7b49\u5f85\u65f6\u95f4 P2050 \u4e3aP2053\u7684\u52a8\u6001\u5f00\u70b9\u7248\u672c P2764 \u6700\u5c0f\u5272 P2825 \u5206\u5272\u8fde\u901a\u5757","title":"Dinic"},{"location":"my%20past/OI/%E7%BD%91%E7%BB%9C%E6%B5%81/#dijkstrajohnson","text":"johnson\u7684\u539f\u7406\u662f\uff1a\u7ed9\u6bcf\u4e2a\u70b9\u52a0\u4e0a\u4e00\u4e2a\u52bfh[u]\uff0c\u4f7f\u5f97\u65b0\u56fe\u4e2d\u7684\u8fb9\u6743\u975e\u8d1f\u3002 \u8bc1\u660e\uff1a\u7531\u4e09\u89d2\u5f62\u4e0d\u7b49\u5f0f,dis[u]+w>=dis[v] --> w+h[u]-h[v]>=0 \u5982\u4f55\u7ef4\u62a4\u52bf\u51fd\u6570h[]\u3002 \u521d\u59cb\u60c5\u51b5\u4e0b,\u5982\u679c\u6240\u6709\u7684\u6743\u503c\u90fd\u4e3a\u6b63,\u90a3\u4e48\u53ef\u4ee5\u7b80\u5355\u5730\u5c06\u6240\u6709h[i]\u8bbe\u7f6e\u4e3a0\uff1b\u5982\u679c\u6709\u8d1f\u6743\u503c,\u90a3\u4e48\u6211\u4eec\u505a\u4e00\u904dspfa,\u8ba9h[]\u7b49\u4e8e\u8ddd\u79bb\u51fd\u6570\u3002 \u8ba9d'[i]\u8868\u793aG'\u4e2dS\u5230\u70b9i\u7684\u8ddd\u79bb,\u5f53\u67d0\u6b21\u589e\u5e7f\u7ed3\u675f\u540e,G'\u4e2d\u4f1a\u65b0\u52a0\u5165\u67d0\u4e9b\u8fb9(j, i),\u800c\u8fd9\u4e9b(j, i)\u5fc5\u5b9a\u6ee1\u8db3d'[i] + w'[i][j] = d' j \u3002\u5bf9\u4e0a\u5f0f\u8fdb\u884c\u4e00\u4e9b\u4ee3\u6570\u53d8\u6362\uff1a $$ d'[i] + w'[i][j] = d'[j] \\d'[i] + w[i][j] + h[i]-h[j] = d'[j] \\(d'[j] + h[j])-(d'[i] + h[i])-w[i][j] = 0 \\(d'[j] + h[j])-(d'[i] + h[i]) + w[j][i] = 0 $$ (\u56e0\u4e3a\u662f\u8d39\u7528\u6d41,\u6240\u4ee5\u6709w[i][j] = -w[j][i]) \u56e0\u6b64\u8ba9\u6240\u6709h[i] += d'[i]\u540e,\u65b0\u52a0\u5165\u7684\u8fb9(j, i)\u4e5f\u4f1a\u6ee1\u8db3\u52bf\u51fd\u6570\u7684\u6027\u8d28\u3002 \u540c\u65f6\u6211\u4eec\u6709\uff1a $$ d'[i] + w'[i][j] - d'[j] >= 0\\ d'[i] + h[i] - h[j] + w[i][j] - d'[j] >= 0\\ (d'[i] + h[i]) - (d'[j] + h[j]) + w[i][j] >= 0\\ $$ P4542 \u8fd9\u9053\u9898\u56f0\u96be\u7684\u5730\u65b9\u5728\u4e8e\u6a21\u578b\u7684\u8f6c\u5316\uff0c\u5373\u5982\u4f55\u770b\u51fa\"\u6309\u987a\u5e8f\u6467\u6bc1\u6839\u636e\u5730\"\u7684\u9690\u85cf\u6761\u4ef6\u3002 \u6211\u4eec\u8bbe$d[i][j]$\u8868\u793a\u4ece$i$\u5230$j$\u4e0d\u7ecf\u8fc7\u4efb\u4f55\u7f16\u53f7\u5927\u4e8e$i,j$\u7684\u70b9\u7684\u6700\u77ed\u8def\u5f84\u3002\u8fd9\u4fdd\u8bc1\u4e86\u6211\u4eec\u4e00\u5b9a\u53ef\u4ee5\u6309\u7167\u7ed9\u5b9a\u7684\u987a\u5e8f\u8fdb\u884c\u66f4\u65b0\u3002 \u6240\u4ee5\u7528$Floyd$\u9884\u5904\u7406\u51fa$d[i][j]$\uff0c\u7136\u540e\u7528\u8d39\u7528\u6d41\u6c42\u89e3\u3002 \u81f3\u4e8e\u5efa\u56fe\uff0c\u56e0\u4e3a\u9898\u76ee\u4fdd\u8bc1\u4e00\u5b9a\u6709\u89e3\uff0c\u6240\u4ee5\u6574\u5f20\u56fe\u4e00\u5b9a\u8054\u901a\uff0c\u4e0d\u7528\u8003\u8651\u6709\u7684\u70b9\u4e0d\u88ab\u7ecf\u8fc7\uff1b\u53c8\u56e0\u4e3a\u8dd1\u7684\u662f\u6700\u5927\u6d41\uff0c\u6240\u4ee5\u6240\u6709\u70b9\u4e00\u5b9a\u90fd\u4f1a\u88ab\u7ecf\u8fc7\uff0c\u6211\u4eec\u53ea\u9700\u8981\u9650\u5236\u4e00\u4e0b\u6d41\u91cf\u4e0d\u8d85\u8fc7$K$\u5373\u53ef\u3002 \u8fd9\u6837\uff0c\u8bbe\u6e90\u6c47\u70b9\u4e3a$s,t$\uff0c\u90a3\u4e48\u5c06$1,2,...,n$\u7684\u70b9\u4e0e$s$\u8fde$w=1$\u7684\u8fb9\uff0c\u8868\u793a\u4e92\u4e0d\u76f8\u4ea4\u4e14\u53ea\u80fd\u6d41\u5411\u4e00\u4e2a\u70b9\uff1b\u5c06$0\\to n$\u8fde$w=K$\u7684\u8fb9\uff0c\u8868\u793a\u6700\u591a\u6709$K$\u6761\u8def\u5f84\uff0c\u6700\u591a\u6d41\u5411$K$\u4e2a\u70b9\u3002 \u4e4b\u540e\uff0c\u5c06$0,1,...,n$\u7684\u70b9\u62c6\u70b9\uff0c\u4e92\u76f8\u8fde$w=1$\u7684\u8fb9\uff0c\u8868\u793a\u53ea\u6d41\u5411\u4e00\u4e2a\u6ee1\u8db3\u987a\u5e8f\u7684\u70b9\u3002 \u6700\u540e\uff0c\u5c06$0',1',...,n'$\u5411$t$\u8fde$w=1$\u7684\u8fb9\uff0c\u6ca1\u6709\u5177\u4f53\u610f\u4e49\uff0c\u5c31\u662f\u5f3a\u884c\u8ba9\u4ed6\u4eec\u6709\u4e00\u4e2a\u6c47\u70b9\u3002 \u8fd9\u6837\u8dd1\u51fa\u6765\u5c31\u662f\u6700\u4f18\u89e3\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<queue> using namespace std; const int N=440,M=4e5+10,INF=0x3f3f3f3f; struct edge{ int v,w,f,nxt; }e[M]; int head[N],pre[N],lst[N],dis[N],vis[N]; int d[N][N]; int n,m,K,cnt,s,t,D,maxflow,mincost,u,v,w; void add(int u,int v,int w,int f){e[++cnt].v=v,e[cnt].w=w,e[cnt].f=f,e[cnt].nxt=head[u],head[u]=cnt;} void init(){ for(int i=0;i<=n;++i){ d[i][i]=0; for(int j=0;j<=n;++j) if(i!=j) d[i][j]=INF; } } void floyd(){ for(int k=0;k<=n;++k) for(int i=0;i<=n;++i) for(int j=0;j<=n;++j) if(k<=max(i,j)) d[i][j]=min(d[i][j],d[i][k]+d[k][j]); } void build(){ s=n*2+10,t=n*2+13,D=n+3; for(int i=0;i<=n;++i){ if(i==0)add(s,i,K,0),add(i,s,0,0); else add(s,i,1,0),add(i,s,0,0); add(i+D,t,1,0),add(t,i+D,0,0); for(int j=i+1;j<=n;++j)add(i,j+D,1,d[i][j]),add(j+D,i,0,-d[i][j]); } } bool SPFA(){ queue<int> q; memset(vis,0,sizeof vis); memset(dis,0x3f,sizeof dis); memset(pre,-1,sizeof pre); dis[s]=0,vis[s]=1; q.push(s); while(!q.empty()){ int u=q.front();q.pop(); vis[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v,w=e[i].w,f=e[i].f; if(w>0 && dis[v]>dis[u]+f){ dis[v]=dis[u]+f,pre[v]=u,lst[v]=i; if(!vis[v]) vis[v]=1,q.push(v); } } } return pre[t]!=-1; } void MCMF(){ maxflow=0,mincost=0; while(SPFA()){ int minn=INF; for(int i=t;i!=s;i=pre[i]) minn=min(minn,e[lst[i]].w); for(int i=t;i!=s;i=pre[i]) e[lst[i]].w-=minn,e[lst[i]^1].w+=minn; maxflow+=minn,mincost+=minn*dis[t]; } } int main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%d%d%d\",&n,&m,&K); init(); for(int i=1;i<=m;++i)scanf(\"%d%d%d\",&u,&v,&w),d[u][v]=d[v][u]=min(d[u][v],w); floyd(); build(); MCMF(); printf(\"%d\",mincost); return 0; }","title":"\u8d39\u7528\u6d41dijkstra\u4e0ejohnson"},{"location":"my%20past/OI/%E8%83%8C%E5%8C%85/","text":"\u80cc\u5305\u603b\u7ed3 P3859 TJOI\u7684\u6c34\u9898\uff08\u9ec4\u9898\u96be\u5ea6\u7684\u7d2b\u9898\uff09 \u5b9a\u4e49f[j]\u8868\u793a\u7528\u4e86j\u65f6\u95f4\u65f6\u83b7\u5f97\u5b9d\u77f3\u7684\u6700\u5927\u4ef7\u503c\u3002~~\u662f\u7684\u53ea\u7528\u4e00\u7ef4\u6eda\u52a8\u5c31\u884c~~ \u56e0\u6b64\u8f6c\u79fb\u65b9\u7a0b\uff1a f[j]=max(max(f[j],f[j-1]),f[j-t]+v); \u53ef\u4ee5\u63d0\u524d\u628a\u5b9d\u77f3\u6309\u9650\u5236\u65f6\u95f4\u6392\u4e2a\u5e8f\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u6392 P1049 \u80cc\u5305\u7684\u7b80\u5355\u53d8\u5f62\u3002 \u8bbef[i] (bool\u7c7b\u578b)\u4e3a\u80fd\u5426\u5c06i\u7684\u7a7a\u95f4\u88c5\u6ee1\u3002\u5219\u8f6c\u79fb\u65b9\u7a0b: f[0]=1; for(int i=1;i<=n;++i){ for(int j=v;j>=a[i];--j){ if(f[j-a[i]])f[j]=1; } } P1064 \u4e00\u9053\u597d\u9898 \u56e0\u4e3a\u6bcf\u4e2a\u7269\u54c1\u7684\u72b6\u6001\u603b\u5171\u5c313\u79cd\uff0c\u5373\u81ea\u5df1\uff0c\u5de6\u513f\u5b50\u548c\u53f3\u513f\u5b50\uff0c\u6240\u4ee5\u5c31\u8bbe\u6240\u6709\u7269\u54c1\u90fd\u6709\u513f\u5b50\u3002 \u8bbef[i]\u8868\u793a\u4ef7\u683c\u4e3ai\u65f6\u4ef7\u683c\u4e0e\u6743\u91cd\u7684\u4e58\u79ef\u6700\u5927\u503c\u3002\u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a f[0]=0; ans=0; for(int i=1;i<=m;++i){ if(!v[i][0])continue; for(int j=n;j>=v[i][0];--j){ if(v[i][1] && v[i][2] && j>=v[i][0]+v[i][1]+v[i][2])f[j]=max(f[j],f[j-v[i][0]-v[i][1]-v[i][2]]+v[i][0]*w[i][0]+v[i][1]*w[i][1]+v[i][2]*w[i][2]); if(v[i][1] && j>=v[i][0]+v[i][1])f[j]=max(f[j],f[j-v[i][0]-v[i][1]]+v[i][0]*w[i][0]+v[i][1]*w[i][1]); if(v[i][2] && j>=v[i][0]+v[i][2])f[j]=max(f[j],f[j-v[i][0]-v[i][2]]+v[i][0]*w[i][0]+v[i][2]*w[i][2]); if(j>=v[i][0])f[j]=max(f[j],f[j-v[i][0]]+v[i][0]*w[i][0]); ans=max(f[j],ans); } } \u6ce8\u610f\u9644\u4ef6\u4e0d\u80fd\u5c06\u4ed6\u7684\u4e3b\u4ef6\u680f\u586b\u8fdb\u53bb(v[i][0],w[i][0])\u3002 //\u8bfb\u5165 for(int i=1;i<=m;++i){ scanf(\"%d%d%d\",&v1,&w1,&p1); if(p1==0)v[i][0]=v1,w[i][0]=w1; else{ if(v[p1][1])v[p1][2]=v1,w[p1][2]=w1; else v[p1][1]=v1,w[p1][1]=w1; } } P1651 \u8bbef[i][j]\u8868\u793a\u524di\u4e2a\u7269\u54c1\u642d\u51fa\u7684\u9ad8\u5ea6\u76f8\u5deej\u7684\u4e24\u4e2a\u5854\u4e2d\u6700\u9ad8\u7684\u5854\u7684\u9ad8\u5ea6\u3002 \u8fd9\u6837\u65e2\u80fd\u5c06\u72b6\u6001\u8868\u793a\u5168\uff0c\u53c8\u80fd\u907f\u514d\u7528\u4e24\u7ef4\u7684\u9ad8\u5ea6\u5bfc\u81f4MLE\u3002\u4e8b\u5b9e\u4e0ai\u90a3\u4e00\u7ef4\u53ef\u4ee5\u6eda\u5b58\u4f18\u5316\u6389\u3002 \u6ce8\u610f\u56e0\u4e3a\u8f6c\u79fb\u4e2d\u4f1a\u51fa\u73b0\u8d1f\u6570\uff0c\u6240\u4ee5\u8981\u5c06\u7b2c\u4e8c\u7ef4\u5f00\u4e24\u500d\uff0c\u5c06\u4e2d\u95f4\u70b9500000\u8bbe\u4e3a\u96f6\u70b9\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=1e6+10,M=53,P=1e6; int f[2][N]; int n; int a[M]; int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); int ans=-0x7fffffff; memset(f,-0x3f,sizeof f); f[0][500000]=0; for(int i=1;i<=n;++i){ for(int j=0;j<=P;++j){ f[i%2][j]=max(f[i%2][j],f[(i%2)^1][j]); if(j-a[i]>=0)f[i%2][j]=max(f[i%2][j],f[(i%2)^1][j-a[i]]+a[i]); if(j+a[i]<=P)f[i%2][j]=max(f[i%2][j],f[(i%2)^1][j+a[i]]); if(j==500000)ans=max(ans,f[i%2][j]); } } if(ans>0)printf(\"%d\",ans); else printf(\"-1\"); return 0; } /* 20 188242 313 1991 4207 2483 1763 224 16 582 22943 111653 23787 16820 12415 1270 3032 2293 5221 396 42 */ P4823 \u9996\u5148\u6709\u4e2a\u8d2a\u5fc3\u7684\u6027\u8d28\uff1a \u5bf9\u4e8e\u6bcf\u4e2a\u5c0f\u77ee\u4eba\uff0c\u4e00\u5b9a\u662f\u9003\u751f\u80fd\u529b\u5f31\uff0c\u5373$a+b$\u8f83\u5c0f\u7684\u4eba\u5148\u9003\u6bd4\u80fd\u529b\u5f3a\u7684\u4eba\u5148\u9003\u7684\u4e0d\u4f1a\u66f4\u5dee\u3002 \u56e0\u4e3a\u80fd\u529b\u5f31\u7684\u4eba\u5982\u679c\u4e0d\u5148\u9003\uff0c\u4ee5\u540e\u5c31\u53ef\u80fd\u9003\u4e0d\u51fa\u53bb\u4e86\u3002 \u4e0d\u4f1a\u51fa\u73b0\u80fd\u529b\u5f3a\u7684\u5148\u9003\u540e\u5f31\u7684\u80fd\u9003\uff0c\u800c\u5f31\u7684\u5148\u9003\u5f3a\u7684\u5c31\u9003\u4e0d\u4e86\u7684\u60c5\u51b5\u3002 \u53ea\u8981\u5f31\u7684\u9003\u4e86\u5f3a\u7684\u9003\u4e0d\u4e86\uff0c\u90a3\u5f3a\u7684\u9003\u4e86\u5f31\u7684\u4e5f\u8dd1\u4e0d\u4e86\u3002\u56e0\u4e3a\u540e\u4e00\u4e2a\u9003\u7684\u811a\u5e95\u4e0b\u9ad8\u5ea6\u662f\u4e00\u5b9a\u7684\u3002 \u6709\u4e86\u8fd9\u4e2a\u6027\u8d28\u540e\u5c31\u53ef\u4ee5\u7528\u80cc\u5305\u89e3\u51b3\u6bcf\u4e2a\u77ee\u4eba\u662f\u5426\u8981\u9003\u51fa\u53bb\u3002\u56e0\u4e3a\u53ef\u80fd\u5b83$a$\u7279\u522b\u5927\uff0c\u4e0d\u9003\u5bf9\u4eba\u68af\u7684\u8d21\u732e\u66f4\u5927\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=2200; struct node{ int a,b; }q[N]; bool cmp(node a,node b){ return a.a+a.b<b.a+b.b; } int n,h; int dp[N]; int main(){ memset(dp,-0x3f,sizeof dp); dp[0]=0; scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d%d\",&q[i].a,&q[i].b),dp[0]+=q[i].a; scanf(\"%d\",&h); sort(q+1,q+n+1,cmp); for(int i=1;i<=n;++i){ for(int j=i;j>=1;--j){ if(dp[j-1]+q[i].b>=h)dp[j]=max(dp[j],dp[j-1]-q[i].a); } } for(int i=n;i>=0;--i){ if(dp[i]>=0){ printf(\"%d\",i); return 0; } } return 0; } \u7ed3\u8bba\uff1a\u5f53\u80cc\u5305\u7684\u8f6c\u79fb\u6536\u5230\u987a\u5e8f\u5f71\u54cd\uff0c\u53c8\u4e0d\u80fd\u786e\u5b9a\u7269\u54c1\u62ff\u53d6\u7684\u5177\u4f53\u987a\u5e8f\uff0c\u53ef\u4ee5\u5bfb\u627e\u8d2a\u5fc3\u7684\u6027\u8d28,\u6392\u5e8f\u540e\u505a\u80cc\u5305\u3002 P3961 \u53ef\u4ee5\u7528\u659c\u7387\u5b58\u50a8\u6240\u6709\u70b9\u7684\u4fe1\u606f\uff0c\u6ce8\u610f\u5904\u7406$x=0$\u5373\u659c\u7387\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u3002 \u4e4b\u540e\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u91d1\u5b50\uff0c\u53ef\u4ee5\u5c06\u7b2c$i$\u4e2a\u7684\u65f6\u95f4\u4ef7\u503c\u548c\u524d$i-1$\u4e2a\u5e76\u518d\u4e00\u8d77\uff0c\u8868\u793a\u8fde\u7eed\u53d6$i$\u4e2a\u91d1\u5b50\u3002 \u5728\u505a\u80cc\u5305\u65f6\uff0c\u540c\u4e00\u7ec4\u53ea\u80fd\u9009\u4e00\u4e2a\uff0c\u6240\u4ee5\u6ce8\u610f\u987a\u5e8f\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=320,M=5e4+10,K=200; int f[M],top[N+N][N],nxt[N],head[N+N][N],l[N],r[N]; int n,T,cnt,tot; struct query{ int x,y,t,v; double k; }q[N]; struct item{ int t,v; }c[N]; bool cmp(query a,query b){ if(a.k==b.k)return a.y<b.y; else return a.k<b.k; } void print1(){ for(int i=1;i<=tot;++i){ for(int k=l[i];k<=r[i];++k){ cout<<c[k].t<<\" \"<<c[k].v<<endl; } } } signed main(){ scanf(\"%lld%lld\",&n,&T); for(int i=1;i<=n;++i){ scanf(\"%lld%lld%lld%lld\",&q[i].x,&q[i].y,&q[i].t,&q[i].v); if(q[i].x!=0)q[i].k=q[i].y*1.0/(q[i].x*1.0); else q[i].k=N; } sort(q+1,q+n+1,cmp); tot=0; for(int i=1;i<=n;++i){ int x=q[i].x,y=q[i].y; if(q[i].k!=q[i-1].k || i==1){ r[tot]=i-1; ++tot; l[tot]=i; } c[i].t+=q[i].t; c[i].v+=q[i].v; if(q[i].k==q[i-1].k && i!=1){ c[i].t+=c[i-1].t; c[i].v+=c[i-1].v; } } r[tot]=n; //print1(); //memset(f,-0x3f,sizeof f); f[0]=0; for(int i=1;i<=tot;++i){ for(int j=T;j>=c[l[i]].t;--j){ for(int k=l[i];k<=r[i];++k){ if(j>=c[k].t)f[j]=max(f[j],f[j-c[k].t]+c[k].v); } } } int maxn=0; for(int i=0;i<=T;++i){ maxn=max(maxn,f[i]); } printf(\"%lld\",maxn); return 0; } /* 4 17 0 10 2 3 -2 3 1 1 -4 6 2 2 -6 8 15 9 3 10 1 1 13 1 2 2 2 2 1 3 4 7 */ P1156 \u8fd9\u9898\u552f\u4e00\u7684\u5751\u70b9\u5c31\u662f\u540c\u4e00\u65f6\u95f4\u4f1a\u653e\u591a\u4e2a\u5783\u573e\u3002 \u8fd9\u65f6\u8981\u7528\u94fe\u8868/vector\u5b58\u50a8\u4e00\u4e0b\uff0c\u5e76\u4e14\u540c\u4e00\u65f6\u523b\u7684\u5783\u573e\u662f\u6709\u5148\u540e\u987a\u5e8f\u7684\uff0c\u5373\u9ad8\u5ea6\u53ef\u4ee5\u7d2f\u52a0\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=4400,T=1000,K=220; int f[N][K]; int D,G,tot; int cnt[N],tim[N]; struct node { int h,f; } c[N][K]; int main() { //freopen(\"P1156_2.in\",\"r\",stdin); scanf(\"%d%d\",&D,&G); int sum=10; for(int i=1,tmp; i<=G; ++i) { scanf(\"%d\",&tmp); ++cnt[tmp]; scanf(\"%d%d\",&c[tmp][cnt[tmp]].f,&c[tmp][cnt[tmp]].h); sum+=c[tmp][cnt[tmp]].f; } memset(f,-1,sizeof f); f[0][0]=10; for(int i=1; i<=sum; ++i) { for(int j=0; j<=cnt[i]; ++j) { tim[++tot]=i; for(int h=D; h>=0; --h) { int t1=tim[tot]-tim[tot-1]; if(c[i][j].h) { if(h>=c[i][j].h && f[tot-1][h-c[i][j].h]-t1>=0)f[tot][h]=max(f[tot][h],f[tot-1][h-c[i][j].h]-t1); if(f[tot-1][h]-t1>=0)f[tot][h]=max(f[tot][h],f[tot-1][h]-t1+c[i][j].f); } if(f[tot-1][h]-t1>=0)f[tot][h]=max(f[tot][h],f[tot-1][h]-t1); } } } int maxn=-1; for(int i=0; i<=tot; ++i) { for(int h=0; h<=D; ++h) { //cout<<f[i][h]<<\" \"; if(f[i][h]>=0)maxn=max(maxn,tim[i]); } //cout<<endl; if(f[i][D]>=0) { printf(\"%d\\n\",tim[i]); return 0; } } printf(\"%d\\n\",maxn); /*for(int i=0;i<=tot;++i){ cout<<tim[i]<<\" \"; }*/ return 0; } /* 100 4 5 4 9 9 3 2 12 6 10 13 1 1 */ P5662 \u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u60f3\u6cd5\uff1a\u6bcf\u5929\u5356\u7684\u4e1c\u897f\u5f53\u5929\u8fd8\u80fd\u4e70\u56de\u6765\u3002\u8fd9\u8ba9\u6211\u4eec\u80fd\u591f\u7b80\u5316\u72b6\u6001\u3002 \u6b64\u65f6\u5982\u679c\u6211\u4eec\u5411\u6301\u6709\u67d0\u7269\u54c1$n$\u5929\uff0c\u6211\u4eec\u5c31\u7b2c$1$\u5929\u4e70\uff0c\u7b2c$2$\u5929\u5356\uff0c\u518d\u7b2c$2$\u5929\u4e70\uff0c\u7b2c$3$\u5929\u5356\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002 \u8fd9\u6837\u6211\u4eec\u5c31\u4e0d\u9700\u8981\u8bb0\u5f55\u6bcf\u5929\u7269\u54c1\u7684\u4e2a\u6570\uff0c\u53ea\u9700\u8981\u8bb0\u5f55\u8f6c\u5929\u7684\u94b1\u6570\u5373\u53ef\u3002 \u8bbe$f[k]$\u8868\u793a\u7b2c$i$\u5929\uff0c\u7b2c$j$\u4e2a\u7269\u54c1\u65f6\u8fd8\u5269$k$\u5143\uff0c\u660e\u5929\u80fd\u83b7\u5f97\u7684\u6700\u5927\u7684\u94b1\u6570\u3002 \u90a3\u4e48\u6709: $$ f[k-c[i][j]]=max(f[k-c[i][j]],f[k]+c[i+1][j]-c[i][j]) $$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=110,M=10010,T=110; int n,m,t,ans; int c[T][N]; int f[M]; signed main(){ scanf(\"%lld%lld%lld\",&t,&n,&m); for(int i=1;i<=t;++i){ for(int j=1;j<=n;++j){ scanf(\"%lld\",&c[i][j]); } } f[m]=0; ans=m; for(int i=1;i<=t;++i){ memset(f,-1,sizeof f); f[ans]=ans; for(int j=1;j<=n;++j){ for(int k=ans;k>=c[i][j];--k){ if(f[k]==-1)continue; f[k-c[i][j]]=max(f[k-c[i][j]],f[k]+c[i+1][j]-c[i][j]); } } for(int i=0;i<=ans;++i)ans=max(ans,f[i]); } printf(\"%lld\",ans); return 0; }","title":"\u80cc\u5305\u603b\u7ed3"},{"location":"my%20past/OI/%E8%83%8C%E5%8C%85/#_1","text":"P3859 TJOI\u7684\u6c34\u9898\uff08\u9ec4\u9898\u96be\u5ea6\u7684\u7d2b\u9898\uff09 \u5b9a\u4e49f[j]\u8868\u793a\u7528\u4e86j\u65f6\u95f4\u65f6\u83b7\u5f97\u5b9d\u77f3\u7684\u6700\u5927\u4ef7\u503c\u3002~~\u662f\u7684\u53ea\u7528\u4e00\u7ef4\u6eda\u52a8\u5c31\u884c~~ \u56e0\u6b64\u8f6c\u79fb\u65b9\u7a0b\uff1a f[j]=max(max(f[j],f[j-1]),f[j-t]+v); \u53ef\u4ee5\u63d0\u524d\u628a\u5b9d\u77f3\u6309\u9650\u5236\u65f6\u95f4\u6392\u4e2a\u5e8f\uff0c\u4e5f\u53ef\u4ee5\u4e0d\u6392 P1049 \u80cc\u5305\u7684\u7b80\u5355\u53d8\u5f62\u3002 \u8bbef[i] (bool\u7c7b\u578b)\u4e3a\u80fd\u5426\u5c06i\u7684\u7a7a\u95f4\u88c5\u6ee1\u3002\u5219\u8f6c\u79fb\u65b9\u7a0b: f[0]=1; for(int i=1;i<=n;++i){ for(int j=v;j>=a[i];--j){ if(f[j-a[i]])f[j]=1; } } P1064 \u4e00\u9053\u597d\u9898 \u56e0\u4e3a\u6bcf\u4e2a\u7269\u54c1\u7684\u72b6\u6001\u603b\u5171\u5c313\u79cd\uff0c\u5373\u81ea\u5df1\uff0c\u5de6\u513f\u5b50\u548c\u53f3\u513f\u5b50\uff0c\u6240\u4ee5\u5c31\u8bbe\u6240\u6709\u7269\u54c1\u90fd\u6709\u513f\u5b50\u3002 \u8bbef[i]\u8868\u793a\u4ef7\u683c\u4e3ai\u65f6\u4ef7\u683c\u4e0e\u6743\u91cd\u7684\u4e58\u79ef\u6700\u5927\u503c\u3002\u5219\u8f6c\u79fb\u65b9\u7a0b\uff1a f[0]=0; ans=0; for(int i=1;i<=m;++i){ if(!v[i][0])continue; for(int j=n;j>=v[i][0];--j){ if(v[i][1] && v[i][2] && j>=v[i][0]+v[i][1]+v[i][2])f[j]=max(f[j],f[j-v[i][0]-v[i][1]-v[i][2]]+v[i][0]*w[i][0]+v[i][1]*w[i][1]+v[i][2]*w[i][2]); if(v[i][1] && j>=v[i][0]+v[i][1])f[j]=max(f[j],f[j-v[i][0]-v[i][1]]+v[i][0]*w[i][0]+v[i][1]*w[i][1]); if(v[i][2] && j>=v[i][0]+v[i][2])f[j]=max(f[j],f[j-v[i][0]-v[i][2]]+v[i][0]*w[i][0]+v[i][2]*w[i][2]); if(j>=v[i][0])f[j]=max(f[j],f[j-v[i][0]]+v[i][0]*w[i][0]); ans=max(f[j],ans); } } \u6ce8\u610f\u9644\u4ef6\u4e0d\u80fd\u5c06\u4ed6\u7684\u4e3b\u4ef6\u680f\u586b\u8fdb\u53bb(v[i][0],w[i][0])\u3002 //\u8bfb\u5165 for(int i=1;i<=m;++i){ scanf(\"%d%d%d\",&v1,&w1,&p1); if(p1==0)v[i][0]=v1,w[i][0]=w1; else{ if(v[p1][1])v[p1][2]=v1,w[p1][2]=w1; else v[p1][1]=v1,w[p1][1]=w1; } } P1651 \u8bbef[i][j]\u8868\u793a\u524di\u4e2a\u7269\u54c1\u642d\u51fa\u7684\u9ad8\u5ea6\u76f8\u5deej\u7684\u4e24\u4e2a\u5854\u4e2d\u6700\u9ad8\u7684\u5854\u7684\u9ad8\u5ea6\u3002 \u8fd9\u6837\u65e2\u80fd\u5c06\u72b6\u6001\u8868\u793a\u5168\uff0c\u53c8\u80fd\u907f\u514d\u7528\u4e24\u7ef4\u7684\u9ad8\u5ea6\u5bfc\u81f4MLE\u3002\u4e8b\u5b9e\u4e0ai\u90a3\u4e00\u7ef4\u53ef\u4ee5\u6eda\u5b58\u4f18\u5316\u6389\u3002 \u6ce8\u610f\u56e0\u4e3a\u8f6c\u79fb\u4e2d\u4f1a\u51fa\u73b0\u8d1f\u6570\uff0c\u6240\u4ee5\u8981\u5c06\u7b2c\u4e8c\u7ef4\u5f00\u4e24\u500d\uff0c\u5c06\u4e2d\u95f4\u70b9500000\u8bbe\u4e3a\u96f6\u70b9\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=1e6+10,M=53,P=1e6; int f[2][N]; int n; int a[M]; int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); int ans=-0x7fffffff; memset(f,-0x3f,sizeof f); f[0][500000]=0; for(int i=1;i<=n;++i){ for(int j=0;j<=P;++j){ f[i%2][j]=max(f[i%2][j],f[(i%2)^1][j]); if(j-a[i]>=0)f[i%2][j]=max(f[i%2][j],f[(i%2)^1][j-a[i]]+a[i]); if(j+a[i]<=P)f[i%2][j]=max(f[i%2][j],f[(i%2)^1][j+a[i]]); if(j==500000)ans=max(ans,f[i%2][j]); } } if(ans>0)printf(\"%d\",ans); else printf(\"-1\"); return 0; } /* 20 188242 313 1991 4207 2483 1763 224 16 582 22943 111653 23787 16820 12415 1270 3032 2293 5221 396 42 */ P4823 \u9996\u5148\u6709\u4e2a\u8d2a\u5fc3\u7684\u6027\u8d28\uff1a \u5bf9\u4e8e\u6bcf\u4e2a\u5c0f\u77ee\u4eba\uff0c\u4e00\u5b9a\u662f\u9003\u751f\u80fd\u529b\u5f31\uff0c\u5373$a+b$\u8f83\u5c0f\u7684\u4eba\u5148\u9003\u6bd4\u80fd\u529b\u5f3a\u7684\u4eba\u5148\u9003\u7684\u4e0d\u4f1a\u66f4\u5dee\u3002 \u56e0\u4e3a\u80fd\u529b\u5f31\u7684\u4eba\u5982\u679c\u4e0d\u5148\u9003\uff0c\u4ee5\u540e\u5c31\u53ef\u80fd\u9003\u4e0d\u51fa\u53bb\u4e86\u3002 \u4e0d\u4f1a\u51fa\u73b0\u80fd\u529b\u5f3a\u7684\u5148\u9003\u540e\u5f31\u7684\u80fd\u9003\uff0c\u800c\u5f31\u7684\u5148\u9003\u5f3a\u7684\u5c31\u9003\u4e0d\u4e86\u7684\u60c5\u51b5\u3002 \u53ea\u8981\u5f31\u7684\u9003\u4e86\u5f3a\u7684\u9003\u4e0d\u4e86\uff0c\u90a3\u5f3a\u7684\u9003\u4e86\u5f31\u7684\u4e5f\u8dd1\u4e0d\u4e86\u3002\u56e0\u4e3a\u540e\u4e00\u4e2a\u9003\u7684\u811a\u5e95\u4e0b\u9ad8\u5ea6\u662f\u4e00\u5b9a\u7684\u3002 \u6709\u4e86\u8fd9\u4e2a\u6027\u8d28\u540e\u5c31\u53ef\u4ee5\u7528\u80cc\u5305\u89e3\u51b3\u6bcf\u4e2a\u77ee\u4eba\u662f\u5426\u8981\u9003\u51fa\u53bb\u3002\u56e0\u4e3a\u53ef\u80fd\u5b83$a$\u7279\u522b\u5927\uff0c\u4e0d\u9003\u5bf9\u4eba\u68af\u7684\u8d21\u732e\u66f4\u5927\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=2200; struct node{ int a,b; }q[N]; bool cmp(node a,node b){ return a.a+a.b<b.a+b.b; } int n,h; int dp[N]; int main(){ memset(dp,-0x3f,sizeof dp); dp[0]=0; scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d%d\",&q[i].a,&q[i].b),dp[0]+=q[i].a; scanf(\"%d\",&h); sort(q+1,q+n+1,cmp); for(int i=1;i<=n;++i){ for(int j=i;j>=1;--j){ if(dp[j-1]+q[i].b>=h)dp[j]=max(dp[j],dp[j-1]-q[i].a); } } for(int i=n;i>=0;--i){ if(dp[i]>=0){ printf(\"%d\",i); return 0; } } return 0; } \u7ed3\u8bba\uff1a\u5f53\u80cc\u5305\u7684\u8f6c\u79fb\u6536\u5230\u987a\u5e8f\u5f71\u54cd\uff0c\u53c8\u4e0d\u80fd\u786e\u5b9a\u7269\u54c1\u62ff\u53d6\u7684\u5177\u4f53\u987a\u5e8f\uff0c\u53ef\u4ee5\u5bfb\u627e\u8d2a\u5fc3\u7684\u6027\u8d28,\u6392\u5e8f\u540e\u505a\u80cc\u5305\u3002 P3961 \u53ef\u4ee5\u7528\u659c\u7387\u5b58\u50a8\u6240\u6709\u70b9\u7684\u4fe1\u606f\uff0c\u6ce8\u610f\u5904\u7406$x=0$\u5373\u659c\u7387\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u3002 \u4e4b\u540e\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u7ec4\u91d1\u5b50\uff0c\u53ef\u4ee5\u5c06\u7b2c$i$\u4e2a\u7684\u65f6\u95f4\u4ef7\u503c\u548c\u524d$i-1$\u4e2a\u5e76\u518d\u4e00\u8d77\uff0c\u8868\u793a\u8fde\u7eed\u53d6$i$\u4e2a\u91d1\u5b50\u3002 \u5728\u505a\u80cc\u5305\u65f6\uff0c\u540c\u4e00\u7ec4\u53ea\u80fd\u9009\u4e00\u4e2a\uff0c\u6240\u4ee5\u6ce8\u610f\u987a\u5e8f\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=320,M=5e4+10,K=200; int f[M],top[N+N][N],nxt[N],head[N+N][N],l[N],r[N]; int n,T,cnt,tot; struct query{ int x,y,t,v; double k; }q[N]; struct item{ int t,v; }c[N]; bool cmp(query a,query b){ if(a.k==b.k)return a.y<b.y; else return a.k<b.k; } void print1(){ for(int i=1;i<=tot;++i){ for(int k=l[i];k<=r[i];++k){ cout<<c[k].t<<\" \"<<c[k].v<<endl; } } } signed main(){ scanf(\"%lld%lld\",&n,&T); for(int i=1;i<=n;++i){ scanf(\"%lld%lld%lld%lld\",&q[i].x,&q[i].y,&q[i].t,&q[i].v); if(q[i].x!=0)q[i].k=q[i].y*1.0/(q[i].x*1.0); else q[i].k=N; } sort(q+1,q+n+1,cmp); tot=0; for(int i=1;i<=n;++i){ int x=q[i].x,y=q[i].y; if(q[i].k!=q[i-1].k || i==1){ r[tot]=i-1; ++tot; l[tot]=i; } c[i].t+=q[i].t; c[i].v+=q[i].v; if(q[i].k==q[i-1].k && i!=1){ c[i].t+=c[i-1].t; c[i].v+=c[i-1].v; } } r[tot]=n; //print1(); //memset(f,-0x3f,sizeof f); f[0]=0; for(int i=1;i<=tot;++i){ for(int j=T;j>=c[l[i]].t;--j){ for(int k=l[i];k<=r[i];++k){ if(j>=c[k].t)f[j]=max(f[j],f[j-c[k].t]+c[k].v); } } } int maxn=0; for(int i=0;i<=T;++i){ maxn=max(maxn,f[i]); } printf(\"%lld\",maxn); return 0; } /* 4 17 0 10 2 3 -2 3 1 1 -4 6 2 2 -6 8 15 9 3 10 1 1 13 1 2 2 2 2 1 3 4 7 */ P1156 \u8fd9\u9898\u552f\u4e00\u7684\u5751\u70b9\u5c31\u662f\u540c\u4e00\u65f6\u95f4\u4f1a\u653e\u591a\u4e2a\u5783\u573e\u3002 \u8fd9\u65f6\u8981\u7528\u94fe\u8868/vector\u5b58\u50a8\u4e00\u4e0b\uff0c\u5e76\u4e14\u540c\u4e00\u65f6\u523b\u7684\u5783\u573e\u662f\u6709\u5148\u540e\u987a\u5e8f\u7684\uff0c\u5373\u9ad8\u5ea6\u53ef\u4ee5\u7d2f\u52a0\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=4400,T=1000,K=220; int f[N][K]; int D,G,tot; int cnt[N],tim[N]; struct node { int h,f; } c[N][K]; int main() { //freopen(\"P1156_2.in\",\"r\",stdin); scanf(\"%d%d\",&D,&G); int sum=10; for(int i=1,tmp; i<=G; ++i) { scanf(\"%d\",&tmp); ++cnt[tmp]; scanf(\"%d%d\",&c[tmp][cnt[tmp]].f,&c[tmp][cnt[tmp]].h); sum+=c[tmp][cnt[tmp]].f; } memset(f,-1,sizeof f); f[0][0]=10; for(int i=1; i<=sum; ++i) { for(int j=0; j<=cnt[i]; ++j) { tim[++tot]=i; for(int h=D; h>=0; --h) { int t1=tim[tot]-tim[tot-1]; if(c[i][j].h) { if(h>=c[i][j].h && f[tot-1][h-c[i][j].h]-t1>=0)f[tot][h]=max(f[tot][h],f[tot-1][h-c[i][j].h]-t1); if(f[tot-1][h]-t1>=0)f[tot][h]=max(f[tot][h],f[tot-1][h]-t1+c[i][j].f); } if(f[tot-1][h]-t1>=0)f[tot][h]=max(f[tot][h],f[tot-1][h]-t1); } } } int maxn=-1; for(int i=0; i<=tot; ++i) { for(int h=0; h<=D; ++h) { //cout<<f[i][h]<<\" \"; if(f[i][h]>=0)maxn=max(maxn,tim[i]); } //cout<<endl; if(f[i][D]>=0) { printf(\"%d\\n\",tim[i]); return 0; } } printf(\"%d\\n\",maxn); /*for(int i=0;i<=tot;++i){ cout<<tim[i]<<\" \"; }*/ return 0; } /* 100 4 5 4 9 9 3 2 12 6 10 13 1 1 */ P5662 \u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u60f3\u6cd5\uff1a\u6bcf\u5929\u5356\u7684\u4e1c\u897f\u5f53\u5929\u8fd8\u80fd\u4e70\u56de\u6765\u3002\u8fd9\u8ba9\u6211\u4eec\u80fd\u591f\u7b80\u5316\u72b6\u6001\u3002 \u6b64\u65f6\u5982\u679c\u6211\u4eec\u5411\u6301\u6709\u67d0\u7269\u54c1$n$\u5929\uff0c\u6211\u4eec\u5c31\u7b2c$1$\u5929\u4e70\uff0c\u7b2c$2$\u5929\u5356\uff0c\u518d\u7b2c$2$\u5929\u4e70\uff0c\u7b2c$3$\u5929\u5356\uff0c\u4ee5\u6b64\u7c7b\u63a8\u3002 \u8fd9\u6837\u6211\u4eec\u5c31\u4e0d\u9700\u8981\u8bb0\u5f55\u6bcf\u5929\u7269\u54c1\u7684\u4e2a\u6570\uff0c\u53ea\u9700\u8981\u8bb0\u5f55\u8f6c\u5929\u7684\u94b1\u6570\u5373\u53ef\u3002 \u8bbe$f[k]$\u8868\u793a\u7b2c$i$\u5929\uff0c\u7b2c$j$\u4e2a\u7269\u54c1\u65f6\u8fd8\u5269$k$\u5143\uff0c\u660e\u5929\u80fd\u83b7\u5f97\u7684\u6700\u5927\u7684\u94b1\u6570\u3002 \u90a3\u4e48\u6709: $$ f[k-c[i][j]]=max(f[k-c[i][j]],f[k]+c[i+1][j]-c[i][j]) $$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=110,M=10010,T=110; int n,m,t,ans; int c[T][N]; int f[M]; signed main(){ scanf(\"%lld%lld%lld\",&t,&n,&m); for(int i=1;i<=t;++i){ for(int j=1;j<=n;++j){ scanf(\"%lld\",&c[i][j]); } } f[m]=0; ans=m; for(int i=1;i<=t;++i){ memset(f,-1,sizeof f); f[ans]=ans; for(int j=1;j<=n;++j){ for(int k=ans;k>=c[i][j];--k){ if(f[k]==-1)continue; f[k-c[i][j]]=max(f[k-c[i][j]],f[k]+c[i+1][j]-c[i][j]); } } for(int i=0;i<=ans;++i)ans=max(ans,f[i]); } printf(\"%lld\",ans); return 0; }","title":"\u80cc\u5305\u603b\u7ed3"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/","text":"\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14 \u83ab\u6bd4\u4e4c\u65af\u51fd\u6570 \u5b9a\u4e49 1) \u83ab\u6bd4\u4e4c\u65af\u51fd\u6570$\\mu(n)$\u7684\u5b9a\u4e49\u57df\u662f$N$ 2) $\\mu(1)=1$ 3) \u5f53$n$\u5b58\u5728\u5e73\u65b9\u56e0\u5b50\u65f6,$\\mu(n)=0$ 4) \u5f53$n$\u662f\u7d20\u6570\u6216\u5947\u6570\u4e2a\u4e0d\u540c\u7d20\u6570\u4e4b\u79ef\u65f6,$\\mu(n)=-1$ 5) \u5f53$n$\u662f\u5076\u6570\u4e2a\u4e0d\u540c\u7d20\u6570\u4e4b\u79ef\u65f6,$\\mu(n)=1$ \u7ebf\u6027\u7b5b\u6c42$\\mu(n)$ void prime(){ mu[1]=1; for(int i=2;i<=n;++i){ if(!vis[i]) p[++m]=i,mu[i]=-1;//\u53ea\u6709\u4e00\u4e2a\u7d20\u56e0\u5b50\uff0c\u5219mu[n]=-1 for(int j=1;j<=m && p[j]*i<=n;++j){ vis[p[j]*i]=1; if(i%p[j]==0)break;//\u5982\u679cp[j]|i,\u8bf4\u660e\u4e00\u5b9a\u5b58\u5728\u5e73\u65b9\u56e0\u5b50\uff0c\u5219\u8df3\u8fc7\u4e0d\u66f4\u65b0mu[p[j]*i]\uff0c\u8fd9\u5c06\u610f\u5473\u7740mu[p[j]*i]\u6c38\u8fdc\u4e3a0 mu[p[j]*i]=-mu[i];//\u5982\u679cmu[i]=0,\u5219mu[p[j]*i]\u540c\u6837\u4e3a0\uff1b\u5982\u679cmu[i]!=0,\u5219mu[p[j]*i]\u52a0\u5165\u4e00\u4e2a\u65b0\u7684\u7d20\u56e0\u5b50p[j]\uff0c\u5e94\u5f53\u4e58-1 } } } \u6027\u8d28 1) \u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570$n$,$\\sum_{d|n}\\mu(d)=[n=1]$ 2) \u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570$n$,$\\sum_{d|n}\\frac{\\mu(d)}{d}=\\frac{\\phi(n)}{n}$ \u8bc1\u660e \u6027\u8d281. \u5f53$n=1$\u65f6\uff0c\u539f\u5f0f$=\\mu(1)=1$,\u6210\u7acb \u5f53$n\\not =1$\u65f6\uff0c\u5c06$n$\u5206\u89e3\u6210$p_1^{a_1}p_2^{a_2}...p_k^{a_k}$ \u53ea\u6709\u6240\u6709\u8d28\u56e0\u5b50\u7684\u4e2a\u6570\u4e3a$1$\u65f6$\\mu(d)$\u4e0d\u4e3a$0$,\u6240\u4ee5\u5047\u8bbe\u7531$x$\u4e2a\u4e0d\u540c\u8d28\u56e0\u5b50\u7684$d$\u6709$C_{k}^{x}$\u4e2a\uff0c\u5219 $$\\sum_{d|n}\\mu(d)=C_k^0-C_k^1+C_k^2-...=\\sum_{i=0}^k(-1)^iC_k^i\\ \u53c8\\because \u4e8c\u9879\u5f0f\u5c55\u5f00\u516c\u5f0f\u4e3a(X+Y)^n=\\sum_{i=0}^nC_n^iX^iY^{n-i}\\ \\therefore \u5e26\u5165X=-1,Y=1\\ \\sum_{i=0}^k(-1)^iC_k^i=[1+(-1)]^k=0 $$ \u6027\u8d282 $$ \u5373\u8bc1n\\sum_{d|n}\\frac{\\mu(d)}d=\\phi(n)\\ \u4ee4F(n)=n,f(n)=\\phi(n),\u5219\\ f(n)=n\\sum_{d|n}\\frac{\\mu(d)}d=\\sum_{d|n}\\frac{n\\mu(d)}d=\\sum_{d|n}\\mu(d)\\frac{n}d=\\sum_{d|n}\\mu(d)F(\\frac nd)\\ \u540c\u65f6\uff0c\u4e0a\u5f0f\u6210\u7acb\u7684\u6761\u4ef6\u662fF(n)=\\sum_{d|n}f(d),\u5373\\ n=\\sum_{d|n}\\phi(d)\\ \u8fd9\u4e2a\u5f0f\u5b50\u5728\u6b27\u62c9\u51fd\u6570\u7684\u7b14\u8bb0\u4e2d\u4ee5\u8bc1\u660e\u3002\\ \u6545\u539f\u547d\u9898\u5f97\u8bc1\u3002 $$ \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14 \u5b9a\u7406 $$\u8bbef(n)\u548cF(n)\u662f\u5b9a\u4e49\u5728\u6b63\u6574\u6570\u96c6\u5408\u4e0a\u7684\u4e24\u4e2a\u51fd\u6570\\ F(n)=\\sum_{d|n}f(d)=\\sum_{d|n}f(\\frac nd)\\ \u5219f(n)=\\sum_{d|n}\\mu(d)F(\\frac nd)=\\sum_{d|n}\\mu(\\frac nd)F(d)\\ \u6216\uff1a\\ F(n)=\\sum_{n|d}f(d)\\ \u5219f(n)=\\sum_{n|d}\\mu(\\frac dn)F(d)\\ $$ \u5957\u8def \u5957\u8def1:\u4f18\u5148\u679a\u4e3e$\\gcd k$ \u5957\u8def2:$\\gcd(i,j)=k\u7b49\u4ef7\u4e8e \\gcd(\\frac ik,\\frac jk)=1$ \u5957\u8def3:\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u7684\u6027\u8d28$\\sum_{d|n}\\mu(d)=[n=1]$ \u5957\u8def4:\u4f18\u5148\u679a\u4e3e$d$ \u5957\u8def5:\u8bbe$dk=T$ P2257 \u5e9f\u8bdd\u4e0d\u8bf4\uff0c\u76f4\u63a5\u5f00\u59cb\u63a8\u5bfc\u3002 $$ \u6c42\\sum_{i=1}^n\\sum_{j=1}^m [gcd(i,j)\\in prime]\\ =\\sum_{k=1}^n\\sum_{i=1}^n\\sum_{j=1}^m [gcd(i,j)=k] (k\\in prime)\\ = \\sum_{k=1}^n\\sum_{i=1}^{\\lfloor \\frac nk \\rfloor}\\sum_{j=1}^{\\lfloor \\frac mk\\rfloor } [gcd(i,j)=1] (k\\in prime)\\ \\because \\sum_{d|n}\\mu(d)=[n=1] \\ \\therefore \\sum_{d|\\gcd(i,j)}\\mu(d)=[\\gcd(i,j)=1]\\ \\therefore =\\sum_{k=1}^n\\sum_{i=1}^{\\lfloor \\frac nk \\rfloor}\\sum_{j=1}^{\\lfloor \\frac mk\\rfloor } \\sum_{d|\\gcd(i,j)}\\mu(d)(k\\in prime) \\ \\because d|\\gcd(i,j),\\therefore i,j\u662fd\u7684\u500d\u6570\\ \u53c8\\because d_{max}=\\lfloor \\frac nk\\rfloor\\ \\therefore = \\sum_{k=1}^n\\sum_{d=1}^{\\lfloor \\frac nk\\rfloor}\\mu(d) \\lfloor \\frac n{kd}\\rfloor \\lfloor \\frac m{kd}\\rfloor (k\\in prime)(\u6ce8_1) \\ \u8bbeT=kd,\u5219T_{max}=k \\lfloor \\frac nk\\rfloor=n\\ \\therefore \u539f\u5f0f=\\sum_{T=1}^n\\lfloor \\frac nT\\rfloor \\lfloor \\frac mT\\rfloor \\sum_{k|T,k\\in prime}\\mu(\\frac Tk)(\u6ce8_2) $$ \u8fd9\u6837\u540e\u9762\u53ef\u4ee5\u5728\u7ebf\u6027\u7b5b\u65f6\u505a$O(n)$\u9884\u5904\u7406+\u524d\u7f00\u548c\uff0c\u524d\u9762\u53ef\u4ee5\u505a$O(T\\sqrt n)$\u6574\u9664\u5206\u5757. #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=1e5+10,M=1e7+10; typedef long long ll; int p[M],mu[M],vis[M],sum[M],f[M]; int m,n,T; void prime(){ mu[1]=1; for(int i=2;i<M;++i){ if(!vis[i]) p[++m]=i,mu[i]=-1; for(int j=1;j<=m && p[j]*i<M;++j){ vis[p[j]*i]=1; if(i%p[j]==0){mu[p[j]*i]=0;break;} mu[p[j]*i]=-mu[i]; } } for(int j=1;j<=m;++j){ for(int i=1;i*p[j]<M;++i){ f[i*p[j]]+=mu[i]; } } for(int i=1;i<M;++i)sum[i]=sum[i-1]+f[i]; } void solve(){ ll ans=0; for(int l=1,r=0;l<=n;l=r+1){ r=min(n/(n/l),m/(m/l)); ans+=(ll)(sum[r]-sum[l-1])*(ll)(n/l)*(ll)(m/l); } printf(\"%lld\\n\",ans); } int main(){ prime(); scanf(\"%d\",&T); while(T--){ scanf(\"%d%d\",&n,&m);if(n>m)swap(n,m); solve(); } return 0; } $\u6ce8_1$:\u8fd9\u91cc\u7684\u53d8\u6362\u65f6\u56e0\u4e3a\u6bcf\u4e00\u4e2a$d$\u90fd\u7531\u8bb8\u591a\u4e2a$i\uff0cj$\u679a\u4e3e\u800c\u6765\uff0c\u6240\u4ee5\u679a\u4e3e$d$\u65f6\u76f4\u63a5\u4e58\u4e0a\u80fd\u8f6c\u79fb\u8fc7\u6765\u7684$i,j$\u7684\u6700\u5927\u4e2a\u6570\u5373\u53ef\uff0c\u800c$d$\u6700\u5927\u80fd\u53d6\u5230$n$ ($\\gcd(n,m)=n$\u65f6) $\u6ce8_2$:\u8fd9\u91cc\u7684\u53d8\u6362\u76f8\u5f53\u4e8e$1$\u7684\u9006\u64cd\u4f5c,$1$\u65f6\u7531\u5927\u53d8\u5c0f\uff0c\u800c$2$\u65f6\u7531\u5c0f\u53d8\u5927\u3002\u4e00\u4e2a$T$\u80fd\u8f6c\u79fb\u5230\u7684\u6240\u6709$d$\u4e3a$d=\\frac Tk (k|T,k\\in prime)$,\u6240\u4ee5\u5bf9\u8fd9\u4e9b$d$\u6709\u8d21\u732e$\\mu(\\frac Tk)$\uff0c\u8981\u52a0\u5728\u4e00\u8d77\u3002 ~~\u5168long long\u8ba1\u7b97\u771f\u7684\u6162\uff0c\u6bd4int\u8f6clong long \u6162\u4e00\u500d~~ P3455 \u6a21\u677f\u9898. \u8fd9\u91cc\u7ed9\u51fa\u4e00\u4e2a\u4e0eP2577\u4e0d\u540c\u7684\u63a8\u5f0f\u5b50\u7684\u65b9\u6cd5\uff0c\u5927\u540c\u5c0f\u5f02 $$f(k)=\\sum_{i=1}^a\\sum_{j=1}^b[gcd(i,j)=k]\\ F(n)=\\sum_{n|k}f(k)=\\lfloor\\frac an\\rfloor\\lfloor \\frac bn\\rfloor\\ f(n)=\\sum_{n|k}\\mu(\\lfloor \\frac kn\\rfloor)F(k) $$ \u4e4b\u540e\u9000\u51fa\u6765\u7684\u5f0f\u5b50\u4e0e\u7528$\\sum_{d|n}\\mu(d)=[n=1]$\u63a8\u51fa\u6765\u7684\u4e00\u6837\u3002 #include<iostream> #include<cstdio> #include<cstring> #define ll long long using namespace std; const int N=1e5+10,M=1e6+10; int a,b,d,n,m,T; int p[M],mu[M],vis[M],sum[M]; void prime(){ mu[1]=1; for(int i=2;i<M;++i){ if(!vis[i]) p[++m]=i,mu[i]=-1; for(int j=1;j<=m && i*p[j]<M;++j){ vis[i*p[j]]=1; if(i%p[j]==0) break; mu[i*p[j]]=-mu[i]; } } for(int i=1;i<M;++i)sum[i]=sum[i-1]+mu[i]; } void solve(){ ll ans=0; n=a/d,m=b/d; if(n>m)swap(n,m); for(int l=1,r=0;l<=n;l=r+1){ r=min(n/(n/l),m/(m/l)); ans+=(ll)(sum[r]-sum[l-1])*(ll)(n/l)*(ll)(m/l); } printf(\"%lld\\n\",ans); } int main(){ prime(); scanf(\"%d\",&T); for(int i=1;i<=T;++i){ scanf(\"%d%d%d\",&a,&b,&d); solve(); } return 0; } P3327 $$ \u5df2\u77e5d(i* j)=\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=1] (\u6ce8_1)\\ \u5219\u539f\u5f0f= \\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=1]\\ = \\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x|i}\\sum_{y|j}\\sum_{d|\\gcd(x,y)}\\mu(d)\\ \u5c06\u679a\u4e3e\u9879i,j\u6539\u4e3a\u679a\u4e3ex,y \\ =\\sum_{x=1}^n \\sum_{y=1}^m \\lfloor\\frac nx\\rfloor\\lfloor\\frac my\\rfloor \\sum_{d|\\gcd(x,y)}\\mu(d)\\ \u7ee7\u7eed\u679a\u4e3ed \\ =\\sum_{x=1}^n \\sum_{y=1}^m \\lfloor\\frac nx\\rfloor\\lfloor\\frac my\\rfloor \\sum_{d=1}^n\\mu(d)[d|\\gcd(x,y)]\\ \u56e0\u4e3a\\mu(d)\u4e0ex,y\u65e0\u5173\uff0c\u53ef\u4ee5\u63d0\u5230\u524d\u9762\u53bb\\ =\\sum_{d=1}^n\\mu(d)\\sum_{x=1}^n\\sum_{y=1}^m \\lfloor\\frac nx\\rfloor\\lfloor\\frac my\\rfloor [d|\\gcd(x,y)]\\ \u5c06\u679a\u4e3e\u9879x,y \u6539\u4e3adx,dy,\u5219[d|\\gcd(x,y)]\u6052\u6ee1\u8db3\uff0c\u53ef\u4ee5\u53bb\u6389\\ = \\sum_{d=1}^n\\mu(d)\\sum_{x=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{y=1}^{\\lfloor\\frac md\\rfloor} \\lfloor\\frac n{dx}\\rfloor\\lfloor\\frac m{dy}\\rfloor\\ = \\sum_{d=1}^n\\mu(d)\\sum_{x=1}^{\\lfloor\\frac nd\\rfloor}\\lfloor\\frac n{dx}\\rfloor\\sum_{y=1}^{\\lfloor\\frac md\\rfloor} \\lfloor\\frac m{dy}\\rfloor $$ \u6b64\u65f6\u540e\u9762\u4e24\u9879\u53ef\u4ee5$O(n\\sqrt n)$\u6574\u9664\u5206\u5757\u9884\u5904\u7406\u51fa$f$\u6570\u7ec4\uff0c\u524d\u9762\u4e5f\u53ef\u4ee5\u7528\u6574\u9664\u5206\u5757$O(T\\sqrt n)$\u505a\u3002 #include<iostream> #include<cstdio> #include<cstring> #define ll long long using namespace std; const int N=7e4+10; int p[N],vis[N],mu[N],sum[N]; int T,n,m,cnt; ll f[N]; void prime() { mu[1]=1; cnt=0; for(int i=2; i<N; ++i) { if(!vis[i])p[++cnt]=i,mu[i]=-1; for(int j=1; j<=cnt && i*p[j]<N; ++j) { vis[i*p[j]]=1; if(i%p[j]==0)break; mu[i*p[j]]=-mu[i]; } } for(int i=1; i<N; ++i) { ll ans=0; for(int l=1,r=0; l<=i; l=r+1) { r=(i/(i/l)); ans+=(ll)(r-l+1)*(ll)(i/l); } f[i]=ans; } for(int i=1; i<N; ++i)sum[i]=sum[i-1]+mu[i]; } void solve() { ll ans=0; for(int l=1,r=0; l<=n; l=r+1) { r=min(n/(n/l),m/(m/l)); ans+=(ll)(sum[r]-sum[l-1])*(ll)(f[m/l])*(ll)(f[n/l]); } printf(\"%lld\\n\",ans); } int main() { prime(); scanf(\"%d\",&T); for(int i=1; i<=T; ++i) { scanf(\"%d%d\",&n,&m);if(n>m) swap(n,m); solve(); } return 0; } $\u6ce8_1$:\u53ef\u4ee5\u5f53\u6210\u7ed3\u8bba\u7528\uff0c\u5177\u4f53\u8bc1\u660e\u53ef\u4ee5\u770b \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14-\u8ba9\u6211\u4eec\u4ece\u57fa\u7840\u5f00\u59cb- P1829 $$ \u6c42\\sum_{i=1}^n\\sum_{j=1}^m \\frac{i j}{\\gcd(i,j)}\\ = \\sum_{d=1}^n\\sum_{i=1}^n\\sum_{j=1}^m \\frac{i j}{d}[\\gcd(i,j)=d]\\ = \\sum_{d=1}^n\\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor} i j d[\\gcd(i,j)=1] (\u6ce8_1)\\ = \\sum_{d=1}^n\\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor} i j d\\sum_{k|\\gcd(i,j)}\\mu(k)\\ = \\sum_{d=1}^nd\\sum_{k=1}^{\\lfloor\\frac nd\\rfloor}\\mu(k)* k^2\\sum_{i=1}^{\\lfloor\\frac n{dk}\\rfloor}i\\sum_{j=1}^{\\lfloor\\frac n{dk}\\rfloor}j(\u6ce8_2) $$ \u6b64\u65f6\u53ef\u4ee5\u4e24\u6b21\u5206\u5757\u6765\u505a\uff0c\u4e00\u6b21\u5728$\\lfloor\\frac n{dk}\\rfloor$\u65f6\uff0c\u4e00\u6b21\u5728$\\lfloor\\frac nd\\rfloor$\u65f6\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(\\sqrt n * \\sqrt n)=O(n)$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e7+10,P=20101009,inv=10050505; int n,m,cnt; int vis[N],mu[N],p[N],sum[N]; void prime() { mu[1]=1;cnt=0; for(int i=2; i<N; ++i) { if(!vis[i])p[++cnt]=i,mu[i]=-1; for(int j=1; j<=cnt && i*p[j]<N; ++j) { vis[i*p[j]]=1; if(i%p[j]==0)break; mu[i*p[j]]=-mu[i]; } } for(int i=1; i<N; ++i)sum[i]=(sum[i-1]+i*i%P*mu[i])%P; } int _solve(int _n,int _m) { int tmp=0; for(int _l=1,_r=0; _l<=_n; _l=_r+1) { //k _r=min(_n/(_n/_l),_m/(_m/_l)); tmp=(tmp+ (sum[_r]-sum[_l-1])%P* (1+(_n/_l))%P*inv%P*(_n/_l)%P* (1+(_m/_l))%P*inv%P*(_m/_l)%P)%P; } return tmp; } int _solve1(int _n,int _m) { int tmp=0; for(int _l=1; _l<=_n; ++_l) { //k tmp=(tmp+mu[_l]*_l%P*_l%P*(1+_n/_l)%P*(_n/_l)%P*inv%P*(1+_m/_l)%P*(_m/_l)%P*inv%P)%P; } return tmp; } void solve1(){ int ans=0; for(int l=1; l<=n; ++l) { //d int _n=n/l,_m=m/l; int tmp=_solve(_n,_m); ans=(ans+ l*tmp%P)%P; } ans=(ans%P+P)%P; printf(\"%lld\",ans); } void solve() { int ans=0; for(int l=1,r=0; l<=n; l=r+1) { //d r=min(n/(n/l),m/(m/l)); int _n=n/l,_m=m/l; int tmp=_solve(_n,_m); ans=(ans+ ((l+r)*inv%P*(r-l+1))%P*tmp)%P; } ans=(ans%P+P)%P; printf(\"%lld\",ans); } signed main() { prime(); scanf(\"%lld%lld\",&n,&m); if(n>m)swap(n,m); solve(); return 0; } ~~\u5341\u5e74OI\u4e00\u573a\u7a7a\uff0c\u4e0d\u5f00long long \u89c1\u7956\u5b97\uff1b\u53d6\u6a21\u64cd\u4f5c\u4e5f\u4e0d\u8981\u541d\u556c\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5c3d\u53ef\u80fd\u5730\u591a\u819c\u4e00\u819c\uff0c\u9632\u6b62\u6ea2\u51fa\u4ece\u4f60\u6211\u505a\u8d77~~ $\u6ce8_1:$\u8fd9\u91cc\u4ece\u9664\u4ee5$d$\u53d8\u6210\u4e58$d$,\u5373\u5728\u539f\u59cb\u57fa\u7840\u4e0a\u4e58\u4e86$d^2$\uff0c\u662f\u56e0\u4e3a$i,j$\u5730\u8303\u56f4\u90fd\u7f29\u5c0f\u4e86$d$\uff0c\u800c\u4e0d\u80fd\u5ffd\u7565\u540e\u9762\u5730$i* j$ $\u6ce8_2:$\u4e58$k^2$\u5730\u539f\u56e0\u540c $\u6ce8_1$ P3911 $$ \u8bbec_i\u8868\u793ai\u51fa\u73b0\u7684\u4e2a\u6570\uff0c\u5219\u539f\u9898\u6c42\\ \\sum_{i=1}^N\\sum_{j=1}^N\\frac{i j}{\\gcd(i,j)} c_i c_j,N\u8868\u793a\\max_{i=1}^nA_i\\ 1.\\ = \\sum_{d=1}^N\\sum_{i=1}^N\\sum_{j=1}^N\\frac{i j}{d} c_i * c_j [\\gcd(i,j)=d]\\ = \\sum_{d=1}^N \\sum_{i=1}^{\\lfloor \\frac Nd\\rfloor} \\sum_{j=1}^{\\lfloor\\frac Nd \\rfloor}i j d c_{d i} * c_{d j} \\gcd(i,j)=1 \\ =\\sum_{d=1}^N \\sum_{i=1}^{\\lfloor \\frac Nd\\rfloor} \\sum_{j=1}^{\\lfloor\\frac Nd \\rfloor}i j d* c_{d i} * c_{d j} \\sum_{k|\\gcd(i,j)}\\mu(k)\\ \\ =\\sum_{d=1}^Nd\\sum_{k=1}^{\\lfloor\\frac Nd \\rfloor}\\mu(k) k^2(\\sum_{i=1}^{\\lfloor\\frac N {dk}\\rfloor}i c_{kdi})(\\sum_{j=1}^{\\lfloor\\frac N {dk}\\rfloor}j c_{kdj})\\ 2.\\ = \\sum_{d=1}^N\\sum_{i=1}^N\\sum_{j=1}^N\\frac{i j}{d} c_i * c_j [\\gcd(i,j)=d]\\ = \\sum_{d=1}^N \\sum_{i=1}^{\\lfloor \\frac Nd\\rfloor} \\sum_{j=1}^{\\lfloor\\frac Nd \\rfloor}i j d c_{d i} * c_{d j} [\\gcd(i,j)=1]\\ =\\sum_{d=1}^N \\sum_{i=1}^{\\lfloor \\frac Nd\\rfloor} \\sum_{j=1}^{\\lfloor\\frac Nd \\rfloor}i j d c_{d i} * c_{d j} \\sum_{k|\\gcd(i,j)}\\mu(k)\\ =\\sum_{d=1}^N d\\sum_{k=1}^{\\lfloor \\frac Nd\\rfloor}\\mu(k)k^2\\sum_{i=1}^{\\lfloor \\frac N{kd}\\rfloor} \\sum_{j=1}^{\\lfloor\\frac N{kd} \\rfloor}i j * c_{d ki} * c_{d kj} \\ \u8bbeT=dk,\u5219\\ = \\sum_{T=1}^N T(\\sum_{i=1}^{\\lfloor \\frac NT \\rfloor} i c_{iT})^2 \\sum_{k|T}\\mu(k)k $$ * $\u6ce8_1:$\u56e0\u4e3a$i,j$\u7684\u5927\u5c0f\u51cf\u5c0f\uff0c\u800c$c$\u7684\u4e0b\u6807\u4e0d\u80fd\u53d8\uff0c\u6240\u4ee5\u4e00\u5b9a\u8981\u4e58$d$","title":"\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#_1","text":"","title":"\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#_2","text":"","title":"\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#_3","text":"1) \u83ab\u6bd4\u4e4c\u65af\u51fd\u6570$\\mu(n)$\u7684\u5b9a\u4e49\u57df\u662f$N$ 2) $\\mu(1)=1$ 3) \u5f53$n$\u5b58\u5728\u5e73\u65b9\u56e0\u5b50\u65f6,$\\mu(n)=0$ 4) \u5f53$n$\u662f\u7d20\u6570\u6216\u5947\u6570\u4e2a\u4e0d\u540c\u7d20\u6570\u4e4b\u79ef\u65f6,$\\mu(n)=-1$ 5) \u5f53$n$\u662f\u5076\u6570\u4e2a\u4e0d\u540c\u7d20\u6570\u4e4b\u79ef\u65f6,$\\mu(n)=1$","title":"\u5b9a\u4e49"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#mun","text":"void prime(){ mu[1]=1; for(int i=2;i<=n;++i){ if(!vis[i]) p[++m]=i,mu[i]=-1;//\u53ea\u6709\u4e00\u4e2a\u7d20\u56e0\u5b50\uff0c\u5219mu[n]=-1 for(int j=1;j<=m && p[j]*i<=n;++j){ vis[p[j]*i]=1; if(i%p[j]==0)break;//\u5982\u679cp[j]|i,\u8bf4\u660e\u4e00\u5b9a\u5b58\u5728\u5e73\u65b9\u56e0\u5b50\uff0c\u5219\u8df3\u8fc7\u4e0d\u66f4\u65b0mu[p[j]*i]\uff0c\u8fd9\u5c06\u610f\u5473\u7740mu[p[j]*i]\u6c38\u8fdc\u4e3a0 mu[p[j]*i]=-mu[i];//\u5982\u679cmu[i]=0,\u5219mu[p[j]*i]\u540c\u6837\u4e3a0\uff1b\u5982\u679cmu[i]!=0,\u5219mu[p[j]*i]\u52a0\u5165\u4e00\u4e2a\u65b0\u7684\u7d20\u56e0\u5b50p[j]\uff0c\u5e94\u5f53\u4e58-1 } } }","title":"\u7ebf\u6027\u7b5b\u6c42$\\mu(n)$"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#_4","text":"1) \u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570$n$,$\\sum_{d|n}\\mu(d)=[n=1]$ 2) \u5bf9\u4e8e\u4efb\u610f\u6b63\u6574\u6570$n$,$\\sum_{d|n}\\frac{\\mu(d)}{d}=\\frac{\\phi(n)}{n}$","title":"\u6027\u8d28"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#_5","text":"","title":"\u8bc1\u660e"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#1","text":"\u5f53$n=1$\u65f6\uff0c\u539f\u5f0f$=\\mu(1)=1$,\u6210\u7acb \u5f53$n\\not =1$\u65f6\uff0c\u5c06$n$\u5206\u89e3\u6210$p_1^{a_1}p_2^{a_2}...p_k^{a_k}$ \u53ea\u6709\u6240\u6709\u8d28\u56e0\u5b50\u7684\u4e2a\u6570\u4e3a$1$\u65f6$\\mu(d)$\u4e0d\u4e3a$0$,\u6240\u4ee5\u5047\u8bbe\u7531$x$\u4e2a\u4e0d\u540c\u8d28\u56e0\u5b50\u7684$d$\u6709$C_{k}^{x}$\u4e2a\uff0c\u5219 $$\\sum_{d|n}\\mu(d)=C_k^0-C_k^1+C_k^2-...=\\sum_{i=0}^k(-1)^iC_k^i\\ \u53c8\\because \u4e8c\u9879\u5f0f\u5c55\u5f00\u516c\u5f0f\u4e3a(X+Y)^n=\\sum_{i=0}^nC_n^iX^iY^{n-i}\\ \\therefore \u5e26\u5165X=-1,Y=1\\ \\sum_{i=0}^k(-1)^iC_k^i=[1+(-1)]^k=0 $$","title":"\u6027\u8d281."},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#2","text":"$$ \u5373\u8bc1n\\sum_{d|n}\\frac{\\mu(d)}d=\\phi(n)\\ \u4ee4F(n)=n,f(n)=\\phi(n),\u5219\\ f(n)=n\\sum_{d|n}\\frac{\\mu(d)}d=\\sum_{d|n}\\frac{n\\mu(d)}d=\\sum_{d|n}\\mu(d)\\frac{n}d=\\sum_{d|n}\\mu(d)F(\\frac nd)\\ \u540c\u65f6\uff0c\u4e0a\u5f0f\u6210\u7acb\u7684\u6761\u4ef6\u662fF(n)=\\sum_{d|n}f(d),\u5373\\ n=\\sum_{d|n}\\phi(d)\\ \u8fd9\u4e2a\u5f0f\u5b50\u5728\u6b27\u62c9\u51fd\u6570\u7684\u7b14\u8bb0\u4e2d\u4ee5\u8bc1\u660e\u3002\\ \u6545\u539f\u547d\u9898\u5f97\u8bc1\u3002 $$","title":"\u6027\u8d282"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#_6","text":"","title":"\u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#_7","text":"$$\u8bbef(n)\u548cF(n)\u662f\u5b9a\u4e49\u5728\u6b63\u6574\u6570\u96c6\u5408\u4e0a\u7684\u4e24\u4e2a\u51fd\u6570\\ F(n)=\\sum_{d|n}f(d)=\\sum_{d|n}f(\\frac nd)\\ \u5219f(n)=\\sum_{d|n}\\mu(d)F(\\frac nd)=\\sum_{d|n}\\mu(\\frac nd)F(d)\\ \u6216\uff1a\\ F(n)=\\sum_{n|d}f(d)\\ \u5219f(n)=\\sum_{n|d}\\mu(\\frac dn)F(d)\\ $$","title":"\u5b9a\u7406"},{"location":"my%20past/OI/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/#_8","text":"\u5957\u8def1:\u4f18\u5148\u679a\u4e3e$\\gcd k$ \u5957\u8def2:$\\gcd(i,j)=k\u7b49\u4ef7\u4e8e \\gcd(\\frac ik,\\frac jk)=1$ \u5957\u8def3:\u83ab\u6bd4\u4e4c\u65af\u51fd\u6570\u7684\u6027\u8d28$\\sum_{d|n}\\mu(d)=[n=1]$ \u5957\u8def4:\u4f18\u5148\u679a\u4e3e$d$ \u5957\u8def5:\u8bbe$dk=T$ P2257 \u5e9f\u8bdd\u4e0d\u8bf4\uff0c\u76f4\u63a5\u5f00\u59cb\u63a8\u5bfc\u3002 $$ \u6c42\\sum_{i=1}^n\\sum_{j=1}^m [gcd(i,j)\\in prime]\\ =\\sum_{k=1}^n\\sum_{i=1}^n\\sum_{j=1}^m [gcd(i,j)=k] (k\\in prime)\\ = \\sum_{k=1}^n\\sum_{i=1}^{\\lfloor \\frac nk \\rfloor}\\sum_{j=1}^{\\lfloor \\frac mk\\rfloor } [gcd(i,j)=1] (k\\in prime)\\ \\because \\sum_{d|n}\\mu(d)=[n=1] \\ \\therefore \\sum_{d|\\gcd(i,j)}\\mu(d)=[\\gcd(i,j)=1]\\ \\therefore =\\sum_{k=1}^n\\sum_{i=1}^{\\lfloor \\frac nk \\rfloor}\\sum_{j=1}^{\\lfloor \\frac mk\\rfloor } \\sum_{d|\\gcd(i,j)}\\mu(d)(k\\in prime) \\ \\because d|\\gcd(i,j),\\therefore i,j\u662fd\u7684\u500d\u6570\\ \u53c8\\because d_{max}=\\lfloor \\frac nk\\rfloor\\ \\therefore = \\sum_{k=1}^n\\sum_{d=1}^{\\lfloor \\frac nk\\rfloor}\\mu(d) \\lfloor \\frac n{kd}\\rfloor \\lfloor \\frac m{kd}\\rfloor (k\\in prime)(\u6ce8_1) \\ \u8bbeT=kd,\u5219T_{max}=k \\lfloor \\frac nk\\rfloor=n\\ \\therefore \u539f\u5f0f=\\sum_{T=1}^n\\lfloor \\frac nT\\rfloor \\lfloor \\frac mT\\rfloor \\sum_{k|T,k\\in prime}\\mu(\\frac Tk)(\u6ce8_2) $$ \u8fd9\u6837\u540e\u9762\u53ef\u4ee5\u5728\u7ebf\u6027\u7b5b\u65f6\u505a$O(n)$\u9884\u5904\u7406+\u524d\u7f00\u548c\uff0c\u524d\u9762\u53ef\u4ee5\u505a$O(T\\sqrt n)$\u6574\u9664\u5206\u5757. #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=1e5+10,M=1e7+10; typedef long long ll; int p[M],mu[M],vis[M],sum[M],f[M]; int m,n,T; void prime(){ mu[1]=1; for(int i=2;i<M;++i){ if(!vis[i]) p[++m]=i,mu[i]=-1; for(int j=1;j<=m && p[j]*i<M;++j){ vis[p[j]*i]=1; if(i%p[j]==0){mu[p[j]*i]=0;break;} mu[p[j]*i]=-mu[i]; } } for(int j=1;j<=m;++j){ for(int i=1;i*p[j]<M;++i){ f[i*p[j]]+=mu[i]; } } for(int i=1;i<M;++i)sum[i]=sum[i-1]+f[i]; } void solve(){ ll ans=0; for(int l=1,r=0;l<=n;l=r+1){ r=min(n/(n/l),m/(m/l)); ans+=(ll)(sum[r]-sum[l-1])*(ll)(n/l)*(ll)(m/l); } printf(\"%lld\\n\",ans); } int main(){ prime(); scanf(\"%d\",&T); while(T--){ scanf(\"%d%d\",&n,&m);if(n>m)swap(n,m); solve(); } return 0; } $\u6ce8_1$:\u8fd9\u91cc\u7684\u53d8\u6362\u65f6\u56e0\u4e3a\u6bcf\u4e00\u4e2a$d$\u90fd\u7531\u8bb8\u591a\u4e2a$i\uff0cj$\u679a\u4e3e\u800c\u6765\uff0c\u6240\u4ee5\u679a\u4e3e$d$\u65f6\u76f4\u63a5\u4e58\u4e0a\u80fd\u8f6c\u79fb\u8fc7\u6765\u7684$i,j$\u7684\u6700\u5927\u4e2a\u6570\u5373\u53ef\uff0c\u800c$d$\u6700\u5927\u80fd\u53d6\u5230$n$ ($\\gcd(n,m)=n$\u65f6) $\u6ce8_2$:\u8fd9\u91cc\u7684\u53d8\u6362\u76f8\u5f53\u4e8e$1$\u7684\u9006\u64cd\u4f5c,$1$\u65f6\u7531\u5927\u53d8\u5c0f\uff0c\u800c$2$\u65f6\u7531\u5c0f\u53d8\u5927\u3002\u4e00\u4e2a$T$\u80fd\u8f6c\u79fb\u5230\u7684\u6240\u6709$d$\u4e3a$d=\\frac Tk (k|T,k\\in prime)$,\u6240\u4ee5\u5bf9\u8fd9\u4e9b$d$\u6709\u8d21\u732e$\\mu(\\frac Tk)$\uff0c\u8981\u52a0\u5728\u4e00\u8d77\u3002 ~~\u5168long long\u8ba1\u7b97\u771f\u7684\u6162\uff0c\u6bd4int\u8f6clong long \u6162\u4e00\u500d~~ P3455 \u6a21\u677f\u9898. \u8fd9\u91cc\u7ed9\u51fa\u4e00\u4e2a\u4e0eP2577\u4e0d\u540c\u7684\u63a8\u5f0f\u5b50\u7684\u65b9\u6cd5\uff0c\u5927\u540c\u5c0f\u5f02 $$f(k)=\\sum_{i=1}^a\\sum_{j=1}^b[gcd(i,j)=k]\\ F(n)=\\sum_{n|k}f(k)=\\lfloor\\frac an\\rfloor\\lfloor \\frac bn\\rfloor\\ f(n)=\\sum_{n|k}\\mu(\\lfloor \\frac kn\\rfloor)F(k) $$ \u4e4b\u540e\u9000\u51fa\u6765\u7684\u5f0f\u5b50\u4e0e\u7528$\\sum_{d|n}\\mu(d)=[n=1]$\u63a8\u51fa\u6765\u7684\u4e00\u6837\u3002 #include<iostream> #include<cstdio> #include<cstring> #define ll long long using namespace std; const int N=1e5+10,M=1e6+10; int a,b,d,n,m,T; int p[M],mu[M],vis[M],sum[M]; void prime(){ mu[1]=1; for(int i=2;i<M;++i){ if(!vis[i]) p[++m]=i,mu[i]=-1; for(int j=1;j<=m && i*p[j]<M;++j){ vis[i*p[j]]=1; if(i%p[j]==0) break; mu[i*p[j]]=-mu[i]; } } for(int i=1;i<M;++i)sum[i]=sum[i-1]+mu[i]; } void solve(){ ll ans=0; n=a/d,m=b/d; if(n>m)swap(n,m); for(int l=1,r=0;l<=n;l=r+1){ r=min(n/(n/l),m/(m/l)); ans+=(ll)(sum[r]-sum[l-1])*(ll)(n/l)*(ll)(m/l); } printf(\"%lld\\n\",ans); } int main(){ prime(); scanf(\"%d\",&T); for(int i=1;i<=T;++i){ scanf(\"%d%d%d\",&a,&b,&d); solve(); } return 0; } P3327 $$ \u5df2\u77e5d(i* j)=\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=1] (\u6ce8_1)\\ \u5219\u539f\u5f0f= \\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x|i}\\sum_{y|j}[\\gcd(x,y)=1]\\ = \\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x|i}\\sum_{y|j}\\sum_{d|\\gcd(x,y)}\\mu(d)\\ \u5c06\u679a\u4e3e\u9879i,j\u6539\u4e3a\u679a\u4e3ex,y \\ =\\sum_{x=1}^n \\sum_{y=1}^m \\lfloor\\frac nx\\rfloor\\lfloor\\frac my\\rfloor \\sum_{d|\\gcd(x,y)}\\mu(d)\\ \u7ee7\u7eed\u679a\u4e3ed \\ =\\sum_{x=1}^n \\sum_{y=1}^m \\lfloor\\frac nx\\rfloor\\lfloor\\frac my\\rfloor \\sum_{d=1}^n\\mu(d)[d|\\gcd(x,y)]\\ \u56e0\u4e3a\\mu(d)\u4e0ex,y\u65e0\u5173\uff0c\u53ef\u4ee5\u63d0\u5230\u524d\u9762\u53bb\\ =\\sum_{d=1}^n\\mu(d)\\sum_{x=1}^n\\sum_{y=1}^m \\lfloor\\frac nx\\rfloor\\lfloor\\frac my\\rfloor [d|\\gcd(x,y)]\\ \u5c06\u679a\u4e3e\u9879x,y \u6539\u4e3adx,dy,\u5219[d|\\gcd(x,y)]\u6052\u6ee1\u8db3\uff0c\u53ef\u4ee5\u53bb\u6389\\ = \\sum_{d=1}^n\\mu(d)\\sum_{x=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{y=1}^{\\lfloor\\frac md\\rfloor} \\lfloor\\frac n{dx}\\rfloor\\lfloor\\frac m{dy}\\rfloor\\ = \\sum_{d=1}^n\\mu(d)\\sum_{x=1}^{\\lfloor\\frac nd\\rfloor}\\lfloor\\frac n{dx}\\rfloor\\sum_{y=1}^{\\lfloor\\frac md\\rfloor} \\lfloor\\frac m{dy}\\rfloor $$ \u6b64\u65f6\u540e\u9762\u4e24\u9879\u53ef\u4ee5$O(n\\sqrt n)$\u6574\u9664\u5206\u5757\u9884\u5904\u7406\u51fa$f$\u6570\u7ec4\uff0c\u524d\u9762\u4e5f\u53ef\u4ee5\u7528\u6574\u9664\u5206\u5757$O(T\\sqrt n)$\u505a\u3002 #include<iostream> #include<cstdio> #include<cstring> #define ll long long using namespace std; const int N=7e4+10; int p[N],vis[N],mu[N],sum[N]; int T,n,m,cnt; ll f[N]; void prime() { mu[1]=1; cnt=0; for(int i=2; i<N; ++i) { if(!vis[i])p[++cnt]=i,mu[i]=-1; for(int j=1; j<=cnt && i*p[j]<N; ++j) { vis[i*p[j]]=1; if(i%p[j]==0)break; mu[i*p[j]]=-mu[i]; } } for(int i=1; i<N; ++i) { ll ans=0; for(int l=1,r=0; l<=i; l=r+1) { r=(i/(i/l)); ans+=(ll)(r-l+1)*(ll)(i/l); } f[i]=ans; } for(int i=1; i<N; ++i)sum[i]=sum[i-1]+mu[i]; } void solve() { ll ans=0; for(int l=1,r=0; l<=n; l=r+1) { r=min(n/(n/l),m/(m/l)); ans+=(ll)(sum[r]-sum[l-1])*(ll)(f[m/l])*(ll)(f[n/l]); } printf(\"%lld\\n\",ans); } int main() { prime(); scanf(\"%d\",&T); for(int i=1; i<=T; ++i) { scanf(\"%d%d\",&n,&m);if(n>m) swap(n,m); solve(); } return 0; } $\u6ce8_1$:\u53ef\u4ee5\u5f53\u6210\u7ed3\u8bba\u7528\uff0c\u5177\u4f53\u8bc1\u660e\u53ef\u4ee5\u770b \u83ab\u6bd4\u4e4c\u65af\u53cd\u6f14-\u8ba9\u6211\u4eec\u4ece\u57fa\u7840\u5f00\u59cb- P1829 $$ \u6c42\\sum_{i=1}^n\\sum_{j=1}^m \\frac{i j}{\\gcd(i,j)}\\ = \\sum_{d=1}^n\\sum_{i=1}^n\\sum_{j=1}^m \\frac{i j}{d}[\\gcd(i,j)=d]\\ = \\sum_{d=1}^n\\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor} i j d[\\gcd(i,j)=1] (\u6ce8_1)\\ = \\sum_{d=1}^n\\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor} i j d\\sum_{k|\\gcd(i,j)}\\mu(k)\\ = \\sum_{d=1}^nd\\sum_{k=1}^{\\lfloor\\frac nd\\rfloor}\\mu(k)* k^2\\sum_{i=1}^{\\lfloor\\frac n{dk}\\rfloor}i\\sum_{j=1}^{\\lfloor\\frac n{dk}\\rfloor}j(\u6ce8_2) $$ \u6b64\u65f6\u53ef\u4ee5\u4e24\u6b21\u5206\u5757\u6765\u505a\uff0c\u4e00\u6b21\u5728$\\lfloor\\frac n{dk}\\rfloor$\u65f6\uff0c\u4e00\u6b21\u5728$\\lfloor\\frac nd\\rfloor$\u65f6\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(\\sqrt n * \\sqrt n)=O(n)$ #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=1e7+10,P=20101009,inv=10050505; int n,m,cnt; int vis[N],mu[N],p[N],sum[N]; void prime() { mu[1]=1;cnt=0; for(int i=2; i<N; ++i) { if(!vis[i])p[++cnt]=i,mu[i]=-1; for(int j=1; j<=cnt && i*p[j]<N; ++j) { vis[i*p[j]]=1; if(i%p[j]==0)break; mu[i*p[j]]=-mu[i]; } } for(int i=1; i<N; ++i)sum[i]=(sum[i-1]+i*i%P*mu[i])%P; } int _solve(int _n,int _m) { int tmp=0; for(int _l=1,_r=0; _l<=_n; _l=_r+1) { //k _r=min(_n/(_n/_l),_m/(_m/_l)); tmp=(tmp+ (sum[_r]-sum[_l-1])%P* (1+(_n/_l))%P*inv%P*(_n/_l)%P* (1+(_m/_l))%P*inv%P*(_m/_l)%P)%P; } return tmp; } int _solve1(int _n,int _m) { int tmp=0; for(int _l=1; _l<=_n; ++_l) { //k tmp=(tmp+mu[_l]*_l%P*_l%P*(1+_n/_l)%P*(_n/_l)%P*inv%P*(1+_m/_l)%P*(_m/_l)%P*inv%P)%P; } return tmp; } void solve1(){ int ans=0; for(int l=1; l<=n; ++l) { //d int _n=n/l,_m=m/l; int tmp=_solve(_n,_m); ans=(ans+ l*tmp%P)%P; } ans=(ans%P+P)%P; printf(\"%lld\",ans); } void solve() { int ans=0; for(int l=1,r=0; l<=n; l=r+1) { //d r=min(n/(n/l),m/(m/l)); int _n=n/l,_m=m/l; int tmp=_solve(_n,_m); ans=(ans+ ((l+r)*inv%P*(r-l+1))%P*tmp)%P; } ans=(ans%P+P)%P; printf(\"%lld\",ans); } signed main() { prime(); scanf(\"%lld%lld\",&n,&m); if(n>m)swap(n,m); solve(); return 0; } ~~\u5341\u5e74OI\u4e00\u573a\u7a7a\uff0c\u4e0d\u5f00long long \u89c1\u7956\u5b97\uff1b\u53d6\u6a21\u64cd\u4f5c\u4e5f\u4e0d\u8981\u541d\u556c\u65f6\u95f4\u590d\u6742\u5ea6\uff0c\u5c3d\u53ef\u80fd\u5730\u591a\u819c\u4e00\u819c\uff0c\u9632\u6b62\u6ea2\u51fa\u4ece\u4f60\u6211\u505a\u8d77~~ $\u6ce8_1:$\u8fd9\u91cc\u4ece\u9664\u4ee5$d$\u53d8\u6210\u4e58$d$,\u5373\u5728\u539f\u59cb\u57fa\u7840\u4e0a\u4e58\u4e86$d^2$\uff0c\u662f\u56e0\u4e3a$i,j$\u5730\u8303\u56f4\u90fd\u7f29\u5c0f\u4e86$d$\uff0c\u800c\u4e0d\u80fd\u5ffd\u7565\u540e\u9762\u5730$i* j$ $\u6ce8_2:$\u4e58$k^2$\u5730\u539f\u56e0\u540c $\u6ce8_1$ P3911 $$ \u8bbec_i\u8868\u793ai\u51fa\u73b0\u7684\u4e2a\u6570\uff0c\u5219\u539f\u9898\u6c42\\ \\sum_{i=1}^N\\sum_{j=1}^N\\frac{i j}{\\gcd(i,j)} c_i c_j,N\u8868\u793a\\max_{i=1}^nA_i\\ 1.\\ = \\sum_{d=1}^N\\sum_{i=1}^N\\sum_{j=1}^N\\frac{i j}{d} c_i * c_j [\\gcd(i,j)=d]\\ = \\sum_{d=1}^N \\sum_{i=1}^{\\lfloor \\frac Nd\\rfloor} \\sum_{j=1}^{\\lfloor\\frac Nd \\rfloor}i j d c_{d i} * c_{d j} \\gcd(i,j)=1 \\ =\\sum_{d=1}^N \\sum_{i=1}^{\\lfloor \\frac Nd\\rfloor} \\sum_{j=1}^{\\lfloor\\frac Nd \\rfloor}i j d* c_{d i} * c_{d j} \\sum_{k|\\gcd(i,j)}\\mu(k)\\ \\ =\\sum_{d=1}^Nd\\sum_{k=1}^{\\lfloor\\frac Nd \\rfloor}\\mu(k) k^2(\\sum_{i=1}^{\\lfloor\\frac N {dk}\\rfloor}i c_{kdi})(\\sum_{j=1}^{\\lfloor\\frac N {dk}\\rfloor}j c_{kdj})\\ 2.\\ = \\sum_{d=1}^N\\sum_{i=1}^N\\sum_{j=1}^N\\frac{i j}{d} c_i * c_j [\\gcd(i,j)=d]\\ = \\sum_{d=1}^N \\sum_{i=1}^{\\lfloor \\frac Nd\\rfloor} \\sum_{j=1}^{\\lfloor\\frac Nd \\rfloor}i j d c_{d i} * c_{d j} [\\gcd(i,j)=1]\\ =\\sum_{d=1}^N \\sum_{i=1}^{\\lfloor \\frac Nd\\rfloor} \\sum_{j=1}^{\\lfloor\\frac Nd \\rfloor}i j d c_{d i} * c_{d j} \\sum_{k|\\gcd(i,j)}\\mu(k)\\ =\\sum_{d=1}^N d\\sum_{k=1}^{\\lfloor \\frac Nd\\rfloor}\\mu(k)k^2\\sum_{i=1}^{\\lfloor \\frac N{kd}\\rfloor} \\sum_{j=1}^{\\lfloor\\frac N{kd} \\rfloor}i j * c_{d ki} * c_{d kj} \\ \u8bbeT=dk,\u5219\\ = \\sum_{T=1}^N T(\\sum_{i=1}^{\\lfloor \\frac NT \\rfloor} i c_{iT})^2 \\sum_{k|T}\\mu(k)k $$ * $\u6ce8_1:$\u56e0\u4e3a$i,j$\u7684\u5927\u5c0f\u51cf\u5c0f\uff0c\u800c$c$\u7684\u4e0b\u6807\u4e0d\u80fd\u53d8\uff0c\u6240\u4ee5\u4e00\u5b9a\u8981\u4e58$d$","title":"\u5957\u8def"},{"location":"my%20past/OI/%E8%8E%AB%E9%98%9F/","text":"\u83ab\u961f ~~\u4f17\u6240\u5468\u77e5\uff0c\u83ab\u961f\u7b49\u4e8e\u5206\u5757+\u66b4\u529b~~ \u7528\u9014 \u79bb\u7ebf\u5904\u7406\u533a\u95f4\u8be2\u95ee\u95ee\u9898\uff0c\u5c24\u5176\u662f\u4e00\u4e9b\"\u4e0d\u6ee1\u8db3\u533a\u95f4\u53ef\u52a0\u6027\u6216\u53ef\u4e58\u6027\"\u7684\u95ee\u9898 \u539f\u7406 1.\u79bb\u7ebf\u7b97\u6cd5\uff0c\u5c06\u6240\u6709\u533a\u95f4\u8bfb\u4e0b\u6765 2.\u7ed9\u6240\u6709\u533a\u95f4\u5206\u5757\uff0c\u5206\u6210$\\sqrt{n}$\u5757 3.\u5c06\u6240\u6709\u533a\u95f4\u7684l\u6309\u7167\u5757\u7684\u987a\u5e8f\u6392\u5e8f 4.\u518d\u5c06\u540c\u4e00\u5757\u7684\u6240\u6709\u533a\u95f4\u6309\u7167r\u7684\u987a\u5e8f\u6392\u5e8f 5.\u7ef4\u62a4\u5de6\u53f3\u4e24\u4e2a\u6307\u9488\uff0c\u6bcf\u5f97\u5230\u4e00\u4e2a\u533a\u95f4\u7684\u5de6\u53f3\u8fb9\u754c\uff0c\u5c31\u66b4\u529b\u8df3\u8f6c\uff0c\u4fee\u6539\u7b54\u6848\u5373\u53ef \u590d\u6742\u5ea6\u5206\u6790 \u603b\uff1a$\\Theta(n\\sqrt{n})$ 1.l:\u56e0\u4e3a\u533a\u95f4\u6309\u7167\u5757\u5c06l\u6392\u4e86\u5e8f\uff0c\u6240\u4ee5l\u6bcf\u6b21\u6700\u591a\u79fb\u52a8$\\sqrt{n}$\u6b21\uff0c\u4e00\u5171n\u4e2a\u8be2\u95ee\uff0c\u603b\u7684\u4e0d\u8d85\u8fc7$n \\sqrt{n}$\u6b21 2.r:\u5bf9\u4e8e\u6bcf\u4e2a\u5757\u4e2d\u7684\u533a\u95f4\uff0cr\u5df2\u7ecf\u6392\u597d\u4e86\u5e8f\uff0c\u6700\u574f\u65f6\u4e00\u4e2a\u5757\u8981\u79fb\u52a8\u5230\u5e8f\u5217\u6700\u53f3\u7aef\uff0c\u5373\u4e00\u5171n\u6b21\uff0c\u4e00\u5171$\\sqrt{n}$\u4e2a\u5757\uff0c\u6240\u4ee5\u4e0d\u8d85\u8fc7$n \\sqrt{n}$\u6b21 3.\u5757\u4e4b\u95f4\u7684\u8df3\u8f6c\uff1a\u4e00\u5171$\\sqrt n$\u4e2a\u5757\uff0cl\u6700\u591a\u4ece\u5757\u5c3e\u5230\u5757\u5934\uff0c$\\sqrt n$\u6b21\uff1br\u6700\u591a\u4ece\u5e8f\u5217\u5c3e\u5230\u5e8f\u5217\u5934\uff0cn\u6b21\uff0c\u6240\u4ee5\u4e0d\u8d85\u8fc7$n\\sqrt n$\u6b21\u3002 \u6a21\u677f P2709 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define int long long using namespace std; const int N=1e5+10; int n,m,k,c; int vis[N],ans[N],a[N]; struct node{ int l,r,k,id; }q[N]; bool cmp(node a,node b){ if(a.k!=b.k)return a.k<b.k; else return a.r<b.r; } int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' ||ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); return; } signed main(){ //freopen(\"P2709_1.in\",\"r\",stdin); //freopen(\"1.out\",\"w\",stdout); n=read1(),m=read1(),k=read1(); for(int i=1;i<=n;++i){ a[i]=read1(); } int len=sqrt(n); for(int i=1;i<=m;++i){ q[i].l=read1(),q[i].r=read1(); q[i].k=(q[i].l-1)/len+1;q[i].id=i; } sort(q+1,q+m+1,cmp); int l=1,r=0; memset(vis,0,sizeof vis); for(int i=1;i<=m;++i){ int x=q[i].l,y=q[i].r; while(l>x)--l,c+=2*vis[a[l]]+1,vis[a[l]]++; while(r<y)++r,c+=2*vis[a[r]]+1,vis[a[r]]++; while(l<x)c-=2*vis[a[l]]-1,vis[a[l]]--,++l; while(r>y)c-=2*vis[a[r]]-1,vis[a[r]]--,--r; ans[q[i].id]=c; } for(int i=1;i<=m;++i){ write1(ans[i]); putchar('\\n'); } return 0; } ~~\u5199\u7684\u65f6\u5019\u6ce8\u610f\uff1a\u5206\u5757\u662f\u6839\u636el\u7684\u503c\u57df(\u6570\u91cf)\u5206\u7684\uff0c\u800c\u4e0d\u662f\u533a\u95f4\u7684\u6570\u91cf\u3002\u4e0d\u7136\u5c31\u9519\u4e86~~ \u4e00\u822c\u5904\u7406\u4e0d\u8d85\u8fc7$1* 10^5$ \u7684\u6570\u636e \u5e26\u4fee\u6539\u83ab\u961f \u539f\u7406 \u5c31\u662f\u5c06\u539f\u6765\u7684\u8be2\u95ee(l,r)\u52a0\u4e86\u4e00\u7ef4\u65f6\u95f4\u8f74(l,r,t)\uff0c\u5c06l,r\u90fd\u5206\u5757 \u5982\u56fe\uff0c\u5c06l\u8f74\u5206\u6210n\u5757\uff0c\u6bcf\u5757\u957f$\\frac{N}{n}$;\u5c06r\u8f74\u5206\u6210k\u5757\uff0c\u6bcf\u5757\u957f$\\frac{N}{k}$ \u590d\u6742\u5ea6 1.\u8bfb\u5165\uff1a$\\Theta(n+m)$ 2.\u6392\u5e8f\uff1a$\\Theta(nlogn)$ 3.l:\u6bcf\u6b21\u6700\u591a\u79fb\u52a8$\\frac{N}{n}$\uff0c\u4e00\u5171m\u4e2a\u8be2\u95ee\uff0c\u6240\u4ee5\u5171$\\Theta(\\frac{N}{n}* m)$ \u5757\u4e0e\u5757\u4e4b\u95f4\u7684\u79fb\u52a8\u5171n\u6b21\uff0c\u4e00\u6b21$\\frac{2* N}{n}$\uff0c\u5171$\\Theta(N)$ 4.r:\u6bcf\u6b21\u6700\u591a\u79fb\u52a8$\\frac{N}{k}$\uff0c\u4e00\u5171m\u4e2a\u8be2\u95ee\uff0c\u6240\u4ee5\u5171$\\Theta(\\frac{N}{k}* m)$ \u5757\u4e0e\u5757\u4e4b\u95f4\u7684\u79fb\u52a8\u5171k\u6b21\uff0c\u4e00\u6b21$\\frac{2* N}{k}$\uff0c\u5171$\\Theta(N)$ 5.t:\u4e00\u5171n * k\u4e2a\u5757\uff0c\u6bcf\u4e2a\u5757\u6700\u574f\u53bb\u60c5\u51b5\u4e3a\u63a8\u5230\u5e8f\u5217\u6700\u540e\u4e00\u4f4d\uff0c\u6240\u4ee5\u590d\u6742\u5ea6$\\Theta(N n k)$ \u5757\u4e0e\u5757\u4e4b\u95f4\u4e00\u5171n k\u6b21\uff0c\u4e00\u6b21\u6700\u591aN\uff0c\u590d\u6742\u5ea6$\\Theta(N n* k)$ \u6240\u4ee5\u590d\u6742\u5ea6\u6700\u5c0f\u65f6n=k\uff0c\u4e3a$max(\\Theta(N^{2-k}),\\Theta(N^{1+2k}))$ \u6b64\u65f62-k=1+2k,\u5373k=$\\frac13$ \u6240\u4ee5\u603b\u590d\u6742\u5ea6\u4e3a$\\Theta(N^{\\frac53})$ P1903 \u6a21\u677f #include<iostream> #include<cmath> #include<algorithm> #include<cstdio> #define int long long using namespace std; const double F=0.666666666667; const int N=2e6+10; int a[N],vis[N],res[N]; int n,m; char ch; struct qe1{int l,r,id,k1,k2,t;}q1[N]; struct qe2{int x,y,id;}q2[N]; bool cmp(qe1 a,qe1 b){ if(a.k1!=b.k1)return a.k1<b.k1; else if(a.k2!=b.k2)return a.k2<b.k2; else return a.t<b.t; } int read1() void write1(int x) signed main(){ n=read1(),m=read1(); for(int i=1;i<=n;++i)a[i]=read1(); int len=pow(n,F),c1=0,c2=0; for(int i=1;i<=m;++i){ cin>>ch; if(ch=='Q')++c1,q1[c1].l=read1(),q1[c1].r=read1(),q1[c1].id=i,q1[c1].k1=(q1[c1].l-1)/len+1,q1[c1].k2=(q1[c1].r-1)/len+1,q1[c1].t=c2; else ++c2,q2[c2].x=read1(),q2[c2].y=read1(),q2[c2].id=i; } sort(q1+1,q1+c1+1,cmp); int l=1,r=0,t=0,ans=0; for(int i=1;i<=c1;++i){ int x=q1[i].l,y=q1[i].r,z=q1[i].t; while(t<z){ ++t; if(q2[t].x<=r && q2[t].x>=l)ans-=vis[a[q2[t].x]]==1?1:0,vis[a[q2[t].x]]--,ans+=vis[q2[t].y]==0?1:0,vis[q2[t].y]++; swap(a[q2[t].x],q2[t].y); } while(t>z){ if(q2[t].x<=r && q2[t].x>=l)ans-=vis[a[q2[t].x]]==1?1:0,vis[a[q2[t].x]]--,ans+=vis[q2[t].y]==0?1:0,vis[q2[t].y]++; swap(a[q2[t].x],q2[t].y); t--; } while(l>x)--l,ans+=vis[a[l]]==0?1:0,vis[a[l]]++; while(r<y)++r,ans+=vis[a[r]]==0?1:0,vis[a[r]]++; while(l<x)ans-=vis[a[l]]==1?1:0,vis[a[l]]--,++l; while(r>y)ans-=vis[a[r]]==1?1:0,vis[a[r]]--,--r; res[q1[i].id]=ans; } for(int i=1;i<=m;++i)if(res[i])write1(res[i]),putchar('\\n'); return 0; } P5906 \u8fd9\u9053\u9898\u662f\u5f88\u597d\u7684\u5206\u5757\u4e0e\u83ab\u961f\u7684\u7ed3\u5408\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u6570(\u5df2\u79bb\u6563\u5316),\u4ed6\u5728\u533a\u95f4\u4e2d\u7684\u6700\u5927\u503c\u5c31\u662f\u53f3\u7aef\u70b9\u5230\u5de6\u7aef\u70b9\u5927\u7684\u8ddd\u79bb\uff0c\u6240\u4ee5\u8003\u8651\u7528\u83ab\u961f\u7ef4\u62a4\u5de6\u53f3\u7aef\u70b9\u3002\u56e0\u4e3a\u6700\u5de6\u7aef\u70b9\u88ab\u5220\u9664\u540e\u8fd8\u9700\u8981\u77e5\u9053\u6b21\u5de6\u7aef\u70b9\uff0c\u6240\u4ee5\u63d0\u524d\u9884\u5904\u7406\u51fa\u6bcf\u4e2a\u6570\u7684\u524d\u9a71\u540e\u7ee7\uff0c\u5373\u7528\u94fe\u8868\u8fde\u63a5\u4e00\u4e0b\uff0c\u65b9\u4fbf\u8df3\u8f6c\u3002 \u800c\u6700\u5927\u503c\u6bd4\u8f83\u96be\u7ef4\u62a4\uff0c\u56e0\u4e3a\u4e00\u5171\u4f1a\u6709$m\\sqrt n$\u6b21\u4fee\u6539\uff0c$m$\u6b21\u67e5\u8be2,\u6240\u4ee5\u7ebf\u6bb5\u6811\u7b49\u7ef4\u62a4\u533a\u95f4\u7684\u5de5\u5177\u4f1a\u88ab\u5361\u6210$m \\sqrt n \\log n$,\u800c\u89c2\u5bdf\u5230\u67e5\u8be2\u6b21\u6570\u8f83\u5c0f\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u503c\u57df\u5206\u5757\u6765\u7ef4\u62a4\u6700\u5927\u503c\u3002\u56e0\u4e3a\u5206\u5757\u7684\u4fee\u6539$O(1)$,\u67e5\u8be2$O(\\sqrt n)$\uff0c\u6240\u4ee5\u53ef\u4ee5\u5747\u644a\u5230$m\\sqrt n$. #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define int long long using namespace std; const int N=2e5+10; int n,m,len,MAX,num; int a[N],b[N],vis[N],K[N],L[N],R[N],pre[N],nxt[N],ans[N],s[N],S[N]; struct query{ int l,r,k,id; }q[N]; struct block{ int l,r; }k[N]; bool cmp(query a,query b){ if(a.k==b.k)return a.r<b.r; else return a.k<b.k; } bool cmp1(int a,int b){ return a<b; } void init(){ len=sqrt(n); sort(b+1,b+n+1,cmp1); int tot=unique(b+1,b+n+1)-b-1; for(int i=1;i<=n;++i){ a[i]=lower_bound(b+1,b+tot+1,a[i])-b; } for(int i=1;i<=n;++i){ if(vis[a[i]])pre[i]=vis[a[i]],nxt[vis[a[i]]]=i; vis[a[i]]=i; } for(int i=1;i<=n;++i){ K[i]=(i-1)/len+1; } num=K[n]; for(int i=1;i<=num;++i){ k[i].l=(i-1)*len+1; k[i].r=i*len; } } void change(int x,int k){ S[K[x]]+=k; s[x]+=k; } int query(){ for(int i=num;i>=1;--i){ if(S[i]>0){ for(int j=k[i].r;j>=k[i].l;--j){ if(s[j]>0)return j; } } } return 0; } void addl(int i){ if(!R[a[i]]){ R[a[i]]=L[a[i]]=i; return; } change(R[a[i]]-L[a[i]],-1); L[a[i]]=i; change(R[a[i]]-L[a[i]],1); } void addr(int i){ if(!L[a[i]]){ R[a[i]]=L[a[i]]=i; return; } change(R[a[i]]-L[a[i]],-1); R[a[i]]=i; change(R[a[i]]-L[a[i]],1); } void dell(int i){ if(R[a[i]]==L[a[i]]){ R[a[i]]=L[a[i]]=0; return; } change(R[a[i]]-L[a[i]],-1); L[a[i]]=nxt[i]; change(R[a[i]]-L[a[i]],1); } void delr(int i){ if(R[a[i]]==L[a[i]]){ R[a[i]]=L[a[i]]=0; return; } change(R[a[i]]-L[a[i]],-1); R[a[i]]=pre[i]; change(R[a[i]]-L[a[i]],1); } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),b[i]=a[i]; init(); scanf(\"%lld\",&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&q[i].l,&q[i].r); q[i].k=(q[i].l-1)/len+1; q[i].id=i; } sort(q+1,q+m+1,cmp); int l=1,r=0; memset(L,0,sizeof L); memset(R,0,sizeof R); for(int i=1;i<=m;++i){ int x=q[i].l,y=q[i].r; while(l>x)addl(--l); while(r<y)addr(++r); while(l<x)dell(l++); while(r>y)delr(r--); ans[q[i].id]=query(); } for(int i=1;i<=m;++i)printf(\"%lld\\n\",ans[i]); return 0; } \u4ec0\u4e48\uff0c\u4f60\u8bf4\u4e0d\u591f\"\u4f18\u96c5\",\u4e0d\u591f\u5feb? \u6ca1\u4e8b\uff0c\u8fd9\u9898\u8fd8\u662f\u4e2a\u56de\u6eda\u83ab\u961f\u7684\u6a21\u677f\u9898... \u56de\u6eda\u83ab\u961f \u5bf9\u4e8e\u6dfb\u52a0\u65b9\u4fbf\u800c\u5220\u9664\u4e0d\u65b9\u4fbf\u7684\u64cd\u4f5c\uff0c\u5982\u7ef4\u62a4\u6700\u5927\u503c\uff0c\u5220\u9664\u540e\u8981\u627e\u5230\u6b21\u5927\u503c\uff0c\u8f83\u4e3a\u9ebb\u70e6\u3002\u8fd9\u65f6\u6211\u4eec\u53ef\u4ee5\u7528\u56de\u6eda\u83ab\u961f\u5c3d\u53ef\u80fd\u7684\u51cf\u5c11\u5220\u9664\u64cd\u4f5c\u3002 \u6211\u4eec\u53ef\u4ee5\u5c06\u5de6\u53f3\u6307\u9488\u653e\u5728\u4e00\u4e2a\u5757\u7684\u6700\u53f3\u7aef\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\uff0c\u5982\u679c\u5b83\u5de6\u53f3\u7aef\u70b9\u90fd\u5728\u4e00\u4e2a\u5757\u5185\uff0c\u867d\u7136\u4e0d\u80fd\u907f\u514d\u5220\u9664\uff0c\u4f46\u662f\u66b4\u529b\u65f6\u95f4\u662f$\\sqrt n$,\u53ef\u4ee5\u63a5\u53d7\u3002 \u63a5\u4e0b\u6765\uff0c\u6bcf\u9047\u5230\u4e00\u4e2a\u65b0\u7684\u5757\uff0c\u6b64\u65f6\u5757\u5185\u7684\u8be2\u95ee\u6ee1\u8db3\u5de6\u7aef\u70b9\u90fd\u5728\u5757\u5185\uff0c\u53f3\u7aef\u70b9\u90fd\u4e0d\u5728\u5757\u5185\uff0c\u8fd9\u65f6\u6211\u4eec\u53ef\u4ee5\u5c06\u53f3\u7aef\u70b9\u4e0d\u65ad\u5411\u53f3\u79fb\u52a8\uff0c\u66f4\u65b0\u7b54\u6848\uff0c\u5de6\u7aef\u70b9\u4e0d\u65ad\u79fb\u52a8\u8fc7\u53bb\u518d~~\u9000~~\u6eda\u56de\u6765\uff0c\u5c06\u6cbf\u8def\u4ea7\u751f\u7684\u8d21\u732e\u5168\u90e8\u5220\u9664\uff0c\u5e76\u4e14\u53ea\u8ba1\u5165\u53d8\u91cf$_tmp$\u4e2d\uff0c\u4e0d\u8ba1\u5165\u539f\u6709\u7b54\u6848\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u5b9e\u73b0\"\u56de\u6eda\"\u7684\u8fc7\u7a0b\uff0c\u5168\u7a0b\u6ca1\u6709\u5220\u9664\u64cd\u4f5c\u3002 \u6700\u540e\u53ea\u9700\u8981\u6bd4\u8f83$_tmp$\u4e0e$tmp$\u7684\u6700\u5927\u503c\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<cmath> #define int long long using namespace std; const int N=3e5+10; int n,m,len,tot,num; int a[N],b[N],L[N],R[N],blk[N],st[N],ed[N],ed1[N],ans[N]; struct query{ int l,r,k,id; }q[N]; bool Cmp(query a,query b){ if(a.k==b.k)return a.r<b.r; else return a.k<b.k; } bool cmp(int a,int b){ return a<b; } void Discrete(){ sort(b+1,b+n+1,cmp); tot=unique(b+1,b+n+1)-b-1; for(int i=1;i<=n;++i)a[i]=lower_bound(b+1,b+tot+1,a[i])-b; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),b[i]=a[i]; Discrete(); scanf(\"%lld\",&m); len=sqrt(n); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&q[i].l,&q[i].r); q[i].k=(q[i].l-1)/len+1; q[i].id=i; } sort(q+1,q+m+1,Cmp); for(int i=1;i<=n;++i){ blk[i]=(i-1)/len+1; } num=blk[n]; for(int i=1;i<=num;++i){ L[i]=(i-1)*len+1; R[i]=(i==num)?n:i*len;//\u5bb9\u6613\u5199\u9519 } int block=0,tmp=0,l=1,r=0; for(int i=1;i<=m;++i){ int x=q[i].l,y=q[i].r,now=blk[x]; if(blk[x]==blk[y]){//\u66b4\u529b tmp=0; for(int j=x;j<=y;++j)st[a[j]]=0; for(int j=x;j<=y;++j){ if(!st[a[j]])st[a[j]]=j; tmp=max(tmp,j-st[a[j]]); } for(int j=x;j<=y;++j)st[a[j]]=0; ans[q[i].id]=tmp; continue; } if(now!=block){ tmp=0; for(int j=l;j<=r;++j)st[a[j]]=ed[a[j]]=0; l=R[now]; r=l-1;//\u6ce8\u610f\uff0c\u83ab\u961f\u5957\u8def\uff0cr=l-1 block=now;//\u6362\u5757\u65f6\u5c06\u6240\u6709\u503c\u521d\u59cb\u5316\u4e3a0\uff0c\u5de6\u53f3\u7aef\u70b9\u632a\u5230\u5757\u53f3\u7aef\u70b9\u3002 } while(r<y){ ++r; if(!st[a[r]])st[a[r]]=r; ed[a[r]]=r;//\u4e0d\u65ad\u66f4\u65b0ed\uff0c\u4fdd\u8bc1\u66f4\u65b0\u5de6\u7aef\u70b9\u65f6\u53ef\u4ee5\u7528\u4e0a\u3002 tmp=max(tmp,r-st[a[r]]); } int p=l,tmp1=0; while(p>x){//add --p; if(!ed1[a[p]])ed1[a[p]]=p; tmp1=max(tmp1,max(ed1[a[p]],ed[a[p]])-p);//\u5728ed1\u548ced\u4e2d\u53d6\u6700\u5927\u503c\u3002 } while(p<l){//del ed1[a[p]]=0; p++; } ans[q[i].id]=max(tmp,tmp1); } for(int i=1;i<=m;++i){ printf(\"%lld\\n\",ans[i]); } return 0; } /* 8 1 6 2 2 3 3 1 6 6 1 3 1 4 2 5 2 8 5 6 1 7 */ AT1219 \u89e3\u6cd5\u4e00\uff1a\u56e0\u4e3a\u6bcf\u4e2a\u6570\u51fa\u73b0\u7684\u6b21\u6570\u4f1a\u5f71\u54cd\u503c\u57df\u5206\u5757\uff0c\u6240\u4ee5\u5bf9\u4e8e\u51fa\u73b0$t$\u6b21\u7684\u6570$x$\uff0c\u5c06$x,2x,3x,...tx$\u5168\u90e8\u8bb0\u5f55\u5230\u79bb\u6563\u5316\u6570\u7ec4\u91cc\uff0c\u518d\u5806\u79bb\u6563\u5316\u6570\u7ec4\u503c\u57df\u5206\u5757\u5373\u53ef\u3002 \u56e0\u4e3a$\\sum t_i=n$,\u6240\u4ee5\u590d\u6742\u5ea6\u6b63\u786e\uff0c\u4e3a$m\\sqrt n$ \u540c\u65f6\u8fd8\u53ef\u4ee5\u56de\u6eda\u83ab\u961f\u505a\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define int long long using namespace std; const int N=1e5+10; int n,m,len,num; int a[N],b[N],blk[N],L[N],R[N],cnt[N],tot[N],ans[N]; struct query{ int l,r,k,id; }q[N]; bool cmp(int a,int b){ return a<b; } bool Cmp(query a,query b){ if(a.k==b.k)return a.r<b.r; else return a.k<b.k; } void Discrete(){ sort(b+1,b+n+1,cmp); int tott=unique(b+1,b+n+1)-b-1; for(int i=1;i<=n;++i)a[i]=lower_bound(b+1,b+tott+1,a[i])-b; } void init(){ for(int i=1;i<=n;++i){ blk[i]=(i-1)/len+1; } num=blk[n]; for(int i=1;i<=num;++i){ L[i]=(i-1)*len+1; R[i]=(i==num)?n:i*len; } } signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),b[i]=a[i]; Discrete(); len=sqrt(n); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&q[i].l,&q[i].r); q[i].k=(q[i].l-1)/len+1; q[i].id=i; } sort(q+1,q+m+1,Cmp); init(); int l=1,r=0,tmp=0,block=0; for(int i=1;i<=m;++i){ int x=q[i].l,y=q[i].r,now=blk[x]; if(blk[x]==blk[y]){ tmp=0; for(int j=x;j<=y;++j)cnt[a[j]]=0; for(int j=x;j<=y;++j){ cnt[a[j]]++; tmp=max(tmp,cnt[a[j]]*b[a[j]]); } for(int j=x;j<=y;++j)cnt[a[j]]=0; ans[q[i].id]=tmp; continue; } if(block!=now){ tmp=0; for(int j=l;j<=r;++j)cnt[a[j]]=0; l=R[now]; r=l-1; block=now; } while(r<y){ ++r; cnt[a[r]]++; tmp=max(tmp,cnt[a[r]]*b[a[r]]); } int p=l,_tmp=0; while(p>x){ --p; tot[a[p]]++; _tmp=max(_tmp,(tot[a[p]]+cnt[a[p]])*b[a[p]]); } while(p<l){ tot[a[p]]=0; p++; } ans[q[i].id]=max(tmp,_tmp); } for(int i=1;i<=m;++i){ printf(\"%lld\\n\",ans[i]); } return 0; } P8078 ~~\u8003\u573a\u4e0a\u53ea\u62ff\u4e8635pts\u5dee\u4e94\u5206\u5c31\u6709\u94dc\u724c\u7684\u849f\u84bb~~ \u5bf9\u4e8e\u6240\u6709\u6570\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u6392\u5e8f\u540e\uff0c\u53ef\u4ee5\u7528\u94fe\u8868\u628a\u4ed6\u4eec\u8fde\u63a5\u8d77\u6765\uff0c\u94fe\u8868\u8fb9\u4e0a\u8bb0\u5f55\u4e00\u4e0b\u6743\u503c\u3002\u53d1\u73b0\u94fe\u8868\u5220\u9664+\u6062\u590d\u8fdc\u6bd4\u6dfb\u52a0\u7b80\u5355\u5f97\u591a\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u4e0d\u6dfb\u52a0\u83ab\u961f\u3002 \u4e0e\u4e0d\u5220\u9664\u83ab\u961f\u7c7b\u4f3c\uff0c\u90fd\u662f\u5904\u7406\u5b8c\u5de6\u7aef\u70b9\u56de\u6eda\u3002\u53ea\u662f\u8fd9\u4e2a\u521d\u59cb\u662f$l=1,r=n$,\u4ece\u4e24\u7aef\u5411\u4e2d\u95f4\u66f4\u6539$l,r$. ~~\u6700\u540e\u8f93\u7ed9\u4e86\u5de8\u5927\u7684\u5e38\u6570\u62ff\u4e8695pts~~ #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define rg register using namespace std; typedef long long ll; const int N=5e5+10,INF=0x3f3f3f3f; inline int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch<='9' && ch>='0') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } inline void write1(ll x){ if(x>9) write1(x/10); putchar(x%10+'0'); } struct node{ int l,r,k,id; }q[N]; struct link{ int v,p; }pre[N],nxt[N]; int n,m,K,L; ll tmp,_tmp; int a[N],blk[N],lb[N],rb[N],s[N]; ll ans[N]; bool cmp(node a,node b){ if(a.k==b.k) return a.r>b.r; return a.k<b.k; } void init(){ _tmp=0; for(rg int i=2;i<=n;++i){ int x=s[i]-s[i-1]; _tmp+=(ll)abs(x); nxt[i-1].v=i,nxt[i-1].p=x; pre[i].v=i-1,pre[i].p=-x; } pre[1].v=pre[1].p=-INF; nxt[n].v=nxt[n].p=-INF; } inline void del(int i){ int _x=pre[a[i]].v,_y=nxt[a[i]].v,l1=pre[a[i]].p,l2=nxt[a[i]].p,l3=-l1+l2; if(_x==-INF && _y!=-INF){//pre pre[_y].v=pre[_y].p=-INF; _tmp-=(ll)abs(l2); } if(_x!=-INF && _y==-INF){//nxt nxt[_x].v=nxt[_x].p=-INF; _tmp-=(ll)abs(l1); } if(_x!=-INF && _y!=-INF){//pre nxt nxt[_x].v=_y;nxt[_x].p=l3; pre[_y].v=_x;pre[_y].p=-l3; _tmp=_tmp-(ll)(abs(l1)+abs(l2)-abs(l3)); } } inline void cov(int i){ int _x=pre[a[i]].v,_y=nxt[a[i]].v,l1=pre[a[i]].p,l2=nxt[a[i]].p,l3=-l1+l2; if(_x==-INF && _y!=-INF){//pre pre[_y].v=a[i],pre[_y].p=-l2; _tmp+=(ll)abs(l2); } if(_x!=-INF && _y==-INF){//nxt nxt[_x].v=a[i];nxt[_x].p=-l1; _tmp+=(ll)abs(l1); } if(_x!=-INF && _y!=-INF){//pre nxt nxt[_x].v=a[i];nxt[_x].p=-l1; pre[_y].v=a[i];pre[_y].p=-l2; _tmp=_tmp+(ll)(abs(l1)+abs(l2)-abs(l3)); } } int main(){ n=read1(),m=read1();L=sqrt(n); for(rg int i=1;i<=n;++i) a[i]=read1(),s[a[i]]=i,blk[i]=(i-1)/L+1; for(rg int i=1;i<=m;++i) q[i].l=read1(),q[i].r=read1(),q[i].k=(q[i].l-1)/L+1,q[i].id=i; K=blk[n]; for(rg int i=1;i<=K;++i) lb[i]=(i-1)*L+1,rb[i]=min(i*L,n); sort(q+1,q+m+1,cmp); int l=1,r=n,now=0; init(); for(rg int i=1;i<=m;++i){ int x=q[i].l,y=q[i].r; if(blk[x]!=now){ now=blk[x]; while(r<n) cov(++r); while(l<lb[now]) del(l++); } while(r>y) del(r--); int p=l; while(p<x) del(p++); ans[q[i].id]=_tmp; while(p>l) cov(--p); } for(rg int i=1;i<=m;++i) write1(ans[i]),putchar('\\n'); return 0; }","title":"\u83ab\u961f"},{"location":"my%20past/OI/%E8%8E%AB%E9%98%9F/#_1","text":"~~\u4f17\u6240\u5468\u77e5\uff0c\u83ab\u961f\u7b49\u4e8e\u5206\u5757+\u66b4\u529b~~","title":"\u83ab\u961f"},{"location":"my%20past/OI/%E8%8E%AB%E9%98%9F/#_2","text":"\u79bb\u7ebf\u5904\u7406\u533a\u95f4\u8be2\u95ee\u95ee\u9898\uff0c\u5c24\u5176\u662f\u4e00\u4e9b\"\u4e0d\u6ee1\u8db3\u533a\u95f4\u53ef\u52a0\u6027\u6216\u53ef\u4e58\u6027\"\u7684\u95ee\u9898","title":"\u7528\u9014"},{"location":"my%20past/OI/%E8%8E%AB%E9%98%9F/#_3","text":"1.\u79bb\u7ebf\u7b97\u6cd5\uff0c\u5c06\u6240\u6709\u533a\u95f4\u8bfb\u4e0b\u6765 2.\u7ed9\u6240\u6709\u533a\u95f4\u5206\u5757\uff0c\u5206\u6210$\\sqrt{n}$\u5757 3.\u5c06\u6240\u6709\u533a\u95f4\u7684l\u6309\u7167\u5757\u7684\u987a\u5e8f\u6392\u5e8f 4.\u518d\u5c06\u540c\u4e00\u5757\u7684\u6240\u6709\u533a\u95f4\u6309\u7167r\u7684\u987a\u5e8f\u6392\u5e8f 5.\u7ef4\u62a4\u5de6\u53f3\u4e24\u4e2a\u6307\u9488\uff0c\u6bcf\u5f97\u5230\u4e00\u4e2a\u533a\u95f4\u7684\u5de6\u53f3\u8fb9\u754c\uff0c\u5c31\u66b4\u529b\u8df3\u8f6c\uff0c\u4fee\u6539\u7b54\u6848\u5373\u53ef","title":"\u539f\u7406"},{"location":"my%20past/OI/%E8%8E%AB%E9%98%9F/#_4","text":"\u603b\uff1a$\\Theta(n\\sqrt{n})$ 1.l:\u56e0\u4e3a\u533a\u95f4\u6309\u7167\u5757\u5c06l\u6392\u4e86\u5e8f\uff0c\u6240\u4ee5l\u6bcf\u6b21\u6700\u591a\u79fb\u52a8$\\sqrt{n}$\u6b21\uff0c\u4e00\u5171n\u4e2a\u8be2\u95ee\uff0c\u603b\u7684\u4e0d\u8d85\u8fc7$n \\sqrt{n}$\u6b21 2.r:\u5bf9\u4e8e\u6bcf\u4e2a\u5757\u4e2d\u7684\u533a\u95f4\uff0cr\u5df2\u7ecf\u6392\u597d\u4e86\u5e8f\uff0c\u6700\u574f\u65f6\u4e00\u4e2a\u5757\u8981\u79fb\u52a8\u5230\u5e8f\u5217\u6700\u53f3\u7aef\uff0c\u5373\u4e00\u5171n\u6b21\uff0c\u4e00\u5171$\\sqrt{n}$\u4e2a\u5757\uff0c\u6240\u4ee5\u4e0d\u8d85\u8fc7$n \\sqrt{n}$\u6b21 3.\u5757\u4e4b\u95f4\u7684\u8df3\u8f6c\uff1a\u4e00\u5171$\\sqrt n$\u4e2a\u5757\uff0cl\u6700\u591a\u4ece\u5757\u5c3e\u5230\u5757\u5934\uff0c$\\sqrt n$\u6b21\uff1br\u6700\u591a\u4ece\u5e8f\u5217\u5c3e\u5230\u5e8f\u5217\u5934\uff0cn\u6b21\uff0c\u6240\u4ee5\u4e0d\u8d85\u8fc7$n\\sqrt n$\u6b21\u3002","title":"\u590d\u6742\u5ea6\u5206\u6790"},{"location":"my%20past/OI/%E8%8E%AB%E9%98%9F/#_5","text":"P2709 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define int long long using namespace std; const int N=1e5+10; int n,m,k,c; int vis[N],ans[N],a[N]; struct node{ int l,r,k,id; }q[N]; bool cmp(node a,node b){ if(a.k!=b.k)return a.k<b.k; else return a.r<b.r; } int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' ||ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); return; } signed main(){ //freopen(\"P2709_1.in\",\"r\",stdin); //freopen(\"1.out\",\"w\",stdout); n=read1(),m=read1(),k=read1(); for(int i=1;i<=n;++i){ a[i]=read1(); } int len=sqrt(n); for(int i=1;i<=m;++i){ q[i].l=read1(),q[i].r=read1(); q[i].k=(q[i].l-1)/len+1;q[i].id=i; } sort(q+1,q+m+1,cmp); int l=1,r=0; memset(vis,0,sizeof vis); for(int i=1;i<=m;++i){ int x=q[i].l,y=q[i].r; while(l>x)--l,c+=2*vis[a[l]]+1,vis[a[l]]++; while(r<y)++r,c+=2*vis[a[r]]+1,vis[a[r]]++; while(l<x)c-=2*vis[a[l]]-1,vis[a[l]]--,++l; while(r>y)c-=2*vis[a[r]]-1,vis[a[r]]--,--r; ans[q[i].id]=c; } for(int i=1;i<=m;++i){ write1(ans[i]); putchar('\\n'); } return 0; } ~~\u5199\u7684\u65f6\u5019\u6ce8\u610f\uff1a\u5206\u5757\u662f\u6839\u636el\u7684\u503c\u57df(\u6570\u91cf)\u5206\u7684\uff0c\u800c\u4e0d\u662f\u533a\u95f4\u7684\u6570\u91cf\u3002\u4e0d\u7136\u5c31\u9519\u4e86~~ \u4e00\u822c\u5904\u7406\u4e0d\u8d85\u8fc7$1* 10^5$ \u7684\u6570\u636e","title":"\u6a21\u677f"},{"location":"my%20past/OI/%E8%8E%AB%E9%98%9F/#_6","text":"","title":"\u5e26\u4fee\u6539\u83ab\u961f"},{"location":"my%20past/OI/%E8%8E%AB%E9%98%9F/#_7","text":"\u5c31\u662f\u5c06\u539f\u6765\u7684\u8be2\u95ee(l,r)\u52a0\u4e86\u4e00\u7ef4\u65f6\u95f4\u8f74(l,r,t)\uff0c\u5c06l,r\u90fd\u5206\u5757 \u5982\u56fe\uff0c\u5c06l\u8f74\u5206\u6210n\u5757\uff0c\u6bcf\u5757\u957f$\\frac{N}{n}$;\u5c06r\u8f74\u5206\u6210k\u5757\uff0c\u6bcf\u5757\u957f$\\frac{N}{k}$","title":"\u539f\u7406"},{"location":"my%20past/OI/%E8%8E%AB%E9%98%9F/#_8","text":"1.\u8bfb\u5165\uff1a$\\Theta(n+m)$ 2.\u6392\u5e8f\uff1a$\\Theta(nlogn)$ 3.l:\u6bcf\u6b21\u6700\u591a\u79fb\u52a8$\\frac{N}{n}$\uff0c\u4e00\u5171m\u4e2a\u8be2\u95ee\uff0c\u6240\u4ee5\u5171$\\Theta(\\frac{N}{n}* m)$ \u5757\u4e0e\u5757\u4e4b\u95f4\u7684\u79fb\u52a8\u5171n\u6b21\uff0c\u4e00\u6b21$\\frac{2* N}{n}$\uff0c\u5171$\\Theta(N)$ 4.r:\u6bcf\u6b21\u6700\u591a\u79fb\u52a8$\\frac{N}{k}$\uff0c\u4e00\u5171m\u4e2a\u8be2\u95ee\uff0c\u6240\u4ee5\u5171$\\Theta(\\frac{N}{k}* m)$ \u5757\u4e0e\u5757\u4e4b\u95f4\u7684\u79fb\u52a8\u5171k\u6b21\uff0c\u4e00\u6b21$\\frac{2* N}{k}$\uff0c\u5171$\\Theta(N)$ 5.t:\u4e00\u5171n * k\u4e2a\u5757\uff0c\u6bcf\u4e2a\u5757\u6700\u574f\u53bb\u60c5\u51b5\u4e3a\u63a8\u5230\u5e8f\u5217\u6700\u540e\u4e00\u4f4d\uff0c\u6240\u4ee5\u590d\u6742\u5ea6$\\Theta(N n k)$ \u5757\u4e0e\u5757\u4e4b\u95f4\u4e00\u5171n k\u6b21\uff0c\u4e00\u6b21\u6700\u591aN\uff0c\u590d\u6742\u5ea6$\\Theta(N n* k)$ \u6240\u4ee5\u590d\u6742\u5ea6\u6700\u5c0f\u65f6n=k\uff0c\u4e3a$max(\\Theta(N^{2-k}),\\Theta(N^{1+2k}))$ \u6b64\u65f62-k=1+2k,\u5373k=$\\frac13$ \u6240\u4ee5\u603b\u590d\u6742\u5ea6\u4e3a$\\Theta(N^{\\frac53})$ P1903 \u6a21\u677f #include<iostream> #include<cmath> #include<algorithm> #include<cstdio> #define int long long using namespace std; const double F=0.666666666667; const int N=2e6+10; int a[N],vis[N],res[N]; int n,m; char ch; struct qe1{int l,r,id,k1,k2,t;}q1[N]; struct qe2{int x,y,id;}q2[N]; bool cmp(qe1 a,qe1 b){ if(a.k1!=b.k1)return a.k1<b.k1; else if(a.k2!=b.k2)return a.k2<b.k2; else return a.t<b.t; } int read1() void write1(int x) signed main(){ n=read1(),m=read1(); for(int i=1;i<=n;++i)a[i]=read1(); int len=pow(n,F),c1=0,c2=0; for(int i=1;i<=m;++i){ cin>>ch; if(ch=='Q')++c1,q1[c1].l=read1(),q1[c1].r=read1(),q1[c1].id=i,q1[c1].k1=(q1[c1].l-1)/len+1,q1[c1].k2=(q1[c1].r-1)/len+1,q1[c1].t=c2; else ++c2,q2[c2].x=read1(),q2[c2].y=read1(),q2[c2].id=i; } sort(q1+1,q1+c1+1,cmp); int l=1,r=0,t=0,ans=0; for(int i=1;i<=c1;++i){ int x=q1[i].l,y=q1[i].r,z=q1[i].t; while(t<z){ ++t; if(q2[t].x<=r && q2[t].x>=l)ans-=vis[a[q2[t].x]]==1?1:0,vis[a[q2[t].x]]--,ans+=vis[q2[t].y]==0?1:0,vis[q2[t].y]++; swap(a[q2[t].x],q2[t].y); } while(t>z){ if(q2[t].x<=r && q2[t].x>=l)ans-=vis[a[q2[t].x]]==1?1:0,vis[a[q2[t].x]]--,ans+=vis[q2[t].y]==0?1:0,vis[q2[t].y]++; swap(a[q2[t].x],q2[t].y); t--; } while(l>x)--l,ans+=vis[a[l]]==0?1:0,vis[a[l]]++; while(r<y)++r,ans+=vis[a[r]]==0?1:0,vis[a[r]]++; while(l<x)ans-=vis[a[l]]==1?1:0,vis[a[l]]--,++l; while(r>y)ans-=vis[a[r]]==1?1:0,vis[a[r]]--,--r; res[q1[i].id]=ans; } for(int i=1;i<=m;++i)if(res[i])write1(res[i]),putchar('\\n'); return 0; } P5906 \u8fd9\u9053\u9898\u662f\u5f88\u597d\u7684\u5206\u5757\u4e0e\u83ab\u961f\u7684\u7ed3\u5408\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u6570(\u5df2\u79bb\u6563\u5316),\u4ed6\u5728\u533a\u95f4\u4e2d\u7684\u6700\u5927\u503c\u5c31\u662f\u53f3\u7aef\u70b9\u5230\u5de6\u7aef\u70b9\u5927\u7684\u8ddd\u79bb\uff0c\u6240\u4ee5\u8003\u8651\u7528\u83ab\u961f\u7ef4\u62a4\u5de6\u53f3\u7aef\u70b9\u3002\u56e0\u4e3a\u6700\u5de6\u7aef\u70b9\u88ab\u5220\u9664\u540e\u8fd8\u9700\u8981\u77e5\u9053\u6b21\u5de6\u7aef\u70b9\uff0c\u6240\u4ee5\u63d0\u524d\u9884\u5904\u7406\u51fa\u6bcf\u4e2a\u6570\u7684\u524d\u9a71\u540e\u7ee7\uff0c\u5373\u7528\u94fe\u8868\u8fde\u63a5\u4e00\u4e0b\uff0c\u65b9\u4fbf\u8df3\u8f6c\u3002 \u800c\u6700\u5927\u503c\u6bd4\u8f83\u96be\u7ef4\u62a4\uff0c\u56e0\u4e3a\u4e00\u5171\u4f1a\u6709$m\\sqrt n$\u6b21\u4fee\u6539\uff0c$m$\u6b21\u67e5\u8be2,\u6240\u4ee5\u7ebf\u6bb5\u6811\u7b49\u7ef4\u62a4\u533a\u95f4\u7684\u5de5\u5177\u4f1a\u88ab\u5361\u6210$m \\sqrt n \\log n$,\u800c\u89c2\u5bdf\u5230\u67e5\u8be2\u6b21\u6570\u8f83\u5c0f\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u503c\u57df\u5206\u5757\u6765\u7ef4\u62a4\u6700\u5927\u503c\u3002\u56e0\u4e3a\u5206\u5757\u7684\u4fee\u6539$O(1)$,\u67e5\u8be2$O(\\sqrt n)$\uff0c\u6240\u4ee5\u53ef\u4ee5\u5747\u644a\u5230$m\\sqrt n$. #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define int long long using namespace std; const int N=2e5+10; int n,m,len,MAX,num; int a[N],b[N],vis[N],K[N],L[N],R[N],pre[N],nxt[N],ans[N],s[N],S[N]; struct query{ int l,r,k,id; }q[N]; struct block{ int l,r; }k[N]; bool cmp(query a,query b){ if(a.k==b.k)return a.r<b.r; else return a.k<b.k; } bool cmp1(int a,int b){ return a<b; } void init(){ len=sqrt(n); sort(b+1,b+n+1,cmp1); int tot=unique(b+1,b+n+1)-b-1; for(int i=1;i<=n;++i){ a[i]=lower_bound(b+1,b+tot+1,a[i])-b; } for(int i=1;i<=n;++i){ if(vis[a[i]])pre[i]=vis[a[i]],nxt[vis[a[i]]]=i; vis[a[i]]=i; } for(int i=1;i<=n;++i){ K[i]=(i-1)/len+1; } num=K[n]; for(int i=1;i<=num;++i){ k[i].l=(i-1)*len+1; k[i].r=i*len; } } void change(int x,int k){ S[K[x]]+=k; s[x]+=k; } int query(){ for(int i=num;i>=1;--i){ if(S[i]>0){ for(int j=k[i].r;j>=k[i].l;--j){ if(s[j]>0)return j; } } } return 0; } void addl(int i){ if(!R[a[i]]){ R[a[i]]=L[a[i]]=i; return; } change(R[a[i]]-L[a[i]],-1); L[a[i]]=i; change(R[a[i]]-L[a[i]],1); } void addr(int i){ if(!L[a[i]]){ R[a[i]]=L[a[i]]=i; return; } change(R[a[i]]-L[a[i]],-1); R[a[i]]=i; change(R[a[i]]-L[a[i]],1); } void dell(int i){ if(R[a[i]]==L[a[i]]){ R[a[i]]=L[a[i]]=0; return; } change(R[a[i]]-L[a[i]],-1); L[a[i]]=nxt[i]; change(R[a[i]]-L[a[i]],1); } void delr(int i){ if(R[a[i]]==L[a[i]]){ R[a[i]]=L[a[i]]=0; return; } change(R[a[i]]-L[a[i]],-1); R[a[i]]=pre[i]; change(R[a[i]]-L[a[i]],1); } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),b[i]=a[i]; init(); scanf(\"%lld\",&m); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&q[i].l,&q[i].r); q[i].k=(q[i].l-1)/len+1; q[i].id=i; } sort(q+1,q+m+1,cmp); int l=1,r=0; memset(L,0,sizeof L); memset(R,0,sizeof R); for(int i=1;i<=m;++i){ int x=q[i].l,y=q[i].r; while(l>x)addl(--l); while(r<y)addr(++r); while(l<x)dell(l++); while(r>y)delr(r--); ans[q[i].id]=query(); } for(int i=1;i<=m;++i)printf(\"%lld\\n\",ans[i]); return 0; } \u4ec0\u4e48\uff0c\u4f60\u8bf4\u4e0d\u591f\"\u4f18\u96c5\",\u4e0d\u591f\u5feb? \u6ca1\u4e8b\uff0c\u8fd9\u9898\u8fd8\u662f\u4e2a\u56de\u6eda\u83ab\u961f\u7684\u6a21\u677f\u9898...","title":"\u590d\u6742\u5ea6"},{"location":"my%20past/OI/%E8%8E%AB%E9%98%9F/#_9","text":"\u5bf9\u4e8e\u6dfb\u52a0\u65b9\u4fbf\u800c\u5220\u9664\u4e0d\u65b9\u4fbf\u7684\u64cd\u4f5c\uff0c\u5982\u7ef4\u62a4\u6700\u5927\u503c\uff0c\u5220\u9664\u540e\u8981\u627e\u5230\u6b21\u5927\u503c\uff0c\u8f83\u4e3a\u9ebb\u70e6\u3002\u8fd9\u65f6\u6211\u4eec\u53ef\u4ee5\u7528\u56de\u6eda\u83ab\u961f\u5c3d\u53ef\u80fd\u7684\u51cf\u5c11\u5220\u9664\u64cd\u4f5c\u3002 \u6211\u4eec\u53ef\u4ee5\u5c06\u5de6\u53f3\u6307\u9488\u653e\u5728\u4e00\u4e2a\u5757\u7684\u6700\u53f3\u7aef\u3002 \u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\uff0c\u5982\u679c\u5b83\u5de6\u53f3\u7aef\u70b9\u90fd\u5728\u4e00\u4e2a\u5757\u5185\uff0c\u867d\u7136\u4e0d\u80fd\u907f\u514d\u5220\u9664\uff0c\u4f46\u662f\u66b4\u529b\u65f6\u95f4\u662f$\\sqrt n$,\u53ef\u4ee5\u63a5\u53d7\u3002 \u63a5\u4e0b\u6765\uff0c\u6bcf\u9047\u5230\u4e00\u4e2a\u65b0\u7684\u5757\uff0c\u6b64\u65f6\u5757\u5185\u7684\u8be2\u95ee\u6ee1\u8db3\u5de6\u7aef\u70b9\u90fd\u5728\u5757\u5185\uff0c\u53f3\u7aef\u70b9\u90fd\u4e0d\u5728\u5757\u5185\uff0c\u8fd9\u65f6\u6211\u4eec\u53ef\u4ee5\u5c06\u53f3\u7aef\u70b9\u4e0d\u65ad\u5411\u53f3\u79fb\u52a8\uff0c\u66f4\u65b0\u7b54\u6848\uff0c\u5de6\u7aef\u70b9\u4e0d\u65ad\u79fb\u52a8\u8fc7\u53bb\u518d~~\u9000~~\u6eda\u56de\u6765\uff0c\u5c06\u6cbf\u8def\u4ea7\u751f\u7684\u8d21\u732e\u5168\u90e8\u5220\u9664\uff0c\u5e76\u4e14\u53ea\u8ba1\u5165\u53d8\u91cf$_tmp$\u4e2d\uff0c\u4e0d\u8ba1\u5165\u539f\u6709\u7b54\u6848\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u5b9e\u73b0\"\u56de\u6eda\"\u7684\u8fc7\u7a0b\uff0c\u5168\u7a0b\u6ca1\u6709\u5220\u9664\u64cd\u4f5c\u3002 \u6700\u540e\u53ea\u9700\u8981\u6bd4\u8f83$_tmp$\u4e0e$tmp$\u7684\u6700\u5927\u503c\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<cmath> #define int long long using namespace std; const int N=3e5+10; int n,m,len,tot,num; int a[N],b[N],L[N],R[N],blk[N],st[N],ed[N],ed1[N],ans[N]; struct query{ int l,r,k,id; }q[N]; bool Cmp(query a,query b){ if(a.k==b.k)return a.r<b.r; else return a.k<b.k; } bool cmp(int a,int b){ return a<b; } void Discrete(){ sort(b+1,b+n+1,cmp); tot=unique(b+1,b+n+1)-b-1; for(int i=1;i<=n;++i)a[i]=lower_bound(b+1,b+tot+1,a[i])-b; } signed main(){ scanf(\"%lld\",&n); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),b[i]=a[i]; Discrete(); scanf(\"%lld\",&m); len=sqrt(n); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&q[i].l,&q[i].r); q[i].k=(q[i].l-1)/len+1; q[i].id=i; } sort(q+1,q+m+1,Cmp); for(int i=1;i<=n;++i){ blk[i]=(i-1)/len+1; } num=blk[n]; for(int i=1;i<=num;++i){ L[i]=(i-1)*len+1; R[i]=(i==num)?n:i*len;//\u5bb9\u6613\u5199\u9519 } int block=0,tmp=0,l=1,r=0; for(int i=1;i<=m;++i){ int x=q[i].l,y=q[i].r,now=blk[x]; if(blk[x]==blk[y]){//\u66b4\u529b tmp=0; for(int j=x;j<=y;++j)st[a[j]]=0; for(int j=x;j<=y;++j){ if(!st[a[j]])st[a[j]]=j; tmp=max(tmp,j-st[a[j]]); } for(int j=x;j<=y;++j)st[a[j]]=0; ans[q[i].id]=tmp; continue; } if(now!=block){ tmp=0; for(int j=l;j<=r;++j)st[a[j]]=ed[a[j]]=0; l=R[now]; r=l-1;//\u6ce8\u610f\uff0c\u83ab\u961f\u5957\u8def\uff0cr=l-1 block=now;//\u6362\u5757\u65f6\u5c06\u6240\u6709\u503c\u521d\u59cb\u5316\u4e3a0\uff0c\u5de6\u53f3\u7aef\u70b9\u632a\u5230\u5757\u53f3\u7aef\u70b9\u3002 } while(r<y){ ++r; if(!st[a[r]])st[a[r]]=r; ed[a[r]]=r;//\u4e0d\u65ad\u66f4\u65b0ed\uff0c\u4fdd\u8bc1\u66f4\u65b0\u5de6\u7aef\u70b9\u65f6\u53ef\u4ee5\u7528\u4e0a\u3002 tmp=max(tmp,r-st[a[r]]); } int p=l,tmp1=0; while(p>x){//add --p; if(!ed1[a[p]])ed1[a[p]]=p; tmp1=max(tmp1,max(ed1[a[p]],ed[a[p]])-p);//\u5728ed1\u548ced\u4e2d\u53d6\u6700\u5927\u503c\u3002 } while(p<l){//del ed1[a[p]]=0; p++; } ans[q[i].id]=max(tmp,tmp1); } for(int i=1;i<=m;++i){ printf(\"%lld\\n\",ans[i]); } return 0; } /* 8 1 6 2 2 3 3 1 6 6 1 3 1 4 2 5 2 8 5 6 1 7 */ AT1219 \u89e3\u6cd5\u4e00\uff1a\u56e0\u4e3a\u6bcf\u4e2a\u6570\u51fa\u73b0\u7684\u6b21\u6570\u4f1a\u5f71\u54cd\u503c\u57df\u5206\u5757\uff0c\u6240\u4ee5\u5bf9\u4e8e\u51fa\u73b0$t$\u6b21\u7684\u6570$x$\uff0c\u5c06$x,2x,3x,...tx$\u5168\u90e8\u8bb0\u5f55\u5230\u79bb\u6563\u5316\u6570\u7ec4\u91cc\uff0c\u518d\u5806\u79bb\u6563\u5316\u6570\u7ec4\u503c\u57df\u5206\u5757\u5373\u53ef\u3002 \u56e0\u4e3a$\\sum t_i=n$,\u6240\u4ee5\u590d\u6742\u5ea6\u6b63\u786e\uff0c\u4e3a$m\\sqrt n$ \u540c\u65f6\u8fd8\u53ef\u4ee5\u56de\u6eda\u83ab\u961f\u505a\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define int long long using namespace std; const int N=1e5+10; int n,m,len,num; int a[N],b[N],blk[N],L[N],R[N],cnt[N],tot[N],ans[N]; struct query{ int l,r,k,id; }q[N]; bool cmp(int a,int b){ return a<b; } bool Cmp(query a,query b){ if(a.k==b.k)return a.r<b.r; else return a.k<b.k; } void Discrete(){ sort(b+1,b+n+1,cmp); int tott=unique(b+1,b+n+1)-b-1; for(int i=1;i<=n;++i)a[i]=lower_bound(b+1,b+tott+1,a[i])-b; } void init(){ for(int i=1;i<=n;++i){ blk[i]=(i-1)/len+1; } num=blk[n]; for(int i=1;i<=num;++i){ L[i]=(i-1)*len+1; R[i]=(i==num)?n:i*len; } } signed main(){ scanf(\"%lld%lld\",&n,&m); for(int i=1;i<=n;++i)scanf(\"%lld\",&a[i]),b[i]=a[i]; Discrete(); len=sqrt(n); for(int i=1;i<=m;++i){ scanf(\"%lld%lld\",&q[i].l,&q[i].r); q[i].k=(q[i].l-1)/len+1; q[i].id=i; } sort(q+1,q+m+1,Cmp); init(); int l=1,r=0,tmp=0,block=0; for(int i=1;i<=m;++i){ int x=q[i].l,y=q[i].r,now=blk[x]; if(blk[x]==blk[y]){ tmp=0; for(int j=x;j<=y;++j)cnt[a[j]]=0; for(int j=x;j<=y;++j){ cnt[a[j]]++; tmp=max(tmp,cnt[a[j]]*b[a[j]]); } for(int j=x;j<=y;++j)cnt[a[j]]=0; ans[q[i].id]=tmp; continue; } if(block!=now){ tmp=0; for(int j=l;j<=r;++j)cnt[a[j]]=0; l=R[now]; r=l-1; block=now; } while(r<y){ ++r; cnt[a[r]]++; tmp=max(tmp,cnt[a[r]]*b[a[r]]); } int p=l,_tmp=0; while(p>x){ --p; tot[a[p]]++; _tmp=max(_tmp,(tot[a[p]]+cnt[a[p]])*b[a[p]]); } while(p<l){ tot[a[p]]=0; p++; } ans[q[i].id]=max(tmp,_tmp); } for(int i=1;i<=m;++i){ printf(\"%lld\\n\",ans[i]); } return 0; } P8078 ~~\u8003\u573a\u4e0a\u53ea\u62ff\u4e8635pts\u5dee\u4e94\u5206\u5c31\u6709\u94dc\u724c\u7684\u849f\u84bb~~ \u5bf9\u4e8e\u6240\u6709\u6570\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u6392\u5e8f\u540e\uff0c\u53ef\u4ee5\u7528\u94fe\u8868\u628a\u4ed6\u4eec\u8fde\u63a5\u8d77\u6765\uff0c\u94fe\u8868\u8fb9\u4e0a\u8bb0\u5f55\u4e00\u4e0b\u6743\u503c\u3002\u53d1\u73b0\u94fe\u8868\u5220\u9664+\u6062\u590d\u8fdc\u6bd4\u6dfb\u52a0\u7b80\u5355\u5f97\u591a\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u4e0d\u6dfb\u52a0\u83ab\u961f\u3002 \u4e0e\u4e0d\u5220\u9664\u83ab\u961f\u7c7b\u4f3c\uff0c\u90fd\u662f\u5904\u7406\u5b8c\u5de6\u7aef\u70b9\u56de\u6eda\u3002\u53ea\u662f\u8fd9\u4e2a\u521d\u59cb\u662f$l=1,r=n$,\u4ece\u4e24\u7aef\u5411\u4e2d\u95f4\u66f4\u6539$l,r$. ~~\u6700\u540e\u8f93\u7ed9\u4e86\u5de8\u5927\u7684\u5e38\u6570\u62ff\u4e8695pts~~ #include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<algorithm> #define rg register using namespace std; typedef long long ll; const int N=5e5+10,INF=0x3f3f3f3f; inline int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch<='9' && ch>='0') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } inline void write1(ll x){ if(x>9) write1(x/10); putchar(x%10+'0'); } struct node{ int l,r,k,id; }q[N]; struct link{ int v,p; }pre[N],nxt[N]; int n,m,K,L; ll tmp,_tmp; int a[N],blk[N],lb[N],rb[N],s[N]; ll ans[N]; bool cmp(node a,node b){ if(a.k==b.k) return a.r>b.r; return a.k<b.k; } void init(){ _tmp=0; for(rg int i=2;i<=n;++i){ int x=s[i]-s[i-1]; _tmp+=(ll)abs(x); nxt[i-1].v=i,nxt[i-1].p=x; pre[i].v=i-1,pre[i].p=-x; } pre[1].v=pre[1].p=-INF; nxt[n].v=nxt[n].p=-INF; } inline void del(int i){ int _x=pre[a[i]].v,_y=nxt[a[i]].v,l1=pre[a[i]].p,l2=nxt[a[i]].p,l3=-l1+l2; if(_x==-INF && _y!=-INF){//pre pre[_y].v=pre[_y].p=-INF; _tmp-=(ll)abs(l2); } if(_x!=-INF && _y==-INF){//nxt nxt[_x].v=nxt[_x].p=-INF; _tmp-=(ll)abs(l1); } if(_x!=-INF && _y!=-INF){//pre nxt nxt[_x].v=_y;nxt[_x].p=l3; pre[_y].v=_x;pre[_y].p=-l3; _tmp=_tmp-(ll)(abs(l1)+abs(l2)-abs(l3)); } } inline void cov(int i){ int _x=pre[a[i]].v,_y=nxt[a[i]].v,l1=pre[a[i]].p,l2=nxt[a[i]].p,l3=-l1+l2; if(_x==-INF && _y!=-INF){//pre pre[_y].v=a[i],pre[_y].p=-l2; _tmp+=(ll)abs(l2); } if(_x!=-INF && _y==-INF){//nxt nxt[_x].v=a[i];nxt[_x].p=-l1; _tmp+=(ll)abs(l1); } if(_x!=-INF && _y!=-INF){//pre nxt nxt[_x].v=a[i];nxt[_x].p=-l1; pre[_y].v=a[i];pre[_y].p=-l2; _tmp=_tmp+(ll)(abs(l1)+abs(l2)-abs(l3)); } } int main(){ n=read1(),m=read1();L=sqrt(n); for(rg int i=1;i<=n;++i) a[i]=read1(),s[a[i]]=i,blk[i]=(i-1)/L+1; for(rg int i=1;i<=m;++i) q[i].l=read1(),q[i].r=read1(),q[i].k=(q[i].l-1)/L+1,q[i].id=i; K=blk[n]; for(rg int i=1;i<=K;++i) lb[i]=(i-1)*L+1,rb[i]=min(i*L,n); sort(q+1,q+m+1,cmp); int l=1,r=n,now=0; init(); for(rg int i=1;i<=m;++i){ int x=q[i].l,y=q[i].r; if(blk[x]!=now){ now=blk[x]; while(r<n) cov(++r); while(l<lb[now]) del(l++); } while(r>y) del(r--); int p=l; while(p<x) del(p++); ans[q[i].id]=_tmp; while(p>l) cov(--p); } for(rg int i=1;i<=m;++i) write1(ans[i]),putchar('\\n'); return 0; }","title":"\u56de\u6eda\u83ab\u961f"},{"location":"my%20past/OI/%E8%99%9A%E6%A0%91/","text":"\u865a\u6811 \u6a21\u677f void insert(int u) { int lca=getlca(u,stk[top]); while(top>1 && id[stk[top-1]]>=id[lca]) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top;//dep[stk[top-1]]>=dep[lca]\u4e5f\u884c if(lca!=stk[top]) add(stk[top],lca,1),add(lca,stk[top],1),stk[top]=lca; stk[++top]=u; } void build() { cnt[1]=-1; sort(a+1,a+m+1,cmp); stk[top=1]=a[1]; for(int i=2; i<=m; ++i) insert(a[i]); while(top>1) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top; rt=stk[1]; } P6572 \u6811\u4e0a\u5dee\u5206+\u865a\u6811 \u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\uff0c\u5efa\u51fa\u865a\u6811\u540e\uff0c\u9996\u5148\u8981\u627e\u51fa\u6df1\u5ea6\u6700\u5927\u7684\u516c\u5171\u6839\uff0c\u9632\u6b62\u5c06\u4e0d\u7528\u7684\u7b54\u6848\u8bb0\u57281\uff08\u6574\u68f5\u6811\u7684\u6839\uff09\u4e0a\uff0c\u5bfc\u81f4\u51fa\u9519 hack \u6570\u636e\u4fbf\u662f\u7b2c\u4e00\u4e2a\u6837\u4f8b 6 3 2 1 3 2 3 3 4 6 4 4 5 4 1 3 2 5 2 6 3 2 3 2 \u65b9\u6cd5\uff1a void getroot(int u,int p){ if(vis[u])siz[u]=1; else siz[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(i>cnt)continue; if(v==p)continue; getroot(v,u); siz[u]+=siz[v]; } if(root==1 && siz[u]>=s)root=u;//\u8fd9\u4e00\u6b65\u7684\u89e3\u91ca\uff1a\u5982\u679c\u4e00\u4e2a\u70b9\u6db5\u76d6\u6240\u6709\u5173\u952e\u70b9\u4e14\u4e0d\u662f\u6839\uff0c\u5219\u5b83\u4e00\u5b9a\u662f\u6700\u5c0f\u7684\u6839\uff08\u56e0\u4e3a\u66f4\u65b0\u7b54\u6848\u662f\u5728\u56de\u6eaf\u65f6\uff0c\u6240\u4ee5\u6309\u7167\u4ece\u4e0b\u5f80\u4e0a\u7684\u987a\u5e8f\uff09 return; } \u4e4b\u540e\u6bcf\u6b21\u6df1\u641c\u5230\u4e00\u4e2a\u70b9\uff0c\u5c31\u5411\u5dee\u5206\u6570\u7ec4\u8bb0\u5f55\u4e00\u4e0b\uff0c\u5b50\u8282\u70b9\u4e0e\u5f53\u524d\u70b9\u4e4b\u95f4\u6240\u6709\u7684\u8fb9+1\uff0c\u505a\u5b8c\u4e00\u7ec4\u8be2\u95ee\u6e05\u96f6\uff0c\u6700\u540e\u5dee\u5206\u6570\u7ec4\u52a0\u8d77\u6765\u5c31\u662f\u7b54\u6848 P3233 ~~\u5173\u4e8e\u865a\u6811\u6a21\u677f\u5199\u5047\u4e86\u8c03\u4e86\u4e00\u4e0a\u5348\u8fd9\u4ef6\u4e8b~~ \u8fd9\u9053\u9898\u53ca\u5176~~\u6076\u5fc3~~\u590d\u6742,\u9700\u8981$6$\u6b21$dfs$\u3002 \u9884\u5904\u7406$lca,dep,size$ \u500d\u589e\u5904\u7406$fa$\uff0c\u56e0\u4e3a\u540e\u9762\u9664\u4e86\u6c42$lca$\u8fd8\u4f1a\u7528\u5230\u3002 \u6c42\u51fa\u865a\u6811\u4e2d\u6bcf\u4e2a\u865a\u6811\u8282\u70b9\u5b50\u6811\u4e2d\u8ddd\u79bb\u6b64\u8282\u70b9\u6700\u8fd1\u7684\"\u5173\u952e\u8282\u70b9\" \u6240\u6709\u5173\u952e\u8282\u70b9\u90fd\u5728\u865a\u6811\u4e0a\uff0c\u6240\u4ee5\u7b2c\u4e00\u904d\u4ece\u4e0b\u800c\u4e0a$dfs$\uff0c\u53ef\u4ee5\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u5728\u5b83\u5b50\u6811\u4e2d\u8ddd\u79bb\u5b83\u6700\u8fd1\u7684\u5173\u952e\u8282\u70b9(\u53ef\u4ee5\u662f\u81ea\u5df1)\u3002 \u6c42\u51fa\u865a\u6811\u4e2d\u8ddd\u79bb\u6bcf\u4e2a\u865a\u6811\u8282\u70b9\u6700\u8fd1\u7684\"\u5173\u952e\u8282\u70b9\" \u7b2c\u4e8c\u904d\u4ece\u4e0a\u800c\u4e0b\u6c42\u51fa\u5b50\u6811\u5916\u8d21\u732e\u3002 \u6ce8\u610f\uff0c\u6211\u4eec\u7ef4\u62a4\u7684\u662f\u4e00\u4e2a\u4e8c\u5143\u7ec4$g[u]$\uff0c\u7b2c\u4e00\u5173\u952e\u5b57\u4e3a\u8ddd\u79bb\uff0c\u7b2c\u4e8c\u5173\u952e\u5b57\u4e3a\u7f16\u53f7\u3002 \u6c42\u51fa\u865a\u6811\u4e0a\u6bcf\u4e2a\u8282\u70b9\u8ddd\u79bb\u6700\u8fd1\u7684\u70b9\u7f16\u53f7\uff0c\u4ee5\u53ca\u8282\u70b9\u4e0a\u7684\u8d21\u732e\u3002 \u6700\u8fd1\u8282\u70b9\u5c31\u662f$num[u]=g[u].second$,\u800c\u8282\u70b9\u4e0a\u7684\u8d21\u732e\u662f\u6307\uff1a\u5bf9\u4e8e\u865a\u6811\u8282\u70b9$u$\uff0c\u5176\u6240\u6709 \u6ca1\u6709\u5173\u952e\u70b9 \u7684\u5b50\u6811\uff0c\u90fd\u5c06\u5f52$num[u]$\u7ba1\u7406\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u904d\u5386\u865a\u6811\u65f6\uff0c\u53ef\u4ee5\u7528$u$\u6240\u5728\u7684\u5b50\u6811\u603b\u7ed3\u70b9\u6570\u51cf\u53bb\u6709\u5173\u952e\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u3002 \u6709\u5173\u952e\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u9700\u8981\u5728\u539f\u6811\u4e0a\u500d\u589e\u6c42\u51fa\u5bf9\u4e8e$v$\u6240\u5728\u5b50\u6811\u7684\u6839$up[v]$\uff0c\u8fd9\u65f6$up[v]$\u5728$u$\u4e0b\u9762\uff0c\u51cf\u6389$sz[up[v]]$\u5373\u53ef\u3002 \u6c42\u51fa\u865a\u6811\u4e0a\u6bcf\u6761\u8fb9\u7684\u8d21\u732e \u5bf9\u4e8e\u6bcf\u6761\u8fb9\u4e24\u7aef\u70b9$u,v$\uff0c\u6709\u4e24\u79cd\u60c5\u51b5\uff1a \u4e00\u662f$num[u]=num[v]$,\u8fd9\u79cd\u60c5\u51b5\u8fd9\u6761\u8fb9\u4e0a\u6240\u6709\u8282\u70b9\u90fd\u5f52$num[u]$\u7ba1\u5373\u53ef\u3002 \u4e8c\u662f$num[u]\\not =num[v]$,\u8fd9\u79cd\u60c5\u51b5\u5148\u6c42\u51fa\u4e2d\u95f4\u70b9\u7684\u6df1\u5ea6\uff0c\u518d\u4ece$v$\u500d\u589e\u627e\u51fa\u4e2d\u95f4\u70b9\u6807\u53f7\u5373\u53ef\u3002 \u5177\u4f53\u5730\uff0c\u4ece$num[u]$\u5230$num[v]$\u7684\u94fe\u957f\u5ea6$L$=$dep[num[v]]-dep[u]+g[u].first$. \u90a3\u4e48\u4e2d\u95f4\u70b9\u7684\u6df1\u5ea6=$\\frac{dep[num[v]]-L} 2$. \u6e05\u7a7a\u865a\u6811\u53ca\u70b9\u6807\u8bb0 \u9700\u8981\u6e05\u7a7a$vis[i],ans[i],up[i],num[i]$. \u81f3\u6b64\uff0c\u8fd9\u9053\u9898\u624d\u7b97\u505a\u5b8c\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<utility> using namespace std; typedef pair<int,int> PI; const int N=3e5+10,K=20,INF=0x3f3f3f3f; int fa[N][K],dep[N],head[2][N],vis[N],a[N],b[N],sz[N],stk[N],ans[N],id[N],num[N],up[N]; int n,q,u,v,cnt[2],tmp,m,top,tot,rt; PI g[N]; struct edge { int v,nxt; } e[2][N<<1]; void add(int u,int v,int i) { e[i][++cnt[i]].v=v,e[i][cnt[i]].nxt=head[i][u],head[i][u]=cnt[i]; } bool cmp(int a,int b) { return id[a]<id[b]; } int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x){ if(x>9) write1(x/10); putchar(x%10+'0'); } void dfs0(int u,int p) { id[u]=++tot;fa[u][0]=p;sz[u]=1; for(int i=1; i<K; ++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[0][u]; ~i; i=e[0][i].nxt) { int v=e[0][i].v; if(v==p) continue; dep[v]=dep[u]+1; dfs0(v,u); sz[u]+=sz[v]; } } void dfs1(int u,int p) { if(vis[u]) g[u]=make_pair(0,u); else g[u]=make_pair(INF,0); for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs1(v,u); g[u]=min(g[u],make_pair(g[v].first+dep[v]-dep[u],g[v].second)); } } void dfs2(int u,int p,int d,int x) { PI tmp=make_pair(d,x); if(tmp<g[u]) g[u]=tmp; else d=g[u].first,x=g[u].second; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs2(v,u,d+dep[v]-dep[u],x); } } void dfs3(int u,int p) { num[u]=g[u].second; ans[num[u]]+=sz[u]; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; int k=v; for(int j=K-1;j>=0;--j) if(fa[k][j] && dep[fa[k][j]]>dep[u]) k=fa[k][j]; ans[num[u]]-=sz[up[v]=k]; dfs3(v,u); } } void dfs4(int u,int p){ for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; if(num[v]==num[u]) ans[num[u]]+=(sz[up[v]]-sz[v]); else{ int dis=dep[num[v]]+dep[u]-g[u].first; dis=dis&1?dis+1>>1:(num[v]<num[u]?dis>>1:(dis>>1)+1); int k=v; for(int j=K-1;j>=0;--j) if(fa[k][j] && dep[fa[k][j]]>=dis) k=fa[k][j]; ans[num[u]]+=sz[up[v]]-sz[k]; ans[num[v]]+=sz[k]-sz[v]; } dfs4(v,u); } } void dfs5(int u,int p){//clear up[u]=num[u]=0; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs5(v,u); } head[1][u]=-1; } int getlca(int u,int v) { if(dep[u]<dep[v]) swap(u,v); int k=dep[u]-dep[v]; for(int i=K-1; i>=0; --i) if(k&(1<<i)) u=fa[u][i]; if(v==u) return u; for(int i=K-1; i>=0; --i) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0]; } void insert(int u) { int lca=getlca(u,stk[top]); while(top>1 && id[stk[top-1]]>=id[lca]) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top; if(lca!=stk[top]) add(stk[top],lca,1),add(lca,stk[top],1),stk[top]=lca; stk[++top]=u; } void build() { cnt[1]=-1; sort(a+1,a+m+1,cmp); stk[top=1]=a[1]; for(int i=2; i<=m; ++i) insert(a[i]); while(top>1) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top; rt=stk[1]; } int main() { memset(head,-1,sizeof head); cnt[0]=-1; scanf(\"%d\",&n); for(int i=1; i<n; ++i) scanf(\"%d%d\",&u,&v),add(u,v,0),add(v,u,0); dfs0(1,0); scanf(\"%d\",&q); for(int i=1; i<=q; ++i) { scanf(\"%d\",&m); for(int j=1; j<=m; ++j) scanf(\"%d\",&a[j]),b[j]=a[j],vis[b[j]]=1; build(); dfs1(rt,0); dfs2(rt,0,g[rt].first,g[rt].second); dfs3(rt,0); dfs4(rt,0); ans[num[rt]]+=sz[1]-sz[rt]; for(int j=1; j<=m; ++j) printf(\"%d \",ans[b[j]]),ans[b[j]]=vis[b[j]]=0;printf(\"\\n\"); dfs5(rt,0); } return 0; }","title":"\u865a\u6811"},{"location":"my%20past/OI/%E8%99%9A%E6%A0%91/#_1","text":"\u6a21\u677f void insert(int u) { int lca=getlca(u,stk[top]); while(top>1 && id[stk[top-1]]>=id[lca]) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top;//dep[stk[top-1]]>=dep[lca]\u4e5f\u884c if(lca!=stk[top]) add(stk[top],lca,1),add(lca,stk[top],1),stk[top]=lca; stk[++top]=u; } void build() { cnt[1]=-1; sort(a+1,a+m+1,cmp); stk[top=1]=a[1]; for(int i=2; i<=m; ++i) insert(a[i]); while(top>1) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top; rt=stk[1]; } P6572 \u6811\u4e0a\u5dee\u5206+\u865a\u6811 \u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\uff0c\u5efa\u51fa\u865a\u6811\u540e\uff0c\u9996\u5148\u8981\u627e\u51fa\u6df1\u5ea6\u6700\u5927\u7684\u516c\u5171\u6839\uff0c\u9632\u6b62\u5c06\u4e0d\u7528\u7684\u7b54\u6848\u8bb0\u57281\uff08\u6574\u68f5\u6811\u7684\u6839\uff09\u4e0a\uff0c\u5bfc\u81f4\u51fa\u9519 hack \u6570\u636e\u4fbf\u662f\u7b2c\u4e00\u4e2a\u6837\u4f8b 6 3 2 1 3 2 3 3 4 6 4 4 5 4 1 3 2 5 2 6 3 2 3 2 \u65b9\u6cd5\uff1a void getroot(int u,int p){ if(vis[u])siz[u]=1; else siz[u]=0; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; if(i>cnt)continue; if(v==p)continue; getroot(v,u); siz[u]+=siz[v]; } if(root==1 && siz[u]>=s)root=u;//\u8fd9\u4e00\u6b65\u7684\u89e3\u91ca\uff1a\u5982\u679c\u4e00\u4e2a\u70b9\u6db5\u76d6\u6240\u6709\u5173\u952e\u70b9\u4e14\u4e0d\u662f\u6839\uff0c\u5219\u5b83\u4e00\u5b9a\u662f\u6700\u5c0f\u7684\u6839\uff08\u56e0\u4e3a\u66f4\u65b0\u7b54\u6848\u662f\u5728\u56de\u6eaf\u65f6\uff0c\u6240\u4ee5\u6309\u7167\u4ece\u4e0b\u5f80\u4e0a\u7684\u987a\u5e8f\uff09 return; } \u4e4b\u540e\u6bcf\u6b21\u6df1\u641c\u5230\u4e00\u4e2a\u70b9\uff0c\u5c31\u5411\u5dee\u5206\u6570\u7ec4\u8bb0\u5f55\u4e00\u4e0b\uff0c\u5b50\u8282\u70b9\u4e0e\u5f53\u524d\u70b9\u4e4b\u95f4\u6240\u6709\u7684\u8fb9+1\uff0c\u505a\u5b8c\u4e00\u7ec4\u8be2\u95ee\u6e05\u96f6\uff0c\u6700\u540e\u5dee\u5206\u6570\u7ec4\u52a0\u8d77\u6765\u5c31\u662f\u7b54\u6848 P3233 ~~\u5173\u4e8e\u865a\u6811\u6a21\u677f\u5199\u5047\u4e86\u8c03\u4e86\u4e00\u4e0a\u5348\u8fd9\u4ef6\u4e8b~~ \u8fd9\u9053\u9898\u53ca\u5176~~\u6076\u5fc3~~\u590d\u6742,\u9700\u8981$6$\u6b21$dfs$\u3002 \u9884\u5904\u7406$lca,dep,size$ \u500d\u589e\u5904\u7406$fa$\uff0c\u56e0\u4e3a\u540e\u9762\u9664\u4e86\u6c42$lca$\u8fd8\u4f1a\u7528\u5230\u3002 \u6c42\u51fa\u865a\u6811\u4e2d\u6bcf\u4e2a\u865a\u6811\u8282\u70b9\u5b50\u6811\u4e2d\u8ddd\u79bb\u6b64\u8282\u70b9\u6700\u8fd1\u7684\"\u5173\u952e\u8282\u70b9\" \u6240\u6709\u5173\u952e\u8282\u70b9\u90fd\u5728\u865a\u6811\u4e0a\uff0c\u6240\u4ee5\u7b2c\u4e00\u904d\u4ece\u4e0b\u800c\u4e0a$dfs$\uff0c\u53ef\u4ee5\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u5728\u5b83\u5b50\u6811\u4e2d\u8ddd\u79bb\u5b83\u6700\u8fd1\u7684\u5173\u952e\u8282\u70b9(\u53ef\u4ee5\u662f\u81ea\u5df1)\u3002 \u6c42\u51fa\u865a\u6811\u4e2d\u8ddd\u79bb\u6bcf\u4e2a\u865a\u6811\u8282\u70b9\u6700\u8fd1\u7684\"\u5173\u952e\u8282\u70b9\" \u7b2c\u4e8c\u904d\u4ece\u4e0a\u800c\u4e0b\u6c42\u51fa\u5b50\u6811\u5916\u8d21\u732e\u3002 \u6ce8\u610f\uff0c\u6211\u4eec\u7ef4\u62a4\u7684\u662f\u4e00\u4e2a\u4e8c\u5143\u7ec4$g[u]$\uff0c\u7b2c\u4e00\u5173\u952e\u5b57\u4e3a\u8ddd\u79bb\uff0c\u7b2c\u4e8c\u5173\u952e\u5b57\u4e3a\u7f16\u53f7\u3002 \u6c42\u51fa\u865a\u6811\u4e0a\u6bcf\u4e2a\u8282\u70b9\u8ddd\u79bb\u6700\u8fd1\u7684\u70b9\u7f16\u53f7\uff0c\u4ee5\u53ca\u8282\u70b9\u4e0a\u7684\u8d21\u732e\u3002 \u6700\u8fd1\u8282\u70b9\u5c31\u662f$num[u]=g[u].second$,\u800c\u8282\u70b9\u4e0a\u7684\u8d21\u732e\u662f\u6307\uff1a\u5bf9\u4e8e\u865a\u6811\u8282\u70b9$u$\uff0c\u5176\u6240\u6709 \u6ca1\u6709\u5173\u952e\u70b9 \u7684\u5b50\u6811\uff0c\u90fd\u5c06\u5f52$num[u]$\u7ba1\u7406\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u904d\u5386\u865a\u6811\u65f6\uff0c\u53ef\u4ee5\u7528$u$\u6240\u5728\u7684\u5b50\u6811\u603b\u7ed3\u70b9\u6570\u51cf\u53bb\u6709\u5173\u952e\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u3002 \u6709\u5173\u952e\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u9700\u8981\u5728\u539f\u6811\u4e0a\u500d\u589e\u6c42\u51fa\u5bf9\u4e8e$v$\u6240\u5728\u5b50\u6811\u7684\u6839$up[v]$\uff0c\u8fd9\u65f6$up[v]$\u5728$u$\u4e0b\u9762\uff0c\u51cf\u6389$sz[up[v]]$\u5373\u53ef\u3002 \u6c42\u51fa\u865a\u6811\u4e0a\u6bcf\u6761\u8fb9\u7684\u8d21\u732e \u5bf9\u4e8e\u6bcf\u6761\u8fb9\u4e24\u7aef\u70b9$u,v$\uff0c\u6709\u4e24\u79cd\u60c5\u51b5\uff1a \u4e00\u662f$num[u]=num[v]$,\u8fd9\u79cd\u60c5\u51b5\u8fd9\u6761\u8fb9\u4e0a\u6240\u6709\u8282\u70b9\u90fd\u5f52$num[u]$\u7ba1\u5373\u53ef\u3002 \u4e8c\u662f$num[u]\\not =num[v]$,\u8fd9\u79cd\u60c5\u51b5\u5148\u6c42\u51fa\u4e2d\u95f4\u70b9\u7684\u6df1\u5ea6\uff0c\u518d\u4ece$v$\u500d\u589e\u627e\u51fa\u4e2d\u95f4\u70b9\u6807\u53f7\u5373\u53ef\u3002 \u5177\u4f53\u5730\uff0c\u4ece$num[u]$\u5230$num[v]$\u7684\u94fe\u957f\u5ea6$L$=$dep[num[v]]-dep[u]+g[u].first$. \u90a3\u4e48\u4e2d\u95f4\u70b9\u7684\u6df1\u5ea6=$\\frac{dep[num[v]]-L} 2$. \u6e05\u7a7a\u865a\u6811\u53ca\u70b9\u6807\u8bb0 \u9700\u8981\u6e05\u7a7a$vis[i],ans[i],up[i],num[i]$. \u81f3\u6b64\uff0c\u8fd9\u9053\u9898\u624d\u7b97\u505a\u5b8c\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<utility> using namespace std; typedef pair<int,int> PI; const int N=3e5+10,K=20,INF=0x3f3f3f3f; int fa[N][K],dep[N],head[2][N],vis[N],a[N],b[N],sz[N],stk[N],ans[N],id[N],num[N],up[N]; int n,q,u,v,cnt[2],tmp,m,top,tot,rt; PI g[N]; struct edge { int v,nxt; } e[2][N<<1]; void add(int u,int v,int i) { e[i][++cnt[i]].v=v,e[i][cnt[i]].nxt=head[i][u],head[i][u]=cnt[i]; } bool cmp(int a,int b) { return id[a]<id[b]; } int read1(){ int x=0;char ch=getchar(); while(ch<'0' || ch>'9') ch=getchar(); while(ch>='0' && ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar(); return x; } void write1(int x){ if(x>9) write1(x/10); putchar(x%10+'0'); } void dfs0(int u,int p) { id[u]=++tot;fa[u][0]=p;sz[u]=1; for(int i=1; i<K; ++i) fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[0][u]; ~i; i=e[0][i].nxt) { int v=e[0][i].v; if(v==p) continue; dep[v]=dep[u]+1; dfs0(v,u); sz[u]+=sz[v]; } } void dfs1(int u,int p) { if(vis[u]) g[u]=make_pair(0,u); else g[u]=make_pair(INF,0); for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs1(v,u); g[u]=min(g[u],make_pair(g[v].first+dep[v]-dep[u],g[v].second)); } } void dfs2(int u,int p,int d,int x) { PI tmp=make_pair(d,x); if(tmp<g[u]) g[u]=tmp; else d=g[u].first,x=g[u].second; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs2(v,u,d+dep[v]-dep[u],x); } } void dfs3(int u,int p) { num[u]=g[u].second; ans[num[u]]+=sz[u]; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; int k=v; for(int j=K-1;j>=0;--j) if(fa[k][j] && dep[fa[k][j]]>dep[u]) k=fa[k][j]; ans[num[u]]-=sz[up[v]=k]; dfs3(v,u); } } void dfs4(int u,int p){ for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; if(num[v]==num[u]) ans[num[u]]+=(sz[up[v]]-sz[v]); else{ int dis=dep[num[v]]+dep[u]-g[u].first; dis=dis&1?dis+1>>1:(num[v]<num[u]?dis>>1:(dis>>1)+1); int k=v; for(int j=K-1;j>=0;--j) if(fa[k][j] && dep[fa[k][j]]>=dis) k=fa[k][j]; ans[num[u]]+=sz[up[v]]-sz[k]; ans[num[v]]+=sz[k]-sz[v]; } dfs4(v,u); } } void dfs5(int u,int p){//clear up[u]=num[u]=0; for(int i=head[1][u]; ~i; i=e[1][i].nxt) { int v=e[1][i].v; if(v==p) continue; dfs5(v,u); } head[1][u]=-1; } int getlca(int u,int v) { if(dep[u]<dep[v]) swap(u,v); int k=dep[u]-dep[v]; for(int i=K-1; i>=0; --i) if(k&(1<<i)) u=fa[u][i]; if(v==u) return u; for(int i=K-1; i>=0; --i) if(fa[u][i]!=fa[v][i]) u=fa[u][i],v=fa[v][i]; return fa[u][0]; } void insert(int u) { int lca=getlca(u,stk[top]); while(top>1 && id[stk[top-1]]>=id[lca]) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top; if(lca!=stk[top]) add(stk[top],lca,1),add(lca,stk[top],1),stk[top]=lca; stk[++top]=u; } void build() { cnt[1]=-1; sort(a+1,a+m+1,cmp); stk[top=1]=a[1]; for(int i=2; i<=m; ++i) insert(a[i]); while(top>1) add(stk[top],stk[top-1],1),add(stk[top-1],stk[top],1),--top; rt=stk[1]; } int main() { memset(head,-1,sizeof head); cnt[0]=-1; scanf(\"%d\",&n); for(int i=1; i<n; ++i) scanf(\"%d%d\",&u,&v),add(u,v,0),add(v,u,0); dfs0(1,0); scanf(\"%d\",&q); for(int i=1; i<=q; ++i) { scanf(\"%d\",&m); for(int j=1; j<=m; ++j) scanf(\"%d\",&a[j]),b[j]=a[j],vis[b[j]]=1; build(); dfs1(rt,0); dfs2(rt,0,g[rt].first,g[rt].second); dfs3(rt,0); dfs4(rt,0); ans[num[rt]]+=sz[1]-sz[rt]; for(int j=1; j<=m; ++j) printf(\"%d \",ans[b[j]]),ans[b[j]]=vis[b[j]]=0;printf(\"\\n\"); dfs5(rt,0); } return 0; }","title":"\u865a\u6811"},{"location":"my%20past/OI/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","text":"\u8bb0\u5fc6\u5316\u641c\u7d22 UVA437 \u4e5f\u662f\u4e00\u9053\u5f88\u597d\u7684\u8bb0\u5fc6\u5316\u641c\u7d22\u7684\u9898\u3002 ~~\u521a\u770b\u5230\u8fd9\u9898\u65f6\u6211\u662f\u61f5\u903c\u7684~~ \u5bf9\u4e8e\u6bcf\u4e2a\u5757\uff0c\u90fd\u80fd\u591f\u4ea7\u751f\u4e09\u79cd\u72b6\u6001\uff0c\u5e76\u4e14\u56e0\u4e3a\u9898\u76ee\u8bf4\u8981\u4e25\u683c\u5c0f\u4e8e\uff0c\u6240\u4ee5\u8fd9\u4e09\u79cd\u72b6\u6001\u6700\u591a\u53ea\u80fd\u653e\u4e00\u4e2a\uff0c\u56e0\u6b64\u6240\u6709\u5757\u7684\u6240\u6709\u72b6\u6001\u52a0\u4e00\u5757\u5c31\u53ea\u6709$3n$\u79cd\u3002 \u8fd9\u5927\u5927\u7b80\u5316\u4e86\u9898\u76ee\u7684\u96be\u5ea6\u3002 \u7531\u9898\u76ee\u6211\u4eec\u77e5\u9053\uff0c\u4e0d\u4f1a\u51fa\u73b0\u4e24\u4e2a\u67f1\u5b50\u67b6\u6865\u7684\u60c5\u51b5\uff0c\u6bcf\u4e2a\u5757\u4e0a\u53ea\u80fd\u653e\u4e00\u4e2a\u5757\u3002 \u4e0b\u9762\u5f00\u59cb\u505a\u9898\u3002 1) \u53e3\u80e1\u7bc7 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8bbe$f[x][y]$\u8868\u793a\u4e0b\u9762\u6709\u957f\u8fb9\u4e3a$x$\uff0c\u77ed\u8fb9\u4e3a$y$\u7684\u65b9\u5757\u65f6\uff0c\u80fd\u653e\u7684\u6700\u5927\u9ad8\u5ea6\u3002 $x,y$\u53ef\u80fd\u5f88\u5927? \u6ca1\u5173\u7cfb\uff0c\u56e0\u4e3a\u53ea\u6709$3n$\u4e2a\u6240\u4ee5\u76f4\u63a5\u79bb\u6563\u5316\u3002 \u653e\u65b9\u5757\u7684\u987a\u5e8f\u5c31\u662f\u6309\u7167$x$\u548c$y$\u4e3a\u7b2c\u4e00\u3001\u7b2c\u4e8c\u5173\u952e\u5b57\u6392\u5e8f\uff0c\u8fd9\u6837\u526a\u679d\u7a0d\u5fae\u63d0\u5347\u901f\u5ea6\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=310; int f[N][N],g[N]; int cnt,n; struct node { int x,y,h; } q[N]; bool Cmp(node a,node b){ if(a.x==b.x)return a.y>b.y; else return a.x>b.x; } bool cmp(int a,int b){ return a<b; } void init() {//Discrete memset(f,0,sizeof f); int a,b,c; for(int i=1; i<=n; ++i) { scanf(\"%lld%lld%lld\",&a,&b,&c); g[3*i-2]=a,g[3*i-1]=b,g[3*i]=c; if(a>b)swap(a,b); if(a>c)swap(a,c); if(b>c)swap(b,c); q[3*i-2].x=c,q[3*i-2].y=b,q[3*i-2].h=a; q[3*i-1].x=c,q[3*i-1].y=a,q[3*i-1].h=b; q[3*i].x=b,q[3*i].y=a,q[3*i].h=c; } sort(g+1,g+3*n+1,cmp); int tot=unique(g+1,g+3*n+1)-g-1; for(int i=1;i<=3*n;++i){ q[i].x=lower_bound(g+1,g+tot+1,q[i].x)-g; q[i].y=lower_bound(g+1,g+tot+1,q[i].y)-g; } sort(q+1,q+3*n+1,Cmp); } int dp(int x,int y,int p){ if(x<y || x<=0 || y<=0)return 0; if(f[x][y])return f[x][y]; for(int i=p;i<=3*n;++i){ if(q[i].x<x && q[i].y<y || q[i].y<x && q[i].x<y)f[x][y]=max(f[x][y],dp(q[i].x,q[i].y,i)+q[i].h); } return f[x][y]; } signed main() { while(1) { ++cnt; scanf(\"%lld\",&n); if(!n)return 0; init(); int ans=0; for(int i=1;i<=3*n;++i){ ans=max(ans,dp(q[i].x,q[i].y,i)+q[i].h); } printf(\"Case %lld: maximum height = %lld\\n\",cnt,ans); } return 0; } 2) \u6b63\u89e3\u7bc7 \u4e8b\u5b9e\u4e0a\uff0c\u72b6\u6001\u5c31\u53ea\u6709$O(n)$\u79cd\uff0c\u8bbe$f[x]$\u8868\u793a\u4e0b\u9762\u662f$x$\u65f6\u7684\u6700\u5927\u503c\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u8fd8\u662f$O(n^2)$\uff0c\u7a7a\u95f4\u53ef\u53d8\u4e3a$O(n)$ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=95; int f[N],g[N]; int cnt,n; struct node { int x,y,h; } q[N]; bool Cmp(node a,node b){ if(a.x==b.x)return a.y>b.y; else return a.x>b.x; } bool cmp(int a,int b){ return a<b; } void init() {//Discrete memset(f,0,sizeof f); int a,b,c; for(int i=1; i<=n; ++i) { scanf(\"%lld%lld%lld\",&a,&b,&c); g[3*i-2]=a,g[3*i-1]=b,g[3*i]=c; if(a>b)swap(a,b); if(a>c)swap(a,c); if(b>c)swap(b,c); q[3*i-2].x=c,q[3*i-2].y=b,q[3*i-2].h=a; q[3*i-1].x=c,q[3*i-1].y=a,q[3*i-1].h=b; q[3*i].x=b,q[3*i].y=a,q[3*i].h=c; } sort(g+1,g+3*n+1,cmp); int tot=unique(g+1,g+3*n+1)-g-1; for(int i=1;i<=3*n;++i){ q[i].x=lower_bound(g+1,g+tot+1,q[i].x)-g; q[i].y=lower_bound(g+1,g+tot+1,q[i].y)-g; } sort(q+1,q+3*n+1,Cmp); } int dp(int p){ int x=q[p].x,y=q[p].y; if(x<y || x<=0 || y<=0)return 0; if(f[p])return f[p]; for(int i=p;i<=3*n;++i){ if(q[i].x<x && q[i].y<y)f[p]=max(f[p],dp(i)+q[i].h); } return f[p]; } signed main() { while(1) { ++cnt; scanf(\"%lld\",&n); if(!n)return 0; init(); int ans=0; for(int i=1;i<=3*n;++i){ ans=max(ans,dp(i)+q[i].h); } printf(\"Case %lld: maximum height = %lld\\n\",cnt,ans); } return 0; } \u7ed3\u8bba\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u57fa\u672c\u4e0e\u7a7a\u95f4\u590d\u6742\u5ea6\u4e00\u81f4\uff0c\u53ea\u8981\u72b6\u6001\u8bbe\u8ba1\u6ca1\u95ee\u9898\uff0c\u65f6\u95f4\u4e0a\u5c31\u8fc7\u5f97\u53bb\u3002 P2476 \u9996\u5148\u8bf4\u660e$f[i][j]$\u8868\u793a\u524d$i$\u4e2a\u6728\u5757\u5df2\u7ecf\u6d82\u5b8c\uff0c\u6700\u524d\u9762\u7684\u6728\u5757\u989c\u8272\u4e3a$j$\u7684\u72b6\u6001\u8bbe\u8ba1\u662f\u9519\u8bef\u7684\uff0c\u56e0\u4e3a\u540c\u4e00\u79cd\u72b6\u6001\u53ef\u80fd\u8868\u793a\u591a\u4e2a\u5206\u652f\uff0c\u4f46\u6709\u7684\u5206\u652f\u53ef\u80fd\u5b58\u5728\u66f4\u591a\u7684\u89e3\u4e0d\u80fd\u88ab\u641c\u5230\uff0c\u4f8b\u5982\u524d\u4e00\u79cd\u5206\u652f\u4e2d$c[k]==0$,\u4f46\u540e\u4e00\u79cd\u5206\u652f$c[k]>0$\uff0c\u53ef\u4ee5\u7ee7\u7eed\u641c\u7d22\uff0c\u4f46\u662f\u7531\u4e8e\u8bb0\u5fc6\u5316\u5bfc\u81f4\u76f4\u63a5\u9000\u51fa\uff0c\u4f7f\u5f97\u7b54\u6848\u53d8\u5c0f\u3002 \u89c2\u5bdf\u5230$c_i$\u5f88\u5c0f\uff0c\u6240\u4ee5\u76f4\u63a5\u8bbe$f[a][b][c][d][e][last]$\u8868\u793a\u6709\u591a\u5c11\u4e2a\u5269$1,2,3,4,5$\u4e2a\u7684\u989c\u8272\u4e14\u4e0a\u4e00\u6b21\u67d3\u8272\u662f\u5269$last$\u4e2a\u7684\u989c\u8272\u65f6\u7684\u8d21\u732e\u3002 \u6bcf\u6b21\u9009\u62e9\u4e00\u79cd\u989c\u8272\uff0c\u90a3\u4e48\u8fd9\u79cd\u989c\u8272\u5269\u4f59\u6570$-1$\uff0c\u6bd4\u4ed6\u5c0f$1$\u7684\u989c\u8272\u6570$+1$,\u5982\u679c$last$\u6bd4\u4ed6\u5927$1$\uff0c\u8bf4\u660e\u8fd9\u4e00\u8f6e\u6709\u4e00\u4e2a\u989c\u8272\u4e0d\u80fd\u7528\uff0c\u6240\u4ee5\u8fd9\u4e00\u8f6e\u603b\u5171\u80fd\u53d6\u7684\u989c\u8272\u6570$-1$. #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=16,M=6,P=1e9+7; int k,n,ans; int v[N],vis[M]; int f[N][N][N][N][N][M]; int dfs(int a,int b,int c,int d,int e,int last){ if(f[a][b][c][d][e][last])return f[a][b][c][d][e][last]; if(a+b+c+d+e==0)return f[a][b][c][d][e][last]=1; int res=0; if(a)res=(res+(a-(last==2))*dfs(a-1,b,c,d,e,1)%P)%P; if(b)res=(res+(b-(last==3))*dfs(a+1,b-1,c,d,e,2)%P)%P; if(c)res=(res+(c-(last==4))*dfs(a,b+1,c-1,d,e,3)%P)%P; if(d)res=(res+(d-(last==5))*dfs(a,b,c+1,d-1,e,4)%P)%P; if(e)res=(res+e*dfs(a,b,c,d+1,e-1,5)%P)%P; return f[a][b][c][d][e][last]=res; } signed main(){ scanf(\"%lld\",&k); for(int i=1;i<=k;++i)scanf(\"%lld\",&v[i]),n+=v[i],++vis[v[i]]; printf(\"%lld\",dfs(vis[1],vis[2],vis[3],vis[4],vis[5],0)%P); return 0; }","title":"\u8bb0\u5fc6\u5316\u641c\u7d22"},{"location":"my%20past/OI/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/#_1","text":"UVA437 \u4e5f\u662f\u4e00\u9053\u5f88\u597d\u7684\u8bb0\u5fc6\u5316\u641c\u7d22\u7684\u9898\u3002 ~~\u521a\u770b\u5230\u8fd9\u9898\u65f6\u6211\u662f\u61f5\u903c\u7684~~ \u5bf9\u4e8e\u6bcf\u4e2a\u5757\uff0c\u90fd\u80fd\u591f\u4ea7\u751f\u4e09\u79cd\u72b6\u6001\uff0c\u5e76\u4e14\u56e0\u4e3a\u9898\u76ee\u8bf4\u8981\u4e25\u683c\u5c0f\u4e8e\uff0c\u6240\u4ee5\u8fd9\u4e09\u79cd\u72b6\u6001\u6700\u591a\u53ea\u80fd\u653e\u4e00\u4e2a\uff0c\u56e0\u6b64\u6240\u6709\u5757\u7684\u6240\u6709\u72b6\u6001\u52a0\u4e00\u5757\u5c31\u53ea\u6709$3n$\u79cd\u3002 \u8fd9\u5927\u5927\u7b80\u5316\u4e86\u9898\u76ee\u7684\u96be\u5ea6\u3002 \u7531\u9898\u76ee\u6211\u4eec\u77e5\u9053\uff0c\u4e0d\u4f1a\u51fa\u73b0\u4e24\u4e2a\u67f1\u5b50\u67b6\u6865\u7684\u60c5\u51b5\uff0c\u6bcf\u4e2a\u5757\u4e0a\u53ea\u80fd\u653e\u4e00\u4e2a\u5757\u3002 \u4e0b\u9762\u5f00\u59cb\u505a\u9898\u3002 1) \u53e3\u80e1\u7bc7 \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8bbe$f[x][y]$\u8868\u793a\u4e0b\u9762\u6709\u957f\u8fb9\u4e3a$x$\uff0c\u77ed\u8fb9\u4e3a$y$\u7684\u65b9\u5757\u65f6\uff0c\u80fd\u653e\u7684\u6700\u5927\u9ad8\u5ea6\u3002 $x,y$\u53ef\u80fd\u5f88\u5927? \u6ca1\u5173\u7cfb\uff0c\u56e0\u4e3a\u53ea\u6709$3n$\u4e2a\u6240\u4ee5\u76f4\u63a5\u79bb\u6563\u5316\u3002 \u653e\u65b9\u5757\u7684\u987a\u5e8f\u5c31\u662f\u6309\u7167$x$\u548c$y$\u4e3a\u7b2c\u4e00\u3001\u7b2c\u4e8c\u5173\u952e\u5b57\u6392\u5e8f\uff0c\u8fd9\u6837\u526a\u679d\u7a0d\u5fae\u63d0\u5347\u901f\u5ea6\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=310; int f[N][N],g[N]; int cnt,n; struct node { int x,y,h; } q[N]; bool Cmp(node a,node b){ if(a.x==b.x)return a.y>b.y; else return a.x>b.x; } bool cmp(int a,int b){ return a<b; } void init() {//Discrete memset(f,0,sizeof f); int a,b,c; for(int i=1; i<=n; ++i) { scanf(\"%lld%lld%lld\",&a,&b,&c); g[3*i-2]=a,g[3*i-1]=b,g[3*i]=c; if(a>b)swap(a,b); if(a>c)swap(a,c); if(b>c)swap(b,c); q[3*i-2].x=c,q[3*i-2].y=b,q[3*i-2].h=a; q[3*i-1].x=c,q[3*i-1].y=a,q[3*i-1].h=b; q[3*i].x=b,q[3*i].y=a,q[3*i].h=c; } sort(g+1,g+3*n+1,cmp); int tot=unique(g+1,g+3*n+1)-g-1; for(int i=1;i<=3*n;++i){ q[i].x=lower_bound(g+1,g+tot+1,q[i].x)-g; q[i].y=lower_bound(g+1,g+tot+1,q[i].y)-g; } sort(q+1,q+3*n+1,Cmp); } int dp(int x,int y,int p){ if(x<y || x<=0 || y<=0)return 0; if(f[x][y])return f[x][y]; for(int i=p;i<=3*n;++i){ if(q[i].x<x && q[i].y<y || q[i].y<x && q[i].x<y)f[x][y]=max(f[x][y],dp(q[i].x,q[i].y,i)+q[i].h); } return f[x][y]; } signed main() { while(1) { ++cnt; scanf(\"%lld\",&n); if(!n)return 0; init(); int ans=0; for(int i=1;i<=3*n;++i){ ans=max(ans,dp(q[i].x,q[i].y,i)+q[i].h); } printf(\"Case %lld: maximum height = %lld\\n\",cnt,ans); } return 0; } 2) \u6b63\u89e3\u7bc7 \u4e8b\u5b9e\u4e0a\uff0c\u72b6\u6001\u5c31\u53ea\u6709$O(n)$\u79cd\uff0c\u8bbe$f[x]$\u8868\u793a\u4e0b\u9762\u662f$x$\u65f6\u7684\u6700\u5927\u503c\u3002 \u65f6\u95f4\u590d\u6742\u5ea6\u8fd8\u662f$O(n^2)$\uff0c\u7a7a\u95f4\u53ef\u53d8\u4e3a$O(n)$ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=95; int f[N],g[N]; int cnt,n; struct node { int x,y,h; } q[N]; bool Cmp(node a,node b){ if(a.x==b.x)return a.y>b.y; else return a.x>b.x; } bool cmp(int a,int b){ return a<b; } void init() {//Discrete memset(f,0,sizeof f); int a,b,c; for(int i=1; i<=n; ++i) { scanf(\"%lld%lld%lld\",&a,&b,&c); g[3*i-2]=a,g[3*i-1]=b,g[3*i]=c; if(a>b)swap(a,b); if(a>c)swap(a,c); if(b>c)swap(b,c); q[3*i-2].x=c,q[3*i-2].y=b,q[3*i-2].h=a; q[3*i-1].x=c,q[3*i-1].y=a,q[3*i-1].h=b; q[3*i].x=b,q[3*i].y=a,q[3*i].h=c; } sort(g+1,g+3*n+1,cmp); int tot=unique(g+1,g+3*n+1)-g-1; for(int i=1;i<=3*n;++i){ q[i].x=lower_bound(g+1,g+tot+1,q[i].x)-g; q[i].y=lower_bound(g+1,g+tot+1,q[i].y)-g; } sort(q+1,q+3*n+1,Cmp); } int dp(int p){ int x=q[p].x,y=q[p].y; if(x<y || x<=0 || y<=0)return 0; if(f[p])return f[p]; for(int i=p;i<=3*n;++i){ if(q[i].x<x && q[i].y<y)f[p]=max(f[p],dp(i)+q[i].h); } return f[p]; } signed main() { while(1) { ++cnt; scanf(\"%lld\",&n); if(!n)return 0; init(); int ans=0; for(int i=1;i<=3*n;++i){ ans=max(ans,dp(i)+q[i].h); } printf(\"Case %lld: maximum height = %lld\\n\",cnt,ans); } return 0; } \u7ed3\u8bba\uff1a\u8bb0\u5fc6\u5316\u641c\u7d22\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u57fa\u672c\u4e0e\u7a7a\u95f4\u590d\u6742\u5ea6\u4e00\u81f4\uff0c\u53ea\u8981\u72b6\u6001\u8bbe\u8ba1\u6ca1\u95ee\u9898\uff0c\u65f6\u95f4\u4e0a\u5c31\u8fc7\u5f97\u53bb\u3002 P2476 \u9996\u5148\u8bf4\u660e$f[i][j]$\u8868\u793a\u524d$i$\u4e2a\u6728\u5757\u5df2\u7ecf\u6d82\u5b8c\uff0c\u6700\u524d\u9762\u7684\u6728\u5757\u989c\u8272\u4e3a$j$\u7684\u72b6\u6001\u8bbe\u8ba1\u662f\u9519\u8bef\u7684\uff0c\u56e0\u4e3a\u540c\u4e00\u79cd\u72b6\u6001\u53ef\u80fd\u8868\u793a\u591a\u4e2a\u5206\u652f\uff0c\u4f46\u6709\u7684\u5206\u652f\u53ef\u80fd\u5b58\u5728\u66f4\u591a\u7684\u89e3\u4e0d\u80fd\u88ab\u641c\u5230\uff0c\u4f8b\u5982\u524d\u4e00\u79cd\u5206\u652f\u4e2d$c[k]==0$,\u4f46\u540e\u4e00\u79cd\u5206\u652f$c[k]>0$\uff0c\u53ef\u4ee5\u7ee7\u7eed\u641c\u7d22\uff0c\u4f46\u662f\u7531\u4e8e\u8bb0\u5fc6\u5316\u5bfc\u81f4\u76f4\u63a5\u9000\u51fa\uff0c\u4f7f\u5f97\u7b54\u6848\u53d8\u5c0f\u3002 \u89c2\u5bdf\u5230$c_i$\u5f88\u5c0f\uff0c\u6240\u4ee5\u76f4\u63a5\u8bbe$f[a][b][c][d][e][last]$\u8868\u793a\u6709\u591a\u5c11\u4e2a\u5269$1,2,3,4,5$\u4e2a\u7684\u989c\u8272\u4e14\u4e0a\u4e00\u6b21\u67d3\u8272\u662f\u5269$last$\u4e2a\u7684\u989c\u8272\u65f6\u7684\u8d21\u732e\u3002 \u6bcf\u6b21\u9009\u62e9\u4e00\u79cd\u989c\u8272\uff0c\u90a3\u4e48\u8fd9\u79cd\u989c\u8272\u5269\u4f59\u6570$-1$\uff0c\u6bd4\u4ed6\u5c0f$1$\u7684\u989c\u8272\u6570$+1$,\u5982\u679c$last$\u6bd4\u4ed6\u5927$1$\uff0c\u8bf4\u660e\u8fd9\u4e00\u8f6e\u6709\u4e00\u4e2a\u989c\u8272\u4e0d\u80fd\u7528\uff0c\u6240\u4ee5\u8fd9\u4e00\u8f6e\u603b\u5171\u80fd\u53d6\u7684\u989c\u8272\u6570$-1$. #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=16,M=6,P=1e9+7; int k,n,ans; int v[N],vis[M]; int f[N][N][N][N][N][M]; int dfs(int a,int b,int c,int d,int e,int last){ if(f[a][b][c][d][e][last])return f[a][b][c][d][e][last]; if(a+b+c+d+e==0)return f[a][b][c][d][e][last]=1; int res=0; if(a)res=(res+(a-(last==2))*dfs(a-1,b,c,d,e,1)%P)%P; if(b)res=(res+(b-(last==3))*dfs(a+1,b-1,c,d,e,2)%P)%P; if(c)res=(res+(c-(last==4))*dfs(a,b+1,c-1,d,e,3)%P)%P; if(d)res=(res+(d-(last==5))*dfs(a,b,c+1,d-1,e,4)%P)%P; if(e)res=(res+e*dfs(a,b,c,d+1,e-1,5)%P)%P; return f[a][b][c][d][e][last]=res; } signed main(){ scanf(\"%lld\",&k); for(int i=1;i<=k;++i)scanf(\"%lld\",&v[i]),n+=v[i],++vis[v[i]]; printf(\"%lld\",dfs(vis[1],vis[2],vis[3],vis[4],vis[5],0)%P); return 0; }","title":"\u8bb0\u5fc6\u5316\u641c\u7d22"},{"location":"my%20past/OI/%E8%B4%AA%E5%BF%83/","text":"\u8d2a\u5fc3 \u4e3a\u4ec0\u4e48\u9009\u62e9\u8d2a\u5fc3? ~~\u9664\u4e86\u6570\u636e\u7ed3\u6784\u548cdp\u5269\u4e0b\u7684\u90fd\u662f\u8d2a\u5fc3\u6a21\u62df\u66b4\u529b~~ 1) \u72b6\u6001\u4e0d\u597d\u8bbe\u8ba1\uff0c\u5982P1016\uff0c\u6bcf\u4e2a\u52a0\u6cb9\u7ad9\u7684\u52a0\u6cb9\u91cf\u8981\u7cbe\u786e\u5230\u5c0f\u6570\u540e\u4e24\u4f4d\uff0c\u57fa\u672c\u65e0\u6cd5\u679a\u4e3e\uff0c\u5e76\u4e14\u539f\u9898\u5177\u6709\u8d2a\u5fc3\u9009\u62e9\u6027\uff0c\u5373\u5c40\u90e8\u6700\u4f18\u89e3\u80fd\u63a8\u51fa\u5168\u5c40\u6700\u4f18\u89e3\uff0c\u8fd9\u6837\u5c31\u7528\u8d2a\u5fc3\u3002 2) \u679a\u4e3e\u91cf\u8fc7\u5927\uff0c\u5982CF939E,\u5982\u679cdp\u5c31\u662f$O(n^2)$,\u4f46\u53d1\u73b0\u6027\u8d28\u540e\u5c3a\u53d6\u6cd5\u5c31\u662f$O(n)$;\u518d\u5982CF47E\u4e5f\u662f\u5c3a\u53d6\u6cd5\uff0c\u5982\u679c\u66b4\u529b\u5c31\u662f$O(n^2)$ \u6709\u4e9b\u679a\u4e3e\u91cf\u8fc7\u5927\u7684\u95ee\u9898\u8fd8\u53ef\u4ee5\u7528\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u3002 P1080 $$\u5047\u8bbe\u5df2\u7ecf\u6392\u4e86\u51e0\u4e2a\u4eba\uff08\u5305\u62ec\u56fd\u738b\uff09\uff0c\u8bbe\u4ed6\u4eec\u5de6\u624b\u4e0a\u7684\u6570\u7684\u4e58\u79ef\u4e3aS.\\ \u73b0\u5728\u8981\u7ed92\u4e2a\u4eba\u6392\u5e8f\uff0c\u8bb0\u7b2c\u4e00\u4e2a\u4eba\u5de6\u624b\u4e0a\u7684\u6570\u4e3aa_{1}\uff0c\u53f3\u624b\u4e0a\u7684\u6570\u4e3ab_{1}\uff1b\u7b2c\u4e8c\u4e2a\u4eba\u5de6\u624b\u4e0a\u7684\u6570\u4e3aa_{2}\uff0c\u53f3\u624b\u4e0a\u7684\u6570\u4e3ab_{2}\u3002\\ \u5982\u679c\u7b2c\u4e00\u4e2a\u4eba\u6392\u5728\u524d\u9762\u4f18\u4e8e\u7b2c\u4e8c\u4e2a\u4eba\u6392\u5728\u524d\u9762\uff0c\u90a3\u4e48\\ max(S/b_1,S\u2217a_1/b_2)<max(S/b_2,S\u2217a_2/b_1)\\ \u663e\u7136\u6709S/b_2\\leq S* a_1/b_2\\ \u5047\u8bbe\u6709S a_1/b_2\\geq S a_2/b_1,\u5219max(S/b_1,S\u2217a_1/b_2)\\geq max(S/b_2,S\u2217a_2/b_1),\u77db\u76fe\u3002\\ \u6240\u4ee5S a_1/b_2<S a_2/b_1,\u6574\u7406\u5f97a_1 b_1<a_2 b_2\\ \u6240\u4ee5\u53ea\u9700\u8981\u6309\u7167a* b\u6392\u5e8f\u5373\u53ef\u3002 $$ \u7ed3\u8bba\uff1a\u5bf9\u4e8e\u8d2a\u5fc3\u9009\u62e9\u6027\u7684\u8bc1\u660e\uff0c\u53ef\u4ee5\u5047\u8bbe\u4e00\u4e2a\u4e2d\u95f4\u72b6\u6001\uff0c\u5373\u5df2\u7ecf\u505a\u5b8c$i-1$\u4e2a\u4eba,\u8003\u8651\u7b2c$i$\u4e2a\u4f4d\u7f6e\u53ef\u4ee5\u653e\u7684\u4eba\uff0c\u4e3a\u4e86\u8bc1\u660e\u65b9\u4fbf\u53ef\u4ee5\u53ea\u8003\u86512\u4e2a\u6216\u5c11\u91cf\u7684\u4eba,\u50cfP3951\u4e00\u6837\u3002 CF939E \u8d2a\u5fc3\u5c3a\u53d6\u6cd5\u3002 \u6709\u4e24\u6761\u91cd\u8981\u6027\u8d28\u3002 1) \u5bf9\u4e8e\u4e00\u4e2a\u52a0\u5165\u7684\u65b0\u6570\u4e00\u5b9a\u8981\u9009\u3002 $$ \u539f\u5f0f ans=Max-\\frac{sum}{n}\\ \u8003\u8651\u7528\u65b0\u7684\u6700\u5927\u66ff\u6362\u6389\u539f\u6765\u7684\u6700\u5927\uff0c\u8bbe\u65b0\u7684\u6700\u5927\u6bd4\u539f\u6765\u6700\u5927\u5927 \\Delta(x)\\ ans=\\frac{(Max+\\Delta(x))\\times n-(sum+\\Delta(x))}{n}\\ \u56e0\u4e3a n\\geq 1\uff0cans\u4e00\u5b9a\u53d8\u5927\uff08\u4f18\u79c0\uff09 $$ 2) \u5bf9\u4e8e\u96c6\u5408 s \u5269\u4e0b\u7684\u6570\uff0c\u4e00\u5b9a\u662f\u9009\u524d\u9762\u51e0\u4e2a\u5c0f\u7684\u6570\uff0c\u5e76\u4e14\u9009\u7684\u6570\u7684\u4e2a\u6570\u662f\u5355\u8c03\u4e0d\u51cf\u7684\u3002 \u53ef\u4ee5\u610f\u4f1a\u4e00\u4e0b\u8bc1\u660e\uff0c\u4e00\u5b9a\u662f\u9009\u6bd4\u5f53\u524d\u96c6\u5408\u5e73\u5747\u6570\u5c0f\u7684\u6570\u52a0\u8fdb\u6765\uff0c\u4f7f\u5e73\u5747\u6570\u66f4\u5c0f\uff0c\u7b54\u6848\u624d\u4f1a\u53d8\u5f97\u66f4\u5927\u3002 $$ \u539f\u5f0f ans=Max-\\frac{sum}{n}\\ \u8003\u8651\u65b0\u52a0\u4e00\u4e2a\u6570 \\Delta(x)\\ \u65b0\u7684\u5f0f\u5b50 ans=Max-\\frac{sum+\\Delta(x)}{n+1}\\ \u82e5\u65b0\u5f0f\u51cf\u53bb\u539f\u5f0f>0\uff0c\u5219\u65b0\u5f0f\u66f4\u4f18\u79c0\\ \u65b0\u5f0f\u51cf\u539f\u5f0f\u5f97\\ -\\frac{sum+\\Delta(x)}{n+1}+\\frac{sum}{n}\\ \u7b49\u4e8e\\ \\frac{sum-n\\times \\Delta(x)}{n\\times(n+1)}>0\\ \u5f97\u51fa\u66f4\u4f18\u79c0\u6761\u4ef6\u4e3a\uff1asum-n\\times \\Delta(x)>0\uff0c\u5373 \\Delta(x) <\\frac{sum}{n}\\ $$ \u8bc1\u6bd5\uff0c\u53ef\u4ee5\u7528\u5c3a\u53d6\u6cd5\u3002 #include<iostream> #include<cstdio> #include<cstring> #define db double #define int long long using namespace std; const int N=5e5+10; int n,cnt,tot; int vis[N],q[N]; db res[N],a[N],sum[N]; int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void work(){ int l=1,r=0; db ans=-1.0; for(int i=1;i<=cnt;++i)sum[i]=sum[i-1]+a[i]; for(int i=1;i<=cnt;++i){ if(!vis[i])continue; ans=-1.0; while(l<=i){ db tmp=(double)(a[i]-(double)(sum[l]+a[i])/(l+1)); if(tmp>ans)ans=tmp,++l; else{ --l; break; } } if(l==i+1)--l; res[i]=ans; } for(int i=1;i<=tot;++i)printf(\"%.10lf\\n\",res[q[i]]); } signed main(){ cnt=0,tot=0; n=read1(); for(int i=1,op;i<=n;++i){ op=read1(); if(op==1){ a[++cnt]=(double)read1(); }else{ vis[cnt]=1; q[++tot]=cnt; } } work(); return 0; } P1645 \u8d2a\u5fc3\u7684\u5c06\u5e8f\u5217\u6309\u7167\u53f3\u7aef\u70b9\u6392\u5e8f\uff0c\u90a3\u4e48\u6bcf\u4e2a\u533a\u95f4\u5185\u5e94\u8be5\u9009\u7684\u70b9\u5e94\u8be5\u5206\u5e03\u5728\u5b83\u7684\u6700\u53f3\u8fb9\uff0c\u8fd9\u6837\u80fd\u591f\u4fdd\u8bc1\u6709\u7684\u70b9\u6700\u5c11\uff0c\u662f\u6700\u4f18\u89e3\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2e3+10; int n,ans; int vis[N]; struct query{ int l,r,m; }q[N]; int w[N][N]; bool cmp(query a,query b){ return a.r<b.r; } signed main(){ memset(vis,0,sizeof vis); memset(w,0,sizeof w); scanf(\"%lld\",&n); for(int i=1;i<=n;++i){ scanf(\"%lld%lld%lld\",&q[i].l,&q[i].r,&q[i].m); } sort(q+1,q+n+1,cmp); for(int i=1;i<=n;++i){ for(int j=q[i].l;j<=q[i].r;++j){ w[j][++w[j][0]]=i; } } int ans=0; for(int i=1;i<=n;++i){ int l=q[i].l,r=q[i].r,m=q[i].m; if(!q[i].m)continue; for(int j=r;j>=l;--j){ if(!q[i].m)break; if(vis[j])continue; vis[j]=1; ans++; //q[i].m--; for(int k=1;k<=w[j][0];++k){ if(q[w[j][k]].m)q[w[j][k]].m--; } } } printf(\"%lld\",ans); return 0; } /* 2 1 1000 1000 1 999 999 */ P1191 \u5c06\u6bcf\u4e00\u5217\u524dn-1\u884c\u5f80\u4e0a\u80fd\u6570\u5230\u7684\u6700\u591a\u7684\u70b9\u6570\u8bb0\u5f55\u4e0b\u6765\uff0c\u90a3\u4e48\u6bcf\u4e2a\u7b2cn\u884c\u7684\u70b9\u7684\u8d21\u732e\u5c31\u662f\u4ece\u5de6\u5f80\u53f3\u626b\u5e76\u53d6\u6700\u5c0f\u503c\u3002 \u4e00\u4e2a\u6570\u626b\u63cf$O(n)$,\u5171$n^2$\u4e2a\u6570\uff0c\u6240\u4ee5\u603b\u590d\u6742\u5ea6$O(n^3)$ P1016 1.\u53ea\u8981\u5b58\u5728\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u4e0e\u4e0b\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u6216\u7ec8\u70b9\u95f4\u7684\u8ddd\u79bb\u5927\u4e8e$c* d_2$,\u90a3\u4e48\u65e0\u89e3. 2.\u5bf9\u4e8e\u6bcf\u4e2a\u52a0\u6cb9\u7ad9\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a 1\uff09\u4ed6\u80fd\u5230\u8fbe\u7684\u6240\u6709\u70b9\u4e2d\u6709\u4ef7\u683c\u6bd4\u4ed6\u5c0f\u7684\u52a0\u6cb9\u7ad9\uff0c\u90a3\u5c31\u52a0\u6cb9\u5230\u521a\u597d\u80fd\u5230\u8fbe\u90a3\u4e2a\u52a0\u6cb9\u7ad9\uff0c\u6b64\u65f6\u6cb9\u91cf\u4f1a\u53d8\u4e3a\u96f6\uff1b 2\uff09\u4ed6\u80fd\u5230\u8fbe\u7684\u70b9\u91cc\u6ca1\u6709\u4ef7\u683c\u5c0f\u4e8e\u5b83\u7684\u52a0\u6cb9\u7ad9\uff0c\u90a3\u5c31\u5728\u8fd9\u91cc\u5145\u6ee1\u6cb9\uff0c\u518d\u5230\u540e\u9762\u90a3\u4e9b\u52a0\u6cb9\u7ad9\u4e2d\u4ef7\u683c\u76f8\u5bf9\u6700\u5c0f\u7684\u52a0\u6cb9\u7ad9\uff0c\u6cb9\u91cf\u4ece$c $\u51cf\u5c11$(\\Delta d)/d_2 $\u3002 \u8bc1\u660e\uff1a 1.1\uff09\u4e2d\u4f1a\u4e0d\u4f1a\u5269\u4f59\u7684\u6cb9\u91cf\u5df2\u7ecf\u80fd\u6ee1\u8db3\u80fd\u591f\u5230\u8fbe\u4e0b\u4e00\u52a0\u6cb9\u7ad9\uff1f \u4e0d\u4f1a\uff0c\u56e0\u4e3a\u5b83\u7531\u4e0a\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u8f6c\u79fb\u8fc7\u6765\uff0c\u800c\u4e0a\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u6700\u8fdc\u80fd\u5230\u7684\u8ddd\u79bb\u5230\u4e0d\u4e86\u76ee\u6807\u52a0\u6cb9\u7ad9\uff0c\u56e0\u6b64\u4e00\u5b9a\u4f1a\u518d\u52a0\u6cb9\uff0c\u4e0d\u4f1a\u7531\u4e0d\u52a0\u6cb9\u5c31\u8d70\u4e86\u7684\u60c5\u51b5\u3002 2.2\uff09\u4e2d\u4e3a\u4ec0\u4e48\u8981\u9009\u4ef7\u683c\u76f8\u5bf9\u6700\u5c11\u7684\u52a0\u6cb9\u7ad9\uff0c\u5e76\u4e14\u8981\u5145\u6ee1\u6cb9\uff1f \u56e0\u4e3a\u5982\u679c\u518d\u540e\u9762\u7684\u52a0\u6cb9\u7ad9\u80fd\u591f\u5230\u8fbe\u6bd4\u5b83\u5c0f\u7684\u52a0\u6cb9\u7ad9\uff0c\u90a3\u4e48\u4ed6\u4f1a\u9700\u8981\u52a0\u6cb9\u6765\u5230\u8fbe\u90a3\u4e00\u52a0\u6cb9\u7ad9\uff0c\u8fd9\u662f\u5c31\u53ef\u4ee5\u7528\u4e4b\u524d\u4ef7\u683c\u4f4e\u7684\u6cb9\uff0c\u8fbe\u5230\u6700\u4f18\uff1b\u5c31\u7b97\u6ca1\u6709\uff0c\u4e3a\u4e86\u5230\u8fbe\u7ec8\u70b9\u4e5f\u8981\u52a0\u6cb9\uff0c\u6240\u4ee5\u9009\u62e9\u76f8\u5bf9\u6700\u5c0f\u7684\u8865\u5145\u6cb9\u91cf\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=210,INF=1050; double d1,c,p0,d2; int n; struct node{ double d,p; }q[N]; bool cmp(node a,node b){ return a.d<b.d; } int main(){ scanf(\"%lf%lf%lf%lf%d\",&d1,&c,&d2,&p0,&n); q[0].d=0,q[0].p=p0; for(int i=1;i<=n;++i){ scanf(\"%lf%lf\",&q[i].d,&q[i].p); } sort(q+1,q+n+1,cmp); q[n+1].d=d1,q[n+1].p=0; for(int i=1;i<=n+1;++i){ if(q[i].d-q[i-1].d>c*d2){ printf(\"No Solution\"); return 0; } } int pos=0;double cc=0;double ans=0; while(pos<n+1){ int tmp=0,loc=n+1,col=n+1; double minn=INF; for(int i=pos+1;i<=n+1;++i){ if(c<(q[i].d-q[pos].d)/d2){ loc=i-1; break; } } for(int i=pos+1;i<=loc;++i){ if(minn>q[i].p){ minn=q[i].p; col=i; } if(q[i].p<=q[pos].p){ tmp=i; break; } } if(tmp)ans+=(((q[tmp].d-q[pos].d)/d2)-cc)*q[pos].p,cc=0,pos=tmp;// delta must bigger than cc else ans+=(c-cc)*q[pos].p,cc=c-(q[col].d-q[pos].d)/d2,pos=col; } printf(\"%.2lf\",ans); return 0; } P1658 \u5047\u8bbe\u5f53\u524d\u624b\u4e2d\u7684\u786c\u5e01\u80fd\u591f\u7ec4\u62101,2,...,sum\u8fd9\u4e9b\u9762\u503c\uff0c\u6b64\u65f6sum<x. \u90a3\u4e48\u8003\u8651\u6dfb\u52a0\u4e00\u79cd\u786c\u5e01\uff0c\u4f7f\u5f97sum\u53d8\u5927\u3002 \u5f53\u5f53\u524d\u786c\u5e01\u7684\u503c\u4e3aa\u65f6\uff0c\u80fd\u7ec4\u6210\u7684\u6700\u5927\u9762\u503c\u7531sum\u53d8\u6210sum+a. \u4f46\u662f\uff0c\u5982\u679ca>sum+1,\u90a3\u4e48sum+1,sum+2,...,a-1\u8fd9\u4e9b\u6570\u5c31\u4e0d\u80fd\u7ec4\u6210\uff0c\u90a3\u4e48\u9762\u503c\u5c31\u4e0d\u8fde\u7eed\u4e86. \u6240\u4ee5\u6211\u4eec\u8981\u53d6a<=sum+1\u4e14a\u6700\u5927\u3002 \u65e0\u89e3\u7684\u60c5\u51b5\u5c31\u662f\u6ca1\u67091\u3002 \u6ce8\u610f\u53d6a\u65f6\u8981\u7528upper_bound-1,\u4e0d\u80fd\u7528lower_bound-1. \u8003\u8651: 5 7 \u6b64\u65f6\u90fd\u6c42\u51fa\u4e865\uff0c\u6b63\u786e\uff1b 5 6 7 \u6b64\u65f6upper_bound\u6c42\u51fa6\uff0c\u6b63\u786e;lower_bound\u6c42\u51fa5\uff0c\u9519\u8bef. code: #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=110; int n,x; int a[N]; bool cmp(int a,int b){ return a<b; } int main(){ scanf(\"%d%d\",&x,&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); sort(a+1,a+n+1,cmp); if(a[1]!=1){ printf(\"-1\"); return 0; } int sum=0,cnt=0; while(sum<x){ int tmp=upper_bound(a+1,a+n+1,sum+1)-a-1; sum+=a[tmp]; cnt++; } printf(\"%d\",cnt); return 0; } P1248 \u8fd9\u9898\u7684\u5751\u70b9\u5c31\u662f$B$\u8f66\u95f4\u4e0d\u80fd\u540c\u65f6\u5904\u7406\u591a\u4e2a\u7269\u4ef6\uff0c\u8981\u5806\u5230\u540e\u9762\u9010\u4e2a\u5904\u7406\u3002 \u9996\u5148\u8003\u8651\u6bcf\u6b21\u7684\u8d21\u732e\uff1a \u8bbe$fa$\u4e3a$a$\u8f66\u95f4\u7684\u5904\u7406\u65f6\u95f4\uff0c$fb$\u4e3a$b$\u8f66\u95f4\u7684\u5904\u7406\u65f6\u95f4\uff0c\u5219\uff1a $$ fb=\\max(fa+s[i].a,fb)+s[i].b;\\ fa+=s[i].a; $$ \u56e0\u4e3a\u53ea\u6709\u7b2c$i$\u4e2a$a$\u7269\u4ef6\u548c\u7b2c$i-1$\u4e2a$b$\u7269\u4ef6\u90fd\u505a\u5b8c\u624d\u80fd\u505a\u7b2c$i$\u4e2a$b$\u7269\u4ef6\u3002 \u518d\u8003\u8651$a$\u8f66\u95f4\u5df2\u7ecf\u505a\u4e86$P$\u65f6\u95f4\u7684\u5de5\u4f5c\uff0c\u4e0d\u8003\u8651$b$\u8f66\u95f4\u5269\u4f59\u7684\u7269\u4ef6\uff0c\u6b64\u65f6\u8fd8\u5269\u4e24\u4ef6\u3002 \u90a3\u4e48$1$\u5728\u524d\u548c$2$\u5728\u524d\u7684\u8d21\u732e\u5206\u522b\u662f\uff1a $$ a_1+\\max(a_2,b_1)+b_2\\\u548c\\a_2+\\max(a_1,b_2)+b_1 $$ \u5982\u679c1\u66f4\u4f18\uff0c\u5c31\u6709 $$ a_1+\\max(a_2,b_1)+b_2<a_2+\\max(a_1,b_2)+b_1\\ a_1+b_2-\\max(a_1,b_2)<b_1+a_2-\\max(a_2,b_1)\\ \u5373\\ \\min(a_1,b_2)<\\min(a_2,b_1) $$ \u4f46\u8fd9\u4e2a\u5f0f\u5b50\u4e0d\u80fd\u76f4\u63a5\u505a\u9898\uff0c\u53cd\u4f8b\u662f\u80fd\u4e3e\u51fa\u6765\u7684\u3002 \u6211\u4eec\u8003\u8651\u4e24(\u4e09)\u79cd\u60c5\u51b5\uff1a 1) $a_i<=b_i$\uff0c\u5219\u6709$a_1 b_i$\uff0c\u5219\u6709$b_1>b_2$ \u53c8\u8003\u8651$a_1>b_1,a_2<b_2$\u65f6\u4e00\u5b9a\u4e0d\u4f1a\u6ee1\u8db3\u4e0a\u8ff0\u5f0f\u5b50\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u4fdd\u8bc1$a_1 b_2$,\u5373$a b$\u7684\u653e\u5728\u540e\u9762\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e3+10; int n; struct node{ int a,b,d,id; }s[N]; bool cmp(node a,node b){ if(a.d==b.d){ if(a.d<=0)return a.a<b.a; else return a.b>b.b; } return a.d<b.d; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&s[i].a); for(int i=1;i<=n;++i)scanf(\"%d\",&s[i].b); for(int i=1;i<=n;++i)s[i].d=s[i].a==s[i].b?0:(s[i].a>s[i].b?1:-1),s[i].id=i; sort(s+1,s+n+1,cmp); int fa=0,fb=0; for(int i=1;i<=n;++i){ fb=max(fa+s[i].a,fb)+s[i].b; fa+=s[i].a; } printf(\"%d\\n\",fb); for(int i=1;i<=n;++i)printf(\"%d \",s[i].id); return 0; } UVA11300 \u5f53\u9762\u5bf9\u8fd9\u79cd\u770b\u4f3c\u6bcf\u79cd\u64cd\u4f5c\u90fd\u6ca1\u6709\u65b9\u5411\uff0c~~\u5f88\u50cf\u6a21\u62df\u9000\u706b~~\u7684\u9898\uff0c\u5c31\u5148\u5f3a\u884c\u89c4\u5b9a\u4e00\u4e2a\u65b9\u5411\u3002 \u6ce8\u610f\u5230\u4e00\u4e2a\u4eba\u7ed9\u522b\u4eba\u94b1\u548c\u522b\u4eba\u7ed9\u5b83\u94b1\u7684\u6b21\u6570\u6ca1\u6709\u9650\u5236\uff0c\u6240\u4ee5\u8bbe$x_i$\u8868\u793a\u540e\u4e00\u4e2a\u4eba\u7ed9\u524d\u4e00\u4e2a\u4eba\u7684\u94b1\u6570\uff0c\u8d1f\u6570\u8868\u793a\u9006\u65b9\u5411\u7ed9\u94b1\u3002 \u6240\u4ee5\u6709: $$A_1+x_1-x_2=M\\ A_2+x_2-x_3=M\\ ...\\ A_{n-1}+x_{n-1}-x_n=M $$ \u6ce8\u610f$A_n$\u90a3\u4e2a\u5f0f\u5b50\u5c31\u6ca1\u6709\u7528\u4e86\u3002 \u6d88\u53bb\u9664$x_1$\u6240\u6709\u7684\u672a\u77e5\u91cf\uff0c\u6574\u7406\u53ef\u5f97\uff1a $$ x_2=x_1-C_1\\ x_3=x_1-C_2\\ ...\\ x_{n-1}=x_1-C_{n-1}\\ \u5176\u4e2dC_i=\\sum_{k=1}^iA_k-i* M $$ \u6240\u4ee5\u8fd9\u4e2a\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u5750\u6807\u8f74\u4e0a$n-1$\u4e2a\u70b9\uff0c\u9009\u90a3\u4e2a\u4f4d\u7f6e\u4f7f\u5f97\u6240\u6709\u7684\u70b9\u5230\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u8ddd\u79bb\u548c\u6700\u77ed\u3002 \u6b64\u65f6\u8f93\u51fa\u4e2d\u4f4d\u6570\u5373\u53ef\uff0c\u8d2a\u5fc3\u7684\u8bc1\u660e\u5f88\u5de7\u5999\uff0c~~\u4f46\u6211\u61d2\uff0c\u7565~~ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=1e6+10; int c[N]; int n,a,tot,ans; bool cmp(int a,int b){ return a<b; } int abs1(int a){ return a>=0?a:-a; } signed main(){ while(scanf(\"%lld\",&n)!=EOF){ tot=0,ans=0; for(int i=1;i<=n;++i)scanf(\"%lld\",&a),c[i]=c[i-1]+a,tot+=a; tot/=n; for(int i=1;i<=n;++i)c[i]-=i*tot; sort(c+1,c+n+1,cmp); int mid=n/2+1; for(int i=1;i<=n;++i){ ans+=abs1(c[i]-c[mid]); } printf(\"%lld\\n\",ans); } return 0; }","title":"\u8d2a\u5fc3"},{"location":"my%20past/OI/%E8%B4%AA%E5%BF%83/#_1","text":"","title":"\u8d2a\u5fc3"},{"location":"my%20past/OI/%E8%B4%AA%E5%BF%83/#_2","text":"~~\u9664\u4e86\u6570\u636e\u7ed3\u6784\u548cdp\u5269\u4e0b\u7684\u90fd\u662f\u8d2a\u5fc3\u6a21\u62df\u66b4\u529b~~ 1) \u72b6\u6001\u4e0d\u597d\u8bbe\u8ba1\uff0c\u5982P1016\uff0c\u6bcf\u4e2a\u52a0\u6cb9\u7ad9\u7684\u52a0\u6cb9\u91cf\u8981\u7cbe\u786e\u5230\u5c0f\u6570\u540e\u4e24\u4f4d\uff0c\u57fa\u672c\u65e0\u6cd5\u679a\u4e3e\uff0c\u5e76\u4e14\u539f\u9898\u5177\u6709\u8d2a\u5fc3\u9009\u62e9\u6027\uff0c\u5373\u5c40\u90e8\u6700\u4f18\u89e3\u80fd\u63a8\u51fa\u5168\u5c40\u6700\u4f18\u89e3\uff0c\u8fd9\u6837\u5c31\u7528\u8d2a\u5fc3\u3002 2) \u679a\u4e3e\u91cf\u8fc7\u5927\uff0c\u5982CF939E,\u5982\u679cdp\u5c31\u662f$O(n^2)$,\u4f46\u53d1\u73b0\u6027\u8d28\u540e\u5c3a\u53d6\u6cd5\u5c31\u662f$O(n)$;\u518d\u5982CF47E\u4e5f\u662f\u5c3a\u53d6\u6cd5\uff0c\u5982\u679c\u66b4\u529b\u5c31\u662f$O(n^2)$ \u6709\u4e9b\u679a\u4e3e\u91cf\u8fc7\u5927\u7684\u95ee\u9898\u8fd8\u53ef\u4ee5\u7528\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u3002 P1080 $$\u5047\u8bbe\u5df2\u7ecf\u6392\u4e86\u51e0\u4e2a\u4eba\uff08\u5305\u62ec\u56fd\u738b\uff09\uff0c\u8bbe\u4ed6\u4eec\u5de6\u624b\u4e0a\u7684\u6570\u7684\u4e58\u79ef\u4e3aS.\\ \u73b0\u5728\u8981\u7ed92\u4e2a\u4eba\u6392\u5e8f\uff0c\u8bb0\u7b2c\u4e00\u4e2a\u4eba\u5de6\u624b\u4e0a\u7684\u6570\u4e3aa_{1}\uff0c\u53f3\u624b\u4e0a\u7684\u6570\u4e3ab_{1}\uff1b\u7b2c\u4e8c\u4e2a\u4eba\u5de6\u624b\u4e0a\u7684\u6570\u4e3aa_{2}\uff0c\u53f3\u624b\u4e0a\u7684\u6570\u4e3ab_{2}\u3002\\ \u5982\u679c\u7b2c\u4e00\u4e2a\u4eba\u6392\u5728\u524d\u9762\u4f18\u4e8e\u7b2c\u4e8c\u4e2a\u4eba\u6392\u5728\u524d\u9762\uff0c\u90a3\u4e48\\ max(S/b_1,S\u2217a_1/b_2)<max(S/b_2,S\u2217a_2/b_1)\\ \u663e\u7136\u6709S/b_2\\leq S* a_1/b_2\\ \u5047\u8bbe\u6709S a_1/b_2\\geq S a_2/b_1,\u5219max(S/b_1,S\u2217a_1/b_2)\\geq max(S/b_2,S\u2217a_2/b_1),\u77db\u76fe\u3002\\ \u6240\u4ee5S a_1/b_2<S a_2/b_1,\u6574\u7406\u5f97a_1 b_1<a_2 b_2\\ \u6240\u4ee5\u53ea\u9700\u8981\u6309\u7167a* b\u6392\u5e8f\u5373\u53ef\u3002 $$ \u7ed3\u8bba\uff1a\u5bf9\u4e8e\u8d2a\u5fc3\u9009\u62e9\u6027\u7684\u8bc1\u660e\uff0c\u53ef\u4ee5\u5047\u8bbe\u4e00\u4e2a\u4e2d\u95f4\u72b6\u6001\uff0c\u5373\u5df2\u7ecf\u505a\u5b8c$i-1$\u4e2a\u4eba,\u8003\u8651\u7b2c$i$\u4e2a\u4f4d\u7f6e\u53ef\u4ee5\u653e\u7684\u4eba\uff0c\u4e3a\u4e86\u8bc1\u660e\u65b9\u4fbf\u53ef\u4ee5\u53ea\u8003\u86512\u4e2a\u6216\u5c11\u91cf\u7684\u4eba,\u50cfP3951\u4e00\u6837\u3002 CF939E \u8d2a\u5fc3\u5c3a\u53d6\u6cd5\u3002 \u6709\u4e24\u6761\u91cd\u8981\u6027\u8d28\u3002 1) \u5bf9\u4e8e\u4e00\u4e2a\u52a0\u5165\u7684\u65b0\u6570\u4e00\u5b9a\u8981\u9009\u3002 $$ \u539f\u5f0f ans=Max-\\frac{sum}{n}\\ \u8003\u8651\u7528\u65b0\u7684\u6700\u5927\u66ff\u6362\u6389\u539f\u6765\u7684\u6700\u5927\uff0c\u8bbe\u65b0\u7684\u6700\u5927\u6bd4\u539f\u6765\u6700\u5927\u5927 \\Delta(x)\\ ans=\\frac{(Max+\\Delta(x))\\times n-(sum+\\Delta(x))}{n}\\ \u56e0\u4e3a n\\geq 1\uff0cans\u4e00\u5b9a\u53d8\u5927\uff08\u4f18\u79c0\uff09 $$ 2) \u5bf9\u4e8e\u96c6\u5408 s \u5269\u4e0b\u7684\u6570\uff0c\u4e00\u5b9a\u662f\u9009\u524d\u9762\u51e0\u4e2a\u5c0f\u7684\u6570\uff0c\u5e76\u4e14\u9009\u7684\u6570\u7684\u4e2a\u6570\u662f\u5355\u8c03\u4e0d\u51cf\u7684\u3002 \u53ef\u4ee5\u610f\u4f1a\u4e00\u4e0b\u8bc1\u660e\uff0c\u4e00\u5b9a\u662f\u9009\u6bd4\u5f53\u524d\u96c6\u5408\u5e73\u5747\u6570\u5c0f\u7684\u6570\u52a0\u8fdb\u6765\uff0c\u4f7f\u5e73\u5747\u6570\u66f4\u5c0f\uff0c\u7b54\u6848\u624d\u4f1a\u53d8\u5f97\u66f4\u5927\u3002 $$ \u539f\u5f0f ans=Max-\\frac{sum}{n}\\ \u8003\u8651\u65b0\u52a0\u4e00\u4e2a\u6570 \\Delta(x)\\ \u65b0\u7684\u5f0f\u5b50 ans=Max-\\frac{sum+\\Delta(x)}{n+1}\\ \u82e5\u65b0\u5f0f\u51cf\u53bb\u539f\u5f0f>0\uff0c\u5219\u65b0\u5f0f\u66f4\u4f18\u79c0\\ \u65b0\u5f0f\u51cf\u539f\u5f0f\u5f97\\ -\\frac{sum+\\Delta(x)}{n+1}+\\frac{sum}{n}\\ \u7b49\u4e8e\\ \\frac{sum-n\\times \\Delta(x)}{n\\times(n+1)}>0\\ \u5f97\u51fa\u66f4\u4f18\u79c0\u6761\u4ef6\u4e3a\uff1asum-n\\times \\Delta(x)>0\uff0c\u5373 \\Delta(x) <\\frac{sum}{n}\\ $$ \u8bc1\u6bd5\uff0c\u53ef\u4ee5\u7528\u5c3a\u53d6\u6cd5\u3002 #include<iostream> #include<cstdio> #include<cstring> #define db double #define int long long using namespace std; const int N=5e5+10; int n,cnt,tot; int vis[N],q[N]; db res[N],a[N],sum[N]; int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void work(){ int l=1,r=0; db ans=-1.0; for(int i=1;i<=cnt;++i)sum[i]=sum[i-1]+a[i]; for(int i=1;i<=cnt;++i){ if(!vis[i])continue; ans=-1.0; while(l<=i){ db tmp=(double)(a[i]-(double)(sum[l]+a[i])/(l+1)); if(tmp>ans)ans=tmp,++l; else{ --l; break; } } if(l==i+1)--l; res[i]=ans; } for(int i=1;i<=tot;++i)printf(\"%.10lf\\n\",res[q[i]]); } signed main(){ cnt=0,tot=0; n=read1(); for(int i=1,op;i<=n;++i){ op=read1(); if(op==1){ a[++cnt]=(double)read1(); }else{ vis[cnt]=1; q[++tot]=cnt; } } work(); return 0; } P1645 \u8d2a\u5fc3\u7684\u5c06\u5e8f\u5217\u6309\u7167\u53f3\u7aef\u70b9\u6392\u5e8f\uff0c\u90a3\u4e48\u6bcf\u4e2a\u533a\u95f4\u5185\u5e94\u8be5\u9009\u7684\u70b9\u5e94\u8be5\u5206\u5e03\u5728\u5b83\u7684\u6700\u53f3\u8fb9\uff0c\u8fd9\u6837\u80fd\u591f\u4fdd\u8bc1\u6709\u7684\u70b9\u6700\u5c11\uff0c\u662f\u6700\u4f18\u89e3\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=2e3+10; int n,ans; int vis[N]; struct query{ int l,r,m; }q[N]; int w[N][N]; bool cmp(query a,query b){ return a.r<b.r; } signed main(){ memset(vis,0,sizeof vis); memset(w,0,sizeof w); scanf(\"%lld\",&n); for(int i=1;i<=n;++i){ scanf(\"%lld%lld%lld\",&q[i].l,&q[i].r,&q[i].m); } sort(q+1,q+n+1,cmp); for(int i=1;i<=n;++i){ for(int j=q[i].l;j<=q[i].r;++j){ w[j][++w[j][0]]=i; } } int ans=0; for(int i=1;i<=n;++i){ int l=q[i].l,r=q[i].r,m=q[i].m; if(!q[i].m)continue; for(int j=r;j>=l;--j){ if(!q[i].m)break; if(vis[j])continue; vis[j]=1; ans++; //q[i].m--; for(int k=1;k<=w[j][0];++k){ if(q[w[j][k]].m)q[w[j][k]].m--; } } } printf(\"%lld\",ans); return 0; } /* 2 1 1000 1000 1 999 999 */ P1191 \u5c06\u6bcf\u4e00\u5217\u524dn-1\u884c\u5f80\u4e0a\u80fd\u6570\u5230\u7684\u6700\u591a\u7684\u70b9\u6570\u8bb0\u5f55\u4e0b\u6765\uff0c\u90a3\u4e48\u6bcf\u4e2a\u7b2cn\u884c\u7684\u70b9\u7684\u8d21\u732e\u5c31\u662f\u4ece\u5de6\u5f80\u53f3\u626b\u5e76\u53d6\u6700\u5c0f\u503c\u3002 \u4e00\u4e2a\u6570\u626b\u63cf$O(n)$,\u5171$n^2$\u4e2a\u6570\uff0c\u6240\u4ee5\u603b\u590d\u6742\u5ea6$O(n^3)$ P1016 1.\u53ea\u8981\u5b58\u5728\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u4e0e\u4e0b\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u6216\u7ec8\u70b9\u95f4\u7684\u8ddd\u79bb\u5927\u4e8e$c* d_2$,\u90a3\u4e48\u65e0\u89e3. 2.\u5bf9\u4e8e\u6bcf\u4e2a\u52a0\u6cb9\u7ad9\uff0c\u6709\u4e24\u79cd\u53ef\u80fd\uff1a 1\uff09\u4ed6\u80fd\u5230\u8fbe\u7684\u6240\u6709\u70b9\u4e2d\u6709\u4ef7\u683c\u6bd4\u4ed6\u5c0f\u7684\u52a0\u6cb9\u7ad9\uff0c\u90a3\u5c31\u52a0\u6cb9\u5230\u521a\u597d\u80fd\u5230\u8fbe\u90a3\u4e2a\u52a0\u6cb9\u7ad9\uff0c\u6b64\u65f6\u6cb9\u91cf\u4f1a\u53d8\u4e3a\u96f6\uff1b 2\uff09\u4ed6\u80fd\u5230\u8fbe\u7684\u70b9\u91cc\u6ca1\u6709\u4ef7\u683c\u5c0f\u4e8e\u5b83\u7684\u52a0\u6cb9\u7ad9\uff0c\u90a3\u5c31\u5728\u8fd9\u91cc\u5145\u6ee1\u6cb9\uff0c\u518d\u5230\u540e\u9762\u90a3\u4e9b\u52a0\u6cb9\u7ad9\u4e2d\u4ef7\u683c\u76f8\u5bf9\u6700\u5c0f\u7684\u52a0\u6cb9\u7ad9\uff0c\u6cb9\u91cf\u4ece$c $\u51cf\u5c11$(\\Delta d)/d_2 $\u3002 \u8bc1\u660e\uff1a 1.1\uff09\u4e2d\u4f1a\u4e0d\u4f1a\u5269\u4f59\u7684\u6cb9\u91cf\u5df2\u7ecf\u80fd\u6ee1\u8db3\u80fd\u591f\u5230\u8fbe\u4e0b\u4e00\u52a0\u6cb9\u7ad9\uff1f \u4e0d\u4f1a\uff0c\u56e0\u4e3a\u5b83\u7531\u4e0a\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u8f6c\u79fb\u8fc7\u6765\uff0c\u800c\u4e0a\u4e00\u4e2a\u52a0\u6cb9\u7ad9\u6700\u8fdc\u80fd\u5230\u7684\u8ddd\u79bb\u5230\u4e0d\u4e86\u76ee\u6807\u52a0\u6cb9\u7ad9\uff0c\u56e0\u6b64\u4e00\u5b9a\u4f1a\u518d\u52a0\u6cb9\uff0c\u4e0d\u4f1a\u7531\u4e0d\u52a0\u6cb9\u5c31\u8d70\u4e86\u7684\u60c5\u51b5\u3002 2.2\uff09\u4e2d\u4e3a\u4ec0\u4e48\u8981\u9009\u4ef7\u683c\u76f8\u5bf9\u6700\u5c11\u7684\u52a0\u6cb9\u7ad9\uff0c\u5e76\u4e14\u8981\u5145\u6ee1\u6cb9\uff1f \u56e0\u4e3a\u5982\u679c\u518d\u540e\u9762\u7684\u52a0\u6cb9\u7ad9\u80fd\u591f\u5230\u8fbe\u6bd4\u5b83\u5c0f\u7684\u52a0\u6cb9\u7ad9\uff0c\u90a3\u4e48\u4ed6\u4f1a\u9700\u8981\u52a0\u6cb9\u6765\u5230\u8fbe\u90a3\u4e00\u52a0\u6cb9\u7ad9\uff0c\u8fd9\u662f\u5c31\u53ef\u4ee5\u7528\u4e4b\u524d\u4ef7\u683c\u4f4e\u7684\u6cb9\uff0c\u8fbe\u5230\u6700\u4f18\uff1b\u5c31\u7b97\u6ca1\u6709\uff0c\u4e3a\u4e86\u5230\u8fbe\u7ec8\u70b9\u4e5f\u8981\u52a0\u6cb9\uff0c\u6240\u4ee5\u9009\u62e9\u76f8\u5bf9\u6700\u5c0f\u7684\u8865\u5145\u6cb9\u91cf\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=210,INF=1050; double d1,c,p0,d2; int n; struct node{ double d,p; }q[N]; bool cmp(node a,node b){ return a.d<b.d; } int main(){ scanf(\"%lf%lf%lf%lf%d\",&d1,&c,&d2,&p0,&n); q[0].d=0,q[0].p=p0; for(int i=1;i<=n;++i){ scanf(\"%lf%lf\",&q[i].d,&q[i].p); } sort(q+1,q+n+1,cmp); q[n+1].d=d1,q[n+1].p=0; for(int i=1;i<=n+1;++i){ if(q[i].d-q[i-1].d>c*d2){ printf(\"No Solution\"); return 0; } } int pos=0;double cc=0;double ans=0; while(pos<n+1){ int tmp=0,loc=n+1,col=n+1; double minn=INF; for(int i=pos+1;i<=n+1;++i){ if(c<(q[i].d-q[pos].d)/d2){ loc=i-1; break; } } for(int i=pos+1;i<=loc;++i){ if(minn>q[i].p){ minn=q[i].p; col=i; } if(q[i].p<=q[pos].p){ tmp=i; break; } } if(tmp)ans+=(((q[tmp].d-q[pos].d)/d2)-cc)*q[pos].p,cc=0,pos=tmp;// delta must bigger than cc else ans+=(c-cc)*q[pos].p,cc=c-(q[col].d-q[pos].d)/d2,pos=col; } printf(\"%.2lf\",ans); return 0; } P1658 \u5047\u8bbe\u5f53\u524d\u624b\u4e2d\u7684\u786c\u5e01\u80fd\u591f\u7ec4\u62101,2,...,sum\u8fd9\u4e9b\u9762\u503c\uff0c\u6b64\u65f6sum<x. \u90a3\u4e48\u8003\u8651\u6dfb\u52a0\u4e00\u79cd\u786c\u5e01\uff0c\u4f7f\u5f97sum\u53d8\u5927\u3002 \u5f53\u5f53\u524d\u786c\u5e01\u7684\u503c\u4e3aa\u65f6\uff0c\u80fd\u7ec4\u6210\u7684\u6700\u5927\u9762\u503c\u7531sum\u53d8\u6210sum+a. \u4f46\u662f\uff0c\u5982\u679ca>sum+1,\u90a3\u4e48sum+1,sum+2,...,a-1\u8fd9\u4e9b\u6570\u5c31\u4e0d\u80fd\u7ec4\u6210\uff0c\u90a3\u4e48\u9762\u503c\u5c31\u4e0d\u8fde\u7eed\u4e86. \u6240\u4ee5\u6211\u4eec\u8981\u53d6a<=sum+1\u4e14a\u6700\u5927\u3002 \u65e0\u89e3\u7684\u60c5\u51b5\u5c31\u662f\u6ca1\u67091\u3002 \u6ce8\u610f\u53d6a\u65f6\u8981\u7528upper_bound-1,\u4e0d\u80fd\u7528lower_bound-1. \u8003\u8651: 5 7 \u6b64\u65f6\u90fd\u6c42\u51fa\u4e865\uff0c\u6b63\u786e\uff1b 5 6 7 \u6b64\u65f6upper_bound\u6c42\u51fa6\uff0c\u6b63\u786e;lower_bound\u6c42\u51fa5\uff0c\u9519\u8bef. code: #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=110; int n,x; int a[N]; bool cmp(int a,int b){ return a<b; } int main(){ scanf(\"%d%d\",&x,&n); for(int i=1;i<=n;++i)scanf(\"%d\",&a[i]); sort(a+1,a+n+1,cmp); if(a[1]!=1){ printf(\"-1\"); return 0; } int sum=0,cnt=0; while(sum<x){ int tmp=upper_bound(a+1,a+n+1,sum+1)-a-1; sum+=a[tmp]; cnt++; } printf(\"%d\",cnt); return 0; } P1248 \u8fd9\u9898\u7684\u5751\u70b9\u5c31\u662f$B$\u8f66\u95f4\u4e0d\u80fd\u540c\u65f6\u5904\u7406\u591a\u4e2a\u7269\u4ef6\uff0c\u8981\u5806\u5230\u540e\u9762\u9010\u4e2a\u5904\u7406\u3002 \u9996\u5148\u8003\u8651\u6bcf\u6b21\u7684\u8d21\u732e\uff1a \u8bbe$fa$\u4e3a$a$\u8f66\u95f4\u7684\u5904\u7406\u65f6\u95f4\uff0c$fb$\u4e3a$b$\u8f66\u95f4\u7684\u5904\u7406\u65f6\u95f4\uff0c\u5219\uff1a $$ fb=\\max(fa+s[i].a,fb)+s[i].b;\\ fa+=s[i].a; $$ \u56e0\u4e3a\u53ea\u6709\u7b2c$i$\u4e2a$a$\u7269\u4ef6\u548c\u7b2c$i-1$\u4e2a$b$\u7269\u4ef6\u90fd\u505a\u5b8c\u624d\u80fd\u505a\u7b2c$i$\u4e2a$b$\u7269\u4ef6\u3002 \u518d\u8003\u8651$a$\u8f66\u95f4\u5df2\u7ecf\u505a\u4e86$P$\u65f6\u95f4\u7684\u5de5\u4f5c\uff0c\u4e0d\u8003\u8651$b$\u8f66\u95f4\u5269\u4f59\u7684\u7269\u4ef6\uff0c\u6b64\u65f6\u8fd8\u5269\u4e24\u4ef6\u3002 \u90a3\u4e48$1$\u5728\u524d\u548c$2$\u5728\u524d\u7684\u8d21\u732e\u5206\u522b\u662f\uff1a $$ a_1+\\max(a_2,b_1)+b_2\\\u548c\\a_2+\\max(a_1,b_2)+b_1 $$ \u5982\u679c1\u66f4\u4f18\uff0c\u5c31\u6709 $$ a_1+\\max(a_2,b_1)+b_2<a_2+\\max(a_1,b_2)+b_1\\ a_1+b_2-\\max(a_1,b_2)<b_1+a_2-\\max(a_2,b_1)\\ \u5373\\ \\min(a_1,b_2)<\\min(a_2,b_1) $$ \u4f46\u8fd9\u4e2a\u5f0f\u5b50\u4e0d\u80fd\u76f4\u63a5\u505a\u9898\uff0c\u53cd\u4f8b\u662f\u80fd\u4e3e\u51fa\u6765\u7684\u3002 \u6211\u4eec\u8003\u8651\u4e24(\u4e09)\u79cd\u60c5\u51b5\uff1a 1) $a_i<=b_i$\uff0c\u5219\u6709$a_1 b_i$\uff0c\u5219\u6709$b_1>b_2$ \u53c8\u8003\u8651$a_1>b_1,a_2<b_2$\u65f6\u4e00\u5b9a\u4e0d\u4f1a\u6ee1\u8db3\u4e0a\u8ff0\u5f0f\u5b50\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u4fdd\u8bc1$a_1 b_2$,\u5373$a b$\u7684\u653e\u5728\u540e\u9762\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> using namespace std; const int N=1e3+10; int n; struct node{ int a,b,d,id; }s[N]; bool cmp(node a,node b){ if(a.d==b.d){ if(a.d<=0)return a.a<b.a; else return a.b>b.b; } return a.d<b.d; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i)scanf(\"%d\",&s[i].a); for(int i=1;i<=n;++i)scanf(\"%d\",&s[i].b); for(int i=1;i<=n;++i)s[i].d=s[i].a==s[i].b?0:(s[i].a>s[i].b?1:-1),s[i].id=i; sort(s+1,s+n+1,cmp); int fa=0,fb=0; for(int i=1;i<=n;++i){ fb=max(fa+s[i].a,fb)+s[i].b; fa+=s[i].a; } printf(\"%d\\n\",fb); for(int i=1;i<=n;++i)printf(\"%d \",s[i].id); return 0; } UVA11300 \u5f53\u9762\u5bf9\u8fd9\u79cd\u770b\u4f3c\u6bcf\u79cd\u64cd\u4f5c\u90fd\u6ca1\u6709\u65b9\u5411\uff0c~~\u5f88\u50cf\u6a21\u62df\u9000\u706b~~\u7684\u9898\uff0c\u5c31\u5148\u5f3a\u884c\u89c4\u5b9a\u4e00\u4e2a\u65b9\u5411\u3002 \u6ce8\u610f\u5230\u4e00\u4e2a\u4eba\u7ed9\u522b\u4eba\u94b1\u548c\u522b\u4eba\u7ed9\u5b83\u94b1\u7684\u6b21\u6570\u6ca1\u6709\u9650\u5236\uff0c\u6240\u4ee5\u8bbe$x_i$\u8868\u793a\u540e\u4e00\u4e2a\u4eba\u7ed9\u524d\u4e00\u4e2a\u4eba\u7684\u94b1\u6570\uff0c\u8d1f\u6570\u8868\u793a\u9006\u65b9\u5411\u7ed9\u94b1\u3002 \u6240\u4ee5\u6709: $$A_1+x_1-x_2=M\\ A_2+x_2-x_3=M\\ ...\\ A_{n-1}+x_{n-1}-x_n=M $$ \u6ce8\u610f$A_n$\u90a3\u4e2a\u5f0f\u5b50\u5c31\u6ca1\u6709\u7528\u4e86\u3002 \u6d88\u53bb\u9664$x_1$\u6240\u6709\u7684\u672a\u77e5\u91cf\uff0c\u6574\u7406\u53ef\u5f97\uff1a $$ x_2=x_1-C_1\\ x_3=x_1-C_2\\ ...\\ x_{n-1}=x_1-C_{n-1}\\ \u5176\u4e2dC_i=\\sum_{k=1}^iA_k-i* M $$ \u6240\u4ee5\u8fd9\u4e2a\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u5750\u6807\u8f74\u4e0a$n-1$\u4e2a\u70b9\uff0c\u9009\u90a3\u4e2a\u4f4d\u7f6e\u4f7f\u5f97\u6240\u6709\u7684\u70b9\u5230\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u8ddd\u79bb\u548c\u6700\u77ed\u3002 \u6b64\u65f6\u8f93\u51fa\u4e2d\u4f4d\u6570\u5373\u53ef\uff0c\u8d2a\u5fc3\u7684\u8bc1\u660e\u5f88\u5de7\u5999\uff0c~~\u4f46\u6211\u61d2\uff0c\u7565~~ #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #define int long long using namespace std; const int N=1e6+10; int c[N]; int n,a,tot,ans; bool cmp(int a,int b){ return a<b; } int abs1(int a){ return a>=0?a:-a; } signed main(){ while(scanf(\"%lld\",&n)!=EOF){ tot=0,ans=0; for(int i=1;i<=n;++i)scanf(\"%lld\",&a),c[i]=c[i-1]+a,tot+=a; tot/=n; for(int i=1;i<=n;++i)c[i]-=i*tot; sort(c+1,c+n+1,cmp); int mid=n/2+1; for(int i=1;i<=n;++i){ ans+=abs1(c[i]-c[mid]); } printf(\"%lld\\n\",ans); } return 0; }","title":"\u4e3a\u4ec0\u4e48\u9009\u62e9\u8d2a\u5fc3?"},{"location":"my%20past/OI/%E9%80%86%E5%85%83/","text":"\u4e58\u6cd5\u9006\u5143 \u4e00\u5171\u56db\u79cd\u65b9\u6cd5\u3002 1.\u6269\u5c55\u6b27\u51e0\u91cc\u5f97O(logn) \u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u80fd$O(\\log n)$\u6c42\u89e3\u4e0d\u5b9a\u65b9\u7a0b$ax+by=c$. \u800c$ax\\equiv1\\pmod p$\u7b49\u4ef7\u4e8e$ax+py=1$(\u76f8\u5f53\u4e8e$ax$\u52a0\u6216\u51cf$y$\u4e2a$p$\u540e\u53d8\u6210$1$) \u56e0\u4e3a$a$\u4e0e$p$\u4e92\u8d28\uff0c\u6240\u4ee5\u53d8\u6210$ax+by=gcd(a,b)$ \u5bf9\u4e8e$ax+by=gcd(a,b)$\u8fd9\u4e2a\u5f0f\u5b50\u5c31\u53ef\u4ee5\u7528\u6269\u6b27\u6c42\u89e3\u4e86. $$ ax+by=gcd(a,b)=gcd(b,a\\ mod\\ b)=bx+(a\\ mod \\ b)y\\ bx+(a\\ mod \\ b)y=bx+(a\u2212\u230a\\frac ab\u230b b) y=ay+b (x\u2212\u230a\\frac ab\u230b y) $$ \u8fd9\u6837\u5c31\u53ef\u4ee5\u9012\u5f52\u6c42\u89e3\u4e86\u3002 void exgcd(int a,int b,int &x,int &y){ if(!b\uff09x=1,y=0; else exgcd(b,a%b,y,x),y-=a\\b*x; } 2.\u5feb\u901f\u5e42O(logn) \u7531\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff1a\u82e5$p$\u662f\u8d28\u6570\uff0c$a$\u4e3a\u4efb\u610f\u6574\u6570\uff0c\u5219$a^p \\equiv a\\pmod p$ \u4e24\u8fb9\u540c\u9664$a$,\u5f97$a^{p-1} \\equiv 1 \\pmod p$ \u6240\u4ee5$a* a^{-1}\\equiv a^{p-1}\\pmod p$ $a^{-1}\\equiv a^{p-2}\\pmod p$ 3.\u7ebf\u6027\u63a8 O(1) $$\u9012\u63a8\u8fb9\u754c\u662f1^{-1}\\equiv 1\\pmod p\\ \u8bbep=k i+r,k= \\lfloor \\frac pi\\rfloor,r=p\\mod i\\ \u5219k i+r\\equiv0\\pmod p\\ (k i+r) (r^{-1} i^{-1})\\equiv 0\\pmod p\\ k r^{-1}+i^{-1}\\equiv 0\\pmod p\\ i^{-1}\\equiv -k* r^{-1}\\pmod p\\ i^{-1}\\equiv -\\lfloor \\frac pi\\rfloor * (p\\mod i)^{-1}\\pmod p $$ 4.\u9636\u4e58\u63a8 O(1) $$ \u8bbef(i)=inv[i!]=\\frac{1}{i!}\\pmod p\\ \\therefore f(i-1)=\\frac1{(i-1)!}=\\frac1{i!} i=f(i) i\\pmod p\\ \u6c42\u51fa\u6240\u6709f(i)\u540e\u4fbf\u6709\uff1a\\ \\frac1i=\\frac1{i!} (i-1)!=f(i) (i-1)!\\pmod p\\ \u6ce8\u610f\u8fb9\u754c\u662ff(n),\u7528\u5feb\u901f\u5e42\u7684\u65b9\u6cd5\u6c42\u4e00\u4e0b\u3002 $$ P5431 \u8fd9\u9053\u9898\u9700\u8981\u7ef4\u62a4\u4e00\u4e0b\u524d\u7f00\u79ef\u548c\u540e\u7f00\u79ef\u3002 \u8003\u8651\u5c06\u539f\u9898\u79cd\u7684\u5206\u5f0f\u901a\u5206\u3002 $$ \u8bbes=\\prod a_i,\u5219\u539f\u5f0f=\\sum_{i=1}^n\\frac{k^i\\frac {s}{a_i}}{s} \\ =s^{-1}\\sum_{i=1}^nk^if[i-1]g[i+1] \\(f\uff0cg\u4e3a\u524d\u7f00\u79ef\u548c\u540e\u7f00\u79ef) $$ \u56e0\u6b64\u53ea\u9700\u8981\u4e00\u6b21\u6c42\u9006\u5c31\u884c\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=5e6+10; int n,p,k,s,ss; int a[N],f[N],g[N]; int kp(int x,int q){ if(q==0)return 1; if(q==1)return x%p; if(q%2==1)return x*kp(x*x%p,q>>1)%p; else return kp(x*x%p,q>>1)%p; } void init(){ f[0]=1; g[n+1]=1; s=1; for(int i=1;i<=n;++i){ s=(s*a[i])%p; f[i]=(f[i-1]*a[i])%p; } for(int i=n;i>=1;--i){ g[i]=(g[i+1]*a[i])%p; } ss=kp(s,p-2)%p; } int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); } signed main(){ n=read1(),p=read1(),k=read1(); for(int i=1;i<=n;++i)a[i]=read1(); init(); int ans=0,kk=1; for(int i=1;i<=n;++i){ kk=(kk*k)%p; ans=(ans+(ss*kk%p)*(f[i-1]*g[i+1]%p))%p; } write1(ans); return 0; } ~~\u5361\u5e38\u51fa\u9898\u4eba\u90fd\u662fSB~~ \u7ed3\u8bba\uff1a\u770b\u5230\u6240\u6709\u9879\u7684\u79ef\u9664\u4ee5\u67d0\u4e00\u9879\u65f6\uff0c\u53ef\u4ee5\u7528\u524d\u7f00\u79ef\u548c\u540e\u7f00\u79ef\u4f18\u5316\u3002\u7c7b\u4f3c\u7684\u8fd8\u6709P1623\u7684\u4f18\u5316\u65b9\u6cd5\u3002\u8fd9\u6837\u53ef\u4ee5\u907f\u514d\u9664\u6cd5\u3002","title":"\u4e58\u6cd5\u9006\u5143"},{"location":"my%20past/OI/%E9%80%86%E5%85%83/#_1","text":"\u4e00\u5171\u56db\u79cd\u65b9\u6cd5\u3002","title":"\u4e58\u6cd5\u9006\u5143"},{"location":"my%20past/OI/%E9%80%86%E5%85%83/#1ologn","text":"\u6269\u5c55\u6b27\u51e0\u91cc\u5f97\u80fd$O(\\log n)$\u6c42\u89e3\u4e0d\u5b9a\u65b9\u7a0b$ax+by=c$. \u800c$ax\\equiv1\\pmod p$\u7b49\u4ef7\u4e8e$ax+py=1$(\u76f8\u5f53\u4e8e$ax$\u52a0\u6216\u51cf$y$\u4e2a$p$\u540e\u53d8\u6210$1$) \u56e0\u4e3a$a$\u4e0e$p$\u4e92\u8d28\uff0c\u6240\u4ee5\u53d8\u6210$ax+by=gcd(a,b)$ \u5bf9\u4e8e$ax+by=gcd(a,b)$\u8fd9\u4e2a\u5f0f\u5b50\u5c31\u53ef\u4ee5\u7528\u6269\u6b27\u6c42\u89e3\u4e86. $$ ax+by=gcd(a,b)=gcd(b,a\\ mod\\ b)=bx+(a\\ mod \\ b)y\\ bx+(a\\ mod \\ b)y=bx+(a\u2212\u230a\\frac ab\u230b b) y=ay+b (x\u2212\u230a\\frac ab\u230b y) $$ \u8fd9\u6837\u5c31\u53ef\u4ee5\u9012\u5f52\u6c42\u89e3\u4e86\u3002 void exgcd(int a,int b,int &x,int &y){ if(!b\uff09x=1,y=0; else exgcd(b,a%b,y,x),y-=a\\b*x; }","title":"1.\u6269\u5c55\u6b27\u51e0\u91cc\u5f97O(logn)"},{"location":"my%20past/OI/%E9%80%86%E5%85%83/#2ologn","text":"\u7531\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff1a\u82e5$p$\u662f\u8d28\u6570\uff0c$a$\u4e3a\u4efb\u610f\u6574\u6570\uff0c\u5219$a^p \\equiv a\\pmod p$ \u4e24\u8fb9\u540c\u9664$a$,\u5f97$a^{p-1} \\equiv 1 \\pmod p$ \u6240\u4ee5$a* a^{-1}\\equiv a^{p-1}\\pmod p$ $a^{-1}\\equiv a^{p-2}\\pmod p$","title":"2.\u5feb\u901f\u5e42O(logn)"},{"location":"my%20past/OI/%E9%80%86%E5%85%83/#3-o1","text":"$$\u9012\u63a8\u8fb9\u754c\u662f1^{-1}\\equiv 1\\pmod p\\ \u8bbep=k i+r,k= \\lfloor \\frac pi\\rfloor,r=p\\mod i\\ \u5219k i+r\\equiv0\\pmod p\\ (k i+r) (r^{-1} i^{-1})\\equiv 0\\pmod p\\ k r^{-1}+i^{-1}\\equiv 0\\pmod p\\ i^{-1}\\equiv -k* r^{-1}\\pmod p\\ i^{-1}\\equiv -\\lfloor \\frac pi\\rfloor * (p\\mod i)^{-1}\\pmod p $$","title":"3.\u7ebf\u6027\u63a8 O(1)"},{"location":"my%20past/OI/%E9%80%86%E5%85%83/#4-o1","text":"$$ \u8bbef(i)=inv[i!]=\\frac{1}{i!}\\pmod p\\ \\therefore f(i-1)=\\frac1{(i-1)!}=\\frac1{i!} i=f(i) i\\pmod p\\ \u6c42\u51fa\u6240\u6709f(i)\u540e\u4fbf\u6709\uff1a\\ \\frac1i=\\frac1{i!} (i-1)!=f(i) (i-1)!\\pmod p\\ \u6ce8\u610f\u8fb9\u754c\u662ff(n),\u7528\u5feb\u901f\u5e42\u7684\u65b9\u6cd5\u6c42\u4e00\u4e0b\u3002 $$ P5431 \u8fd9\u9053\u9898\u9700\u8981\u7ef4\u62a4\u4e00\u4e0b\u524d\u7f00\u79ef\u548c\u540e\u7f00\u79ef\u3002 \u8003\u8651\u5c06\u539f\u9898\u79cd\u7684\u5206\u5f0f\u901a\u5206\u3002 $$ \u8bbes=\\prod a_i,\u5219\u539f\u5f0f=\\sum_{i=1}^n\\frac{k^i\\frac {s}{a_i}}{s} \\ =s^{-1}\\sum_{i=1}^nk^if[i-1]g[i+1] \\(f\uff0cg\u4e3a\u524d\u7f00\u79ef\u548c\u540e\u7f00\u79ef) $$ \u56e0\u6b64\u53ea\u9700\u8981\u4e00\u6b21\u6c42\u9006\u5c31\u884c\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=5e6+10; int n,p,k,s,ss; int a[N],f[N],g[N]; int kp(int x,int q){ if(q==0)return 1; if(q==1)return x%p; if(q%2==1)return x*kp(x*x%p,q>>1)%p; else return kp(x*x%p,q>>1)%p; } void init(){ f[0]=1; g[n+1]=1; s=1; for(int i=1;i<=n;++i){ s=(s*a[i])%p; f[i]=(f[i-1]*a[i])%p; } for(int i=n;i>=1;--i){ g[i]=(g[i+1]*a[i])%p; } ss=kp(s,p-2)%p; } int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); } signed main(){ n=read1(),p=read1(),k=read1(); for(int i=1;i<=n;++i)a[i]=read1(); init(); int ans=0,kk=1; for(int i=1;i<=n;++i){ kk=(kk*k)%p; ans=(ans+(ss*kk%p)*(f[i-1]*g[i+1]%p))%p; } write1(ans); return 0; } ~~\u5361\u5e38\u51fa\u9898\u4eba\u90fd\u662fSB~~ \u7ed3\u8bba\uff1a\u770b\u5230\u6240\u6709\u9879\u7684\u79ef\u9664\u4ee5\u67d0\u4e00\u9879\u65f6\uff0c\u53ef\u4ee5\u7528\u524d\u7f00\u79ef\u548c\u540e\u7f00\u79ef\u4f18\u5316\u3002\u7c7b\u4f3c\u7684\u8fd8\u6709P1623\u7684\u4f18\u5316\u65b9\u6cd5\u3002\u8fd9\u6837\u53ef\u4ee5\u907f\u514d\u9664\u6cd5\u3002","title":"4.\u9636\u4e58\u63a8 O(1)"},{"location":"my%20past/OI/%E9%80%92%E5%BD%92/","text":"\u9012\u5f52 & \u9012\u63a8 \u89e3\u9898\u91cd\u70b9\u5728\u4e8e\u5047\u8bbe\u51fa\u5f53\u524d\u7684\u72b6\u6001\u4ee5\u7ee7\u5b50\u95ee\u9898\u7684\u72b6\u6001\uff0c\u901a\u8fc7\u4e00\u6b65\u7684\u64cd\u4f5c\u627e\u51fa\u72b6\u6001\u7684\u8f6c\u79fb\u65b9\u5f0f\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u9012\u5f52/\u9012\u63a8\u4e86\u3002 P1760 \u6c49\u8bfa\u5854 \u666e\u901a\u7684\u9012\u5f52\u6cd5\u5c31\u662f\uff0c\u8ba9\u524d$n-1$\u4e2a\u76d8\u5b50\u79fb\u52a8\u5230\u7a7a\u67f1\u5b50\u4e0a\uff0c\u5c06\u7b2c$n$\u4e2a\u76d8\u5b50\u79fb\u52a8\u5230\u6307\u5b9a\u67f1\u5b50\uff0c\u518d\u5c06$n-1$\u4e2a\u76d8\u5b50\u79fb\u52a8\u5230\u7b2c$n$\u76d8\u4e0a\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=15510; int n,ans; int f(int n,int a,int b,int c){ if(n==1){ printf(\"move %lld from %lld to %lld\\n\",n,a,c); return 1; } int ans=1; ans+=f(n-1,a,c,b); printf(\"move %lld from %lld to %lld\\n\",n,a,c); ans+=f(n-1,b,a,c); return ans; } signed main(){ scanf(\"%lld\",&n); ans=f(n,1,2,3); printf(\"%lld\\n\",ans); return 0; } \u8fd9\u6837\u4f60\u4f1a\u53d1\u73b0\uff0c$f(n-1,a,c,b)$\u4e0e$f(n-1,b,a,c)$\u6240\u7528\u7684\u6b65\u6570\u65f6\u4e00\u6837\u7684\uff0c\u6240\u4ee5\u6709\u7ed3\u8bba\uff1a $x[i]=2* x[i-1]+1$,\u5373$x[i]=2^i-1$. ~~\u6240\u4ee5\u9ad8\u7cbe\u5ea6\u5c31\u4e0d\u5c55\u793a\u4e86~~ P1242 \u8fd9\u9053\u9898\u4e5f\u662f\u540c\u6837\u3002 \u53ea\u4e0d\u8fc7\u7ed9\u51fa\u4e86\u5c06\u6700\u7ec8\u72b6\u6001\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u64cd\u4f5c\u62c6\u6210\u4e09\u90e8\u5206\uff1a 1) \u5c06\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\u6539\u53d8\u7684\u6700\u5927\u76d8\u5b50\u4e0a\u9762\u7684\u5c0f\u76d8\u5b50\u632a\u5f00\u5230\u7a7a\u4f59\u7684\u67f1\u5b50 2) \u7528\u4e00\u6b65\u5c06\u5927\u76d8\u5b50\u4ee5\u5230\u6307\u5b9a\u4f4d\u7f6e 3) \u5c06\u5c0f\u76d8\u5b50\u632a\u5230\u6307\u5b9a\u4f4d\u7f6e \u7531\u4e8e\u5bf9\u79f0\u6027\uff0c\u7b2c\u4e09\u6b65\u53ef\u4ee5\u7406\u89e3\u4e3a\u5c06\u5c0f\u76d8\u5b50\u4ece\u6700\u7ec8\u72b6\u6001\u632a\u5230\u7a7a\u4f59\u67f1\u5b50\u3002 ~~\u7136\u540e\u4f60\u5c31\u53d1\u73b0\uff0c\u88abHack\u4e86~~ \u6b63\u786e\u505a\u6cd5\u662f\uff1a\u7b2c\u4e00\u6b65\u6709\u4e24\u79cd\uff1a (\u5047\u8bbe\u5c06\u5927\u76d8\u5b50\u4ece\u67f1\u5b501\u632a\u5230\u67f1\u5b502) 1) \u5c0f\u76d8\u5b50\u5230\u67f1\u5b503$\\to$\u5927\u76d8\u5b50\u4ece1\u52302$\\to$\u5c0f\u76d8\u5b50\u5230\u6700\u7ec8\u72b6\u6001 2) \u5c0f\u76d8\u5b50\u5230\u67f1\u5b502$\\to$\u5927\u76d8\u5b50\u4ece1\u52303$\\to$\u5c0f\u76d8\u5b50\u5230\u67f1\u5b501$\\to$\u5927\u76d8\u5b50\u4ece3\u52302$\\to$\u5c0f\u76d8\u5b50\u5230\u6700\u7ec8\u72b6\u6001 \u8fd9\u5c31\u662fP1242 \u7b2c11\u4e2a\u70b9\u7684$Hack$\u539f\u7406. #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=122,M=5e6+10; int start[N],finish[N],mid[N]; int n,cnt,m; struct node { int n,a,b; } step1[M],step2[M]; void g(int n,int a,int b,int c,node *step) { if(n==0)return; g(n-1,a,c,b,step); step[++cnt].n=n,step[cnt].a=a,step[cnt].b=c; g(n-1,b,a,c,step); return; } int f(int* P,int i,int final,node *step) { if(i==0)return 0; if(P[i]==final)return f(P,i-1,final,step); int tmp=f(P,i-1,6-P[i]-final,step); step[++cnt].n=i,step[cnt].a=P[i],step[cnt].b=final; g(i-1,6-P[i]-final,P[i],final,step); return tmp+(1ll<<(i-1)); } void print1(int cnt,int ans,int a,int b,node *step) { for(int i=a+1; i<=cnt; ++i) { swap(step[i].a,step[i].b); } for(int i=1; i<=b/2; ++i) { swap(step[i+a+1-1],step[cnt-i+1]); } for(int i=1; i<=ans; ++i) { printf(\"move %d from %c to %c\\n\",step[i].n,step[i].a+'A'-1,step[i].b+'A'-1); } printf(\"%lld\",ans); } signed main() { scanf(\"%lld\",&n); for(int i=1; i<=3; ++i) { scanf(\"%lld\",&m); for(int k=1,p; k<=m; ++k)scanf(\"%lld\",&p),start[p]=i; } for(int i=1; i<=3; ++i) { scanf(\"%lld\",&m); for(int k=1,p; k<=m; ++k)scanf(\"%lld\",&p),finish[p]=i; } while(start[n]==finish[n] && n>=1)--n; int ans=0,tmp1=0,tmp2=0,tmp3=0,tmp4=0; if(n>=1) { cnt=0; tmp1=f(start,n-1,6-start[n]-finish[n],step1)+1; step1[++cnt].n=n,step1[cnt].a=start[n],step1[cnt].b=finish[n]; tmp2=f(finish,n-1,6-start[n]-finish[n],step1); cnt=0; tmp3+=f(start,n-1,finish[n],step2)+1; step2[++cnt].n=n,step2[cnt].a=start[n],step2[cnt].b=6-start[n]-finish[n]; for(int i=1;i<n;++i)mid[i]=finish[n]; mid[n]=6-start[n]-finish[n]; tmp3+=f(mid,n-1,start[n],step2)+1; step2[++cnt].n=n,step2[cnt].a=6-start[n]-finish[n],step2[cnt].b=finish[n]; tmp4=f(finish,n-1,start[n],step2); if(tmp1+tmp2<tmp3+tmp4) { ans=tmp1+tmp2; print1(ans,ans,tmp1,tmp2,step1); } else { ans=tmp3+tmp4; print1(ans,ans,tmp3,tmp4,step2); } } return 0; } P","title":"\u9012\u5f52 &amp; \u9012\u63a8"},{"location":"my%20past/OI/%E9%80%92%E5%BD%92/#_1","text":"\u89e3\u9898\u91cd\u70b9\u5728\u4e8e\u5047\u8bbe\u51fa\u5f53\u524d\u7684\u72b6\u6001\u4ee5\u7ee7\u5b50\u95ee\u9898\u7684\u72b6\u6001\uff0c\u901a\u8fc7\u4e00\u6b65\u7684\u64cd\u4f5c\u627e\u51fa\u72b6\u6001\u7684\u8f6c\u79fb\u65b9\u5f0f\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u9012\u5f52/\u9012\u63a8\u4e86\u3002 P1760 \u6c49\u8bfa\u5854 \u666e\u901a\u7684\u9012\u5f52\u6cd5\u5c31\u662f\uff0c\u8ba9\u524d$n-1$\u4e2a\u76d8\u5b50\u79fb\u52a8\u5230\u7a7a\u67f1\u5b50\u4e0a\uff0c\u5c06\u7b2c$n$\u4e2a\u76d8\u5b50\u79fb\u52a8\u5230\u6307\u5b9a\u67f1\u5b50\uff0c\u518d\u5c06$n-1$\u4e2a\u76d8\u5b50\u79fb\u52a8\u5230\u7b2c$n$\u76d8\u4e0a\u3002 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=15510; int n,ans; int f(int n,int a,int b,int c){ if(n==1){ printf(\"move %lld from %lld to %lld\\n\",n,a,c); return 1; } int ans=1; ans+=f(n-1,a,c,b); printf(\"move %lld from %lld to %lld\\n\",n,a,c); ans+=f(n-1,b,a,c); return ans; } signed main(){ scanf(\"%lld\",&n); ans=f(n,1,2,3); printf(\"%lld\\n\",ans); return 0; } \u8fd9\u6837\u4f60\u4f1a\u53d1\u73b0\uff0c$f(n-1,a,c,b)$\u4e0e$f(n-1,b,a,c)$\u6240\u7528\u7684\u6b65\u6570\u65f6\u4e00\u6837\u7684\uff0c\u6240\u4ee5\u6709\u7ed3\u8bba\uff1a $x[i]=2* x[i-1]+1$,\u5373$x[i]=2^i-1$. ~~\u6240\u4ee5\u9ad8\u7cbe\u5ea6\u5c31\u4e0d\u5c55\u793a\u4e86~~ P1242 \u8fd9\u9053\u9898\u4e5f\u662f\u540c\u6837\u3002 \u53ea\u4e0d\u8fc7\u7ed9\u51fa\u4e86\u5c06\u6700\u7ec8\u72b6\u6001\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5c06\u64cd\u4f5c\u62c6\u6210\u4e09\u90e8\u5206\uff1a 1) \u5c06\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\u6539\u53d8\u7684\u6700\u5927\u76d8\u5b50\u4e0a\u9762\u7684\u5c0f\u76d8\u5b50\u632a\u5f00\u5230\u7a7a\u4f59\u7684\u67f1\u5b50 2) \u7528\u4e00\u6b65\u5c06\u5927\u76d8\u5b50\u4ee5\u5230\u6307\u5b9a\u4f4d\u7f6e 3) \u5c06\u5c0f\u76d8\u5b50\u632a\u5230\u6307\u5b9a\u4f4d\u7f6e \u7531\u4e8e\u5bf9\u79f0\u6027\uff0c\u7b2c\u4e09\u6b65\u53ef\u4ee5\u7406\u89e3\u4e3a\u5c06\u5c0f\u76d8\u5b50\u4ece\u6700\u7ec8\u72b6\u6001\u632a\u5230\u7a7a\u4f59\u67f1\u5b50\u3002 ~~\u7136\u540e\u4f60\u5c31\u53d1\u73b0\uff0c\u88abHack\u4e86~~ \u6b63\u786e\u505a\u6cd5\u662f\uff1a\u7b2c\u4e00\u6b65\u6709\u4e24\u79cd\uff1a (\u5047\u8bbe\u5c06\u5927\u76d8\u5b50\u4ece\u67f1\u5b501\u632a\u5230\u67f1\u5b502) 1) \u5c0f\u76d8\u5b50\u5230\u67f1\u5b503$\\to$\u5927\u76d8\u5b50\u4ece1\u52302$\\to$\u5c0f\u76d8\u5b50\u5230\u6700\u7ec8\u72b6\u6001 2) \u5c0f\u76d8\u5b50\u5230\u67f1\u5b502$\\to$\u5927\u76d8\u5b50\u4ece1\u52303$\\to$\u5c0f\u76d8\u5b50\u5230\u67f1\u5b501$\\to$\u5927\u76d8\u5b50\u4ece3\u52302$\\to$\u5c0f\u76d8\u5b50\u5230\u6700\u7ec8\u72b6\u6001 \u8fd9\u5c31\u662fP1242 \u7b2c11\u4e2a\u70b9\u7684$Hack$\u539f\u7406. #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=122,M=5e6+10; int start[N],finish[N],mid[N]; int n,cnt,m; struct node { int n,a,b; } step1[M],step2[M]; void g(int n,int a,int b,int c,node *step) { if(n==0)return; g(n-1,a,c,b,step); step[++cnt].n=n,step[cnt].a=a,step[cnt].b=c; g(n-1,b,a,c,step); return; } int f(int* P,int i,int final,node *step) { if(i==0)return 0; if(P[i]==final)return f(P,i-1,final,step); int tmp=f(P,i-1,6-P[i]-final,step); step[++cnt].n=i,step[cnt].a=P[i],step[cnt].b=final; g(i-1,6-P[i]-final,P[i],final,step); return tmp+(1ll<<(i-1)); } void print1(int cnt,int ans,int a,int b,node *step) { for(int i=a+1; i<=cnt; ++i) { swap(step[i].a,step[i].b); } for(int i=1; i<=b/2; ++i) { swap(step[i+a+1-1],step[cnt-i+1]); } for(int i=1; i<=ans; ++i) { printf(\"move %d from %c to %c\\n\",step[i].n,step[i].a+'A'-1,step[i].b+'A'-1); } printf(\"%lld\",ans); } signed main() { scanf(\"%lld\",&n); for(int i=1; i<=3; ++i) { scanf(\"%lld\",&m); for(int k=1,p; k<=m; ++k)scanf(\"%lld\",&p),start[p]=i; } for(int i=1; i<=3; ++i) { scanf(\"%lld\",&m); for(int k=1,p; k<=m; ++k)scanf(\"%lld\",&p),finish[p]=i; } while(start[n]==finish[n] && n>=1)--n; int ans=0,tmp1=0,tmp2=0,tmp3=0,tmp4=0; if(n>=1) { cnt=0; tmp1=f(start,n-1,6-start[n]-finish[n],step1)+1; step1[++cnt].n=n,step1[cnt].a=start[n],step1[cnt].b=finish[n]; tmp2=f(finish,n-1,6-start[n]-finish[n],step1); cnt=0; tmp3+=f(start,n-1,finish[n],step2)+1; step2[++cnt].n=n,step2[cnt].a=start[n],step2[cnt].b=6-start[n]-finish[n]; for(int i=1;i<n;++i)mid[i]=finish[n]; mid[n]=6-start[n]-finish[n]; tmp3+=f(mid,n-1,start[n],step2)+1; step2[++cnt].n=n,step2[cnt].a=6-start[n]-finish[n],step2[cnt].b=finish[n]; tmp4=f(finish,n-1,start[n],step2); if(tmp1+tmp2<tmp3+tmp4) { ans=tmp1+tmp2; print1(ans,ans,tmp1,tmp2,step1); } else { ans=tmp3+tmp4; print1(ans,ans,tmp3,tmp4,step2); } } return 0; } P","title":"\u9012\u5f52 &amp; \u9012\u63a8"},{"location":"my%20past/OI/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","text":"\u9ad8\u65af\u6d88\u5143 \u89e3\u6cd5\u4e00 \u63091\\~n\u7684\u987a\u5e8f\u9009\u62e9\u672a\u77e5\u6570$x_i$,\u9009\u62e9$x_i$\u7cfb\u6570\u6700\u5927\u7684\u65b9\u7a0b\uff0c\u5c06\u9009\u4e2d\u7684\u65b9\u7a0b\u7684$x_i$\u7cfb\u6570\u5316\u4e3a1\uff0c\u5e76\u7528\u90a3\u4e2a\u65b9\u7a0b\u6d88\u53bb\u5176\u4ed6\u65b9\u7a0b\u4e2d\u7684$x_i$\u9879\u3002 \u6700\u540e\u5269\u4e0b\u4e00\u4e2a\u53ea\u6709\u4e00\u4e2a\u672a\u77e5\u6570\u5e76\u4e14\u7cfb\u6570\u4e3a1\u7684\u65b9\u7a0b\uff0c\u76f4\u63a5\u5f97\u51fa\u7b54\u6848\uff0c\u7528\u90a3\u4e2a\u7b54\u6848\u56de\u5e26\u5230\u5176\u4ed6\u65b9\u7a0b\uff0c\u4f9d\u6b21\u6c42\u89e3\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=110; const double eps=1e-7; double f[N][N]; double ans[N]; int n; double abs1(double a){ return a>=0.0?a:-a; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i){ for(int j=1;j<=n+1;++j){ scanf(\"%lf\",&f[i][j]); } } for(int i=1;i<=n;++i){ int r=i; for(int j=i;j<=n;++j){ if(abs1(f[r][i])<abs1(f[j][i]))r=j; } if(abs1(f[r][i])<eps){//\u5c31\u662f\u7b49\u4e8e0\uff0c\u90a3\u5c31\u662f\u8bf4\u8fd9\u4e2a\u672a\u77e5\u6570\u6240\u6709\u65b9\u7a0b\u7cfb\u6570\u90fd\u662f0\uff0c\u80af\u5b9a\u65e0\u89e3\u3002 printf(\"No Solution\"); return 0; } if(i!=r)swap(f[r],f[i]); double tmp=f[i][i]; for(int j=i;j<=n+1;++j)f[i][j]/=tmp; for(int j=i+1;j<=n;++j){ double tmp=f[j][i]; for(int k=i;k<=n+1;++k){ f[j][k]-=f[i][k]*tmp; } } } ans[n]=f[n][n+1]; for(int i=n-1;i>=1;--i){ for(int j=i+1;j<=n;++j){ f[i][n+1]-=ans[j]*f[i][j]; } ans[i]=f[i][n+1]; } for(int i=1;i<=n;++i){ printf(\"%.2lf\\n\",ans[i]); } return 0; } \u89e3\u6cd5\u4e8c \u56e0\u4e3a\u56de\u5e26\u7684\u8fc7\u7a0b\u590d\u6742\u5e76\u4e14\u6ca1\u6709\u5fc5\u8981\uff0c\u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u4e0d\u56de\u5e26\u4e86\u3002 \u6bcf\u6b21\u53ea\u9700\u8981\u5c06\u9664\u4e86\u9009\u4e2d\u7684\u65b9\u7a0b\u7684\u5176\u4ed6\u6240\u6709\u65b9\u7a0b\u7684\u5f53\u524d\u672a\u77e5\u6570\u90fd\u6d88\u9664\u6389\uff0c\u90a3\u4e48\u6700\u540e\u5c31\u5269\u4e0bn\u4e2a\u53ea\u6709\u4e00\u4e2a\u672a\u77e5\u6570\u4e14\u7cfb\u6570\u4e3a1\u7684\u65b9\u7a0b\uff0c\u76f4\u63a5\u8f93\u51fa\u7b54\u6848\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=110; double f[N][N]; int n; double abs1(double a){ return a>=0.0?a:-a; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i) for(int j=1;j<=n+1;++j)scanf(\"%lf\",&f[i][j]); for(int i=1;i<=n;++i){ int r=i; for(int j=i;j<=n;++j){ if(abs1(f[r][i])<abs1(f[j][i]))r=j; } if(!abs1(f[r][i])){ printf(\"No Solution\"); return 0; } if(i!=r)swap(f[r],f[i]); double tmp=f[i][i]; for(int j=i;j<=n+1;++j)f[i][j]/=tmp; for(int j=1;j<=n;++j){ if(j==i)continue; double tmp=f[j][i]; for(int k=i;k<=n+1;++k)f[j][k]-=f[i][k]*tmp;//k=1\u4e5f\u884c\uff0c\u6ca1\u5fc5\u8981 } } for(int i=1;i<=n;++i){ printf(\"%.2lf\\n\",f[i][n+1]); } return 0; } P3389 \u6a21\u677f P2011 \u5bf9\u4e8e\u6bcf\u4e2a\u4e0d\u662f\u6b63\u6781\u6216\u8d1f\u6781\u7684\u70b9$u$\uff0c\u90fd\u6709\uff1a $$\\sum_{v_i}\\frac{U_{v_i}-U_u}{R_{w_i}}=0$$ \u5c06\u6240\u6709\u662f\u6b63\u6781\u8d1f\u6781\u7684\u70b9\u7684\u7ed3\u679c\u79fb\u5230$n+1$\u8868\u793a\u5e38\u6570\uff0c\u800c$v_i$\u5f97\u7cfb\u6570\u4e3a$-\\frac{1}{R_{w_i}}$,$u$\u5f97\u7cfb\u6570\u4e3a$\\sum {v_i}\\frac{1}{R {w_i}}$ \u90a3\u4e48\u4f1a\u6709n-k\u4e2a\u5f0f\u5b50\uff0c\u4e00\u5171n-k\u4e2a\u672a\u77e5\u6570\uff0c\u5bf9\u5e94\u6c42\u89e3\u5373\u53ef\u3002 \u6ce8\u610f\u5199\u6cd5\u4e2d\uff0c\u6bcf\u4e2a\u5f0f\u5b50\u4e2d\u4f1a\u67090\u7cfb\u6570\u5b58\u5728\uff0c\u8981\u5ffd\u7565\u8fd9\u4e9b0\u7cfb\u6570\uff0c\u5e76\u4e14\u672a\u77e5\u6570\u7f16\u53f7\u8981\u4e0e\u5217\u53f7\u4e00\u4e00\u5bf9\u5e94\u3002(vis[i]\u6570\u7ec4\u7684\u4f5c\u7528) #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=440,M=2e5+10; double f[N][N],ans[N]; int head[N],vis[N],id[N]; int cnt,n,m,k,q,tot; struct node{ int v,nxt; double w; }e[M<<1]; double abs1(double a){ return a>=0.0?a:-a; } void add(int u,int v,double w){ e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; return; } void clear1(){ for(int i=0;i<=n;++i)ans[i]=-1.0; ans[0]=0.0; } void init(){ tot=0; for(int u=0;u<=n;++u){ if(ans[u]<0.0){ tot++; vis[tot]=u; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; double w=e[i].w; if(ans[v]>=0.0){ f[tot][n+1]+=ans[v]/w;//constant }else f[tot][v]-=1.0/w; f[tot][u]+=1.0/w; } } } } void work(){ for(int u=1,i;u<=tot;++u){ i=vis[u]; int r=u; for(int j=u;j<=tot;++j){ if(abs1(f[r][i])<abs1(f[j][i]))r=j; } /*if(!abs1(f[r][i])){ return 0; }*/ if(u!=r)swap(f[r],f[u]); double tmp=f[u][i]; for(int j=i;j<=n+1;++j)f[u][j]/=tmp; for(int j=u+1;j<=tot;++j){ double tmp=f[j][i]; for(int k=i;k<=n+1;++k){ f[j][k]-=f[u][k]*tmp; } } } ans[vis[tot]]=f[tot][n+1]; for(int i=tot-1;i>=1;--i){ for(int j=i+1;j<=n;++j){ f[i][n+1]-=f[i][vis[j]]*ans[vis[j]]; } ans[vis[i]]=f[i][n+1]; } } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld%lld%lld\",&n,&m,&k,&q); clear1(); for(int i=1,tmp;i<=k;++i){ scanf(\"%lld\",&tmp); scanf(\"%lf\",&ans[tmp]); } for(int i=1,u,v,w;i<=m;++i){ scanf(\"%lld%lld%lld\",&u,&v,&w); add(u,v,w); add(v,u,w); } init(); work(); for(int i=1,x,y;i<=q;++i){ scanf(\"%lld%lld\",&x,&y); printf(\"%.2lf\\n\",ans[x]-ans[y]); } return 0; } /* 3 5 1 3 2 18 2 1 6 2 3 2 1 3 6 3 0 6 1 0 2 2 0 1 3 2 1 */","title":"\u9ad8\u65af\u6d88\u5143"},{"location":"my%20past/OI/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/#_1","text":"","title":"\u9ad8\u65af\u6d88\u5143"},{"location":"my%20past/OI/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/#_2","text":"\u63091\\~n\u7684\u987a\u5e8f\u9009\u62e9\u672a\u77e5\u6570$x_i$,\u9009\u62e9$x_i$\u7cfb\u6570\u6700\u5927\u7684\u65b9\u7a0b\uff0c\u5c06\u9009\u4e2d\u7684\u65b9\u7a0b\u7684$x_i$\u7cfb\u6570\u5316\u4e3a1\uff0c\u5e76\u7528\u90a3\u4e2a\u65b9\u7a0b\u6d88\u53bb\u5176\u4ed6\u65b9\u7a0b\u4e2d\u7684$x_i$\u9879\u3002 \u6700\u540e\u5269\u4e0b\u4e00\u4e2a\u53ea\u6709\u4e00\u4e2a\u672a\u77e5\u6570\u5e76\u4e14\u7cfb\u6570\u4e3a1\u7684\u65b9\u7a0b\uff0c\u76f4\u63a5\u5f97\u51fa\u7b54\u6848\uff0c\u7528\u90a3\u4e2a\u7b54\u6848\u56de\u5e26\u5230\u5176\u4ed6\u65b9\u7a0b\uff0c\u4f9d\u6b21\u6c42\u89e3\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=110; const double eps=1e-7; double f[N][N]; double ans[N]; int n; double abs1(double a){ return a>=0.0?a:-a; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i){ for(int j=1;j<=n+1;++j){ scanf(\"%lf\",&f[i][j]); } } for(int i=1;i<=n;++i){ int r=i; for(int j=i;j<=n;++j){ if(abs1(f[r][i])<abs1(f[j][i]))r=j; } if(abs1(f[r][i])<eps){//\u5c31\u662f\u7b49\u4e8e0\uff0c\u90a3\u5c31\u662f\u8bf4\u8fd9\u4e2a\u672a\u77e5\u6570\u6240\u6709\u65b9\u7a0b\u7cfb\u6570\u90fd\u662f0\uff0c\u80af\u5b9a\u65e0\u89e3\u3002 printf(\"No Solution\"); return 0; } if(i!=r)swap(f[r],f[i]); double tmp=f[i][i]; for(int j=i;j<=n+1;++j)f[i][j]/=tmp; for(int j=i+1;j<=n;++j){ double tmp=f[j][i]; for(int k=i;k<=n+1;++k){ f[j][k]-=f[i][k]*tmp; } } } ans[n]=f[n][n+1]; for(int i=n-1;i>=1;--i){ for(int j=i+1;j<=n;++j){ f[i][n+1]-=ans[j]*f[i][j]; } ans[i]=f[i][n+1]; } for(int i=1;i<=n;++i){ printf(\"%.2lf\\n\",ans[i]); } return 0; }","title":"\u89e3\u6cd5\u4e00"},{"location":"my%20past/OI/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/#_3","text":"\u56e0\u4e3a\u56de\u5e26\u7684\u8fc7\u7a0b\u590d\u6742\u5e76\u4e14\u6ca1\u6709\u5fc5\u8981\uff0c\u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u4e0d\u56de\u5e26\u4e86\u3002 \u6bcf\u6b21\u53ea\u9700\u8981\u5c06\u9664\u4e86\u9009\u4e2d\u7684\u65b9\u7a0b\u7684\u5176\u4ed6\u6240\u6709\u65b9\u7a0b\u7684\u5f53\u524d\u672a\u77e5\u6570\u90fd\u6d88\u9664\u6389\uff0c\u90a3\u4e48\u6700\u540e\u5c31\u5269\u4e0bn\u4e2a\u53ea\u6709\u4e00\u4e2a\u672a\u77e5\u6570\u4e14\u7cfb\u6570\u4e3a1\u7684\u65b9\u7a0b\uff0c\u76f4\u63a5\u8f93\u51fa\u7b54\u6848\u5373\u53ef\u3002 #include<iostream> #include<cstdio> #include<cstring> using namespace std; const int N=110; double f[N][N]; int n; double abs1(double a){ return a>=0.0?a:-a; } int main(){ scanf(\"%d\",&n); for(int i=1;i<=n;++i) for(int j=1;j<=n+1;++j)scanf(\"%lf\",&f[i][j]); for(int i=1;i<=n;++i){ int r=i; for(int j=i;j<=n;++j){ if(abs1(f[r][i])<abs1(f[j][i]))r=j; } if(!abs1(f[r][i])){ printf(\"No Solution\"); return 0; } if(i!=r)swap(f[r],f[i]); double tmp=f[i][i]; for(int j=i;j<=n+1;++j)f[i][j]/=tmp; for(int j=1;j<=n;++j){ if(j==i)continue; double tmp=f[j][i]; for(int k=i;k<=n+1;++k)f[j][k]-=f[i][k]*tmp;//k=1\u4e5f\u884c\uff0c\u6ca1\u5fc5\u8981 } } for(int i=1;i<=n;++i){ printf(\"%.2lf\\n\",f[i][n+1]); } return 0; } P3389 \u6a21\u677f P2011 \u5bf9\u4e8e\u6bcf\u4e2a\u4e0d\u662f\u6b63\u6781\u6216\u8d1f\u6781\u7684\u70b9$u$\uff0c\u90fd\u6709\uff1a $$\\sum_{v_i}\\frac{U_{v_i}-U_u}{R_{w_i}}=0$$ \u5c06\u6240\u6709\u662f\u6b63\u6781\u8d1f\u6781\u7684\u70b9\u7684\u7ed3\u679c\u79fb\u5230$n+1$\u8868\u793a\u5e38\u6570\uff0c\u800c$v_i$\u5f97\u7cfb\u6570\u4e3a$-\\frac{1}{R_{w_i}}$,$u$\u5f97\u7cfb\u6570\u4e3a$\\sum {v_i}\\frac{1}{R {w_i}}$ \u90a3\u4e48\u4f1a\u6709n-k\u4e2a\u5f0f\u5b50\uff0c\u4e00\u5171n-k\u4e2a\u672a\u77e5\u6570\uff0c\u5bf9\u5e94\u6c42\u89e3\u5373\u53ef\u3002 \u6ce8\u610f\u5199\u6cd5\u4e2d\uff0c\u6bcf\u4e2a\u5f0f\u5b50\u4e2d\u4f1a\u67090\u7cfb\u6570\u5b58\u5728\uff0c\u8981\u5ffd\u7565\u8fd9\u4e9b0\u7cfb\u6570\uff0c\u5e76\u4e14\u672a\u77e5\u6570\u7f16\u53f7\u8981\u4e0e\u5217\u53f7\u4e00\u4e00\u5bf9\u5e94\u3002(vis[i]\u6570\u7ec4\u7684\u4f5c\u7528) #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=440,M=2e5+10; double f[N][N],ans[N]; int head[N],vis[N],id[N]; int cnt,n,m,k,q,tot; struct node{ int v,nxt; double w; }e[M<<1]; double abs1(double a){ return a>=0.0?a:-a; } void add(int u,int v,double w){ e[++cnt].v=v; e[cnt].w=w; e[cnt].nxt=head[u]; head[u]=cnt; return; } void clear1(){ for(int i=0;i<=n;++i)ans[i]=-1.0; ans[0]=0.0; } void init(){ tot=0; for(int u=0;u<=n;++u){ if(ans[u]<0.0){ tot++; vis[tot]=u; for(int i=head[u];~i;i=e[i].nxt){ int v=e[i].v; double w=e[i].w; if(ans[v]>=0.0){ f[tot][n+1]+=ans[v]/w;//constant }else f[tot][v]-=1.0/w; f[tot][u]+=1.0/w; } } } } void work(){ for(int u=1,i;u<=tot;++u){ i=vis[u]; int r=u; for(int j=u;j<=tot;++j){ if(abs1(f[r][i])<abs1(f[j][i]))r=j; } /*if(!abs1(f[r][i])){ return 0; }*/ if(u!=r)swap(f[r],f[u]); double tmp=f[u][i]; for(int j=i;j<=n+1;++j)f[u][j]/=tmp; for(int j=u+1;j<=tot;++j){ double tmp=f[j][i]; for(int k=i;k<=n+1;++k){ f[j][k]-=f[u][k]*tmp; } } } ans[vis[tot]]=f[tot][n+1]; for(int i=tot-1;i>=1;--i){ for(int j=i+1;j<=n;++j){ f[i][n+1]-=f[i][vis[j]]*ans[vis[j]]; } ans[vis[i]]=f[i][n+1]; } } signed main(){ memset(head,-1,sizeof head); cnt=-1; scanf(\"%lld%lld%lld%lld\",&n,&m,&k,&q); clear1(); for(int i=1,tmp;i<=k;++i){ scanf(\"%lld\",&tmp); scanf(\"%lf\",&ans[tmp]); } for(int i=1,u,v,w;i<=m;++i){ scanf(\"%lld%lld%lld\",&u,&v,&w); add(u,v,w); add(v,u,w); } init(); work(); for(int i=1,x,y;i<=q;++i){ scanf(\"%lld%lld\",&x,&y); printf(\"%.2lf\\n\",ans[x]-ans[y]); } return 0; } /* 3 5 1 3 2 18 2 1 6 2 3 2 1 3 6 3 0 6 1 0 2 2 0 1 3 2 1 */","title":"\u89e3\u6cd5\u4e8c"},{"location":"my%20past/OI/%E9%AB%98%E7%B2%BE%E5%BA%A6/","text":"\u9ad8\u7cbe\u5ea6 ~~\u6211\u613f\u79f0\u4e4b\u4e3a\u53f2\u4e0a\u6700\u70e6\u4eba\u7684\u7b97\u6cd5~~ __int128 ~~\u867d\u7136\u7406\u8bba\u4e0a\u53ea\u80fd\u5728linux\u73af\u5883\u4e2d\u7528\uff0c\u4e0d\u77e5\u9053\u8003\u8bd5\u65f6CCF\u7684\u8001\u5e74\u673a\u80fd\u4e0d\u80fd\u7f16\u8bd1\u901a\u8fc7\uff0c\u4f46\u6d1b\u8c37\u662f\u53ef\u4ee5\u7684~~ \u672c\u8d28\u5c31\u662f\u4e00\u4e2a128\u4f4d\u7684\u5927\u6574\u6570\uff0c\u5927\u7ea640\u4f4d\uff0c\u5bf9\u4e8e\u5c0f\u90e8\u5206\u5bf9\u9ad8\u7cbe\u5ea6\u8981\u6c42\u8f83$_ { \u5c0f} $\u7684\u9898\u662f\u53ef\u4ee5\u7528\u7684\uff0c\u7701\u4e8b\u3002 gcc\u4e2d\u5b98\u65b9\u7ed9\u51fa\u7684__int128\u6709\u4e24\u79cd,\u4e3a __int128_t a=10000000000000L; __uint128_t b=200000000000000L; //__int128 c=100000000000L a*=b;//long long \u6ea2\u51fa\uff0c\u4f46__int128\u4e0d\u4f1a ~~\u4e8b\u5b9e\u4e0a__int128\u548c__int128_t\u90fd\u80fd\u7528~~ \u8fd0\u7b97\u7684\u8bdd\uff0c\u540c\u6837\u652f\u6301\u53d6\u53cd\uff0c\u5f02\u6216\uff0c\u4f4d\u79fb\uff0c\u52a0\u51cf\u4e58\u9664\u7b49\u3002 \u5c31\u662f\u8f93\u5165\u8f93\u51fa\u8981\u7528\u5feb\u5199\u5feb\u8bfb #define int __int128 int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch>='0' && ch<='9'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); return; } P1005 1.__int128 #include<iostream> #include<cstdio> #include<cstring> #define int __int128_t using namespace std; const int N=110; int n,m; int f[N][N],a[N][N],tmp[N]; int kp(int x,int p){ if(p<=1)return x; if(p%2==0)return kp(x*x,p>>1); else return x*kp(x*x,p>>1); } int dp(int x){ memset(f,0,sizeof f); for(int i=1;i<=m;++i)tmp[i]=a[x][i]; tmp[0]=tmp[m+1]=0; for(int i=1;i<=m;++i){ f[i][i]=tmp[i]<<1; } for(int l=2;l<=m;++l){ for(int b=1;b+l-1<=m;++b){ int e=b+l-1; f[b][e]=max(f[b][e],2*f[b][e-1]+2*tmp[e]); f[b][e]=max(f[b][e],2*f[b+1][e]+2*tmp[b]); } } return f[1][m]; } int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch>='0' && ch<='9'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); return; } signed main(){ n=read1(),m=read1(); for(int i=1;i<=n;++i){ for(int j=1;j<=m;++j){ a[i][j]=read1(); } } int ans=0; for(int i=1;i<=n;++i){ int tmp=dp(i); //write1(tmp); //putchar('\\n'); ans+=tmp; } write1(ans); return 0; } /* 5 5 0 0 0 0 0 0 0 0 0 1 876 1 566 920 598 259 945 123 659 997 176 478 293 464 278 2 3 1 5 2 3 4 2 2 4 1 4 2 3 1 4 3 2 */ 2.\u6734\u7d20 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=110; int n,m; struct HP{ int p[N],len; void clear1(){ memset(p,0,sizeof p); len=1; return; } void read1(){ memset(p,0,sizeof p); len=1; p[0]=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')p[0]=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ p[++len]=ch-'0'; ch=getchar(); } for(int i=1;i<=len/2;++i){ swap(p[i],p[len-i+1]); } } void write1(){ if(p[0]==-1)putchar('-'); for(int i=len;i>=1;--i){ putchar(p[i]+'0'); } putchar('\\n'); } }f[N][N],a[N][N],tmp[N],ans,tp; HP operator +(const HP &a,const HP &b){ //if(a.p[0]==-1 || b.p[0]==-1)return a-b; HP c; c.clear1(); int la=a.len,lb=b.len,lc=max(la,lb); int f=0; for(int i=1;i<=lc;++i){ c.p[i]=a.p[i]+b.p[i]+f; f=c.p[i]/10; c.p[i]%=10; } if(f)c.p[++lc]=f; c.len=lc; return c; } int cmp(const HP &a,const HP &b){ //cout<<a.len<<\" \"<<b.len<<endl; if(a.len<b.len)return -1; if(a.len>b.len)return 1; for(int i=a.len;i>=1;--i){ if(a.p[i]<b.p[i])return -1; if(a.p[i]>b.p[i])return 1; } return 0; } HP max1(const HP &a,const HP &b){ int res=cmp(a,b); if(res>=0)return a; else return b; } HP operator -(const HP &x,const HP &y){ HP c,a,b; c.clear1(); if(cmp(x,y)==-1){ a=y,b=x; c.p[0]=-1; }else{ a=x,b=y; c.p[0]=1; } int la=a.len,lb=b.len,lc=max(la,lb); int f=0; for(int i=1;i<=lc;++i){ if(a.p[i]<b.p[i]){ a.p[i]+=10; a.p[i+1]--; } c.p[i]=a.p[i]-b.p[i]; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } HP operator *(const HP &a,const HP &b){ HP c; c.clear1(); int la=a.len,lb=b.len,lc=la+lb; for(int i=1;i<=la;++i){ int x=0; for(int j=1;j<=lb;++j){ c.p[i+j-1]+=a.p[i]*b.p[j]+x; x=c.p[i+j-1]/10; c.p[i+j-1]%=10; } c.p[i+lb]=x; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; int tmp; if(a.p[0]==-1 && b.p[0]==-1)tmp=1; else if(a.p[0]>=0 && b.p[0]>=0)tmp=1; else tmp=-1; c.p[0]=tmp; return c; } HP operator /=(const HP &a,int b){ HP c; c.clear1(); int la=a.len,f=0,lc=la; for(int i=la;i>=1;--i){ c.p[i]=(f*10+a.p[i])/b; f=(f*10+a.p[i])%b; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } HP operator /(const HP &x,const HP &y){ HP c,a=x,b=y; c.clear1(); int la=a.len,lb=b.len,lc=la-lb+1; for(int i=lc;i>=1;--i){ HP e; e.clear1(); for(int k=1;k<=lb;++k){ e.p[k+i-1]=b.p[k]; } e.len=i+lb-1; while(cmp(a,e)>=0)c.p[i]++,a=a-e; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } HP kp(HP x,int p){ if(p<=1)return x; if(p%2==0)return kp(x*x,p>>1); else return x*kp(x*x,p>>1); } HP dp(int x){ memset(f,0,sizeof f); for(int i=1;i<=m;++i)tmp[i]=a[x][i]; HP two; two.clear1(); two.len=1,two.p[1]=2; for(int i=1;i<=m;++i){ f[i][i]=tmp[i]*two; } for(int l=2;l<=m;++l){ for(int b=1;b+l-1<=m;++b){ int e=b+l-1; f[b][e]=max1(f[b][e],two*f[b][e-1]+two*tmp[e]); f[b][e]=max1(f[b][e],two*f[b+1][e]+two*tmp[b]); } } return f[1][m]; } signed main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i){ for(int j=1;j<=m;++j){ a[i][j].read1(); } } ans.clear1(); for(int i=1;i<=n;++i){ tp=dp(i); //write1(tmp); //putchar('\\n'); ans=ans+tp; } ans.write1(); return 0; } /* 5 5 0 0 0 0 0 0 0 0 0 1 876 1 566 920 598 259 945 123 659 997 176 478 293 464 278 2 3 1 5 2 3 4 2 2 4 1 4 2 3 1 4 3 2 */ \u6734\u7d20\u9ad8\u7cbe\u5ea6 struct HP{ int p[N],len; void clear1(){ memset(p,0,sizeof p); len=1; return; } void read1(){ memset(p,0,sizeof p); len=1; p[0]=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')p[0]=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ p[++len]=ch-'0'; ch=getchar(); } for(int i=1;i<=len/2;++i){ swap(p[i],p[len-i+1]); } } void write1(){ if(p[0]==-1)putchar('-'); for(int i=len;i>=1;--i){ putchar(p[i]+'0'); } putchar('\\n'); } }; HP operator +(const HP &a,const HP &b){ //if(a.p[0]==-1 || b.p[0]==-1)return a-b; HP c; c.clear1(); int la=a.len,lb=b.len,lc=max(la,lb); int f=0; for(int i=1;i<=lc;++i){ c.p[i]=a.p[i]+b.p[i]+f; f=c.p[i]/10; c.p[i]%=10; } if(f)c.p[++lc]=f; c.len=lc; return c; } int cmp(const HP &a,const HP &b){ //cout<<a.len<<\" \"<<b.len<<endl; if(a.len<b.len)return -1; if(a.len>b.len)return 1; for(int i=a.len;i>=1;--i){ if(a.p[i]<b.p[i])return -1; if(a.p[i]>b.p[i])return 1; } return 0; } HP max1(const HP &a,const HP &b){ int res=cmp(a,b); if(res>=0)return a; else return b; } HP operator -(const HP &x,const HP &y){ HP c,a,b; c.clear1(); if(cmp(x,y)==-1){ a=y,b=x; c.p[0]=-1; }else{ a=x,b=y; c.p[0]=1; } int la=a.len,lb=b.len,lc=max(la,lb); int f=0; for(int i=1;i<=lc;++i){ if(a.p[i]<b.p[i]){ a.p[i]+=10; a.p[i+1]--; } c.p[i]=a.p[i]-b.p[i]; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } HP operator *(const HP &a,const HP &b){ HP c; c.clear1(); int la=a.len,lb=b.len,lc=la+lb; for(int i=1;i<=la;++i){ int x=0; for(int j=1;j<=lb;++j){ c.p[i+j-1]+=a.p[i]*b.p[j]+x; x=c.p[i+j-1]/10; c.p[i+j-1]%=10; } c.p[i+lb]=x; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; int tmp; if(a.p[0]==-1 && b.p[0]==-1)tmp=1; else if(a.p[0]>=0 && b.p[0]>=0)tmp=1; else tmp=-1; c.p[0]=tmp; return c; } HP operator /=(const HP &a,int b){ HP c; c.clear1(); int la=a.len,f=0,lc=la; for(int i=la;i>=1;--i){ c.p[i]=(f*10+a.p[i])/b; f=(f*10+a.p[i])%b; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } HP operator /(const HP &x,const HP &y){ HP c,a=x,b=y; c.clear1(); int la=a.len,lb=b.len,lc=la-lb+1; for(int i=lc;i>=1;--i){ HP e; e.clear1(); for(int k=1;k<=lb;++k){ e.p[k+i-1]=b.p[k]; } e.len=i+lb-1; while(cmp(a,e)>=0)c.p[i]++,a=a-e; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } \u8bb0\u5f97\u5e38\u6e05\u96f6\uff0c\u5c11\u7528\u5c40\u90e8\u53d8\u91cf\uff0c\u4e0d\u7136\u4f1a\u51fa\u73b0\u521d\u59cb\u503c\u4e0d\u4e3a\u96f6\u7684\u60c5\u51b5\u3002 \u538b\u7f29\u9ad8\u7cbe\u5ea6 const int M=1000+5,base=1e8; int n; struct BigInt{ int sum[21]; void operator += (const BigInt &x){ sum[0]=max(sum[0],x.sum[0]); for(int i=1; i<=sum[0]; i++){ sum[i]+=x.sum[i]; if(sum[i]>=base) sum[i+1]++,sum[i]-=base; } if(sum[sum[0]+1]>0) sum[0]++; } void operator *= (const BigInt &x){ long long A[21]={}; for(int i=1; i<=sum[0]; i++){ for(int j=1; j<=x.sum[0]; j++){ A[i+j-1]+=1ll*sum[i]*x.sum[j]; } } for(int i=1; i<=sum[0]+x.sum[0]; i++){ A[i+1]+=A[i]/base; A[i]%=base; sum[i]=A[i]; } if(A[sum[0]+x.sum[0]]) sum[0]=sum[0]+x.sum[0]; else sum[0]=sum[0]+x.sum[0]-1; } void Print(){ printf(\"%d\",sum[sum[0]]); for(int i=sum[0]-1; i>0; i--){ printf(\"%08d\",sum[i]); } } }","title":"\u9ad8\u7cbe\u5ea6"},{"location":"my%20past/OI/%E9%AB%98%E7%B2%BE%E5%BA%A6/#_1","text":"~~\u6211\u613f\u79f0\u4e4b\u4e3a\u53f2\u4e0a\u6700\u70e6\u4eba\u7684\u7b97\u6cd5~~","title":"\u9ad8\u7cbe\u5ea6"},{"location":"my%20past/OI/%E9%AB%98%E7%B2%BE%E5%BA%A6/#__int128","text":"~~\u867d\u7136\u7406\u8bba\u4e0a\u53ea\u80fd\u5728linux\u73af\u5883\u4e2d\u7528\uff0c\u4e0d\u77e5\u9053\u8003\u8bd5\u65f6CCF\u7684\u8001\u5e74\u673a\u80fd\u4e0d\u80fd\u7f16\u8bd1\u901a\u8fc7\uff0c\u4f46\u6d1b\u8c37\u662f\u53ef\u4ee5\u7684~~ \u672c\u8d28\u5c31\u662f\u4e00\u4e2a128\u4f4d\u7684\u5927\u6574\u6570\uff0c\u5927\u7ea640\u4f4d\uff0c\u5bf9\u4e8e\u5c0f\u90e8\u5206\u5bf9\u9ad8\u7cbe\u5ea6\u8981\u6c42\u8f83$_ { \u5c0f} $\u7684\u9898\u662f\u53ef\u4ee5\u7528\u7684\uff0c\u7701\u4e8b\u3002 gcc\u4e2d\u5b98\u65b9\u7ed9\u51fa\u7684__int128\u6709\u4e24\u79cd,\u4e3a __int128_t a=10000000000000L; __uint128_t b=200000000000000L; //__int128 c=100000000000L a*=b;//long long \u6ea2\u51fa\uff0c\u4f46__int128\u4e0d\u4f1a ~~\u4e8b\u5b9e\u4e0a__int128\u548c__int128_t\u90fd\u80fd\u7528~~ \u8fd0\u7b97\u7684\u8bdd\uff0c\u540c\u6837\u652f\u6301\u53d6\u53cd\uff0c\u5f02\u6216\uff0c\u4f4d\u79fb\uff0c\u52a0\u51cf\u4e58\u9664\u7b49\u3002 \u5c31\u662f\u8f93\u5165\u8f93\u51fa\u8981\u7528\u5feb\u5199\u5feb\u8bfb #define int __int128 int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch>='0' && ch<='9'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); return; } P1005 1.__int128 #include<iostream> #include<cstdio> #include<cstring> #define int __int128_t using namespace std; const int N=110; int n,m; int f[N][N],a[N][N],tmp[N]; int kp(int x,int p){ if(p<=1)return x; if(p%2==0)return kp(x*x,p>>1); else return x*kp(x*x,p>>1); } int dp(int x){ memset(f,0,sizeof f); for(int i=1;i<=m;++i)tmp[i]=a[x][i]; tmp[0]=tmp[m+1]=0; for(int i=1;i<=m;++i){ f[i][i]=tmp[i]<<1; } for(int l=2;l<=m;++l){ for(int b=1;b+l-1<=m;++b){ int e=b+l-1; f[b][e]=max(f[b][e],2*f[b][e-1]+2*tmp[e]); f[b][e]=max(f[b][e],2*f[b+1][e]+2*tmp[b]); } } return f[1][m]; } int read1(){ int x=0,f=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')f=-1; ch=getchar(); } while(ch>='0' && ch<='9'){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*f; } void write1(int x){ if(x<0)putchar('-'),x=-x; if(x>9)write1(x/10); putchar(x%10+'0'); return; } signed main(){ n=read1(),m=read1(); for(int i=1;i<=n;++i){ for(int j=1;j<=m;++j){ a[i][j]=read1(); } } int ans=0; for(int i=1;i<=n;++i){ int tmp=dp(i); //write1(tmp); //putchar('\\n'); ans+=tmp; } write1(ans); return 0; } /* 5 5 0 0 0 0 0 0 0 0 0 1 876 1 566 920 598 259 945 123 659 997 176 478 293 464 278 2 3 1 5 2 3 4 2 2 4 1 4 2 3 1 4 3 2 */ 2.\u6734\u7d20 #include<iostream> #include<cstdio> #include<cstring> #define int long long using namespace std; const int N=110; int n,m; struct HP{ int p[N],len; void clear1(){ memset(p,0,sizeof p); len=1; return; } void read1(){ memset(p,0,sizeof p); len=1; p[0]=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')p[0]=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ p[++len]=ch-'0'; ch=getchar(); } for(int i=1;i<=len/2;++i){ swap(p[i],p[len-i+1]); } } void write1(){ if(p[0]==-1)putchar('-'); for(int i=len;i>=1;--i){ putchar(p[i]+'0'); } putchar('\\n'); } }f[N][N],a[N][N],tmp[N],ans,tp; HP operator +(const HP &a,const HP &b){ //if(a.p[0]==-1 || b.p[0]==-1)return a-b; HP c; c.clear1(); int la=a.len,lb=b.len,lc=max(la,lb); int f=0; for(int i=1;i<=lc;++i){ c.p[i]=a.p[i]+b.p[i]+f; f=c.p[i]/10; c.p[i]%=10; } if(f)c.p[++lc]=f; c.len=lc; return c; } int cmp(const HP &a,const HP &b){ //cout<<a.len<<\" \"<<b.len<<endl; if(a.len<b.len)return -1; if(a.len>b.len)return 1; for(int i=a.len;i>=1;--i){ if(a.p[i]<b.p[i])return -1; if(a.p[i]>b.p[i])return 1; } return 0; } HP max1(const HP &a,const HP &b){ int res=cmp(a,b); if(res>=0)return a; else return b; } HP operator -(const HP &x,const HP &y){ HP c,a,b; c.clear1(); if(cmp(x,y)==-1){ a=y,b=x; c.p[0]=-1; }else{ a=x,b=y; c.p[0]=1; } int la=a.len,lb=b.len,lc=max(la,lb); int f=0; for(int i=1;i<=lc;++i){ if(a.p[i]<b.p[i]){ a.p[i]+=10; a.p[i+1]--; } c.p[i]=a.p[i]-b.p[i]; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } HP operator *(const HP &a,const HP &b){ HP c; c.clear1(); int la=a.len,lb=b.len,lc=la+lb; for(int i=1;i<=la;++i){ int x=0; for(int j=1;j<=lb;++j){ c.p[i+j-1]+=a.p[i]*b.p[j]+x; x=c.p[i+j-1]/10; c.p[i+j-1]%=10; } c.p[i+lb]=x; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; int tmp; if(a.p[0]==-1 && b.p[0]==-1)tmp=1; else if(a.p[0]>=0 && b.p[0]>=0)tmp=1; else tmp=-1; c.p[0]=tmp; return c; } HP operator /=(const HP &a,int b){ HP c; c.clear1(); int la=a.len,f=0,lc=la; for(int i=la;i>=1;--i){ c.p[i]=(f*10+a.p[i])/b; f=(f*10+a.p[i])%b; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } HP operator /(const HP &x,const HP &y){ HP c,a=x,b=y; c.clear1(); int la=a.len,lb=b.len,lc=la-lb+1; for(int i=lc;i>=1;--i){ HP e; e.clear1(); for(int k=1;k<=lb;++k){ e.p[k+i-1]=b.p[k]; } e.len=i+lb-1; while(cmp(a,e)>=0)c.p[i]++,a=a-e; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } HP kp(HP x,int p){ if(p<=1)return x; if(p%2==0)return kp(x*x,p>>1); else return x*kp(x*x,p>>1); } HP dp(int x){ memset(f,0,sizeof f); for(int i=1;i<=m;++i)tmp[i]=a[x][i]; HP two; two.clear1(); two.len=1,two.p[1]=2; for(int i=1;i<=m;++i){ f[i][i]=tmp[i]*two; } for(int l=2;l<=m;++l){ for(int b=1;b+l-1<=m;++b){ int e=b+l-1; f[b][e]=max1(f[b][e],two*f[b][e-1]+two*tmp[e]); f[b][e]=max1(f[b][e],two*f[b+1][e]+two*tmp[b]); } } return f[1][m]; } signed main(){ scanf(\"%d%d\",&n,&m); for(int i=1;i<=n;++i){ for(int j=1;j<=m;++j){ a[i][j].read1(); } } ans.clear1(); for(int i=1;i<=n;++i){ tp=dp(i); //write1(tmp); //putchar('\\n'); ans=ans+tp; } ans.write1(); return 0; } /* 5 5 0 0 0 0 0 0 0 0 0 1 876 1 566 920 598 259 945 123 659 997 176 478 293 464 278 2 3 1 5 2 3 4 2 2 4 1 4 2 3 1 4 3 2 */","title":"__int128"},{"location":"my%20past/OI/%E9%AB%98%E7%B2%BE%E5%BA%A6/#_2","text":"struct HP{ int p[N],len; void clear1(){ memset(p,0,sizeof p); len=1; return; } void read1(){ memset(p,0,sizeof p); len=1; p[0]=1; char ch=getchar(); while(ch>'9' || ch<'0'){ if(ch=='-')p[0]=-1; ch=getchar(); } while(ch<='9' && ch>='0'){ p[++len]=ch-'0'; ch=getchar(); } for(int i=1;i<=len/2;++i){ swap(p[i],p[len-i+1]); } } void write1(){ if(p[0]==-1)putchar('-'); for(int i=len;i>=1;--i){ putchar(p[i]+'0'); } putchar('\\n'); } }; HP operator +(const HP &a,const HP &b){ //if(a.p[0]==-1 || b.p[0]==-1)return a-b; HP c; c.clear1(); int la=a.len,lb=b.len,lc=max(la,lb); int f=0; for(int i=1;i<=lc;++i){ c.p[i]=a.p[i]+b.p[i]+f; f=c.p[i]/10; c.p[i]%=10; } if(f)c.p[++lc]=f; c.len=lc; return c; } int cmp(const HP &a,const HP &b){ //cout<<a.len<<\" \"<<b.len<<endl; if(a.len<b.len)return -1; if(a.len>b.len)return 1; for(int i=a.len;i>=1;--i){ if(a.p[i]<b.p[i])return -1; if(a.p[i]>b.p[i])return 1; } return 0; } HP max1(const HP &a,const HP &b){ int res=cmp(a,b); if(res>=0)return a; else return b; } HP operator -(const HP &x,const HP &y){ HP c,a,b; c.clear1(); if(cmp(x,y)==-1){ a=y,b=x; c.p[0]=-1; }else{ a=x,b=y; c.p[0]=1; } int la=a.len,lb=b.len,lc=max(la,lb); int f=0; for(int i=1;i<=lc;++i){ if(a.p[i]<b.p[i]){ a.p[i]+=10; a.p[i+1]--; } c.p[i]=a.p[i]-b.p[i]; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } HP operator *(const HP &a,const HP &b){ HP c; c.clear1(); int la=a.len,lb=b.len,lc=la+lb; for(int i=1;i<=la;++i){ int x=0; for(int j=1;j<=lb;++j){ c.p[i+j-1]+=a.p[i]*b.p[j]+x; x=c.p[i+j-1]/10; c.p[i+j-1]%=10; } c.p[i+lb]=x; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; int tmp; if(a.p[0]==-1 && b.p[0]==-1)tmp=1; else if(a.p[0]>=0 && b.p[0]>=0)tmp=1; else tmp=-1; c.p[0]=tmp; return c; } HP operator /=(const HP &a,int b){ HP c; c.clear1(); int la=a.len,f=0,lc=la; for(int i=la;i>=1;--i){ c.p[i]=(f*10+a.p[i])/b; f=(f*10+a.p[i])%b; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } HP operator /(const HP &x,const HP &y){ HP c,a=x,b=y; c.clear1(); int la=a.len,lb=b.len,lc=la-lb+1; for(int i=lc;i>=1;--i){ HP e; e.clear1(); for(int k=1;k<=lb;++k){ e.p[k+i-1]=b.p[k]; } e.len=i+lb-1; while(cmp(a,e)>=0)c.p[i]++,a=a-e; } while(lc>1 && c.p[lc]==0)--lc; c.len=lc; return c; } \u8bb0\u5f97\u5e38\u6e05\u96f6\uff0c\u5c11\u7528\u5c40\u90e8\u53d8\u91cf\uff0c\u4e0d\u7136\u4f1a\u51fa\u73b0\u521d\u59cb\u503c\u4e0d\u4e3a\u96f6\u7684\u60c5\u51b5\u3002","title":"\u6734\u7d20\u9ad8\u7cbe\u5ea6"},{"location":"my%20past/OI/%E9%AB%98%E7%B2%BE%E5%BA%A6/#_3","text":"const int M=1000+5,base=1e8; int n; struct BigInt{ int sum[21]; void operator += (const BigInt &x){ sum[0]=max(sum[0],x.sum[0]); for(int i=1; i<=sum[0]; i++){ sum[i]+=x.sum[i]; if(sum[i]>=base) sum[i+1]++,sum[i]-=base; } if(sum[sum[0]+1]>0) sum[0]++; } void operator *= (const BigInt &x){ long long A[21]={}; for(int i=1; i<=sum[0]; i++){ for(int j=1; j<=x.sum[0]; j++){ A[i+j-1]+=1ll*sum[i]*x.sum[j]; } } for(int i=1; i<=sum[0]+x.sum[0]; i++){ A[i+1]+=A[i]/base; A[i]%=base; sum[i]=A[i]; } if(A[sum[0]+x.sum[0]]) sum[0]=sum[0]+x.sum[0]; else sum[0]=sum[0]+x.sum[0]-1; } void Print(){ printf(\"%d\",sum[sum[0]]); for(int i=sum[0]-1; i>0; i--){ printf(\"%08d\",sum[i]); } } }","title":"\u538b\u7f29\u9ad8\u7cbe\u5ea6"},{"location":"my%20past/bangumi/bangumi/","text":"\u65e5\u756a\u63a8\u8350\uff1a \u6211\u7684\u8111\u5185\u604b\u788d\u9009\u9879 \u4e2d\u4e8c\u75c5\u4e5f\u8981\u8c08\u604b\u7231 \u9b54\u6cd5\u7981\u4e66\u76ee\u5f55 \u67d0\u79d1\u5b66\u7684\u8d85\u7535\u78c1\u70ae re0:\u4ece\u96f6\u5f00\u59cb\u7684\u5f02\u4e16\u754c\u751f\u6d3b \u7f18\u4e4b\u7a7a \u65e5\u5728\u6821\u56ed \u8fdb\u51fb\u7684\u5de8\u4eba clannad \u5c0f\u6797\u5bb6\u7684\u9f99\u5973\u4ec6 \u4e3a\u7f8e\u597d\u4e16\u754c\u732e\u4e0a\u795d\u798f \u9f99\u4e0e\u864e \u9b3c\u706d\u4e4b\u5203 \u5492\u672f\u56de\u6218 \u767d\u8272\u76f8\u7c3f2 \u7518\u6210\u5149\u8f89\u6e38\u4e50\u56ed \u6b22\u8fce\u6765\u5230\u5b9e\u529b\u4e3b\u4e49\u81f3\u4e0a\u6559\u5ba4 \u672a\u6765\u65e5\u8bb0 \u6b7b\u4ea1\u7b14\u8bb0 \u51b0\u83d3 \u8fd9\u4e2a\u7f8e\u672f\u793e\u5927\u6709\u95ee\u9898 \u5de5\u4f5c\u7ec6\u80de \u6708\u520a\u5c11\u5973\u91ce\u5d0e\u541b \u56fd\u738b\u6392\u540d \u7535\u952f\u4eba \u65e0\u804c\u8f6c\u751f \u52c7\u8005\u6b7b\u4e86 \u56de\u590d\u672f\u58eb\u7684\u91cd\u542f\u4eba\u751f \u4e3a\u7f8e\u597d\u4e16\u754c\u732e\u4e0a\u7206\u708e \u5173\u4e8e\u6211\u8f6c\u751f\u6210\u53f2\u83b1\u59c6\u8fd9\u6863\u4e8b \u7d2b\u7f57\u5170\u6c38\u6052\u82b1\u56ed \u603b\u4e4b\u5c31\u662f\u975e\u5e38\u53ef\u7231 \u5200\u5251\u795e\u57df \u6211\u7684\u9752\u6625\u604b\u7231\u7269\u8bed\u679c\u7136\u6709\u95ee\u9898 \u9752\u6625\u732a\u5934\u5c11\u5e74\u4e0d\u4f1a\u68a6\u5230\u5154\u5973\u90ce\u5b66\u59d0 EVA \u7ea6\u4f1a\u5927\u4f5c\u6218 \u53ef\u5851\u6027\u8bb0\u5fc6 \u5f3a\u98ce\u5439\u62c2 \u5e72\u7269\u59b9\u5c0f\u57cb \u590f\u65e5\u91cd\u73b0 \u7ea6\u5b9a\u7684\u68a6\u5e7b\u5c9b \u547d\u8fd0\u77f3\u4e4b\u95e8 \u94a2\u4e4b\u70bc\u91d1\u672f\u5e08 \u65e0\u5934\u9a91\u58eb\u5f02\u95fb\u5f55 \u7537\u5b50\u9ad8\u4e2d\u751f\u65e5\u5e38 \u64c5\u957f\u6349\u5f04\u7684\u9ad8\u6728\u540c\u5b66 \u5929\u4f7f\u964d\u4e34\u5230\u6211\u8eab\u8fb9 \u7cbe\u7075\u5b9d\u53ef\u68a6(?) \u6211\u7684\u59b9\u59b9\u4e0d\u53ef\u80fd\u8fd9\u4e48\u53ef\u7231 \u4f1a\u957f\u662f\u5973\u4ec6\u5927\u4eba \u8f89\u591c\u5927\u5c0f\u59d0 \u4f60\u7684\u540d\u5b57 \u8a00\u53f6\u4e4b\u5ead \u79d2\u901f\u4e94\u5398\u7c73 \u5929\u6c14\u4e4b\u5b50 \u8424\u706b\u4e4b\u68ee \u672a\u95fb\u82b1\u540d \u6708\u8272\u771f\u7f8e \u6a31\u82b1\u5e84\u7684\u5ba0\u7269\u5973\u5b69 \u5800\u4e0e\u5bab\u6751 \u56db\u6708\u662f\u4f60\u7684\u8c0e\u8a00 \u5883\u754c\u7684\u5f7c\u65b9 \u7f6a\u6076\u738b\u51a0 \u590f\u76ee\u53cb\u4eba\u5e10 \u865a\u6784\u63a8\u7406 \u7406\u79d1\u751f\u5760\u5165\u60c5\u7f51 \u4e94\u7b49\u4efd\u65b0\u5a18 \u78a7\u84dd\u4e4b\u6d77 \u5c5e\u6027\u5496\u5561\u5385 \u5947\u5e7b\u4e16\u754c\u8205\u8205 \u8def\u4eba\u5973\u4e3b\u7684\u517b\u6210\u65b9\u6cd5 Darling in the Franxx Charlotte \u5b64\u72ec\u6447\u6eda \u707c\u773c\u7684\u590f\u5a1c \u5f92\u7136\u559c\u6b22\u4f60 angel beats \u6e38\u620f\u4eba\u751f \u9f99\u738b\u7684\u5de5\u4f5c \u73c8\u767e\u7483\u7684\u5815\u843d \u9b54\u7b1bMAGI \u604b\u7231\u968f\u610f\u94fe\u63a5 b\u578bh\u7cfb citrus \u76fe\u4e4b\u52c7\u8005 \u6765\u81ea\u6df1\u6e0a \u65e5\u5e38 \u8857\u89d2\u9b54\u65cf \u5f02\u79cd\u65cf\u98ce\u4fd7\u5a18\u8bc4\u9274\u6307\u5357 \u604b\u7231\u7981\u6b62\u7684\u4e16\u754c \u5c71\u7530\u8fdb\u884clv999 \u7ecf\u9a8c\u4e3a\u96f6\u7684\u6211 \u5f7b\u591c\u4e4b\u6b4c \u9b54\u5973\u4e4b\u65c5 \u6253\u5de5\u5427\u9b54\u738b\u5927\u4eba \u82b1\u5f00\u4f0a\u5415\u6ce2 \u6563\u534e\u793c\u5f25 \u4e0a\u4f4e\u97f3\u53f7 \u4eba\u6e23\u7684\u672c\u613f \u5728\u5730\u4e0b\u57ce\u5bfb\u6c42\u9082\u9005\u662f\u5426\u641e\u9519\u4e86\u4ec0\u4e48 \u4f2a\u604b \u987a\u5176\u81ea\u7136\u7684\u65e5\u5b50 \u522b\u5f53\u6b27\u5c3c\u9171\u4e86 \u5982\u679c\u6709\u59b9\u59b9\u5c31\u597d\u4e86 \u8d5b\u535a\u670b\u514b \u6076\u9b54\u9ad8\u6821 \u5bb6\u6709\u5973\u53cb \u79df\u754c\u5973\u53cb \u51fa\u5305\u738b\u5973 \u7389\u5b50\u5e02\u573a \u8f7b\u97f3\u5c11\u5973 \u767e\u5723\u5973\u4e0e\u9ed1\u7267\u5e08 \u7075\u80fd\u767e\u5206\u767e 86\u4e0d\u5b58\u5728\u7684\u6218\u533a \u672b\u65e5\u65f6\u5728\u505a\u4ec0\u4e48\uff1f\u6709\u6ca1\u6709\u7a7a\uff1f\u53ef\u4ee5\u6765\u62ef\u6551\u5417\uff1f \u5bd2\u8749\u9e23\u6ce3\u4e4b\u65f6 \u4e00\u5468\u7684\u670b\u53cb overlord lycoris recoil engage kiss \u8d5b\u9a6c\u5a18 fate \u516c\u53f8\u7684\u5c0f\u5c0f\u524d\u8f88 \u77f3\u7eaa\u5143 \u6697\u6740\u6559\u5ba4 \u9b54\u6cd5\u5c11\u5973\u5c0f\u5706 \u51c9\u5bab\u6625\u65e5\u7684\u5fe7\u90c1 jojo \u5173\u4e8e\u524d\u8f88\u5f88\u70e6\u4eba\u7684\u4e8b \u95f4\u8c0d\u8fc7\u5bb6\u5bb6 \u51b0\u6d77\u6218\u8bb0 \u9ec4\u91d1\u795e\u5a01 \u9f50\u6728\u6960\u96c4\u7684\u707e\u96be \u5996\u7cbe\u7684\u5c3e\u5df4 \u5bb6\u5ead\u6559\u5e08 \u5f02\u4e16\u754c\u8ff7\u5bab\u5f00\u540e\u5bab \u76f8\u548c\u4e4b\u7269 \u544a\u767d\u5b9e\u884c\u59d4\u5458\u4f1a \u6211\u88ab\u9010\u51fa\u961f\u4f0d\u540e\u8fc7\u4e0a\u6162\u751f\u6d3b BEASTARS \u6211\u63a8\u7684\u5b69\u5b50 \u673a\u52a8\u6218\u58eb\u9ad8\u8fbe\uff1a\u6c34\u661f\u7684\u9b54\u5973 SSSS\u7535\u673a\u738b \u72fc\u4e0e\u9999\u8f9b\u6599 \u5b87\u5d0e\u5b66\u59b9\u60f3\u8981\u73a9 odd taxis \u5947\u86cb\u7269\u8bed \u4e45\u4fdd\u540c\u5b66 \u963f\u6ce2\u8fde \u53e4\u89c1\u540c\u5b66\u6709\u4ea4\u6d41\u969c\u788d\u75c7 \u5f0f\u5b88\u540c\u5b66\u4e0d\u6b62\u53ef\u7231 \u821e\u52a8\u9752\u6625 \u660e\u65e5\u9171\u7684\u6c34\u624b\u670d lovelive banG dream \u673a\u52a8\u6218\u58eb\u9ad8\u8fbe \u94c1\u8840\u7684\u5965\u5c14\u82ac\u65af megalobox vivi\u8424\u77f3\u773c\u4e4b\u6b4c \u5168\u5458\u6076\u7389 \u6211\u7acb\u4e8e\u767e\u4e07\u751f\u547d\u4e4b\u4e0a \u4e1c\u4eac\u5c0f\u5403\u8d27 \u604b\u7231\u5c0f\u884c\u661f \u5076\u50cf\u5927\u5e08 \u5728\u4e0b\u5742\u672c\u6709\u4f55\u8d35\u5e72 \u5243\u987b \u66f4\u8863\u4eba\u5076\u5760\u5165\u7231\u6cb3 \u58f0\u4e4b\u5f62 \u57c3\u7f57\u8292\u963f\u8001\u5e08 \u5723\u8bde\u4e4b\u543b www\u8ff7\u7cca\u9910\u5385 3\u6708\u7684\u72ee\u5b50 \u6211\u7684\u524d\u5973\u53cb\u662f\u7ee7\u6bcd\u7684\u62d6\u6cb9\u74f6 16bit\u7684\u611f\u52a8 \u6e38\u620f\u4e09\u4eba\u5a18 \u4ffa\u7269\u8bed \u5973\u53cb\u6210\u53cc \u6211\u4eec\u7684\u91cd\u7f6e\u4eba\u751f \u52c7\u8005\u8fc7\u5206\u614e\u91cd \u76fe\u4e4b\u52c7\u8005\u6210\u540d\u5f55 \u4f60\u597d\u4e16\u754c \u5973\u795e\u5bbf\u820d\u7684\u7ba1\u7406\u5458 \u5065\u8eab\u5c11\u5973 \u6211\u4eec\u65e0\u6cd5\u4e00\u8d77\u5b66\u4e60 \u5e78\u8fd0\u661f \u8299\u8389\u83b2 \u5438\u8840\u59ec \u7ec8\u7ed3\u7684\u70bd\u5929\u4f7f \u8bf7\u95ee\u4f60\u4eca\u5929\u8981\u6765\u70b9\u5154\u5b50\u5417 \u901a\u5f80\u590f\u5929\u7684\u96a7\u9053\uff0c\u662f\u518d\u89c1\u7684\u51fa\u53e3 \u5347\u8d77\u7684\u70df\u82b1\u4ece\u4e0b\u9762\u770b\u8fd8\u662f\u4ece\u4fa7\u9762\u770b \u9752\u9171\u4e0d\u80fd\u5b66\u4e60 \u5c11\u5973\u6b4c\u5267 \u597d\u60f3\u544a\u8bc9\u4f60 \u5973\u795e\u9732\u5929\u5496\u5561\u5385 \u53cd\u53db\u7684\u9c81\u8def\u4fee \u4e09\u4eba\u884c\u5fc5\u6709\u6211\u59b9 \u5723\u5251\u5b66\u9662\u7684\u9b54\u6cd5\u4f7f","title":"Bangumi"},{"location":"my%20past/python/Bongo%20Cat/","text":"Python Bongo Cat 1.\u952e\u76d8\u76d1\u542c \u5982\u679c\u4f7f\u7528$Pygame$\u7684\u952e\u76d8\u4e8b\u4ef6\uff0c\u5c31\u53ea\u6709\u5728\u9f20\u6807\u70b9\u8fdb\u7a97\u53e3\u65f6\uff0c\u7a0b\u5e8f\u624d\u80fd\u63a5\u6536\u5230\u952e\u76d8\u8f93\u5165\uff0c\u5982\u679c\u6b64\u65f6\u4f60\u6b63\u5728\u7528\u5176\u4ed6\u8f6f\u4ef6\uff0c\u90a3\u4e48\u7a0b\u5e8f\u65e0\u6cd5\u63a5\u6536\u5230\u952e\u76d8\u4fe1\u53f7\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u8981\u6539\u7528\u540e\u53f0\u76d1\u542c\uff0c\u76d1\u542c\u952e\u76d8\u7684\u4e00\u4e3e\u4e00\u52a8\u3002~~(\u8fd9tm\u4e0d\u662f\u75c5\u6bd2\u5417)~~ \u56e0\u6b64\u6211\u4eec\u4f7f\u7528$pynput$\u5e93\u3002 from pynput import keyboard from pynput import mouse def listen_key_block(): with keyboard.Listener( on_press=on_press, on_release=on_release) as listener: listener.join() # \u52a0\u5165\u7ebf\u7a0b\u6c60\uff0c\u963b\u585e\u5199\u6cd5 def listen_key_nblock(): # \u53ef\u4ee5\u548c\u5176\u4ed6\u51fd\u6570\u5e76\u884c\u8fd0\u884c listener = keyboard.Listener( on_press=on_press, on_release=on_release ) listener.start() # \u542f\u52a8\u7ebf\u7a0b listen_key_nblock() while True: pass \u6ce8\u610f\u7b2c\u4e00\u79cd\u963b\u585e\u5199\u6cd5\u7684\u610f\u601d\u662f\u963b\u585e\u4e3b\u7ebf\u7a0b\uff0c\u76f4\u5230\u5f53\u524d\u5b50\u7ebf\u7a0b\u8fd0\u884c\u5b8c\u6bd5\u3002\u6240\u4ee5\u5b83\u4e0d\u80fd\u4e0e\u5176\u4ed6\u7a0b\u5e8f\u5e76\u884c\u3002 \u800c\u7b2c\u4e8c\u79cd\u5199\u6cd5\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898,\u5c31\u662f\u8981\u52a0\u4e00\u4e2a\u65e0\u9650\u5faa\u73af\u7ef4\u6301\u7a0b\u5e8f\u7684\u6267\u884c\u3002 \u6240\u4ee5\uff0c\u67d0\u79cd\u7a0b\u5ea6\u4e0a\u6765\u8bf4\uff0c\u963b\u585e\u5199\u6cd5\u4e5f\u7b97\u4e00\u4e2a\u65e0\u9650\u5faa\u73af\u3002 2.\u7a97\u53e3\u521b\u5efa & \u7ed8\u56fe \u4f7f\u7528$Pygame$\u5373\u53ef\u521b\u5efa\u4efb\u610f\u5927\u5c0f\u7684\u7a97\u53e3\uff0c\u5e76\u5728\u5de6\u4e0a\u89d2\u7ed8\u5236\u56fe\u7247\u3002 # canvas.py import pygame as pg class Background(): def __init__(self, screen): self.screen = screen self.image = pg.image.load('images/bongo_cat.png')# \u521d\u59cb\u5316\u5b9a\u4e49\u4e3a\u62ac\u8d77\u624b\u7684\u56fe\u7247 self.rect = self.image.get_rect() # \u83b7\u53d6\u77e9\u5f62 self.rect.x = 0 # \u56fa\u5b9a\u5750\u6807\u4e3a\u5de6\u4e0a\u89d2 self.rect.y = 0 def draw(self, image): self.image = pg.image.load(image) # \u52a0\u8f7d\u56fe\u7247 self.screen.blit(self.image, self.rect) # \u7ed8\u56fe # bongo_cat.py import pygame as pg import sys from canvas import Background def run_game(): interval = 0.03 pg.init() screen = pg.display.set_mode((300, 177)) pg.display.set_caption('bongo_cat') bgc = (230, 230, 230) bg = Background(screen) while True: for event in pg.event.get(): if event.type == pg.QUIT: # \u68c0\u6d4b\u53f3\u4e0a\u89d2\u9f20\u6807\u70b9\u51fb\u9000\u51fa\u4e8b\u4ef6 sys.exit() screen.fill(bgc) # \u80cc\u666f\u8272 bg.draw('images/bongo_cat.png') pg.display.flip() # \u66f4\u65b0\u5f53\u524d\u56fe\u5c42 time.sleep(interval) # \u65f6\u95f4\u95f4\u9694\uff0c\u5373\u5e27\u7387 run_game() 3.\u72b6\u6001\u5207\u6362 \u5f53\u70b9\u51fb\u952e\u76d8\u65f6\uff0c$pynput$\u7684$listener$\u4f1a\u68c0\u6d4b\u5230\u53c2\u6570$key$\uff0c\u91cc\u9762\u5305\u542b\u4e86\u4f60\u6309\u4e86\u54ea\u4e2a\u952e\u3002\u6240\u4ee5\u53ef\u4ee5\u7528\u4e00\u4e2a\u5217\u8868\u5b58\u50a8\u4e0b\u5b57\u7b26\u4e32$keys$,\u5176\u4e2d$keys = str(key)$\u3002 \u8fdb\u4e00\u6b65\u5730\uff0c\u6211\u4eec\u7528\u4e00\u4e2a\u5b57\u5178\u5b58\u50a8\u4e03\u4e2a\u6309\u952e\u5728\u4e00\u4e2a\u65f6\u95f4\u95f4\u9694\u5185\u5bf9\u5e94\u7684\u70b9\u51fb\u6b21\u6570\uff0c\u6bcf\u4e2a\u95f4\u9694\u7ed3\u675f\u540e\u6e05\u96f6\u3002 \u4f46\u662f\u6709\u4e2a\u95ee\u9898\uff0c\u952e\u76d8\u7684\u8f93\u5165\u662f\uff0c\u5148\u63a5\u53d7\u4e00\u6b21$on_press$\u4e8b\u4ef6\uff0c\u5982\u679c\u4e00\u6bb5\u65f6\u95f4\u4e0d\u677e\u624b\uff0c\u624d\u4f1a\u8fde\u7eed\u63a5\u53d7$on_press$\u3002\u8fd9\u5c31\u5bfc\u81f4\u6bcf\u6b21\u6309\u4e0b\u952e\u76d8\uff0c\u5c0f\u732b\u7684\u624b\u90fd\u4f1a\u5148\u95ea\u4e00\u4e0b\uff0c\u624d\u4f1a\u6301\u7eed\u6309\u4e0b\uff0c\u5f88\u4e0d\u6d41\u7545\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u6539\u6210$on_release$\u51fa\u53d1\u540e\u518d\u5c06\u5b57\u5178\u4e2d\u5bf9\u5e94\u7684\u6309\u952e\u7684\u503c\u6e05\u96f6\u3002\u8fd9\u6837\u753b\u9762\u4f1a\u6bd4\u8f83\u6d41\u7545\u3002 \u800c\u6240\u6709\u56fe\u7247\u548c\u8fd9\u4e2a\u5b57\u5178\u90fd\u5b58\u50a8\u5728\u4e00\u4e2a$tmp$\u6587\u4ef6\u4e2d\uff0c\u65b9\u4fbf\u67e5\u8868\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u7684\u7a0b\u5e8f\u5c31\u5b8c\u6210\u4e86\u3002 #image_tmp.py image = 'images/bongo_cat.png' bc = 'images/bongo_cat.png' bc_0 = 'images/bongo_cat_0.png' bc_1 = 'images/bongo_cat_1.png' bc_2 = 'images/bongo_cat_2.png' bc_d = 'images/bongo_cat_down.png' bc_u = 'images/bongo_cat_up.png' bc_r = 'images/bongo_cat_right.png' bc_l = 'images/bongo_cat_left.png' bc_R = 'images/bongo_cat_r.png' bc_s = 'images/bongo_cat_shift.png' bc_z = 'images/bongo_cat_z.png' bc_ds = 'images/bongo_cat_down_shift.png' bc_us = 'images/bongo_cat_up_shift.png' bc_ls = 'images/bongo_cat_left_shift.png' bc_rs = 'images/bongo_cat_right_shift.png' bc_dz = 'images/bongo_cat_down_z.png' bc_uz = 'images/bongo_cat_up_z.png' bc_lz = 'images/bongo_cat_left_z.png' bc_rz = 'images/bongo_cat_right_z.png' bc_dR = 'images/bongo_cat_down_r.png' bc_uR = 'images/bongo_cat_up_r.png' bc_lR = 'images/bongo_cat_left_r.png' bc_rR = 'images/bongo_cat_right_r.png' BC = [[bc,bc_l,bc_r,bc_u,bc_d], [bc_R,bc_lR,bc_rR,bc_uR,bc_dR], [bc_z,bc_lz,bc_rz,bc_uz,bc_dz], [bc_s,bc_ls,bc_rs,bc_us,bc_ds]] tmp_0 = {'z': 0, 'R': 0, 's': 0, 'l': 0, 'r': 0, 'd': 0, 'u': 0} tmp = {'z': 0, 'R': 0, 's': 0, 'l': 0, 'r': 0, 'd': 0, 'u': 0} typen = 0 typem = 0 #canvas.py import pygame as pg class Background(): def __init__(self, screen): self.screen = screen self.image = pg.image.load('images_0/bongo_cat.png') self.rect = self.image.get_rect() #print(self.rect) #self.screen_rect = screen.get_rect() self.rect.x = 0 self.rect.y = 0 def draw(self, image): self.image = pg.image.load(image) self.screen.blit(self.image, self.rect) #listener.py from pynput import keyboard from pynput import mouse import image_tmp as imt import time def on_press(key): keys = str(key) if keys == 'Key.left': imt.tmp['l'] += 1 elif keys == 'Key.right': imt.tmp['r'] += 1 elif keys == 'Key.down': imt.tmp['d'] += 1 elif keys == 'Key.up': imt.tmp['u'] += 1 elif keys == 'Key.shift': imt.tmp['s'] += 1 elif keys == \"'z'\": imt.tmp['z'] += 1 elif keys == \"'r'\": imt.tmp['R'] += 1 def on_release(key): keys = str(key) if keys == 'Key.left': imt.tmp['l'] = 0 elif keys == 'Key.right': imt.tmp['r'] = 0 elif keys == 'Key.down': imt.tmp['d'] = 0 elif keys == 'Key.up': imt.tmp['u'] = 0 elif keys == 'Key.shift': imt.tmp['s'] = 0 elif keys == \"'z'\": imt.tmp['z'] = 0 elif keys == \"'r'\": imt.tmp['R'] = 0 def run_lsn(): maxn = 0 maxm = 0 imt.typen = 0 imt.typem = 0 for key, value in imt.tmp.items(): if key == 'r' or key == 'l' or key == 'u' or key == 'd': maxn = max(maxn, value) else: maxm = max(maxm, value) for key, value in imt.tmp.items(): if key == 'l' and value >= maxn: if maxn > 0: imt.typen = 1 elif key == 'r' and value >= maxn: if maxn > 0: imt.typen = 2 elif key == 'u' and value >= maxn: if maxn > 0: imt.typen = 3 elif key == 'd' and value >= maxn: if maxn > 0: imt.typen = 4 if key == 'R' and value >= maxm: if maxm > 0: imt.typem = 1 elif key == 'z' and value >= maxm: if maxm > 0: imt.typem = 2 elif key == 's' and value >= maxm: if maxm > 0: imt.typem = 3 #print(imt.typen, imt.typem) #imt.tmp = imt.tmp_0.copy() def on_move(x, y): print('move to', x, y) def on_click(x, y, button, pressed): print('click at', x, y, button, pressed) def on_scroll(x, y, dx, dy): print('scroll at', x, y, 'by', dx, dy) # \u76d1\u542c\u5199\u6cd51 def listen_key_block(): # \u76f8\u5f53\u4e8e\u4e00\u4e2a\u65e0\u7a77\u5faa\u73af\uff0c\u6240\u4ee5\u4e0d\u80fd\u5957\u5728while\u5faa\u73af\u91cc with keyboard.Listener( on_press=on_press, on_release=on_release) as listener: listener.join() # \u52a0\u5165\u7ebf\u7a0b\u6c60\uff0c\u963b\u585e\u5199\u6cd5 def listen_mouse_block(): with mouse.Listener( on_move=None, on_click=on_click, on_scroll=on_scroll) as listener: listener.join() # \u76d1\u542c\u5199\u6cd52 def listen_key_nblock(): # \u53ef\u4ee5\u548c\u5176\u4ed6\u51fd\u6570\u5e76\u884c\u8fd0\u884c listener = keyboard.Listener( on_press=on_press, on_release=on_release ) listener.start() # \u542f\u52a8\u7ebf\u7a0b def listen_mouse_nblock(): listener = mouse.Listener( on_move=None, # \u56e0\u4e3aon_move\u592a\u591a\u8f93\u51fa\u4e86\uff0c\u5c31\u4e0d\u653e\u8fdb\u6765\u4e86\uff0c\u6709\u5174\u8da3\u53ef\u4ee5\u52a0\u5165 on_click=on_click, on_scroll=on_scroll ) listener.start() \"\"\" imt.tmp = imt.tmp_0.copy() listen_key_nblock() while True: run_lsn() time.sleep(1) \"\"\" \"\"\" Key.right Key.left Key.up Key.down 'z' Key.shift 'r' \"\"\" #bongo_cat.py import pygame as pg import sys from canvas import Background import listener as lsn import image_tmp as imt import time def init(): imt.tmp = imt.tmp_0.copy() def run_game(): interval = 0.03 pg.init() screen = pg.display.set_mode((300, 177)) pg.display.set_caption('bongo_cat') bgc = (230, 230, 230) bg = Background(screen) init() lsn.listen_key_nblock() while True: for event in pg.event.get(): if event.type == pg.QUIT: sys.exit() lsn.run_lsn() screen.fill(bgc) bg.draw(imt.BC[imt.typem][imt.typen]) pg.display.flip() time.sleep(interval) run_game() 4.\u603b\u7ed3 & \u4e00\u4e9b\u5751\u70b9 \u4e00\u5f00\u59cb\u4e3b\u5faa\u73af\u6ca1\u6709$time.sleep()$,\u5bfc\u81f4$cpu$\u5360\u7528$20\\%$ \u5199$listener.py$\u65f6\u88abwindows\u5b89\u5168\u4e2d\u5fc3\u5f53\u6210\u75c5\u6bd2\u9694\u79bb\u4e86\u5c31nm\u79bb\u8c31 \u6700\u540e\u7528$Pyinstaller$\u5c01\u88c5\u6210\u4e86$.exe$,\u4e0d\u8fc7\u56fe\u7247\u6587\u4ef6\u8981\u548c$.exe$\u653e\u5728\u540c\u4e00\u6587\u4ef6\u76ee\u5f55\u4e0b\u3002 Pyinstaller -F -w -i bongo_cat.ico bongo_cat.py \u540e\u671f\u6253\u7b97\u628a\u8fd9\u4e2a\u653e\u5230$Github$\u4e0a\u9493\u9c7c\uff0c~~\u770b\u6709\u6ca1\u6709\u4eba\u7ed9stars~~","title":"Python Bongo Cat"},{"location":"my%20past/python/Bongo%20Cat/#python-bongo-cat","text":"","title":"Python Bongo Cat"},{"location":"my%20past/python/Bongo%20Cat/#1","text":"\u5982\u679c\u4f7f\u7528$Pygame$\u7684\u952e\u76d8\u4e8b\u4ef6\uff0c\u5c31\u53ea\u6709\u5728\u9f20\u6807\u70b9\u8fdb\u7a97\u53e3\u65f6\uff0c\u7a0b\u5e8f\u624d\u80fd\u63a5\u6536\u5230\u952e\u76d8\u8f93\u5165\uff0c\u5982\u679c\u6b64\u65f6\u4f60\u6b63\u5728\u7528\u5176\u4ed6\u8f6f\u4ef6\uff0c\u90a3\u4e48\u7a0b\u5e8f\u65e0\u6cd5\u63a5\u6536\u5230\u952e\u76d8\u4fe1\u53f7\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u8981\u6539\u7528\u540e\u53f0\u76d1\u542c\uff0c\u76d1\u542c\u952e\u76d8\u7684\u4e00\u4e3e\u4e00\u52a8\u3002~~(\u8fd9tm\u4e0d\u662f\u75c5\u6bd2\u5417)~~ \u56e0\u6b64\u6211\u4eec\u4f7f\u7528$pynput$\u5e93\u3002 from pynput import keyboard from pynput import mouse def listen_key_block(): with keyboard.Listener( on_press=on_press, on_release=on_release) as listener: listener.join() # \u52a0\u5165\u7ebf\u7a0b\u6c60\uff0c\u963b\u585e\u5199\u6cd5 def listen_key_nblock(): # \u53ef\u4ee5\u548c\u5176\u4ed6\u51fd\u6570\u5e76\u884c\u8fd0\u884c listener = keyboard.Listener( on_press=on_press, on_release=on_release ) listener.start() # \u542f\u52a8\u7ebf\u7a0b listen_key_nblock() while True: pass \u6ce8\u610f\u7b2c\u4e00\u79cd\u963b\u585e\u5199\u6cd5\u7684\u610f\u601d\u662f\u963b\u585e\u4e3b\u7ebf\u7a0b\uff0c\u76f4\u5230\u5f53\u524d\u5b50\u7ebf\u7a0b\u8fd0\u884c\u5b8c\u6bd5\u3002\u6240\u4ee5\u5b83\u4e0d\u80fd\u4e0e\u5176\u4ed6\u7a0b\u5e8f\u5e76\u884c\u3002 \u800c\u7b2c\u4e8c\u79cd\u5199\u6cd5\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898,\u5c31\u662f\u8981\u52a0\u4e00\u4e2a\u65e0\u9650\u5faa\u73af\u7ef4\u6301\u7a0b\u5e8f\u7684\u6267\u884c\u3002 \u6240\u4ee5\uff0c\u67d0\u79cd\u7a0b\u5ea6\u4e0a\u6765\u8bf4\uff0c\u963b\u585e\u5199\u6cd5\u4e5f\u7b97\u4e00\u4e2a\u65e0\u9650\u5faa\u73af\u3002","title":"1.\u952e\u76d8\u76d1\u542c"},{"location":"my%20past/python/Bongo%20Cat/#2","text":"\u4f7f\u7528$Pygame$\u5373\u53ef\u521b\u5efa\u4efb\u610f\u5927\u5c0f\u7684\u7a97\u53e3\uff0c\u5e76\u5728\u5de6\u4e0a\u89d2\u7ed8\u5236\u56fe\u7247\u3002 # canvas.py import pygame as pg class Background(): def __init__(self, screen): self.screen = screen self.image = pg.image.load('images/bongo_cat.png')# \u521d\u59cb\u5316\u5b9a\u4e49\u4e3a\u62ac\u8d77\u624b\u7684\u56fe\u7247 self.rect = self.image.get_rect() # \u83b7\u53d6\u77e9\u5f62 self.rect.x = 0 # \u56fa\u5b9a\u5750\u6807\u4e3a\u5de6\u4e0a\u89d2 self.rect.y = 0 def draw(self, image): self.image = pg.image.load(image) # \u52a0\u8f7d\u56fe\u7247 self.screen.blit(self.image, self.rect) # \u7ed8\u56fe # bongo_cat.py import pygame as pg import sys from canvas import Background def run_game(): interval = 0.03 pg.init() screen = pg.display.set_mode((300, 177)) pg.display.set_caption('bongo_cat') bgc = (230, 230, 230) bg = Background(screen) while True: for event in pg.event.get(): if event.type == pg.QUIT: # \u68c0\u6d4b\u53f3\u4e0a\u89d2\u9f20\u6807\u70b9\u51fb\u9000\u51fa\u4e8b\u4ef6 sys.exit() screen.fill(bgc) # \u80cc\u666f\u8272 bg.draw('images/bongo_cat.png') pg.display.flip() # \u66f4\u65b0\u5f53\u524d\u56fe\u5c42 time.sleep(interval) # \u65f6\u95f4\u95f4\u9694\uff0c\u5373\u5e27\u7387 run_game()","title":"2.\u7a97\u53e3\u521b\u5efa &amp; \u7ed8\u56fe"},{"location":"my%20past/python/Bongo%20Cat/#3","text":"\u5f53\u70b9\u51fb\u952e\u76d8\u65f6\uff0c$pynput$\u7684$listener$\u4f1a\u68c0\u6d4b\u5230\u53c2\u6570$key$\uff0c\u91cc\u9762\u5305\u542b\u4e86\u4f60\u6309\u4e86\u54ea\u4e2a\u952e\u3002\u6240\u4ee5\u53ef\u4ee5\u7528\u4e00\u4e2a\u5217\u8868\u5b58\u50a8\u4e0b\u5b57\u7b26\u4e32$keys$,\u5176\u4e2d$keys = str(key)$\u3002 \u8fdb\u4e00\u6b65\u5730\uff0c\u6211\u4eec\u7528\u4e00\u4e2a\u5b57\u5178\u5b58\u50a8\u4e03\u4e2a\u6309\u952e\u5728\u4e00\u4e2a\u65f6\u95f4\u95f4\u9694\u5185\u5bf9\u5e94\u7684\u70b9\u51fb\u6b21\u6570\uff0c\u6bcf\u4e2a\u95f4\u9694\u7ed3\u675f\u540e\u6e05\u96f6\u3002 \u4f46\u662f\u6709\u4e2a\u95ee\u9898\uff0c\u952e\u76d8\u7684\u8f93\u5165\u662f\uff0c\u5148\u63a5\u53d7\u4e00\u6b21$on_press$\u4e8b\u4ef6\uff0c\u5982\u679c\u4e00\u6bb5\u65f6\u95f4\u4e0d\u677e\u624b\uff0c\u624d\u4f1a\u8fde\u7eed\u63a5\u53d7$on_press$\u3002\u8fd9\u5c31\u5bfc\u81f4\u6bcf\u6b21\u6309\u4e0b\u952e\u76d8\uff0c\u5c0f\u732b\u7684\u624b\u90fd\u4f1a\u5148\u95ea\u4e00\u4e0b\uff0c\u624d\u4f1a\u6301\u7eed\u6309\u4e0b\uff0c\u5f88\u4e0d\u6d41\u7545\u3002 \u6240\u4ee5\uff0c\u6211\u4eec\u6539\u6210$on_release$\u51fa\u53d1\u540e\u518d\u5c06\u5b57\u5178\u4e2d\u5bf9\u5e94\u7684\u6309\u952e\u7684\u503c\u6e05\u96f6\u3002\u8fd9\u6837\u753b\u9762\u4f1a\u6bd4\u8f83\u6d41\u7545\u3002 \u800c\u6240\u6709\u56fe\u7247\u548c\u8fd9\u4e2a\u5b57\u5178\u90fd\u5b58\u50a8\u5728\u4e00\u4e2a$tmp$\u6587\u4ef6\u4e2d\uff0c\u65b9\u4fbf\u67e5\u8868\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u7684\u7a0b\u5e8f\u5c31\u5b8c\u6210\u4e86\u3002 #image_tmp.py image = 'images/bongo_cat.png' bc = 'images/bongo_cat.png' bc_0 = 'images/bongo_cat_0.png' bc_1 = 'images/bongo_cat_1.png' bc_2 = 'images/bongo_cat_2.png' bc_d = 'images/bongo_cat_down.png' bc_u = 'images/bongo_cat_up.png' bc_r = 'images/bongo_cat_right.png' bc_l = 'images/bongo_cat_left.png' bc_R = 'images/bongo_cat_r.png' bc_s = 'images/bongo_cat_shift.png' bc_z = 'images/bongo_cat_z.png' bc_ds = 'images/bongo_cat_down_shift.png' bc_us = 'images/bongo_cat_up_shift.png' bc_ls = 'images/bongo_cat_left_shift.png' bc_rs = 'images/bongo_cat_right_shift.png' bc_dz = 'images/bongo_cat_down_z.png' bc_uz = 'images/bongo_cat_up_z.png' bc_lz = 'images/bongo_cat_left_z.png' bc_rz = 'images/bongo_cat_right_z.png' bc_dR = 'images/bongo_cat_down_r.png' bc_uR = 'images/bongo_cat_up_r.png' bc_lR = 'images/bongo_cat_left_r.png' bc_rR = 'images/bongo_cat_right_r.png' BC = [[bc,bc_l,bc_r,bc_u,bc_d], [bc_R,bc_lR,bc_rR,bc_uR,bc_dR], [bc_z,bc_lz,bc_rz,bc_uz,bc_dz], [bc_s,bc_ls,bc_rs,bc_us,bc_ds]] tmp_0 = {'z': 0, 'R': 0, 's': 0, 'l': 0, 'r': 0, 'd': 0, 'u': 0} tmp = {'z': 0, 'R': 0, 's': 0, 'l': 0, 'r': 0, 'd': 0, 'u': 0} typen = 0 typem = 0 #canvas.py import pygame as pg class Background(): def __init__(self, screen): self.screen = screen self.image = pg.image.load('images_0/bongo_cat.png') self.rect = self.image.get_rect() #print(self.rect) #self.screen_rect = screen.get_rect() self.rect.x = 0 self.rect.y = 0 def draw(self, image): self.image = pg.image.load(image) self.screen.blit(self.image, self.rect) #listener.py from pynput import keyboard from pynput import mouse import image_tmp as imt import time def on_press(key): keys = str(key) if keys == 'Key.left': imt.tmp['l'] += 1 elif keys == 'Key.right': imt.tmp['r'] += 1 elif keys == 'Key.down': imt.tmp['d'] += 1 elif keys == 'Key.up': imt.tmp['u'] += 1 elif keys == 'Key.shift': imt.tmp['s'] += 1 elif keys == \"'z'\": imt.tmp['z'] += 1 elif keys == \"'r'\": imt.tmp['R'] += 1 def on_release(key): keys = str(key) if keys == 'Key.left': imt.tmp['l'] = 0 elif keys == 'Key.right': imt.tmp['r'] = 0 elif keys == 'Key.down': imt.tmp['d'] = 0 elif keys == 'Key.up': imt.tmp['u'] = 0 elif keys == 'Key.shift': imt.tmp['s'] = 0 elif keys == \"'z'\": imt.tmp['z'] = 0 elif keys == \"'r'\": imt.tmp['R'] = 0 def run_lsn(): maxn = 0 maxm = 0 imt.typen = 0 imt.typem = 0 for key, value in imt.tmp.items(): if key == 'r' or key == 'l' or key == 'u' or key == 'd': maxn = max(maxn, value) else: maxm = max(maxm, value) for key, value in imt.tmp.items(): if key == 'l' and value >= maxn: if maxn > 0: imt.typen = 1 elif key == 'r' and value >= maxn: if maxn > 0: imt.typen = 2 elif key == 'u' and value >= maxn: if maxn > 0: imt.typen = 3 elif key == 'd' and value >= maxn: if maxn > 0: imt.typen = 4 if key == 'R' and value >= maxm: if maxm > 0: imt.typem = 1 elif key == 'z' and value >= maxm: if maxm > 0: imt.typem = 2 elif key == 's' and value >= maxm: if maxm > 0: imt.typem = 3 #print(imt.typen, imt.typem) #imt.tmp = imt.tmp_0.copy() def on_move(x, y): print('move to', x, y) def on_click(x, y, button, pressed): print('click at', x, y, button, pressed) def on_scroll(x, y, dx, dy): print('scroll at', x, y, 'by', dx, dy) # \u76d1\u542c\u5199\u6cd51 def listen_key_block(): # \u76f8\u5f53\u4e8e\u4e00\u4e2a\u65e0\u7a77\u5faa\u73af\uff0c\u6240\u4ee5\u4e0d\u80fd\u5957\u5728while\u5faa\u73af\u91cc with keyboard.Listener( on_press=on_press, on_release=on_release) as listener: listener.join() # \u52a0\u5165\u7ebf\u7a0b\u6c60\uff0c\u963b\u585e\u5199\u6cd5 def listen_mouse_block(): with mouse.Listener( on_move=None, on_click=on_click, on_scroll=on_scroll) as listener: listener.join() # \u76d1\u542c\u5199\u6cd52 def listen_key_nblock(): # \u53ef\u4ee5\u548c\u5176\u4ed6\u51fd\u6570\u5e76\u884c\u8fd0\u884c listener = keyboard.Listener( on_press=on_press, on_release=on_release ) listener.start() # \u542f\u52a8\u7ebf\u7a0b def listen_mouse_nblock(): listener = mouse.Listener( on_move=None, # \u56e0\u4e3aon_move\u592a\u591a\u8f93\u51fa\u4e86\uff0c\u5c31\u4e0d\u653e\u8fdb\u6765\u4e86\uff0c\u6709\u5174\u8da3\u53ef\u4ee5\u52a0\u5165 on_click=on_click, on_scroll=on_scroll ) listener.start() \"\"\" imt.tmp = imt.tmp_0.copy() listen_key_nblock() while True: run_lsn() time.sleep(1) \"\"\" \"\"\" Key.right Key.left Key.up Key.down 'z' Key.shift 'r' \"\"\" #bongo_cat.py import pygame as pg import sys from canvas import Background import listener as lsn import image_tmp as imt import time def init(): imt.tmp = imt.tmp_0.copy() def run_game(): interval = 0.03 pg.init() screen = pg.display.set_mode((300, 177)) pg.display.set_caption('bongo_cat') bgc = (230, 230, 230) bg = Background(screen) init() lsn.listen_key_nblock() while True: for event in pg.event.get(): if event.type == pg.QUIT: sys.exit() lsn.run_lsn() screen.fill(bgc) bg.draw(imt.BC[imt.typem][imt.typen]) pg.display.flip() time.sleep(interval) run_game()","title":"3.\u72b6\u6001\u5207\u6362"},{"location":"my%20past/python/Bongo%20Cat/#4","text":"\u4e00\u5f00\u59cb\u4e3b\u5faa\u73af\u6ca1\u6709$time.sleep()$,\u5bfc\u81f4$cpu$\u5360\u7528$20\\%$ \u5199$listener.py$\u65f6\u88abwindows\u5b89\u5168\u4e2d\u5fc3\u5f53\u6210\u75c5\u6bd2\u9694\u79bb\u4e86\u5c31nm\u79bb\u8c31 \u6700\u540e\u7528$Pyinstaller$\u5c01\u88c5\u6210\u4e86$.exe$,\u4e0d\u8fc7\u56fe\u7247\u6587\u4ef6\u8981\u548c$.exe$\u653e\u5728\u540c\u4e00\u6587\u4ef6\u76ee\u5f55\u4e0b\u3002 Pyinstaller -F -w -i bongo_cat.ico bongo_cat.py \u540e\u671f\u6253\u7b97\u628a\u8fd9\u4e2a\u653e\u5230$Github$\u4e0a\u9493\u9c7c\uff0c~~\u770b\u6709\u6ca1\u6709\u4eba\u7ed9stars~~","title":"4.\u603b\u7ed3 &amp; \u4e00\u4e9b\u5751\u70b9"},{"location":"my%20past/python/pokemon/","text":"Python Pokemon\u81ea\u52a8\u5237\u602a \u82b1\u4e86\u4e00\u5929\u65f6\u95f4\u5199\u7684$_{\u5c0f\u7a0b\u5e8f}$, \u5206\u6210\u4e86\u4e09\u4e2a\u90e8\u5206 1.\u653b\u51fb \u8bbe\u7f6e\u95f4\u9694$0.4$\u79d2\u6309\u4e00\u6b21$j$(\u81ea\u5e26\u8bb2\u7a76\u56f4\u5dfe\u6548\u679c) import pyautogui import datetime cnt = 0 a = datetime.datetime.now().timestamp() end = a t = a while a-end < 60: if a-t >= 0.4: t = a pyautogui.keyUp('j') pyautogui.keyDown('j') a = datetime.datetime.now().timestamp() 2.\u79fb\u52a8 \u95f4\u9694\u4e00\u79d2\u6362\u4e00\u6b21\u65b9\u5411\uff0c\u53ef\u4ee5\u662f\u4e0a\u4e0b\u79fb\u52a8\uff0c\u4e5f\u53ef\u4ee5\u5de6\u53f3\u3002 import pyautogui import datetime cnt=0 a = datetime.datetime.now().timestamp() end = a t = a while a-end<60: if a-t>=1: t=a if cnt%2==0: pyautogui.keyUp('a') pyautogui.keyDown('d') else: pyautogui.keyUp('d') pyautogui.keyDown('a') cnt=(cnt+1)%2 a = datetime.datetime.now().timestamp() 3.\u68c0\u6d4b\u989c\u8272\u5e76\u8f6c\u6362\u6a21\u5f0f \u5c06\u6e38\u620f\u7a97\u53e3\u653e\u5728\u53f3\u4e0a\u89d2\u540e\uff0c\u6839\u636e\u5bf9\u8bdd\u6846\u5728\u6218\u6597\u65f6\u53d8\u767d\uff0c\u6218\u6597\u7ed3\u675f\u65f6\u53d8\u9ed1\u7684\u7279\u70b9\uff0c\u5728\u5b9a\u70b9\u8bbe\u7f6e\u989c\u8272\u68c0\u6d4b import pyautogui as pag import datetime from ctypes import * def get_color(x, y): gdi32 = windll.gdi32 user32 = windll.user32 hdc = user32.GetDC(None) # \u83b7\u53d6\u989c\u8272\u503c pixel = gdi32.GetPixel(hdc, x, y) # \u63d0\u53d6RGB\u503c r = pixel & 0x0000ff g = (pixel & 0x00ff00) >> 8 b = pixel >> 16 return [r, g, b] #[41, 41, 57] x = 202 y = 234 cnt = 0 a = datetime.datetime.now().timestamp() i = 1 t = a timer = int(input(\"total time(s)\")) timer = timer state = \"walk\" pag.moveTo(100, 200) while i < timer: if a-t >= 0.2: # x, y = pag.position() RGB = get_color(x, y) if RGB == [255, 255, 255] and state == \"walk\" : state = \"fight\" print(state) elif RGB == [0, 0, 0] and state == \"fight\": state = \"walk\" print(state) t = a i += 1 #if i % 5 == 0: #print(i/5) #print(\"s\") a = datetime.datetime.now().timestamp() \u6700\u540e\u5408\u5728\u4e00\u8d77\u5c31\u884c\u4e86 import pyautogui as pag import datetime from ctypes import * cnt = 0 x = 202 y = 234 a = datetime.datetime.now().timestamp() T3 = a T2 = a T1 = a start = a def get_color(_x, _y): gdi32 = windll.gdi32 user32 = windll.user32 hdc = user32.GetDC(None) # \u83b7\u53d6\u989c\u8272\u503c pixel = gdi32.GetPixel(hdc, _x, _y) # \u63d0\u53d6RGB\u503c r = pixel & 0x0000ff g = (pixel & 0x00ff00) >> 8 b = pixel >> 16 return [r, g, b] def walk(_t2, _cnt): if a - _t2 >= 1.0: _t2 = a if state == \"walk\": if _cnt % 2 == 0: pag.keyUp('w') pag.keyDown('s') else: pag.keyUp('s') pag.keyDown('w') _cnt = (_cnt + 1) % 2 return [_t2, _cnt] def fight(_t3): if a - _t3 >= 0.4: _t3 = a if state == \"fight\": pag.keyUp('j') pag.keyDown('j') return _t3 def get_state(_t1, _state): if a - _t1 >= 0.2: _t1 = a # x, y = pag.position() RGB = get_color(x, y) if RGB == [255, 255, 255] and _state == \"walk\": _state = \"fight\" print(_state) elif RGB == [0, 0, 0] and _state == \"fight\": _state = \"walk\" print(_state) return [_t1, _state] timer = int(input(\"total time(s)\")) timer = timer state = \"walk\" while a - start < timer: if state == \"fight\": cnt = 0 T1, state = get_state(T1, state) T2, cnt = walk(T2, cnt) T3 = fight(T3) a = datetime.datetime.now().timestamp() \u5751\u70b9 \u4e00\u5f00\u59cb\u505a\u7684\u79fb\u52a8\uff0c\u53d1\u73b0\u53ef\u4ee5\u5728$Pycharm,Word,Google$\u8fd9\u4e9b\u8f6f\u4ef6\u91cc\u6253\u51fa$A,D$,\u4f46\u662f\u5728\u6e38\u620f\u91cc\u548c$Dev C++$\u91cc\u4e0d\u884c\u3002 \u540e\u6765\u4e00\u67e5\uff0c\u53ef\u80fd\u662f\u6ca1\u6709\u83b7\u5f97\u7ba1\u7406\u5458\u6743\u9650(\u6211\u8fd9\u8fa3\u9e21\u7535\u8111\u7684\u4f20\u7edf\u827a\u80fd)\uff0c\u4e8e\u662f\u4ee5\u7ba1\u7406\u5458\u8eab\u4efd\u8fd0\u884c\uff0c\u53ef\u4ee5\u63a7\u5236$Dev C++$\u4e86\uff0c\u4f46\u662f\u6e38\u620f\u8fd8\u662f\u4e0d\u884c\u3002 \u6211\u4ee5\u4e3a\u662f\u952e\u76d8\u5b9e\u9645\u8f93\u5165\u4fe1\u53f7\u4e0e\u7a0b\u5e8f\u6a21\u62df\u4fe1\u53f7\u4e0d\u540c\u5bfc\u81f4\uff0c\u4e8e\u662f\u6362\u7528\u4e86$PyUserInput$(\u8d39\u4e86\u534a\u5929\u52b2\u641e$pip$)\uff0c\u8fd8\u662f\u4e0d\u884c\u3002 ~~\u6b64\u65f6\uff0c\u6211\u4eec\u8003\u8651\u653e\u5f03~~ \u6b64\u65f6\uff0c\u53ef\u80fd\u662f\u6a21\u62df\u5668\u7684\u539f\u56e0\uff0c\u53ea\u6709\u5b83\u65e0\u6cd5\u63a5\u53d7\u5b57\u7b26\u4fe1\u53f7\u3002 \u5f00\u59cb\u7528\u7684$no\\$gba$,\u540e\u6765\u6362\u7528$DeSmuME2$\u540e\uff0c\u5947\u8ff9\u53d1\u751f\u4e86\uff0c\u80fd\u79fb\u52a8\u4e86\uff01(~~no\\$gba\u662f\u4ec0\u4e48\u8fa3\u9e21\u6a21\u62df\u5668~~) \u81f3\u6b64\uff0c\u6211\u4eec\u5b8c\u6210\u4e86\u8fd9\u4e2a\u7a0b\u5e8f 2022.5.31 update \u6211\u4eec\u53d1\u73b0\u4e0a\u8ff0\u7a0b\u5e8f\u7684\u8ba1\u7b97\u91cf\u6bd4\u8f83\u5927\uff0c\u5c31\u662f\u4e00\u79d2\u8ba1\u7b97\u4e86\u8bb8\u591a\u6b21\u65f6\u95f4\u3002\u5176\u5b9e\u6211\u4eec\u53ea\u9700\u8981\u81f3\u591a\u8ba1\u7b975\u6b21\u5373\u53ef\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u7528 time.sleep(0.2) \u6765\u66f4\u6539 while \u5faa\u73af\uff0c\u8fbe\u5230\u51cf\u5c11\u8ba1\u7b97\u6b21\u6570\u7684\u76ee\u7684\u3002 import time import pyautogui as pag import datetime from ctypes import * cnt = 0 timecnt = 0 x = 202 y = 234 def get_color(_x, _y): gdi32 = windll.gdi32 user32 = windll.user32 hdc = user32.GetDC(None) # \u83b7\u53d6\u989c\u8272\u503c pixel = gdi32.GetPixel(hdc, _x, _y) # \u63d0\u53d6RGB\u503c r = pixel & 0x0000ff g = (pixel & 0x00ff00) >> 8 b = pixel >> 16 return [r, g, b] def walk(c, s): if c % 5 == 0: if state == \"walk\": if s % 2 == 0: pag.keyUp('w') pag.keyDown('s') else: pag.keyUp('s') pag.keyDown('w') s = (s + 1) % 2 return s def fight(c): if c % 2 == 0: if state == \"fight\": pag.keyUp('j') pag.keyDown('j') def get_state(_state): # x, y = pag.position() RGB = get_color(x, y) if RGB == [255, 255, 255] and _state == \"walk\": _state = \"fight\" print(_state) elif RGB == [0, 0, 0] and _state == \"fight\": _state = \"walk\" print(_state) return _state timer = int(input(\"total time(s)\")) state = \"walk\" while timecnt < (timer * 5): if state == \"fight\": cnt = 0 state = get_state(state) cnt = walk(timecnt, cnt) fight(timecnt) timecnt += 1 time.sleep(0.2) \u8fd9\u6837\u53ef\u4ee5\u5c06$cpu$\u8ba1\u7b97\u91cf\u51cf\u5c11$ \\%5 $\u5de6\u53f3\u3002","title":"Python Pokemon\u81ea\u52a8\u5237\u602a"},{"location":"my%20past/python/pokemon/#python-pokemon","text":"\u82b1\u4e86\u4e00\u5929\u65f6\u95f4\u5199\u7684$_{\u5c0f\u7a0b\u5e8f}$, \u5206\u6210\u4e86\u4e09\u4e2a\u90e8\u5206","title":"Python Pokemon\u81ea\u52a8\u5237\u602a"},{"location":"my%20past/python/pokemon/#1","text":"\u8bbe\u7f6e\u95f4\u9694$0.4$\u79d2\u6309\u4e00\u6b21$j$(\u81ea\u5e26\u8bb2\u7a76\u56f4\u5dfe\u6548\u679c) import pyautogui import datetime cnt = 0 a = datetime.datetime.now().timestamp() end = a t = a while a-end < 60: if a-t >= 0.4: t = a pyautogui.keyUp('j') pyautogui.keyDown('j') a = datetime.datetime.now().timestamp()","title":"1.\u653b\u51fb"},{"location":"my%20past/python/pokemon/#2","text":"\u95f4\u9694\u4e00\u79d2\u6362\u4e00\u6b21\u65b9\u5411\uff0c\u53ef\u4ee5\u662f\u4e0a\u4e0b\u79fb\u52a8\uff0c\u4e5f\u53ef\u4ee5\u5de6\u53f3\u3002 import pyautogui import datetime cnt=0 a = datetime.datetime.now().timestamp() end = a t = a while a-end<60: if a-t>=1: t=a if cnt%2==0: pyautogui.keyUp('a') pyautogui.keyDown('d') else: pyautogui.keyUp('d') pyautogui.keyDown('a') cnt=(cnt+1)%2 a = datetime.datetime.now().timestamp()","title":"2.\u79fb\u52a8"},{"location":"my%20past/python/pokemon/#3","text":"\u5c06\u6e38\u620f\u7a97\u53e3\u653e\u5728\u53f3\u4e0a\u89d2\u540e\uff0c\u6839\u636e\u5bf9\u8bdd\u6846\u5728\u6218\u6597\u65f6\u53d8\u767d\uff0c\u6218\u6597\u7ed3\u675f\u65f6\u53d8\u9ed1\u7684\u7279\u70b9\uff0c\u5728\u5b9a\u70b9\u8bbe\u7f6e\u989c\u8272\u68c0\u6d4b import pyautogui as pag import datetime from ctypes import * def get_color(x, y): gdi32 = windll.gdi32 user32 = windll.user32 hdc = user32.GetDC(None) # \u83b7\u53d6\u989c\u8272\u503c pixel = gdi32.GetPixel(hdc, x, y) # \u63d0\u53d6RGB\u503c r = pixel & 0x0000ff g = (pixel & 0x00ff00) >> 8 b = pixel >> 16 return [r, g, b] #[41, 41, 57] x = 202 y = 234 cnt = 0 a = datetime.datetime.now().timestamp() i = 1 t = a timer = int(input(\"total time(s)\")) timer = timer state = \"walk\" pag.moveTo(100, 200) while i < timer: if a-t >= 0.2: # x, y = pag.position() RGB = get_color(x, y) if RGB == [255, 255, 255] and state == \"walk\" : state = \"fight\" print(state) elif RGB == [0, 0, 0] and state == \"fight\": state = \"walk\" print(state) t = a i += 1 #if i % 5 == 0: #print(i/5) #print(\"s\") a = datetime.datetime.now().timestamp() \u6700\u540e\u5408\u5728\u4e00\u8d77\u5c31\u884c\u4e86 import pyautogui as pag import datetime from ctypes import * cnt = 0 x = 202 y = 234 a = datetime.datetime.now().timestamp() T3 = a T2 = a T1 = a start = a def get_color(_x, _y): gdi32 = windll.gdi32 user32 = windll.user32 hdc = user32.GetDC(None) # \u83b7\u53d6\u989c\u8272\u503c pixel = gdi32.GetPixel(hdc, _x, _y) # \u63d0\u53d6RGB\u503c r = pixel & 0x0000ff g = (pixel & 0x00ff00) >> 8 b = pixel >> 16 return [r, g, b] def walk(_t2, _cnt): if a - _t2 >= 1.0: _t2 = a if state == \"walk\": if _cnt % 2 == 0: pag.keyUp('w') pag.keyDown('s') else: pag.keyUp('s') pag.keyDown('w') _cnt = (_cnt + 1) % 2 return [_t2, _cnt] def fight(_t3): if a - _t3 >= 0.4: _t3 = a if state == \"fight\": pag.keyUp('j') pag.keyDown('j') return _t3 def get_state(_t1, _state): if a - _t1 >= 0.2: _t1 = a # x, y = pag.position() RGB = get_color(x, y) if RGB == [255, 255, 255] and _state == \"walk\": _state = \"fight\" print(_state) elif RGB == [0, 0, 0] and _state == \"fight\": _state = \"walk\" print(_state) return [_t1, _state] timer = int(input(\"total time(s)\")) timer = timer state = \"walk\" while a - start < timer: if state == \"fight\": cnt = 0 T1, state = get_state(T1, state) T2, cnt = walk(T2, cnt) T3 = fight(T3) a = datetime.datetime.now().timestamp()","title":"3.\u68c0\u6d4b\u989c\u8272\u5e76\u8f6c\u6362\u6a21\u5f0f"},{"location":"my%20past/python/pokemon/#_1","text":"\u4e00\u5f00\u59cb\u505a\u7684\u79fb\u52a8\uff0c\u53d1\u73b0\u53ef\u4ee5\u5728$Pycharm,Word,Google$\u8fd9\u4e9b\u8f6f\u4ef6\u91cc\u6253\u51fa$A,D$,\u4f46\u662f\u5728\u6e38\u620f\u91cc\u548c$Dev C++$\u91cc\u4e0d\u884c\u3002 \u540e\u6765\u4e00\u67e5\uff0c\u53ef\u80fd\u662f\u6ca1\u6709\u83b7\u5f97\u7ba1\u7406\u5458\u6743\u9650(\u6211\u8fd9\u8fa3\u9e21\u7535\u8111\u7684\u4f20\u7edf\u827a\u80fd)\uff0c\u4e8e\u662f\u4ee5\u7ba1\u7406\u5458\u8eab\u4efd\u8fd0\u884c\uff0c\u53ef\u4ee5\u63a7\u5236$Dev C++$\u4e86\uff0c\u4f46\u662f\u6e38\u620f\u8fd8\u662f\u4e0d\u884c\u3002 \u6211\u4ee5\u4e3a\u662f\u952e\u76d8\u5b9e\u9645\u8f93\u5165\u4fe1\u53f7\u4e0e\u7a0b\u5e8f\u6a21\u62df\u4fe1\u53f7\u4e0d\u540c\u5bfc\u81f4\uff0c\u4e8e\u662f\u6362\u7528\u4e86$PyUserInput$(\u8d39\u4e86\u534a\u5929\u52b2\u641e$pip$)\uff0c\u8fd8\u662f\u4e0d\u884c\u3002 ~~\u6b64\u65f6\uff0c\u6211\u4eec\u8003\u8651\u653e\u5f03~~ \u6b64\u65f6\uff0c\u53ef\u80fd\u662f\u6a21\u62df\u5668\u7684\u539f\u56e0\uff0c\u53ea\u6709\u5b83\u65e0\u6cd5\u63a5\u53d7\u5b57\u7b26\u4fe1\u53f7\u3002 \u5f00\u59cb\u7528\u7684$no\\$gba$,\u540e\u6765\u6362\u7528$DeSmuME2$\u540e\uff0c\u5947\u8ff9\u53d1\u751f\u4e86\uff0c\u80fd\u79fb\u52a8\u4e86\uff01(~~no\\$gba\u662f\u4ec0\u4e48\u8fa3\u9e21\u6a21\u62df\u5668~~) \u81f3\u6b64\uff0c\u6211\u4eec\u5b8c\u6210\u4e86\u8fd9\u4e2a\u7a0b\u5e8f 2022.5.31 update \u6211\u4eec\u53d1\u73b0\u4e0a\u8ff0\u7a0b\u5e8f\u7684\u8ba1\u7b97\u91cf\u6bd4\u8f83\u5927\uff0c\u5c31\u662f\u4e00\u79d2\u8ba1\u7b97\u4e86\u8bb8\u591a\u6b21\u65f6\u95f4\u3002\u5176\u5b9e\u6211\u4eec\u53ea\u9700\u8981\u81f3\u591a\u8ba1\u7b975\u6b21\u5373\u53ef\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u7528 time.sleep(0.2) \u6765\u66f4\u6539 while \u5faa\u73af\uff0c\u8fbe\u5230\u51cf\u5c11\u8ba1\u7b97\u6b21\u6570\u7684\u76ee\u7684\u3002 import time import pyautogui as pag import datetime from ctypes import * cnt = 0 timecnt = 0 x = 202 y = 234 def get_color(_x, _y): gdi32 = windll.gdi32 user32 = windll.user32 hdc = user32.GetDC(None) # \u83b7\u53d6\u989c\u8272\u503c pixel = gdi32.GetPixel(hdc, _x, _y) # \u63d0\u53d6RGB\u503c r = pixel & 0x0000ff g = (pixel & 0x00ff00) >> 8 b = pixel >> 16 return [r, g, b] def walk(c, s): if c % 5 == 0: if state == \"walk\": if s % 2 == 0: pag.keyUp('w') pag.keyDown('s') else: pag.keyUp('s') pag.keyDown('w') s = (s + 1) % 2 return s def fight(c): if c % 2 == 0: if state == \"fight\": pag.keyUp('j') pag.keyDown('j') def get_state(_state): # x, y = pag.position() RGB = get_color(x, y) if RGB == [255, 255, 255] and _state == \"walk\": _state = \"fight\" print(_state) elif RGB == [0, 0, 0] and _state == \"fight\": _state = \"walk\" print(_state) return _state timer = int(input(\"total time(s)\")) state = \"walk\" while timecnt < (timer * 5): if state == \"fight\": cnt = 0 state = get_state(state) cnt = walk(timecnt, cnt) fight(timecnt) timecnt += 1 time.sleep(0.2) \u8fd9\u6837\u53ef\u4ee5\u5c06$cpu$\u8ba1\u7b97\u91cf\u51cf\u5c11$ \\%5 $\u5de6\u53f3\u3002","title":"\u5751\u70b9"},{"location":"my%20past/python/spider/","text":"python \u722c\u866b\u603b\u7ed3 \u722c\u866b\u4e3b\u8981\u9488\u5bf9b\u7ad9\u7684\u8d44\u6e90\u83b7\u53d6\uff0c\u56e0\u4e3ab\u7ad9\u7684\u53cd\u722c\u673a\u5236\u8fd8\u662f\u53ef\u4ee5\u7684 \u4e00.b\u7ad9\u56fe\u7247\u7684\u83b7\u53d6 1.\u901a\u8fc7\u9759\u6001\u7f51\u9875img\u6807\u7b7e\u83b7\u53d6 \u7b2c\u4e00\u79cd\u65b9\u6cd5\u662f\uff0c\u4f7f\u7528$requests$\u6a21\u5757\u83b7\u53d6b\u7ad9\u7f51\u9875\u6e90\u4ee3\u7801\uff0c\u901a\u8fc7\u6b63\u5219\u8868\u8fbe\u5f0f\u89e3\u6790\u51fa\u94fe\u63a5($img$\u6807\u7b7e\u7684\u89e3\u6790)\uff0c\u518d\u8bbf\u95ee\u8fd9\u4e9b\u94fe\u63a5\u8fdb\u884c\u56fe\u7247\u7684\u50a8\u5b58\u3002 \u5b9e\u4f8b:b\u7ad9\u4e3b\u9875\u90e8\u5206\u9759\u6001\u56fe\u7247\u7684\u83b7\u53d6 import time import requests import re import os from bs4 import BeautifulSoup headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } def get_html(url_base): response = requests.get(url_base, headers=headers) html = response.text return html def get_url(html): Img = re.compile(r'img.*src=\"(.*?)\"') soup = BeautifulSoup(html, \"html.parser\") data = [] for item in soup.find_all('img'): item = str(item) pic_list = re.findall(Img, item) for t in pic_list: data.append(t) return data def save_pic(data, lim): cnt = 0 for i in data: if not i.lower().startswith('https:'): i = 'https:' + i try: img = requests.get(i) byte = img.content with open(\"image{}.jpg\".format(cnt), \"wb\") as f: f.write(byte) cnt += 1 print(\"downloaded:{}\".format(cnt)) except requests.exceptions.InvalidURL: pass time.sleep(0.25) if cnt >= lim: break def get_image(url_base, target_dir, pic_num): if not os.path.exists(target_dir): os.mkdir(target_dir) html = get_html(url_base) data = get_url(html) os.chdir(target_dir) print(\"target dir: \"+str(os.getcwd())) save_pic(data, pic_num) if __name__ == '__main__': url = r'https://www.bilibili.com/' #input(\"\u8bf7\u8f93\u5165\u7f51\u5740:\") dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili\u4e3b\u9875_1' #input(\"\u8bf7\u8f93\u5165\u76ee\u6807\u6587\u4ef6\u5939:\") num = int(input(\"\u8bf7\u8f93\u5165\u60f3\u8981\u83b7\u53d6\u7684\u56fe\u7247\u6570\u91cf:\")) get_image(url, dirt, num) \u4e0d\u8fc7\uff0c\u8fd9\u79cd\u65b9\u6cd5\u53ea\u80fd\u83b7\u53d6b\u7ad9\u90e8\u5206\u7f51\u9875\u7684\u56fe\u7247\uff0c\u5176\u4ed6\u7f51\u9875\uff0c\u4f8b\u5982B\u7ad9\u4e3b\u9875\u7684\u56fe\u7247\u51e0\u4e4e\u90fd\u662f\u7528$js$\u6e32\u67d3\u51fa\u6765\u7684\uff0c\u5728\u9759\u6001\u7f51\u9875\u4e2d\u4e0d\u663e\u793a\u3002 2.\u901a\u8fc7\u52a8\u6001\u7f51\u9875img\u6807\u7b7e\u83b7\u53d6 \u56e0\u6b64\uff0c\u7b2c\u4e8c\u79cd\u65b9\u6cd5\u662f\u4f7f\u7528$seleium$\u83b7\u53d6\u5f53\u524d\u7f51\u9875\u7684\u52a8\u6001\u4ee3\u7801\uff0c\u518d\u83b7\u53d6\u94fe\u63a5\u3002 \u8fd9\u79cd\u65b9\u6cd5\u4e00\u5b9a\u80fd\u83b7\u53d6\u56fe\u7247\uff0c\u56e0\u4e3a\u4f60\u770b\u5230\u7684\u56fe\u7247\uff0c\u90fd\u5728\u52a8\u6001\u4ee3\u7801\u4e2d\uff0c\u800c$selenium$\u90fd\u80fd\u591f\u83b7\u53d6\u4e0b\u6765\u3002\u4f46\u662f\uff0c$selenium$\u9875\u53ea\u80fd\u83b7\u53d6\u5df2\u7ecf\u52a0\u8f7d\u7684\u56fe\u7247\uff0c\u56e0\u6b64\u8981\u81ea\u52a8\u8bbe\u7f6e\u5c06\u7f51\u9875\u4e0b\u79fb\u5230\u5e95\u90e8\uff0c\u5982\u679c\u60f3\u8981\u83b7\u53d6\u591a\u4e2a\u7f51\u9875\u7684\u56fe\u7247\uff0c\u8fd8\u9700\u8981\u8bbe\u7f6e\u7ffb\u9875\u3002\u5e76\u4e14\u901f\u5ea6\u4e5f\u4e0d\u5982$requests$\u5feb\u3002 \u5b9e\u4f8b:\u83b7\u53d6b\u7ad9\u4e3b\u9875\u7684\u56fe\u7247 # selenium_get_html.py from selenium import webdriver import time def get_html(url_base): driver = webdriver.Edge() driver.get(url_base) for i in range(0, 10): # \u63a7\u5236\u7f51\u9875\u5411\u4e0b\u6eda\u52a81000\u50cf\u7d20\u503c driver.execute_script(\"window.scrollBy(0,1000)\") time.sleep(1) driver.encoding = 'UTF-8' return driver.page_source if __name__ == '__main__': url = r'https://www.bilibili.com/' # selenium_get_image.py import time import requests import re import os from bs4 import BeautifulSoup import selenium_get_html as sgh headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } def get_html(url_base): response = requests.get(url_base, headers=headers) html = response.text return html def get_url(html): Img = re.compile(r'img.*src=\"(.*?)\"') soup = BeautifulSoup(html, \"html.parser\") data = [] for item in soup.find_all('img'): item = str(item) pic_list = re.findall(Img, item) for t in pic_list: data.append(t) return data def save_pic(data, lim): cnt = 0 for i in data: if not i.lower().startswith('https:'): i = 'https:' + i try: img = requests.get(i) byte = img.content with open(\"image{}.jpg\".format(cnt), \"wb\") as f: f.write(byte) cnt += 1 print(\"downloaded:{}\".format(cnt)) except requests.exceptions.InvalidURL: pass time.sleep(0.25) if cnt >= lim: break def get_image(url_base, target_dir, pic_num): if not os.path.exists(target_dir): os.mkdir(target_dir) html = sgh.get_html(url_base) data = get_url(html) os.chdir(target_dir) print(\"target dir: \"+str(os.getcwd())) save_pic(data, pic_num) if __name__ == '__main__': url = r'https://www.bilibili.com/' #input(\"\u8bf7\u8f93\u5165\u7f51\u5740:\") dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili\u4e3b\u9875_1' #input(\"\u8bf7\u8f93\u5165\u76ee\u6807\u6587\u4ef6\u5939:\") num = int(input(\"\u8bf7\u8f93\u5165\u60f3\u8981\u83b7\u53d6\u7684\u56fe\u7247\u6570\u91cf:\")) get_image(url, dirt, num) 3.\u901a\u8fc7\u5206\u6790\"\u7f51\u7edc\"\u6570\u636e \u7b2c\u4e09\u79cd\u65b9\u6cd5\uff0c\u662f\u901a\u8fc7$F12$\u63a7\u5236\u53f0\"\u7f51\u7edc\"\u754c\u9762\u6279\u91cf\u83b7\u53d6\u6570\u636e\u6587\u4ef6\u7684\u94fe\u63a5\uff0c\u5728\u901a\u8fc7\u89e3\u6790\u8fd9\u4e9b\u6587\u4ef6\u7684\u6570\u636e\u6765\u83b7\u53d6\u56fe\u7247\u94fe\u63a5\uff0c\u8fdb\u800c\u83b7\u53d6\u56fe\u7247\u3002 \u8fd9\u79cd\u65b9\u6cd5\u9700\u8981\u5145\u5206\u4e86\u89e3\u7f51\u7ad9\u4f20\u8f93\u4e86\u90a3\u4e9b\u6587\u4ef6\uff0c\u54ea\u4e2a\u6587\u4ef6\u4e2d\u6709\u6709\u7528\u7684\u6570\u636e\uff0c\u56e0\u6b64\u6bd4\u8f83\u70e6\uff0c\u4f46\u662f\u4e0d\u9700\u8981\u7528$selenium$\u4e5f\u53ef\u4ee5\u83b7\u53d6\u5927\u91cf\u56fe\u7247\u3002 \u5b9e\u4f8b:\u83b7\u53d6b\u7ad9\u65b0\u756a\u699cTop200\u56fe\u7247 import requests import json import os headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } dirt = r'C:\\Users\\Yimen\\Desktop\\\u65b0\u756a\u699cTop200' front_url = r'https://api.bilibili.com/pgc/season/index/result?season_version=-1&spoken_language_type=-1&area=-1' \\ r'&is_finish=-1&copyright=-1&season_status=-1&season_month=-1&year=-1&style_id=-1&order=3&st=1&sort=0&page=' back_url = r'&season_type=1&pagesize=20&type=1' if not os.path.exists(dirt): os.mkdir(dirt) def write_json(html, num): _dirt = os.path.join(dirt, 'list{}.json'.format(num)) print('NO.' + str(num) + ' printed') with open(_dirt, 'wb') as f: f.write(html) def get_json(): lst = [] for i in range(6, 11): url = front_url + str(i) + back_url try: response = requests.get(url, headers=headers) html = response.content.decode() dic = json.loads(html) lst.append(dic) # write_json(html, i) except requests.exceptions.InvalidURL: pass return lst def save_pic(lst): os.chdir(dirt) num = 0 for dic in lst: _lst = dic[\"data\"][\"list\"] for _dic in _lst: num += 1 pic_url = _dic[\"cover\"] pic_name = _dic[\"title\"] # + \"_\" + _dic[\"subTitle\"] response = requests.get(pic_url, headers=headers) pic_byte = response.content pic_dirt = str(num) + '_' + pic_name + '.jpg' print(pic_dirt + ' printed') with open(pic_dirt, 'wb') as f: f.write(pic_byte) if __name__ == '__main__': save_pic(get_json()) ~~\u8fd9\u4e2a\u5b9e\u4f8b\u6709\u70b9\u95ee\u9898\uff0c\u5c31\u662f\u5982\u679c\u65b0\u756a\u7684\u540d\u79f0\u4e2d\u542b\u6709\"\u5947\u7279\"\u7684\u7b26\u53f7\uff0c\u5c31\u4f1a\u62a5\u9519\uff0c\u4e0d\u8fc7\u4e0d\u663e\u793a\u65b0\u756a\u540d\u5b57\uff0c\u7528\u6570\u5b57\u5c31\u884c\u4e86\u3002~~ 4.\u901a\u8fc7\u5206\u6790\u6e90\u4ee3\u7801\u6570\u636e b\u7ad9\u4e3b\u9875\u7684\u56fe\u7247\u8fd8\u6709\u4e00\u79cd\u83b7\u53d6\u65b9\u6cd5\uff0c\u5c31\u662f\u5c06\u6e90\u4ee3\u7801\u4e2d\u7684$script$\u6807\u7b7e\u4e2d\u7684$json$\u4e32\u53d6\u51fa\u6765\uff0c\u5206\u6790\u5176\u4e2d\u7684\u94fe\u63a5\u6765\u83b7\u53d6\u3002\u8fd9\u91cc\u4ee3\u7801\u7701\u7565\u3002 5.\u603b\u7ed3 \u722c\u866b\u5171\u6709\u4e24\u79cd\u65b9\u6cd5\uff0c\u4e00\u79cd\u662f\u83b7\u53d6\u7f51\u9875\u6e90\u4ee3\u7801\u5e76\u901a\u8fc7\u89e3\u6790\u6807\u7b7e\u83b7\u53d6\u94fe\u63a5\uff1b\u4e00\u79cd\u662f\u901a\u8fc7\u5bf9\u7f51\u7edc\u4f20\u8f93\u7684\u6570\u636e\u8fdb\u884c\u5206\u6790\uff0c\u4ece\u4e2d\u627e\u5230\u89c4\u5f8b\u5e76\u83b7\u53d6\u6709\u7528\u7684\u94fe\u63a5\u3002\u83b7\u53d6\u7f51\u9875\u6e90\u4ee3\u7801\u6807\u7b7e\u53c8\u5206\u4e3a\u9759\u6001\u83b7\u53d6\u548c\u52a8\u6001\u83b7\u53d6\u3002\u5982\u679c\u7f51\u9875\u5b8c\u5168\u9759\u6001\uff0c\u65e0$js$\u6e32\u67d3\uff0c\u5c31\u53ef\u4ee5\u7528$requests$\u83b7\u53d6\u7f51\u9875\u6807\u7b7e\u3002\u5982\u679c\u7f51\u9875\u4e3a\u52a8\u6001\u52a0\u8f7d\uff0c\u5219\u9700\u8981\u7528\u5230$selenium$\u3002\u800c\u6570\u636e\u5206\u6790\u5982\u679c\u505a\u7684\u597d\uff0c\u90a3\u4e48\u52a8\u6001\u7f51\u9875\u4e5f\u53ef\u4ee5\u76f4\u63a5\u901a\u8fc7$requests$\u8bbf\u95ee\u94fe\u63a5\u3002 \u4e8c.\u83b7\u53d6b\u7ad9\u5f39\u5e55 1.\u52a8\u6001\u83b7\u53d6 \u901a\u8fc7\u89c2\u5bdf\u7f51\u9875\u6e90\u4ee3\u7801\uff0c\u6211\u4eec\u53d1\u73b0\u5f39\u5e55\u4e5f\u662f$js$\u6e32\u67d3\u51fa\u6765\u7684\uff0c\u6240\u4ee5\u7406\u8bba\u4e0a\u53ef\u4ee5\u7528$selenium$\u83b7\u53d6\uff0c\u4f46\u662f\u5f39\u5e55\u65f6\u523b\u5728\u53d8\uff0c\u7528$selenium$\u5c31\u8981\u628a\u89c6\u9891\u5168\u770b\u4e00\u904d\u624d\u80fd\u83b7\u53d6\u5b8c\u6574\u5f39\u5e55\u3002 2.\u5206\u6790\u6570\u636e \u901a\u8fc7\u5206\u6790\u7f51\u7edc\u4f20\u8f93\u7684\u6570\u636e\uff0c\u6211\u4eec\u53d1\u73b0\u5728$seg.so$\u4e2d\u50a8\u5b58\u7740\u5f39\u5e55\u7684\u6570\u636e\uff0c\u5e76\u4e14\u6240\u6709\u94fe\u63a5\u53ea\u6709$index$\u4e0d\u540c\uff0c\u53ef\u4ee5\u6279\u91cf\u83b7\u53d6\u3002\u4f46\u662f\uff0c$.so$\u6587\u4ef6\u4e3a\u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u5f88\u96be\u89e3\u7801\u3002~~\u6211\u8bd5\u4e86\u4e00\u5929\uff0c\u65e0\u679c\u3002~~\u8fd9\u79cd\u65b9\u6cd5\u7406\u8bba\u4e0a\u6765\u8bf4\u53ef\u4ee5\u83b7\u53d6\u5168\u90e8\u5f39\u5e55\uff0c\u4f46\u662f\u65e0\u6cd5\u89e3\u6790\u6570\u636e\u6587\u4ef6\uff0c\u5c31\u5bc4\u4e86\u3002 3.\u5947\u5999\u65b9\u6cd5 ~~\u901a\u8fc7\u770b\u7f51\u53cb\u4eec\u7684\u65b9\u6cd5~~\uff0c\u6211\u4eec\u53d1\u73b0b\u7ad9\u4e00\u4e2a\u53e4\u8001\uff0c\u5df2\u5e9f\u5f03\u7684\u50a8\u5b58\u5f39\u5e55\u7684\u65b9\u5f0f:$https://comment.bilibili.com/{cid}.xml$,\u8fd9\u4e2a\u94fe\u63a5\u91cc\u5b58\u653e\u7740\u8be5\u89c6\u9891\u90e8\u5206\u7684\u5f39\u5e55(\u6709\u65f6\u5168\uff0c\u6709\u65f6\u4e0d\u5168)\u3002\u800c$cid$\u5c31\u653e\u5728\u7f51\u9875\u6e90\u4ee3\u7801\u91cc\u3002\u6240\u4ee5\uff0c\u6b64\u6cd5\u53ef\u884c\u3002 import re import requests import os import openpyxl import openpyxl.styles headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } or_url = r'https://www.bilibili.com/video/{}?spm_id_from=333.337.search-card.all.click' dm_url = r'https://comment.bilibili.com/{}.xml' bv_id = r'BV1yG4y1r77N' # input('\u8f93\u5165bv\u53f7:') dirt = r'C:\\Users\\Yimen\\Desktop' def get_html(): resp = requests.get(or_url.format(bv_id)) html = resp.text with open('danmaku.html', 'w', encoding='utf-8') as f: f.write(html) return html def get_cid(html): # tmp = re.compile(r'\"videoData\":.*?\"dynamic\":.*?,\"cid\":(.*?),\"dimension\":') lst = re.findall(tmp, html) cid = lst[0] return cid def get_title(html): tmp = re.compile(r'\"videoData\":.*?\"pic\":.*?,\"title\":\"(.*?)\",\"pubdate\":') lst = re.findall(tmp, html) title = lst[0] return title def write_xml(xml): with open('danmaku.xml', 'w', encoding='utf-8') as f: f.write(xml) def get_xml(cid): resp = requests.get(dm_url.format(cid)) xml = resp.content.decode() #write_xml(xml) return xml def get_time(tm): tm = float(tm) min = int(tm / 60) sec = int(tm - min * 60) smin = str(min) ssec = str(sec) if min < 10: smin = '0' + smin if sec < 10: ssec = '0' + ssec word = smin + ':' + ssec return word def get_color(cl): color_val = str(hex(cl)).upper()[2:] # print(color_val) color_len = len(color_val) if color_len < 6: for i in range(0, 6 - color_len): color_val = \"0\" + color_val if color_val == \"FFFFFF\": color_val = \"000000\" return color_val def get_danmaku(xml, title): tmp = re.compile(r'<d p=\"(.*?),.*?,.*?,(.*?),.*?\">(.*?)</d>') tmp_lst = re.findall(tmp, xml) lst = [] for i in tmp_lst: lst.append([float(i[0]), int(i[1]), i[2]]) lst.sort(reverse=False) os.chdir(dirt) workbook = openpyxl.Workbook() sheet = workbook.active sheet.title = '\u5f39\u5e55' sheet.append(['\u51fa\u73b0\u65f6\u95f4', '\u5f39\u5e55\u5185\u5bb9']) num = 1 sheet.column_dimensions['A'].width = 15 sheet.column_dimensions['B'].width = 150 sheet.row_dimensions[num].height = 25 for tm, cl, dm in lst: sheet.append([get_time(tm), dm]) num += 1 sheet.row_dimensions[num].height = 20 pos = 'B' + str(num) cell = sheet[pos] color_val = get_color(cl) cell.font = openpyxl.styles.Font(name=\"\u5fae\u8f6f\u96c5\u9ed1\", size=10, bold=True, italic=False, color=\"\" + color_val + \"\") workbook.save(\"\u5f39\u5e55_\" + title + \".xlsx\") if __name__ == '__main__': html = get_html() cid = get_cid(html) title = get_title(html) xml = get_xml(cid) get_danmaku(xml, title) \u53e6\u5916\uff0c\u8fd9\u65b9\u6cd5\u83b7\u53d6\u7684\u5f39\u5e55\u4e0d\u53ea\u6709\u5185\u5bb9\uff0c\u8fd8\u6709\u65f6\u95f4\u548c\u989c\u8272\u7b49\u4fe1\u606f\uff0c\u6240\u4ee5\u7528$excel$\u8868\u683c\u5448\u73b0\u8fd9\u4e9b\u5185\u5bb9\u518d\u5408\u9002\u4e0d\u8fc7\u3002 \u4e09.b\u7ad9\u89c6\u9891\u7684\u83b7\u53d6 ~~\u5230\u4e86\u5927boss\u4e86,\u5f53\u521d\u5b66\u722c\u866b\u5c31\u662f\u4e3a\u4e86\u8fd9\u4e2a~~ 1.\u7701\u4e8b\u8fd8\u662f\u8d39\u4e8b \u4e00\u79cd\u7701\u65f6\u53c8\u7701\u4e8b\u7684\u65b9\u6cd5\u662f\u7528$you$-$get$\u83b7\u53d6\u89c6\u9891\u3002~~\u56e0\u6b64\uff0c\u6b64\u8d34\u5b8c\u7ed3~~ 2.\u5b66\u8fd8\u662f\u4e0d\u5b66 \u6211\u4eec\u5b66$python$\u722c\u866b\u4e0d\u662f\u4e3a\u4e86\u7701\u4e8b\uff0c\u800c\u662f\u4e3a\u4e86\u5b66\u4e60\u8fd9\u5176\u4e2d\u7684\u539f\u7406\u3002~~\u8981\u662f\u4e3a\u4e86\u7701\u4e8b\uff0c\u82b1\u94b1\u8ba9\u522b\u4eba\u5e2e\u81ea\u5df1\u505a\u5c82\u4e0d\u662f\u66f4\u723d~~ \u6211\u4eec\u53d1\u73b0\uff0c\u7f51\u9875\u6e90\u4ee3\u7801\u4e2d\u7684$script$\u6807\u7b7e\u4e2d\u5c31\u542b\u6709\u89c6\u9891\u7684\u4fe1\u606f\uff0c\u4e0d\u8fc7b\u7ad9\u89c6\u9891\u5206\u4e3a\u89c6\u9891\u548c\u97f3\u9891\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u5c06$script$\u6807\u7b7e\u4e2d\u7684$json$\u4e32\u53d6\u51fa\u6765\uff0c\u518d\u5206\u6790\u6587\u4ef6\u5f97\u5230\u89c6\u9891\u548c\u97f3\u9891\u7684\u94fe\u63a5\uff0c\u5206\u522b\u4e0b\u8f7d\u5373\u53ef\u3002 \u5b9e\u4f8b:\u83b7\u53d6b\u7ad9\u89c6\u9891 import os import re import requests as req import json headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } or_url = r'https://www.bilibili.com/video/{}' ep_url = r'https://www.bilibili.com/bangumi/play/{}?from_spmid=666.25.episode.0&from_outer_spmid=333.337.0.0' bv_id = r'BV1ua4y1H714?p=2' # input('\u8f93\u5165bv\u53f7:') ep_id = r'ep517946' dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili_video' if not os.path.exists(dirt): os.mkdir(dirt) def write_html(html): with open('video.html', 'w', encoding='utf-8') as f: f.write(html) def get_html(url): resp = req.get(url, headers=headers) html = resp.content.decode() # write_html(html) return html def write_json(json_dic): with open('video.json', 'w', encoding='utf-8') as f: json.dump(json_dic, f) def get_json(html): tmp = re.compile(r'<script>window.__playinfo__=(.*?)</script>') json_text = re.findall(tmp, html)[0] json_dic = json.loads(json_text) # write_json(json_dic) return json_dic def get_times(): with open('times.json', 'r') as f: dic = json.load(f) cnt = dic[\"times\"] dic[\"times\"] += 1 with open('times.json', 'w') as f: json.dump(dic, f) return cnt def get_video_clip(dic): re_url = or_url.format(bv_id) _headers_ = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63', 'Referer': re_url } cnt = get_times() os.chdir(dirt) url = dic['data']['dash']['video'][0]['base_url'] print(\"\u89c6\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5\") resp = req.get(url, headers=_headers_) print(\"\u89c6\u9891\u83b7\u53d6\u5b8c\u6bd5\") vid = resp.content print(\"\u6b63\u5728\u4fdd\u5b58\u89c6\u9891...\") with open('video_{}.mp4'.format(cnt), 'wb') as f: f.write(vid) print(\"\u4fdd\u5b58\u5b8c\u6bd5\uff01\") url = dic['data']['dash']['audio'][0]['base_url'] print(\"\u97f3\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5\") resp = req.get(url, headers=_headers_) print(\"\u97f3\u9891\u83b7\u53d6\u5b8c\u6bd5\") vid = resp.content print(\"\u6b63\u5728\u4fdd\u5b58\u97f3\u9891...\") with open('audio_{}.mp3'.format(cnt), 'wb') as f: f.write(vid) print(\"\u4fdd\u5b58\u5b8c\u6bd5\uff01\") def init(): with open('times.json', 'w') as f: json.dump({\"times\": 0}, f) if __name__ == '__main__': get_video_clip(get_json(get_html(or_url.format(bv_id)))) \u4ec5\u4ec5\u83b7\u53d6\u5206\u5f00\u7684\u97f3\u9891\u548c\u89c6\u9891\u8fd8\u4e0d\u591f\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u5c06\u4ed6\u4eec\u8fdb\u884c\u5408\u5e76\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u7528$ffmpeg$\u5b9e\u73b0\u5c06\u97f3\u89c6\u9891\u5408\u5e76\u7684\u64cd\u4f5c\u3002\u5f53\u7136\uff0c\u4f7f\u7528$moviepy.editor$\u4e5f\u53ef\u4ee5\u5408\u5e76\u97f3\u89c6\u9891\uff0c\u4f46\u662f\u901f\u5ea6\u8981\u8fdc\u6162\u4e8e$ffmpeg$\u3002 \u6ce8\u610f\uff0c$ffmpeg$\u4e3a\u975e\u7cfb\u7edf\u7a0b\u5e8f\uff0c\u6240\u4ee5\u8981\u5c06\u7edd\u5bf9\u8def\u5f84\u8f93\u5165\u547d\u4ee4\u884c\u4e2d\uff0c\u4e0d\u7136\u4f1a\u62a5\u9519\u3002 \u5173\u4e8e$ffmpeg$\u7684\u5b89\u88c5:\u5148\u5c06\u5b98\u7f51\u4e0b\u8f7d\u7684$.zip$\u6587\u4ef6\u89e3\u538b\u7f29\uff0c\u5c06\u6587\u4ef6\u5939\u653e\u5165\u4efb\u610f\u4f4d\u7f6e\uff0c\u5e76\u5728\u7cfb\u7edf\u53d8\u91cf\u4e2d\u6dfb\u52a0$bin$\u6587\u4ef6\u5939\u7684\u7edd\u5bf9\u8def\u5f84\u3002 # merge_video_audio.py import os import moviepy.editor as me def run_by_moviepy(audio_name, video_name, output_name): audio = me.AudioFileClip(audio_name) video = me.VideoFileClip(video_name) output = video.set_audio(audio) output.write_videofile(output_name) def run_by_ffmpeg(audio_name, video_name, output_name): cmd = f'C:\\\\Windows\\\\ffmpeg-5.1-essentials_build\\\\bin\\\\ffmpeg.exe -i {audio_name} -i {video_name} -acodec copy -vcodec copy {output_name}' os.system(cmd) # normal_get_video.py import os import re import requests as req import json import merge_video_audio as mva headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } or_url = r'https://www.bilibili.com/video/{}' ep_url = r'https://www.bilibili.com/bangumi/play/{}?from_spmid=666.25.episode.0&from_outer_spmid=333.337.0.0' bv_id = r'BV1xa411V7Tq' # input('\u8f93\u5165bv\u53f7:') ep_id = r'ep517946' dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili_video' if not os.path.exists(dirt): os.mkdir(dirt) def write_html(html): with open('video.html', 'w', encoding='utf-8') as f: f.write(html) def get_html(url): resp = req.get(url, headers=headers) html = resp.content.decode() # write_html(html) return html def write_json(json_dic): with open('video.json', 'w', encoding='utf-8') as f: json.dump(json_dic, f) def get_json(html): tmp = re.compile(r'<script>window.__playinfo__=(.*?)</script>') json_text = re.findall(tmp, html)[0] json_dic = json.loads(json_text) # write_json(json_dic) return json_dic def get_times(): with open('times.json', 'r') as f: dic = json.load(f) cnt = dic[\"times\"] dic[\"times\"] += 1 with open('times.json', 'w') as f: json.dump(dic, f) return cnt def get_title(html): tmp = re.compile(r'\"videoData\":.*?\"pic\":.*?,\"title\":\"(.*?)\",\"pubdate\":') lst = re.findall(tmp, html) title = lst[0] return title def get_video_clip(dic): re_url = or_url.format(bv_id) title = get_title(get_html(re_url)) _headers_ = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63', 'Referer': re_url } cnt = get_times() os.chdir(dirt) url = dic['data']['dash']['video'][0]['base_url'] print(\"\u89c6\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5,\u6b63\u5728\u4e0b\u8f7d\u89c6\u9891...\") resp = req.get(url, headers=_headers_) print(\"\u89c6\u9891\u83b7\u53d6\u5b8c\u6bd5\") vid = resp.content print(\"\u6b63\u5728\u4fdd\u5b58\u89c6\u9891...\") video_name = 'video_{}.mp4'.format(cnt) with open(video_name, 'wb') as f: f.write(vid) print(\"\u4fdd\u5b58\u5b8c\u6bd5\uff01\") print(\"--------------------\") url = dic['data']['dash']['audio'][0]['base_url'] print(\"\u97f3\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5\") resp = req.get(url, headers=_headers_) print(\"\u97f3\u9891\u83b7\u53d6\u5b8c\u6bd5\") vid = resp.content print(\"\u6b63\u5728\u4fdd\u5b58\u97f3\u9891...\") audio_name = 'audio_{}.mp3'.format(cnt) with open(audio_name, 'wb') as f: f.write(vid) print(\"\u4fdd\u5b58\u5b8c\u6bd5\uff01\") print(\"--------------------\") print(\"\u6b63\u5728\u5408\u5e76\u97f3\u89c6\u9891...\") output_name = 'output_{}.mp4'.format(cnt) rename = title + '.mp4' mva.run_by_ffmpeg(audio_name, video_name, output_name) os.rename(output_name, rename) print(\"\u5408\u6210\u5b8c\u6bd5!\") print(\"--------------------\") print(\"\u6b63\u5728\u6e05\u7406\u6570\u636e\u6587\u4ef6...\") os.remove(audio_name) os.remove(video_name) print(\"\u6e05\u7406\u5b8c\u6bd5!\") def init(): with open('times.json', 'w') as f: json.dump({\"times\": 0}, f) if __name__ == '__main__': get_video_clip(get_json(get_html(or_url.format(bv_id)))) \u540c\u65f6\uff0c\u7531\u4e8e\u901a\u8fc7\u89c6\u9891\u94fe\u63a5\u83b7\u53d6\u89c6\u9891\u7f51\u9875\u6e90\u7801\u7684\u8fc7\u7a0b\u6bd4\u8f83\u6162\uff0c\u53ef\u4ee5\u505a\u4e00\u4e2a\u8fdb\u5ea6\u6761\u6765\u663e\u793a\u5f53\u524d\u7684\u4e0b\u8f7d\u8fdb\u5ea6\u3002\u518d\u5b58\u50a8\u89c6\u9891\u6587\u4ef6\u65f6\uff0c\u6211\u4eec\u8fd8\u8981\u6ce8\u610f\u547d\u540d:\u5982\u679c\u51fa\u73b0\u91cd\u540d\uff0c\u8981\u81ea\u52a8\u751f\u6210\u65b0\u540d\u5b57(\"_\" + \u6570\u5b57)\uff1b\u5982\u679c\u540d\u5b57\u4e2d\u542b\u6709\u975e\u6cd5\u5b57\u7b26\uff0c\u5c31\u81ea\u52a8\u4fdd\u5b58\u4e3a\u6307\u5b9a\u7684\u540d\u5b57(\"output.mp4\")\u3002 # download_process_bar.py from contextlib import closing import requests as req hea = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } def download_with_process_bar(url, filename, headers=None): if headers is None: headers = hea with closing(req.get(url, headers=headers, stream=True)) as resp: chunk_size = 1024 content_size = int(resp.headers['content-length']) data_count = 0 with open(filename, 'wb') as f: for data in resp.iter_content(chunk_size=chunk_size): f.write(data) done_block = int((data_count / content_size) * 50) data_count = data_count + len(data) now_percent = (data_count / content_size) * 100 print(\"\\r [%s%s] %d%% \" % (done_block * '\u2588', ' ' * (50 - 1 - done_block), now_percent), end=\" \") \u8fd9\u91cc\u7684$closing$\u662f\u4e3a\u4e86\u5c06$req.get$\u81ea\u52a8\u751f\u6210\u4e0a\u4e0b\u6587\u7ba1\u7406\uff0c\u8fd9\u6837\u624d\u80fd\u7528$with$\u6253\u5f00\uff1b$resp.iter_content$\u5219\u53ef\u4ee5\u5c06\u6587\u4ef6\u5206\u6bb5\uff0c\u4ee5\u663e\u793a\u51fa\u8fdb\u5ea6\u6761\u3002'\\r'\u662f\u4e3a\u4e86\u8ba9\u8f93\u51fa\u663e\u793a\u5728\u540c\u4e00\u884c\uff0c\u4f5c\u7528\u662f\u8ba9\u5149\u6807\u56de\u5230\u884c\u9996\u3002 # normal_get_video.py import os import re import requests as req import json import merge_video_audio as mva import download_process_bar as dpb headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } or_url = r'https://www.bilibili.com/video/{}' ep_url = r'https://www.bilibili.com/bangumi/play/{}?from_spmid=666.25.episode.0&from_outer_spmid=333.337.0.0' bv_id = r'BV1254y187SE' # input('\u8f93\u5165bv\u53f7:') ep_id = r'ep517946' dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili_video' if not os.path.exists(dirt): os.mkdir(dirt) def write_html(html): with open('video.html', 'w', encoding='utf-8') as f: f.write(html) def get_html(url): resp = req.get(url, headers=headers) html = resp.content.decode() # write_html(html) return html def write_json(json_dic): with open('video.json', 'w', encoding='utf-8') as f: json.dump(json_dic, f) def get_json(html): tmp = re.compile(r'<script>window.__playinfo__=(.*?)</script>') json_text = re.findall(tmp, html)[0] json_dic = json.loads(json_text) # write_json(json_dic) return json_dic def get_times(): with open('times.json', 'r') as f: dic = json.load(f) cnt = dic[\"times\"] dic[\"times\"] += 1 with open('times.json', 'w') as f: json.dump(dic, f) return cnt def get_title(html): tmp = re.compile(r'\"videoData\":.*?\"pic\":.*?,\"title\":\"(.*?)\",\"pubdate\":') lst = re.findall(tmp, html) title = lst[0] return title def get_video_clip(dic): re_url = or_url.format(bv_id) title = get_title(get_html(re_url)) _headers_ = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63', 'Referer': re_url } cnt = get_times() os.chdir(dirt) url = dic['data']['dash']['video'][0]['base_url'] print(\"\u89c6\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5,\u6b63\u5728\u4e0b\u8f7d\u89c6\u9891...\") video_name = 'video_{}.mp4'.format(cnt) dpb.download_with_process_bar(url, video_name, _headers_) print(\"\u4e0b\u8f7d\u5b8c\u6bd5\uff01\") print(\"--------------------\") url = dic['data']['dash']['audio'][0]['base_url'] print(\"\u97f3\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5\") resp = req.get(url, headers=_headers_) print(\"\u97f3\u9891\u83b7\u53d6\u5b8c\u6bd5\") vid = resp.content print(\"\u6b63\u5728\u4fdd\u5b58\u97f3\u9891...\") audio_name = 'audio_{}.mp3'.format(cnt) with open(audio_name, 'wb') as f: f.write(vid) print(\"\u4fdd\u5b58\u5b8c\u6bd5\uff01\") print(\"--------------------\") print(\"\u6b63\u5728\u5408\u5e76\u97f3\u89c6\u9891...\") output_name = 'output_{}.mp4'.format(cnt) rename = title + '.mp4' mva.run_by_ffmpeg(audio_name, video_name, output_name) num = 0 while os.path.exists(rename): rename = title + '_' + str(num) + '.mp4' num += 1 try: os.rename(output_name, rename) except OSError: print(\"\u6587\u4ef6\u540d\u4e0d\u6b63\u786e\uff0c\u6587\u4ef6\u5c06\u81ea\u52a8\u547d\u540d\u4e3a \" + output_name + '.') pass print(\"\u5408\u6210\u5b8c\u6bd5!\") print(\"--------------------\") print(\"\u6b63\u5728\u6e05\u7406\u6570\u636e\u6587\u4ef6...\") os.remove(audio_name) os.remove(video_name) print(\"\u6e05\u7406\u5b8c\u6bd5!\") def init(): with open('times.json', 'w') as f: json.dump({\"times\": 0}, f) if __name__ == '__main__': get_video_clip(get_json(get_html(or_url.format(bv_id)))) \u56db.\u83b7\u53d6b\u7ad9\u8bc4\u8bba b\u7ad9\u8bc4\u8bba\u4e0eb\u7ad9\u89c6\u9891\u7684\u83b7\u53d6\u65b9\u6cd5\u5982\u51fa\u4e00\u8f99\uff0c\u4e5f\u662f\u4ece$script$\u6807\u7b7e\u4e2d\u53d6\u51fa$json$\u4e32\uff0c\u5728\u8fdb\u884c\u4fdd\u5b58\u3002\u4e0d\u8fc7\uff0c\u8bc4\u8bba\u5177\u6709\u6811\u5f62\u7ed3\u6784\uff0c\u6240\u4ee5\u9700\u8981\u5c06\u6bcf\u4e2a\u8bc4\u8bba\u4e0b\u9762\u7684\u8ddf\u8bc4\u4e5f\u4e0b\u8f7d\u4e0b\u6765\u3002 \u8fd9\u4e2a\u8fc7\u7a0b\u5b58\u5728\u5927\u91cf\u8bbf\u95ee\u4e0d\u540c\u5730\u5740\u7684\u60c5\u51b5\uff0c\u53ef\u80fd\u4f1a\u88ab\u62e6\u622a\u3002\u56e0\u6b64\u4e3a\u4e86\u8ba9\u7a0b\u5e8f\u4e0d\u7ec8\u6b62\uff0c\u9700\u8981\u6dfb\u52a0\u4e00\u4e9b\u7279\u5224\u3002\u5e76\u4e14\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u968f\u5373\u5207\u6362\u4ee3\u7406$IP$,\u8bf7\u6c42\u5934\u7684\u9a9a\u64cd\u4f5c\u5c1d\u8bd5\u4e0d\u88ab\u8bc6\u522b\u4e3a\u7a0b\u5e8f\u3002 ~~\u4e8b\u5b9e\u4e0a\u5e76\u6ca1\u4ec0\u4e48\u5375\u7528\uff0c200\u4e2a\u8bf7\u6c42\u540e\u4e00\u5b9a\u4f1a\u88ab\u62e6\u622a~~ \u5b9e\u4f8b:\u83b7\u53d6b\u7ad9\u8bc4\u8bba # my_headers.py import random my_headers = [ \"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\", \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14\", \"Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)\", 'Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11', 'Opera/9.25 (Windows NT 5.1; U; en)', 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)', 'Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.5 (like Gecko) (Kubuntu)', 'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12', 'Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9', \"Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.7 (KHTML, like Gecko) Ubuntu/11.04 Chromium/16.0.912.77 Chrome/16.0.912.77 Safari/535.7\", \"Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0 \", 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63' ] proxy_list = [ '183.95.80.102:8080', '123.160.31.71:8080', '115.231.128.79:8080', '166.111.77.32:80', '43.240.138.31:8080', '218.201.98.196:3128', '47.94.230.42:9999', '192.168.131.1:8080' ] def headers(origin_url): num = random.randint(0, 13) hea = { 'user-agent': my_headers[num], 'referer': origin_url } return hea def proxy(): num = random.randint(0, 7) pro = { 'http': proxy_list[num] } return pro def Proxy(): prox = '' for i in range(0, 4): num = random.randint(1, 255) if i == 3: prox = prox + str(num) + ':' else: prox = prox + str(num) + '.' prox = prox + '8080' pro = { 'http': prox } return pro # normal_get_review.py import os import requests as req import json import re import openpyxl import openpyxl.styles import my_headers as mh or_url = r'https://api.bilibili.com/x/v2/reply/main?csrf=289e176593e8271d3d55f66616' \\ r'bc8ed0&mode=3&next={}&oid=845534966&plat=1&type=1' bv_url = r'https://www.bilibili.com/video/BV1Q54y157AT?spm_id_from=333.999.0.' \\ r'0&vd_source=291e2d237373b8b9b036cf97aa555083' more_rev_url = r'https://api.bilibili.com/x/v2/reply/reply?csrf=289e176593e8271d3d55f66616bc8ed0&oid=84553496' \\ r'6&pn={}&ps=10&root={}&type=1' dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili_review' if not os.path.exists(dirt): os.mkdir(dirt) def get_title(html): tmp = re.compile(r'\"videoData\":.*?\"pic\":.*?,\"title\":\"(.*?)\",\"pubdate\":') lst = re.findall(tmp, html) title = lst[0] return title def get_html(url): h = mh.headers(bv_url) p = mh.Proxy() # print(p['http'] + h['user-agent']) resp = req.get(url, headers=h, proxies=p) html = resp.text return html def write_json(json_dic, cnt): obj = json.dumps(json_dic, ensure_ascii=False) with open('review{}.json'.format(cnt), 'w', encoding='utf-8') as f: f.write(obj) def get_json(html, cnt): json_dic = json.loads(html) write_json(json_dic, cnt) return json_dic def write_rev(dic, rev_lst, num): name = dic[\"member\"][\"uname\"] if num > 0: name = str(num) + '_' + name content = dic[\"content\"][\"message\"] rev_lst.append([name, content]) return dic[\"rpid\"] def write_review(): os.chdir(dirt) rev_lst = [] title = get_title(get_html(bv_url)) for i in range(0, 10): now_url = or_url.format(i) html = get_html(now_url) dic = get_json(html, i) lst = dic[\"data\"][\"replies\"] user_num = 1 for new_dic in lst: rpid = write_rev(new_dic, rev_lst, -1) cnt = 1 while True: try: more_url = more_rev_url.format(cnt, rpid) tmp_html = get_html(more_url) tmp_dic = get_json(tmp_html, i) state = tmp_dic[\"message\"] if state == \"\u8bf7\u6c42\u88ab\u62e6\u622a\": print(state) break else: tmp_lst = tmp_dic[\"data\"][\"replies\"] if type(tmp_lst) == type([]): for every_dic in tmp_lst: write_rev(every_dic, rev_lst, user_num) else: break except req.exceptions.InvalidURL: break cnt += 1 # print(cnt) user_num += 1 workbook = openpyxl.Workbook() sheet = workbook.active sheet.title = '\u8bc4\u8bba' sheet.append(['\u7528\u6237\u540d\u79f0', '\u8bc4\u8bba\u5185\u5bb9']) num = 1 sheet.column_dimensions['A'].width = 30 sheet.column_dimensions['B'].width = 300 sheet.row_dimensions[num].height = 25 for name, content in rev_lst: sheet.append([name, content]) num += 1 sheet.row_dimensions[num].height = 20 workbook.save(\"\u8bc4\u8bba_1_\" + title + \".xlsx\") if __name__ == '__main__': write_review() 9.4 update \u540e\u6765\u53d1\u73b0\uff0c\u53ea\u8981\u5728\u8bf7\u6c42\u4e4b\u95f4\u52a0\u4e2a\u4e00\u79d2\u95f4\u9694 time.sleep(1) \u5c31\u4e0d\u4f1a\u88ab\u62e6\u622a\u4e86\uff0c\u4e50 \u4e94.\u722c\u53d6pixiv \u56fe\u7247 \u6316\u4e2a\u5751\uff0c\u5bd2\u5047\u518d\u586b \u516d.\u7eafpython\u7684vpn \u5bd2\u5047\u586b\u5751 update 2023.1.25 \u5bd2\u5047\u586bnmb\u5751\uff0c\u8fd8\u670950\u5929\u82f1\u8bed\u9ad8\u8003\u4e86 \u6691\u5047\u518d\u586b","title":"python \u722c\u866b\u603b\u7ed3"},{"location":"my%20past/python/spider/#python","text":"\u722c\u866b\u4e3b\u8981\u9488\u5bf9b\u7ad9\u7684\u8d44\u6e90\u83b7\u53d6\uff0c\u56e0\u4e3ab\u7ad9\u7684\u53cd\u722c\u673a\u5236\u8fd8\u662f\u53ef\u4ee5\u7684","title":"python \u722c\u866b\u603b\u7ed3"},{"location":"my%20past/python/spider/#b","text":"","title":"\u4e00.b\u7ad9\u56fe\u7247\u7684\u83b7\u53d6"},{"location":"my%20past/python/spider/#1img","text":"\u7b2c\u4e00\u79cd\u65b9\u6cd5\u662f\uff0c\u4f7f\u7528$requests$\u6a21\u5757\u83b7\u53d6b\u7ad9\u7f51\u9875\u6e90\u4ee3\u7801\uff0c\u901a\u8fc7\u6b63\u5219\u8868\u8fbe\u5f0f\u89e3\u6790\u51fa\u94fe\u63a5($img$\u6807\u7b7e\u7684\u89e3\u6790)\uff0c\u518d\u8bbf\u95ee\u8fd9\u4e9b\u94fe\u63a5\u8fdb\u884c\u56fe\u7247\u7684\u50a8\u5b58\u3002 \u5b9e\u4f8b:b\u7ad9\u4e3b\u9875\u90e8\u5206\u9759\u6001\u56fe\u7247\u7684\u83b7\u53d6 import time import requests import re import os from bs4 import BeautifulSoup headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } def get_html(url_base): response = requests.get(url_base, headers=headers) html = response.text return html def get_url(html): Img = re.compile(r'img.*src=\"(.*?)\"') soup = BeautifulSoup(html, \"html.parser\") data = [] for item in soup.find_all('img'): item = str(item) pic_list = re.findall(Img, item) for t in pic_list: data.append(t) return data def save_pic(data, lim): cnt = 0 for i in data: if not i.lower().startswith('https:'): i = 'https:' + i try: img = requests.get(i) byte = img.content with open(\"image{}.jpg\".format(cnt), \"wb\") as f: f.write(byte) cnt += 1 print(\"downloaded:{}\".format(cnt)) except requests.exceptions.InvalidURL: pass time.sleep(0.25) if cnt >= lim: break def get_image(url_base, target_dir, pic_num): if not os.path.exists(target_dir): os.mkdir(target_dir) html = get_html(url_base) data = get_url(html) os.chdir(target_dir) print(\"target dir: \"+str(os.getcwd())) save_pic(data, pic_num) if __name__ == '__main__': url = r'https://www.bilibili.com/' #input(\"\u8bf7\u8f93\u5165\u7f51\u5740:\") dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili\u4e3b\u9875_1' #input(\"\u8bf7\u8f93\u5165\u76ee\u6807\u6587\u4ef6\u5939:\") num = int(input(\"\u8bf7\u8f93\u5165\u60f3\u8981\u83b7\u53d6\u7684\u56fe\u7247\u6570\u91cf:\")) get_image(url, dirt, num) \u4e0d\u8fc7\uff0c\u8fd9\u79cd\u65b9\u6cd5\u53ea\u80fd\u83b7\u53d6b\u7ad9\u90e8\u5206\u7f51\u9875\u7684\u56fe\u7247\uff0c\u5176\u4ed6\u7f51\u9875\uff0c\u4f8b\u5982B\u7ad9\u4e3b\u9875\u7684\u56fe\u7247\u51e0\u4e4e\u90fd\u662f\u7528$js$\u6e32\u67d3\u51fa\u6765\u7684\uff0c\u5728\u9759\u6001\u7f51\u9875\u4e2d\u4e0d\u663e\u793a\u3002","title":"1.\u901a\u8fc7\u9759\u6001\u7f51\u9875img\u6807\u7b7e\u83b7\u53d6"},{"location":"my%20past/python/spider/#2img","text":"\u56e0\u6b64\uff0c\u7b2c\u4e8c\u79cd\u65b9\u6cd5\u662f\u4f7f\u7528$seleium$\u83b7\u53d6\u5f53\u524d\u7f51\u9875\u7684\u52a8\u6001\u4ee3\u7801\uff0c\u518d\u83b7\u53d6\u94fe\u63a5\u3002 \u8fd9\u79cd\u65b9\u6cd5\u4e00\u5b9a\u80fd\u83b7\u53d6\u56fe\u7247\uff0c\u56e0\u4e3a\u4f60\u770b\u5230\u7684\u56fe\u7247\uff0c\u90fd\u5728\u52a8\u6001\u4ee3\u7801\u4e2d\uff0c\u800c$selenium$\u90fd\u80fd\u591f\u83b7\u53d6\u4e0b\u6765\u3002\u4f46\u662f\uff0c$selenium$\u9875\u53ea\u80fd\u83b7\u53d6\u5df2\u7ecf\u52a0\u8f7d\u7684\u56fe\u7247\uff0c\u56e0\u6b64\u8981\u81ea\u52a8\u8bbe\u7f6e\u5c06\u7f51\u9875\u4e0b\u79fb\u5230\u5e95\u90e8\uff0c\u5982\u679c\u60f3\u8981\u83b7\u53d6\u591a\u4e2a\u7f51\u9875\u7684\u56fe\u7247\uff0c\u8fd8\u9700\u8981\u8bbe\u7f6e\u7ffb\u9875\u3002\u5e76\u4e14\u901f\u5ea6\u4e5f\u4e0d\u5982$requests$\u5feb\u3002 \u5b9e\u4f8b:\u83b7\u53d6b\u7ad9\u4e3b\u9875\u7684\u56fe\u7247 # selenium_get_html.py from selenium import webdriver import time def get_html(url_base): driver = webdriver.Edge() driver.get(url_base) for i in range(0, 10): # \u63a7\u5236\u7f51\u9875\u5411\u4e0b\u6eda\u52a81000\u50cf\u7d20\u503c driver.execute_script(\"window.scrollBy(0,1000)\") time.sleep(1) driver.encoding = 'UTF-8' return driver.page_source if __name__ == '__main__': url = r'https://www.bilibili.com/' # selenium_get_image.py import time import requests import re import os from bs4 import BeautifulSoup import selenium_get_html as sgh headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } def get_html(url_base): response = requests.get(url_base, headers=headers) html = response.text return html def get_url(html): Img = re.compile(r'img.*src=\"(.*?)\"') soup = BeautifulSoup(html, \"html.parser\") data = [] for item in soup.find_all('img'): item = str(item) pic_list = re.findall(Img, item) for t in pic_list: data.append(t) return data def save_pic(data, lim): cnt = 0 for i in data: if not i.lower().startswith('https:'): i = 'https:' + i try: img = requests.get(i) byte = img.content with open(\"image{}.jpg\".format(cnt), \"wb\") as f: f.write(byte) cnt += 1 print(\"downloaded:{}\".format(cnt)) except requests.exceptions.InvalidURL: pass time.sleep(0.25) if cnt >= lim: break def get_image(url_base, target_dir, pic_num): if not os.path.exists(target_dir): os.mkdir(target_dir) html = sgh.get_html(url_base) data = get_url(html) os.chdir(target_dir) print(\"target dir: \"+str(os.getcwd())) save_pic(data, pic_num) if __name__ == '__main__': url = r'https://www.bilibili.com/' #input(\"\u8bf7\u8f93\u5165\u7f51\u5740:\") dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili\u4e3b\u9875_1' #input(\"\u8bf7\u8f93\u5165\u76ee\u6807\u6587\u4ef6\u5939:\") num = int(input(\"\u8bf7\u8f93\u5165\u60f3\u8981\u83b7\u53d6\u7684\u56fe\u7247\u6570\u91cf:\")) get_image(url, dirt, num)","title":"2.\u901a\u8fc7\u52a8\u6001\u7f51\u9875img\u6807\u7b7e\u83b7\u53d6"},{"location":"my%20past/python/spider/#3","text":"\u7b2c\u4e09\u79cd\u65b9\u6cd5\uff0c\u662f\u901a\u8fc7$F12$\u63a7\u5236\u53f0\"\u7f51\u7edc\"\u754c\u9762\u6279\u91cf\u83b7\u53d6\u6570\u636e\u6587\u4ef6\u7684\u94fe\u63a5\uff0c\u5728\u901a\u8fc7\u89e3\u6790\u8fd9\u4e9b\u6587\u4ef6\u7684\u6570\u636e\u6765\u83b7\u53d6\u56fe\u7247\u94fe\u63a5\uff0c\u8fdb\u800c\u83b7\u53d6\u56fe\u7247\u3002 \u8fd9\u79cd\u65b9\u6cd5\u9700\u8981\u5145\u5206\u4e86\u89e3\u7f51\u7ad9\u4f20\u8f93\u4e86\u90a3\u4e9b\u6587\u4ef6\uff0c\u54ea\u4e2a\u6587\u4ef6\u4e2d\u6709\u6709\u7528\u7684\u6570\u636e\uff0c\u56e0\u6b64\u6bd4\u8f83\u70e6\uff0c\u4f46\u662f\u4e0d\u9700\u8981\u7528$selenium$\u4e5f\u53ef\u4ee5\u83b7\u53d6\u5927\u91cf\u56fe\u7247\u3002 \u5b9e\u4f8b:\u83b7\u53d6b\u7ad9\u65b0\u756a\u699cTop200\u56fe\u7247 import requests import json import os headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } dirt = r'C:\\Users\\Yimen\\Desktop\\\u65b0\u756a\u699cTop200' front_url = r'https://api.bilibili.com/pgc/season/index/result?season_version=-1&spoken_language_type=-1&area=-1' \\ r'&is_finish=-1&copyright=-1&season_status=-1&season_month=-1&year=-1&style_id=-1&order=3&st=1&sort=0&page=' back_url = r'&season_type=1&pagesize=20&type=1' if not os.path.exists(dirt): os.mkdir(dirt) def write_json(html, num): _dirt = os.path.join(dirt, 'list{}.json'.format(num)) print('NO.' + str(num) + ' printed') with open(_dirt, 'wb') as f: f.write(html) def get_json(): lst = [] for i in range(6, 11): url = front_url + str(i) + back_url try: response = requests.get(url, headers=headers) html = response.content.decode() dic = json.loads(html) lst.append(dic) # write_json(html, i) except requests.exceptions.InvalidURL: pass return lst def save_pic(lst): os.chdir(dirt) num = 0 for dic in lst: _lst = dic[\"data\"][\"list\"] for _dic in _lst: num += 1 pic_url = _dic[\"cover\"] pic_name = _dic[\"title\"] # + \"_\" + _dic[\"subTitle\"] response = requests.get(pic_url, headers=headers) pic_byte = response.content pic_dirt = str(num) + '_' + pic_name + '.jpg' print(pic_dirt + ' printed') with open(pic_dirt, 'wb') as f: f.write(pic_byte) if __name__ == '__main__': save_pic(get_json()) ~~\u8fd9\u4e2a\u5b9e\u4f8b\u6709\u70b9\u95ee\u9898\uff0c\u5c31\u662f\u5982\u679c\u65b0\u756a\u7684\u540d\u79f0\u4e2d\u542b\u6709\"\u5947\u7279\"\u7684\u7b26\u53f7\uff0c\u5c31\u4f1a\u62a5\u9519\uff0c\u4e0d\u8fc7\u4e0d\u663e\u793a\u65b0\u756a\u540d\u5b57\uff0c\u7528\u6570\u5b57\u5c31\u884c\u4e86\u3002~~","title":"3.\u901a\u8fc7\u5206\u6790\"\u7f51\u7edc\"\u6570\u636e"},{"location":"my%20past/python/spider/#4","text":"b\u7ad9\u4e3b\u9875\u7684\u56fe\u7247\u8fd8\u6709\u4e00\u79cd\u83b7\u53d6\u65b9\u6cd5\uff0c\u5c31\u662f\u5c06\u6e90\u4ee3\u7801\u4e2d\u7684$script$\u6807\u7b7e\u4e2d\u7684$json$\u4e32\u53d6\u51fa\u6765\uff0c\u5206\u6790\u5176\u4e2d\u7684\u94fe\u63a5\u6765\u83b7\u53d6\u3002\u8fd9\u91cc\u4ee3\u7801\u7701\u7565\u3002","title":"4.\u901a\u8fc7\u5206\u6790\u6e90\u4ee3\u7801\u6570\u636e"},{"location":"my%20past/python/spider/#5","text":"\u722c\u866b\u5171\u6709\u4e24\u79cd\u65b9\u6cd5\uff0c\u4e00\u79cd\u662f\u83b7\u53d6\u7f51\u9875\u6e90\u4ee3\u7801\u5e76\u901a\u8fc7\u89e3\u6790\u6807\u7b7e\u83b7\u53d6\u94fe\u63a5\uff1b\u4e00\u79cd\u662f\u901a\u8fc7\u5bf9\u7f51\u7edc\u4f20\u8f93\u7684\u6570\u636e\u8fdb\u884c\u5206\u6790\uff0c\u4ece\u4e2d\u627e\u5230\u89c4\u5f8b\u5e76\u83b7\u53d6\u6709\u7528\u7684\u94fe\u63a5\u3002\u83b7\u53d6\u7f51\u9875\u6e90\u4ee3\u7801\u6807\u7b7e\u53c8\u5206\u4e3a\u9759\u6001\u83b7\u53d6\u548c\u52a8\u6001\u83b7\u53d6\u3002\u5982\u679c\u7f51\u9875\u5b8c\u5168\u9759\u6001\uff0c\u65e0$js$\u6e32\u67d3\uff0c\u5c31\u53ef\u4ee5\u7528$requests$\u83b7\u53d6\u7f51\u9875\u6807\u7b7e\u3002\u5982\u679c\u7f51\u9875\u4e3a\u52a8\u6001\u52a0\u8f7d\uff0c\u5219\u9700\u8981\u7528\u5230$selenium$\u3002\u800c\u6570\u636e\u5206\u6790\u5982\u679c\u505a\u7684\u597d\uff0c\u90a3\u4e48\u52a8\u6001\u7f51\u9875\u4e5f\u53ef\u4ee5\u76f4\u63a5\u901a\u8fc7$requests$\u8bbf\u95ee\u94fe\u63a5\u3002","title":"5.\u603b\u7ed3"},{"location":"my%20past/python/spider/#b_1","text":"","title":"\u4e8c.\u83b7\u53d6b\u7ad9\u5f39\u5e55"},{"location":"my%20past/python/spider/#1","text":"\u901a\u8fc7\u89c2\u5bdf\u7f51\u9875\u6e90\u4ee3\u7801\uff0c\u6211\u4eec\u53d1\u73b0\u5f39\u5e55\u4e5f\u662f$js$\u6e32\u67d3\u51fa\u6765\u7684\uff0c\u6240\u4ee5\u7406\u8bba\u4e0a\u53ef\u4ee5\u7528$selenium$\u83b7\u53d6\uff0c\u4f46\u662f\u5f39\u5e55\u65f6\u523b\u5728\u53d8\uff0c\u7528$selenium$\u5c31\u8981\u628a\u89c6\u9891\u5168\u770b\u4e00\u904d\u624d\u80fd\u83b7\u53d6\u5b8c\u6574\u5f39\u5e55\u3002","title":"1.\u52a8\u6001\u83b7\u53d6"},{"location":"my%20past/python/spider/#2","text":"\u901a\u8fc7\u5206\u6790\u7f51\u7edc\u4f20\u8f93\u7684\u6570\u636e\uff0c\u6211\u4eec\u53d1\u73b0\u5728$seg.so$\u4e2d\u50a8\u5b58\u7740\u5f39\u5e55\u7684\u6570\u636e\uff0c\u5e76\u4e14\u6240\u6709\u94fe\u63a5\u53ea\u6709$index$\u4e0d\u540c\uff0c\u53ef\u4ee5\u6279\u91cf\u83b7\u53d6\u3002\u4f46\u662f\uff0c$.so$\u6587\u4ef6\u4e3a\u4e8c\u8fdb\u5236\u6587\u4ef6\uff0c\u5f88\u96be\u89e3\u7801\u3002~~\u6211\u8bd5\u4e86\u4e00\u5929\uff0c\u65e0\u679c\u3002~~\u8fd9\u79cd\u65b9\u6cd5\u7406\u8bba\u4e0a\u6765\u8bf4\u53ef\u4ee5\u83b7\u53d6\u5168\u90e8\u5f39\u5e55\uff0c\u4f46\u662f\u65e0\u6cd5\u89e3\u6790\u6570\u636e\u6587\u4ef6\uff0c\u5c31\u5bc4\u4e86\u3002","title":"2.\u5206\u6790\u6570\u636e"},{"location":"my%20past/python/spider/#3_1","text":"~~\u901a\u8fc7\u770b\u7f51\u53cb\u4eec\u7684\u65b9\u6cd5~~\uff0c\u6211\u4eec\u53d1\u73b0b\u7ad9\u4e00\u4e2a\u53e4\u8001\uff0c\u5df2\u5e9f\u5f03\u7684\u50a8\u5b58\u5f39\u5e55\u7684\u65b9\u5f0f:$https://comment.bilibili.com/{cid}.xml$,\u8fd9\u4e2a\u94fe\u63a5\u91cc\u5b58\u653e\u7740\u8be5\u89c6\u9891\u90e8\u5206\u7684\u5f39\u5e55(\u6709\u65f6\u5168\uff0c\u6709\u65f6\u4e0d\u5168)\u3002\u800c$cid$\u5c31\u653e\u5728\u7f51\u9875\u6e90\u4ee3\u7801\u91cc\u3002\u6240\u4ee5\uff0c\u6b64\u6cd5\u53ef\u884c\u3002 import re import requests import os import openpyxl import openpyxl.styles headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } or_url = r'https://www.bilibili.com/video/{}?spm_id_from=333.337.search-card.all.click' dm_url = r'https://comment.bilibili.com/{}.xml' bv_id = r'BV1yG4y1r77N' # input('\u8f93\u5165bv\u53f7:') dirt = r'C:\\Users\\Yimen\\Desktop' def get_html(): resp = requests.get(or_url.format(bv_id)) html = resp.text with open('danmaku.html', 'w', encoding='utf-8') as f: f.write(html) return html def get_cid(html): # tmp = re.compile(r'\"videoData\":.*?\"dynamic\":.*?,\"cid\":(.*?),\"dimension\":') lst = re.findall(tmp, html) cid = lst[0] return cid def get_title(html): tmp = re.compile(r'\"videoData\":.*?\"pic\":.*?,\"title\":\"(.*?)\",\"pubdate\":') lst = re.findall(tmp, html) title = lst[0] return title def write_xml(xml): with open('danmaku.xml', 'w', encoding='utf-8') as f: f.write(xml) def get_xml(cid): resp = requests.get(dm_url.format(cid)) xml = resp.content.decode() #write_xml(xml) return xml def get_time(tm): tm = float(tm) min = int(tm / 60) sec = int(tm - min * 60) smin = str(min) ssec = str(sec) if min < 10: smin = '0' + smin if sec < 10: ssec = '0' + ssec word = smin + ':' + ssec return word def get_color(cl): color_val = str(hex(cl)).upper()[2:] # print(color_val) color_len = len(color_val) if color_len < 6: for i in range(0, 6 - color_len): color_val = \"0\" + color_val if color_val == \"FFFFFF\": color_val = \"000000\" return color_val def get_danmaku(xml, title): tmp = re.compile(r'<d p=\"(.*?),.*?,.*?,(.*?),.*?\">(.*?)</d>') tmp_lst = re.findall(tmp, xml) lst = [] for i in tmp_lst: lst.append([float(i[0]), int(i[1]), i[2]]) lst.sort(reverse=False) os.chdir(dirt) workbook = openpyxl.Workbook() sheet = workbook.active sheet.title = '\u5f39\u5e55' sheet.append(['\u51fa\u73b0\u65f6\u95f4', '\u5f39\u5e55\u5185\u5bb9']) num = 1 sheet.column_dimensions['A'].width = 15 sheet.column_dimensions['B'].width = 150 sheet.row_dimensions[num].height = 25 for tm, cl, dm in lst: sheet.append([get_time(tm), dm]) num += 1 sheet.row_dimensions[num].height = 20 pos = 'B' + str(num) cell = sheet[pos] color_val = get_color(cl) cell.font = openpyxl.styles.Font(name=\"\u5fae\u8f6f\u96c5\u9ed1\", size=10, bold=True, italic=False, color=\"\" + color_val + \"\") workbook.save(\"\u5f39\u5e55_\" + title + \".xlsx\") if __name__ == '__main__': html = get_html() cid = get_cid(html) title = get_title(html) xml = get_xml(cid) get_danmaku(xml, title) \u53e6\u5916\uff0c\u8fd9\u65b9\u6cd5\u83b7\u53d6\u7684\u5f39\u5e55\u4e0d\u53ea\u6709\u5185\u5bb9\uff0c\u8fd8\u6709\u65f6\u95f4\u548c\u989c\u8272\u7b49\u4fe1\u606f\uff0c\u6240\u4ee5\u7528$excel$\u8868\u683c\u5448\u73b0\u8fd9\u4e9b\u5185\u5bb9\u518d\u5408\u9002\u4e0d\u8fc7\u3002","title":"3.\u5947\u5999\u65b9\u6cd5"},{"location":"my%20past/python/spider/#b_2","text":"~~\u5230\u4e86\u5927boss\u4e86,\u5f53\u521d\u5b66\u722c\u866b\u5c31\u662f\u4e3a\u4e86\u8fd9\u4e2a~~","title":"\u4e09.b\u7ad9\u89c6\u9891\u7684\u83b7\u53d6"},{"location":"my%20past/python/spider/#1_1","text":"\u4e00\u79cd\u7701\u65f6\u53c8\u7701\u4e8b\u7684\u65b9\u6cd5\u662f\u7528$you$-$get$\u83b7\u53d6\u89c6\u9891\u3002~~\u56e0\u6b64\uff0c\u6b64\u8d34\u5b8c\u7ed3~~","title":"1.\u7701\u4e8b\u8fd8\u662f\u8d39\u4e8b"},{"location":"my%20past/python/spider/#2_1","text":"\u6211\u4eec\u5b66$python$\u722c\u866b\u4e0d\u662f\u4e3a\u4e86\u7701\u4e8b\uff0c\u800c\u662f\u4e3a\u4e86\u5b66\u4e60\u8fd9\u5176\u4e2d\u7684\u539f\u7406\u3002~~\u8981\u662f\u4e3a\u4e86\u7701\u4e8b\uff0c\u82b1\u94b1\u8ba9\u522b\u4eba\u5e2e\u81ea\u5df1\u505a\u5c82\u4e0d\u662f\u66f4\u723d~~ \u6211\u4eec\u53d1\u73b0\uff0c\u7f51\u9875\u6e90\u4ee3\u7801\u4e2d\u7684$script$\u6807\u7b7e\u4e2d\u5c31\u542b\u6709\u89c6\u9891\u7684\u4fe1\u606f\uff0c\u4e0d\u8fc7b\u7ad9\u89c6\u9891\u5206\u4e3a\u89c6\u9891\u548c\u97f3\u9891\u3002 \u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u5c06$script$\u6807\u7b7e\u4e2d\u7684$json$\u4e32\u53d6\u51fa\u6765\uff0c\u518d\u5206\u6790\u6587\u4ef6\u5f97\u5230\u89c6\u9891\u548c\u97f3\u9891\u7684\u94fe\u63a5\uff0c\u5206\u522b\u4e0b\u8f7d\u5373\u53ef\u3002 \u5b9e\u4f8b:\u83b7\u53d6b\u7ad9\u89c6\u9891 import os import re import requests as req import json headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } or_url = r'https://www.bilibili.com/video/{}' ep_url = r'https://www.bilibili.com/bangumi/play/{}?from_spmid=666.25.episode.0&from_outer_spmid=333.337.0.0' bv_id = r'BV1ua4y1H714?p=2' # input('\u8f93\u5165bv\u53f7:') ep_id = r'ep517946' dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili_video' if not os.path.exists(dirt): os.mkdir(dirt) def write_html(html): with open('video.html', 'w', encoding='utf-8') as f: f.write(html) def get_html(url): resp = req.get(url, headers=headers) html = resp.content.decode() # write_html(html) return html def write_json(json_dic): with open('video.json', 'w', encoding='utf-8') as f: json.dump(json_dic, f) def get_json(html): tmp = re.compile(r'<script>window.__playinfo__=(.*?)</script>') json_text = re.findall(tmp, html)[0] json_dic = json.loads(json_text) # write_json(json_dic) return json_dic def get_times(): with open('times.json', 'r') as f: dic = json.load(f) cnt = dic[\"times\"] dic[\"times\"] += 1 with open('times.json', 'w') as f: json.dump(dic, f) return cnt def get_video_clip(dic): re_url = or_url.format(bv_id) _headers_ = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63', 'Referer': re_url } cnt = get_times() os.chdir(dirt) url = dic['data']['dash']['video'][0]['base_url'] print(\"\u89c6\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5\") resp = req.get(url, headers=_headers_) print(\"\u89c6\u9891\u83b7\u53d6\u5b8c\u6bd5\") vid = resp.content print(\"\u6b63\u5728\u4fdd\u5b58\u89c6\u9891...\") with open('video_{}.mp4'.format(cnt), 'wb') as f: f.write(vid) print(\"\u4fdd\u5b58\u5b8c\u6bd5\uff01\") url = dic['data']['dash']['audio'][0]['base_url'] print(\"\u97f3\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5\") resp = req.get(url, headers=_headers_) print(\"\u97f3\u9891\u83b7\u53d6\u5b8c\u6bd5\") vid = resp.content print(\"\u6b63\u5728\u4fdd\u5b58\u97f3\u9891...\") with open('audio_{}.mp3'.format(cnt), 'wb') as f: f.write(vid) print(\"\u4fdd\u5b58\u5b8c\u6bd5\uff01\") def init(): with open('times.json', 'w') as f: json.dump({\"times\": 0}, f) if __name__ == '__main__': get_video_clip(get_json(get_html(or_url.format(bv_id)))) \u4ec5\u4ec5\u83b7\u53d6\u5206\u5f00\u7684\u97f3\u9891\u548c\u89c6\u9891\u8fd8\u4e0d\u591f\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u5c06\u4ed6\u4eec\u8fdb\u884c\u5408\u5e76\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u7528$ffmpeg$\u5b9e\u73b0\u5c06\u97f3\u89c6\u9891\u5408\u5e76\u7684\u64cd\u4f5c\u3002\u5f53\u7136\uff0c\u4f7f\u7528$moviepy.editor$\u4e5f\u53ef\u4ee5\u5408\u5e76\u97f3\u89c6\u9891\uff0c\u4f46\u662f\u901f\u5ea6\u8981\u8fdc\u6162\u4e8e$ffmpeg$\u3002 \u6ce8\u610f\uff0c$ffmpeg$\u4e3a\u975e\u7cfb\u7edf\u7a0b\u5e8f\uff0c\u6240\u4ee5\u8981\u5c06\u7edd\u5bf9\u8def\u5f84\u8f93\u5165\u547d\u4ee4\u884c\u4e2d\uff0c\u4e0d\u7136\u4f1a\u62a5\u9519\u3002 \u5173\u4e8e$ffmpeg$\u7684\u5b89\u88c5:\u5148\u5c06\u5b98\u7f51\u4e0b\u8f7d\u7684$.zip$\u6587\u4ef6\u89e3\u538b\u7f29\uff0c\u5c06\u6587\u4ef6\u5939\u653e\u5165\u4efb\u610f\u4f4d\u7f6e\uff0c\u5e76\u5728\u7cfb\u7edf\u53d8\u91cf\u4e2d\u6dfb\u52a0$bin$\u6587\u4ef6\u5939\u7684\u7edd\u5bf9\u8def\u5f84\u3002 # merge_video_audio.py import os import moviepy.editor as me def run_by_moviepy(audio_name, video_name, output_name): audio = me.AudioFileClip(audio_name) video = me.VideoFileClip(video_name) output = video.set_audio(audio) output.write_videofile(output_name) def run_by_ffmpeg(audio_name, video_name, output_name): cmd = f'C:\\\\Windows\\\\ffmpeg-5.1-essentials_build\\\\bin\\\\ffmpeg.exe -i {audio_name} -i {video_name} -acodec copy -vcodec copy {output_name}' os.system(cmd) # normal_get_video.py import os import re import requests as req import json import merge_video_audio as mva headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } or_url = r'https://www.bilibili.com/video/{}' ep_url = r'https://www.bilibili.com/bangumi/play/{}?from_spmid=666.25.episode.0&from_outer_spmid=333.337.0.0' bv_id = r'BV1xa411V7Tq' # input('\u8f93\u5165bv\u53f7:') ep_id = r'ep517946' dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili_video' if not os.path.exists(dirt): os.mkdir(dirt) def write_html(html): with open('video.html', 'w', encoding='utf-8') as f: f.write(html) def get_html(url): resp = req.get(url, headers=headers) html = resp.content.decode() # write_html(html) return html def write_json(json_dic): with open('video.json', 'w', encoding='utf-8') as f: json.dump(json_dic, f) def get_json(html): tmp = re.compile(r'<script>window.__playinfo__=(.*?)</script>') json_text = re.findall(tmp, html)[0] json_dic = json.loads(json_text) # write_json(json_dic) return json_dic def get_times(): with open('times.json', 'r') as f: dic = json.load(f) cnt = dic[\"times\"] dic[\"times\"] += 1 with open('times.json', 'w') as f: json.dump(dic, f) return cnt def get_title(html): tmp = re.compile(r'\"videoData\":.*?\"pic\":.*?,\"title\":\"(.*?)\",\"pubdate\":') lst = re.findall(tmp, html) title = lst[0] return title def get_video_clip(dic): re_url = or_url.format(bv_id) title = get_title(get_html(re_url)) _headers_ = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63', 'Referer': re_url } cnt = get_times() os.chdir(dirt) url = dic['data']['dash']['video'][0]['base_url'] print(\"\u89c6\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5,\u6b63\u5728\u4e0b\u8f7d\u89c6\u9891...\") resp = req.get(url, headers=_headers_) print(\"\u89c6\u9891\u83b7\u53d6\u5b8c\u6bd5\") vid = resp.content print(\"\u6b63\u5728\u4fdd\u5b58\u89c6\u9891...\") video_name = 'video_{}.mp4'.format(cnt) with open(video_name, 'wb') as f: f.write(vid) print(\"\u4fdd\u5b58\u5b8c\u6bd5\uff01\") print(\"--------------------\") url = dic['data']['dash']['audio'][0]['base_url'] print(\"\u97f3\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5\") resp = req.get(url, headers=_headers_) print(\"\u97f3\u9891\u83b7\u53d6\u5b8c\u6bd5\") vid = resp.content print(\"\u6b63\u5728\u4fdd\u5b58\u97f3\u9891...\") audio_name = 'audio_{}.mp3'.format(cnt) with open(audio_name, 'wb') as f: f.write(vid) print(\"\u4fdd\u5b58\u5b8c\u6bd5\uff01\") print(\"--------------------\") print(\"\u6b63\u5728\u5408\u5e76\u97f3\u89c6\u9891...\") output_name = 'output_{}.mp4'.format(cnt) rename = title + '.mp4' mva.run_by_ffmpeg(audio_name, video_name, output_name) os.rename(output_name, rename) print(\"\u5408\u6210\u5b8c\u6bd5!\") print(\"--------------------\") print(\"\u6b63\u5728\u6e05\u7406\u6570\u636e\u6587\u4ef6...\") os.remove(audio_name) os.remove(video_name) print(\"\u6e05\u7406\u5b8c\u6bd5!\") def init(): with open('times.json', 'w') as f: json.dump({\"times\": 0}, f) if __name__ == '__main__': get_video_clip(get_json(get_html(or_url.format(bv_id)))) \u540c\u65f6\uff0c\u7531\u4e8e\u901a\u8fc7\u89c6\u9891\u94fe\u63a5\u83b7\u53d6\u89c6\u9891\u7f51\u9875\u6e90\u7801\u7684\u8fc7\u7a0b\u6bd4\u8f83\u6162\uff0c\u53ef\u4ee5\u505a\u4e00\u4e2a\u8fdb\u5ea6\u6761\u6765\u663e\u793a\u5f53\u524d\u7684\u4e0b\u8f7d\u8fdb\u5ea6\u3002\u518d\u5b58\u50a8\u89c6\u9891\u6587\u4ef6\u65f6\uff0c\u6211\u4eec\u8fd8\u8981\u6ce8\u610f\u547d\u540d:\u5982\u679c\u51fa\u73b0\u91cd\u540d\uff0c\u8981\u81ea\u52a8\u751f\u6210\u65b0\u540d\u5b57(\"_\" + \u6570\u5b57)\uff1b\u5982\u679c\u540d\u5b57\u4e2d\u542b\u6709\u975e\u6cd5\u5b57\u7b26\uff0c\u5c31\u81ea\u52a8\u4fdd\u5b58\u4e3a\u6307\u5b9a\u7684\u540d\u5b57(\"output.mp4\")\u3002 # download_process_bar.py from contextlib import closing import requests as req hea = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } def download_with_process_bar(url, filename, headers=None): if headers is None: headers = hea with closing(req.get(url, headers=headers, stream=True)) as resp: chunk_size = 1024 content_size = int(resp.headers['content-length']) data_count = 0 with open(filename, 'wb') as f: for data in resp.iter_content(chunk_size=chunk_size): f.write(data) done_block = int((data_count / content_size) * 50) data_count = data_count + len(data) now_percent = (data_count / content_size) * 100 print(\"\\r [%s%s] %d%% \" % (done_block * '\u2588', ' ' * (50 - 1 - done_block), now_percent), end=\" \") \u8fd9\u91cc\u7684$closing$\u662f\u4e3a\u4e86\u5c06$req.get$\u81ea\u52a8\u751f\u6210\u4e0a\u4e0b\u6587\u7ba1\u7406\uff0c\u8fd9\u6837\u624d\u80fd\u7528$with$\u6253\u5f00\uff1b$resp.iter_content$\u5219\u53ef\u4ee5\u5c06\u6587\u4ef6\u5206\u6bb5\uff0c\u4ee5\u663e\u793a\u51fa\u8fdb\u5ea6\u6761\u3002'\\r'\u662f\u4e3a\u4e86\u8ba9\u8f93\u51fa\u663e\u793a\u5728\u540c\u4e00\u884c\uff0c\u4f5c\u7528\u662f\u8ba9\u5149\u6807\u56de\u5230\u884c\u9996\u3002 # normal_get_video.py import os import re import requests as req import json import merge_video_audio as mva import download_process_bar as dpb headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63' } or_url = r'https://www.bilibili.com/video/{}' ep_url = r'https://www.bilibili.com/bangumi/play/{}?from_spmid=666.25.episode.0&from_outer_spmid=333.337.0.0' bv_id = r'BV1254y187SE' # input('\u8f93\u5165bv\u53f7:') ep_id = r'ep517946' dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili_video' if not os.path.exists(dirt): os.mkdir(dirt) def write_html(html): with open('video.html', 'w', encoding='utf-8') as f: f.write(html) def get_html(url): resp = req.get(url, headers=headers) html = resp.content.decode() # write_html(html) return html def write_json(json_dic): with open('video.json', 'w', encoding='utf-8') as f: json.dump(json_dic, f) def get_json(html): tmp = re.compile(r'<script>window.__playinfo__=(.*?)</script>') json_text = re.findall(tmp, html)[0] json_dic = json.loads(json_text) # write_json(json_dic) return json_dic def get_times(): with open('times.json', 'r') as f: dic = json.load(f) cnt = dic[\"times\"] dic[\"times\"] += 1 with open('times.json', 'w') as f: json.dump(dic, f) return cnt def get_title(html): tmp = re.compile(r'\"videoData\":.*?\"pic\":.*?,\"title\":\"(.*?)\",\"pubdate\":') lst = re.findall(tmp, html) title = lst[0] return title def get_video_clip(dic): re_url = or_url.format(bv_id) title = get_title(get_html(re_url)) _headers_ = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0' '.5112.102 Safari/537.36 Edg/104.0.1293.63', 'Referer': re_url } cnt = get_times() os.chdir(dirt) url = dic['data']['dash']['video'][0]['base_url'] print(\"\u89c6\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5,\u6b63\u5728\u4e0b\u8f7d\u89c6\u9891...\") video_name = 'video_{}.mp4'.format(cnt) dpb.download_with_process_bar(url, video_name, _headers_) print(\"\u4e0b\u8f7d\u5b8c\u6bd5\uff01\") print(\"--------------------\") url = dic['data']['dash']['audio'][0]['base_url'] print(\"\u97f3\u9891\u94fe\u63a5\u83b7\u53d6\u5b8c\u6bd5\") resp = req.get(url, headers=_headers_) print(\"\u97f3\u9891\u83b7\u53d6\u5b8c\u6bd5\") vid = resp.content print(\"\u6b63\u5728\u4fdd\u5b58\u97f3\u9891...\") audio_name = 'audio_{}.mp3'.format(cnt) with open(audio_name, 'wb') as f: f.write(vid) print(\"\u4fdd\u5b58\u5b8c\u6bd5\uff01\") print(\"--------------------\") print(\"\u6b63\u5728\u5408\u5e76\u97f3\u89c6\u9891...\") output_name = 'output_{}.mp4'.format(cnt) rename = title + '.mp4' mva.run_by_ffmpeg(audio_name, video_name, output_name) num = 0 while os.path.exists(rename): rename = title + '_' + str(num) + '.mp4' num += 1 try: os.rename(output_name, rename) except OSError: print(\"\u6587\u4ef6\u540d\u4e0d\u6b63\u786e\uff0c\u6587\u4ef6\u5c06\u81ea\u52a8\u547d\u540d\u4e3a \" + output_name + '.') pass print(\"\u5408\u6210\u5b8c\u6bd5!\") print(\"--------------------\") print(\"\u6b63\u5728\u6e05\u7406\u6570\u636e\u6587\u4ef6...\") os.remove(audio_name) os.remove(video_name) print(\"\u6e05\u7406\u5b8c\u6bd5!\") def init(): with open('times.json', 'w') as f: json.dump({\"times\": 0}, f) if __name__ == '__main__': get_video_clip(get_json(get_html(or_url.format(bv_id))))","title":"2.\u5b66\u8fd8\u662f\u4e0d\u5b66"},{"location":"my%20past/python/spider/#b_3","text":"b\u7ad9\u8bc4\u8bba\u4e0eb\u7ad9\u89c6\u9891\u7684\u83b7\u53d6\u65b9\u6cd5\u5982\u51fa\u4e00\u8f99\uff0c\u4e5f\u662f\u4ece$script$\u6807\u7b7e\u4e2d\u53d6\u51fa$json$\u4e32\uff0c\u5728\u8fdb\u884c\u4fdd\u5b58\u3002\u4e0d\u8fc7\uff0c\u8bc4\u8bba\u5177\u6709\u6811\u5f62\u7ed3\u6784\uff0c\u6240\u4ee5\u9700\u8981\u5c06\u6bcf\u4e2a\u8bc4\u8bba\u4e0b\u9762\u7684\u8ddf\u8bc4\u4e5f\u4e0b\u8f7d\u4e0b\u6765\u3002 \u8fd9\u4e2a\u8fc7\u7a0b\u5b58\u5728\u5927\u91cf\u8bbf\u95ee\u4e0d\u540c\u5730\u5740\u7684\u60c5\u51b5\uff0c\u53ef\u80fd\u4f1a\u88ab\u62e6\u622a\u3002\u56e0\u6b64\u4e3a\u4e86\u8ba9\u7a0b\u5e8f\u4e0d\u7ec8\u6b62\uff0c\u9700\u8981\u6dfb\u52a0\u4e00\u4e9b\u7279\u5224\u3002\u5e76\u4e14\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u968f\u5373\u5207\u6362\u4ee3\u7406$IP$,\u8bf7\u6c42\u5934\u7684\u9a9a\u64cd\u4f5c\u5c1d\u8bd5\u4e0d\u88ab\u8bc6\u522b\u4e3a\u7a0b\u5e8f\u3002 ~~\u4e8b\u5b9e\u4e0a\u5e76\u6ca1\u4ec0\u4e48\u5375\u7528\uff0c200\u4e2a\u8bf7\u6c42\u540e\u4e00\u5b9a\u4f1a\u88ab\u62e6\u622a~~ \u5b9e\u4f8b:\u83b7\u53d6b\u7ad9\u8bc4\u8bba # my_headers.py import random my_headers = [ \"Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\", \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:30.0) Gecko/20100101 Firefox/30.0\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_2) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/537.75.14\", \"Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Win64; x64; Trident/6.0)\", 'Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1.11) Gecko/20071127 Firefox/2.0.0.11', 'Opera/9.25 (Windows NT 5.1; U; en)', 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)', 'Mozilla/5.0 (compatible; Konqueror/3.5; Linux) KHTML/3.5.5 (like Gecko) (Kubuntu)', 'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.0.12) Gecko/20070731 Ubuntu/dapper-security Firefox/1.5.0.12', 'Lynx/2.8.5rel.1 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/1.2.9', \"Mozilla/5.0 (X11; Linux i686) AppleWebKit/535.7 (KHTML, like Gecko) Ubuntu/11.04 Chromium/16.0.912.77 Chrome/16.0.912.77 Safari/535.7\", \"Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:10.0) Gecko/20100101 Firefox/10.0 \", 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.102 Safari/537.36 Edg/104.0.1293.63' ] proxy_list = [ '183.95.80.102:8080', '123.160.31.71:8080', '115.231.128.79:8080', '166.111.77.32:80', '43.240.138.31:8080', '218.201.98.196:3128', '47.94.230.42:9999', '192.168.131.1:8080' ] def headers(origin_url): num = random.randint(0, 13) hea = { 'user-agent': my_headers[num], 'referer': origin_url } return hea def proxy(): num = random.randint(0, 7) pro = { 'http': proxy_list[num] } return pro def Proxy(): prox = '' for i in range(0, 4): num = random.randint(1, 255) if i == 3: prox = prox + str(num) + ':' else: prox = prox + str(num) + '.' prox = prox + '8080' pro = { 'http': prox } return pro # normal_get_review.py import os import requests as req import json import re import openpyxl import openpyxl.styles import my_headers as mh or_url = r'https://api.bilibili.com/x/v2/reply/main?csrf=289e176593e8271d3d55f66616' \\ r'bc8ed0&mode=3&next={}&oid=845534966&plat=1&type=1' bv_url = r'https://www.bilibili.com/video/BV1Q54y157AT?spm_id_from=333.999.0.' \\ r'0&vd_source=291e2d237373b8b9b036cf97aa555083' more_rev_url = r'https://api.bilibili.com/x/v2/reply/reply?csrf=289e176593e8271d3d55f66616bc8ed0&oid=84553496' \\ r'6&pn={}&ps=10&root={}&type=1' dirt = r'C:\\Users\\Yimen\\Desktop\\bilibili_review' if not os.path.exists(dirt): os.mkdir(dirt) def get_title(html): tmp = re.compile(r'\"videoData\":.*?\"pic\":.*?,\"title\":\"(.*?)\",\"pubdate\":') lst = re.findall(tmp, html) title = lst[0] return title def get_html(url): h = mh.headers(bv_url) p = mh.Proxy() # print(p['http'] + h['user-agent']) resp = req.get(url, headers=h, proxies=p) html = resp.text return html def write_json(json_dic, cnt): obj = json.dumps(json_dic, ensure_ascii=False) with open('review{}.json'.format(cnt), 'w', encoding='utf-8') as f: f.write(obj) def get_json(html, cnt): json_dic = json.loads(html) write_json(json_dic, cnt) return json_dic def write_rev(dic, rev_lst, num): name = dic[\"member\"][\"uname\"] if num > 0: name = str(num) + '_' + name content = dic[\"content\"][\"message\"] rev_lst.append([name, content]) return dic[\"rpid\"] def write_review(): os.chdir(dirt) rev_lst = [] title = get_title(get_html(bv_url)) for i in range(0, 10): now_url = or_url.format(i) html = get_html(now_url) dic = get_json(html, i) lst = dic[\"data\"][\"replies\"] user_num = 1 for new_dic in lst: rpid = write_rev(new_dic, rev_lst, -1) cnt = 1 while True: try: more_url = more_rev_url.format(cnt, rpid) tmp_html = get_html(more_url) tmp_dic = get_json(tmp_html, i) state = tmp_dic[\"message\"] if state == \"\u8bf7\u6c42\u88ab\u62e6\u622a\": print(state) break else: tmp_lst = tmp_dic[\"data\"][\"replies\"] if type(tmp_lst) == type([]): for every_dic in tmp_lst: write_rev(every_dic, rev_lst, user_num) else: break except req.exceptions.InvalidURL: break cnt += 1 # print(cnt) user_num += 1 workbook = openpyxl.Workbook() sheet = workbook.active sheet.title = '\u8bc4\u8bba' sheet.append(['\u7528\u6237\u540d\u79f0', '\u8bc4\u8bba\u5185\u5bb9']) num = 1 sheet.column_dimensions['A'].width = 30 sheet.column_dimensions['B'].width = 300 sheet.row_dimensions[num].height = 25 for name, content in rev_lst: sheet.append([name, content]) num += 1 sheet.row_dimensions[num].height = 20 workbook.save(\"\u8bc4\u8bba_1_\" + title + \".xlsx\") if __name__ == '__main__': write_review()","title":"\u56db.\u83b7\u53d6b\u7ad9\u8bc4\u8bba"},{"location":"my%20past/python/spider/#94-update","text":"\u540e\u6765\u53d1\u73b0\uff0c\u53ea\u8981\u5728\u8bf7\u6c42\u4e4b\u95f4\u52a0\u4e2a\u4e00\u79d2\u95f4\u9694 time.sleep(1) \u5c31\u4e0d\u4f1a\u88ab\u62e6\u622a\u4e86\uff0c\u4e50","title":"9.4 update"},{"location":"my%20past/python/spider/#pixiv","text":"\u6316\u4e2a\u5751\uff0c\u5bd2\u5047\u518d\u586b","title":"\u4e94.\u722c\u53d6pixiv \u56fe\u7247"},{"location":"my%20past/python/spider/#pythonvpn","text":"\u5bd2\u5047\u586b\u5751 update 2023.1.25 \u5bd2\u5047\u586bnmb\u5751\uff0c\u8fd8\u670950\u5929\u82f1\u8bed\u9ad8\u8003\u4e86 \u6691\u5047\u518d\u586b","title":"\u516d.\u7eafpython\u7684vpn"},{"location":"my%20past/python/tool/","text":"Python\u5e38\u7528\u5e93/\u5de5\u5177 pip \u4f7f\u7528 \u5728$cmd$\u754c\u9762\u4e2d\u5207\u6362\u5230\u5f53\u524d\u5b89\u88c5\u76ee\u5f55\u4e2d(\u542b\u6709$pip.exe$) >>>cd C:/... \u68c0\u67e5 >>>pip \u662f\u5426\u5b89\u88c5 \u7136\u540e\u5c31\u53ef\u4ee5\u7528 >>>pip install xxx \u6765\u5b89\u88c5\u6240\u9700\u7684\u5e93\u4e86 pyautogui \u4f7f\u7528 import pyautogui as py # \u9f20\u6807\u70b9\u51fb py.click() # \u952e\u76d8 py.keyUp('s') py.keyDown('s') py.press('s') py.hotkey('win'+'r') PyUserInput from pykeyboard import PyKeyboard from pymouse import PyMouse m=PyMouse() k=PyKeyboard() turtle import turtle forward(100) left(90) forward(100) left(90) forward(100) left(90) forward(100) left(90) goto(50,0) left(90) circle(50) goto(50,50) Dot() os \u7528\u4e8e\u6587\u4ef6\u5939\uff0c\u8def\u5f84\u64cd\u4f5c pygame \u7528\u6765\u505a\u6e38\u620f\u6216\u5c0f\u8f6f\u4ef6 pynput \u7528\u4e8e\u952e\u76d8\uff0c\u9f20\u6807\u7684\u76d1\u542c moviepy \u7528\u4e8e\u89c6\u9891\u97f3\u9891\u7684\u7f16\u8f91\uff0c\u8f6c\u6362\u7b49 ctypes 1.\u7528\u4e8e\u83b7\u53d6\u5c4f\u5e55\u989c\u8272 2.\u5176\u4ed6() PIL \u7528\u4e8e\u56fe\u50cf\u5904\u7406","title":"Python\u5e38\u7528\u5e93/\u5de5\u5177"},{"location":"my%20past/python/tool/#python","text":"","title":"Python\u5e38\u7528\u5e93/\u5de5\u5177"},{"location":"my%20past/python/tool/#pip","text":"","title":"pip"},{"location":"my%20past/python/tool/#_1","text":"\u5728$cmd$\u754c\u9762\u4e2d\u5207\u6362\u5230\u5f53\u524d\u5b89\u88c5\u76ee\u5f55\u4e2d(\u542b\u6709$pip.exe$) >>>cd C:/... \u68c0\u67e5 >>>pip \u662f\u5426\u5b89\u88c5 \u7136\u540e\u5c31\u53ef\u4ee5\u7528 >>>pip install xxx \u6765\u5b89\u88c5\u6240\u9700\u7684\u5e93\u4e86","title":"\u4f7f\u7528"},{"location":"my%20past/python/tool/#pyautogui","text":"","title":"pyautogui"},{"location":"my%20past/python/tool/#_2","text":"import pyautogui as py # \u9f20\u6807\u70b9\u51fb py.click() # \u952e\u76d8 py.keyUp('s') py.keyDown('s') py.press('s') py.hotkey('win'+'r')","title":"\u4f7f\u7528"},{"location":"my%20past/python/tool/#pyuserinput","text":"from pykeyboard import PyKeyboard from pymouse import PyMouse m=PyMouse() k=PyKeyboard()","title":"PyUserInput"},{"location":"my%20past/python/tool/#turtle","text":"import turtle forward(100) left(90) forward(100) left(90) forward(100) left(90) forward(100) left(90) goto(50,0) left(90) circle(50) goto(50,50) Dot()","title":"turtle"},{"location":"my%20past/python/tool/#os","text":"\u7528\u4e8e\u6587\u4ef6\u5939\uff0c\u8def\u5f84\u64cd\u4f5c","title":"os"},{"location":"my%20past/python/tool/#pygame","text":"\u7528\u6765\u505a\u6e38\u620f\u6216\u5c0f\u8f6f\u4ef6","title":"pygame"},{"location":"my%20past/python/tool/#pynput","text":"\u7528\u4e8e\u952e\u76d8\uff0c\u9f20\u6807\u7684\u76d1\u542c","title":"pynput"},{"location":"my%20past/python/tool/#moviepy","text":"\u7528\u4e8e\u89c6\u9891\u97f3\u9891\u7684\u7f16\u8f91\uff0c\u8f6c\u6362\u7b49","title":"moviepy"},{"location":"my%20past/python/tool/#ctypes","text":"1.\u7528\u4e8e\u83b7\u53d6\u5c4f\u5e55\u989c\u8272 2.\u5176\u4ed6()","title":"ctypes"},{"location":"my%20past/python/tool/#pil","text":"\u7528\u4e8e\u56fe\u50cf\u5904\u7406","title":"PIL"}]}