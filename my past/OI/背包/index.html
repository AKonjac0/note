<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>背包总结 - My Docs</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/fontawesome.min.css" rel="stylesheet">
        <link href="../../../css/brands.min.css" rel="stylesheet">
        <link href="../../../css/solid.min.css" rel="stylesheet">
        <link href="../../../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">My Docs</a>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#_1" class="nav-link">背包总结</a>
              <ul class="nav flex-column">
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="_1">背包总结</h1>
<blockquote>
<p>P3859</p>
</blockquote>
<p>TJOI的水题（黄题难度的紫题）</p>
<p>定义f[j]表示用了j时间时获得宝石的最大价值。~~是的只用一维滚动就行~~</p>
<p>因此转移方程：</p>
<pre><code class="language-cpp">    f[j]=max(max(f[j],f[j-1]),f[j-t]+v);
</code></pre>
<p>可以提前把宝石按限制时间排个序，也可以不排</p>
<blockquote>
<p>P1049</p>
</blockquote>
<p>背包的简单变形。</p>
<p>设f[i] (bool类型)为能否将i的空间装满。则转移方程:</p>
<pre><code class="language-cpp">    f[0]=1;
    for(int i=1;i&lt;=n;++i){
        for(int j=v;j&gt;=a[i];--j){
            if(f[j-a[i]])f[j]=1;    
        }
    }
</code></pre>
<blockquote>
<p>P1064</p>
</blockquote>
<p>一道好题</p>
<p>因为每个物品的状态总共就3种，即自己，左儿子和右儿子，所以就设所有物品都有儿子。</p>
<p>设f[i]表示价格为i时价格与权重的乘积最大值。则转移方程：</p>
<pre><code class="language-cpp">f[0]=0;
    ans=0;
    for(int i=1;i&lt;=m;++i){
        if(!v[i][0])continue;
        for(int j=n;j&gt;=v[i][0];--j){
            if(v[i][1] &amp;&amp; v[i][2] &amp;&amp; j&gt;=v[i][0]+v[i][1]+v[i][2])f[j]=max(f[j],f[j-v[i][0]-v[i][1]-v[i][2]]+v[i][0]*w[i][0]+v[i][1]*w[i][1]+v[i][2]*w[i][2]);
            if(v[i][1] &amp;&amp; j&gt;=v[i][0]+v[i][1])f[j]=max(f[j],f[j-v[i][0]-v[i][1]]+v[i][0]*w[i][0]+v[i][1]*w[i][1]);
            if(v[i][2] &amp;&amp; j&gt;=v[i][0]+v[i][2])f[j]=max(f[j],f[j-v[i][0]-v[i][2]]+v[i][0]*w[i][0]+v[i][2]*w[i][2]);
            if(j&gt;=v[i][0])f[j]=max(f[j],f[j-v[i][0]]+v[i][0]*w[i][0]);
            ans=max(f[j],ans);
        }
    }
</code></pre>
<p>注意附件不能将他的主件栏填进去(v[i][0],w[i][0])。</p>
<pre><code class="language-cpp">//读入
for(int i=1;i&lt;=m;++i){
        scanf(&quot;%d%d%d&quot;,&amp;v1,&amp;w1,&amp;p1);
        if(p1==0)v[i][0]=v1,w[i][0]=w1;
        else{
            if(v[p1][1])v[p1][2]=v1,w[p1][2]=w1;
            else v[p1][1]=v1,w[p1][1]=w1;
        }
    }
</code></pre>
<blockquote>
<p>P1651</p>
</blockquote>
<p>设f[i][j]表示前i个物品搭出的高度相差j的两个塔中最高的塔的高度。</p>
<p>这样既能将状态表示全，又能避免用两维的高度导致MLE。事实上i那一维可以滚存优化掉。</p>
<p>注意因为转移中会出现负数，所以要将第二维开两倍，将中间点500000设为零点。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=1e6+10,M=53,P=1e6;
int f[2][N];
int n;
int a[M];
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,&amp;a[i]);
    int ans=-0x7fffffff;
    memset(f,-0x3f,sizeof f);
    f[0][500000]=0;
    for(int i=1;i&lt;=n;++i){
        for(int j=0;j&lt;=P;++j){
            f[i%2][j]=max(f[i%2][j],f[(i%2)^1][j]);
            if(j-a[i]&gt;=0)f[i%2][j]=max(f[i%2][j],f[(i%2)^1][j-a[i]]+a[i]);
            if(j+a[i]&lt;=P)f[i%2][j]=max(f[i%2][j],f[(i%2)^1][j+a[i]]);
            if(j==500000)ans=max(ans,f[i%2][j]);
        }
    }
    if(ans&gt;0)printf(&quot;%d&quot;,ans);
    else printf(&quot;-1&quot;);
    return 0;
}
/*
20
188242 313 1991 4207 2483 1763 224 16 582 22943 111653 23787 16820 12415 1270 3032 2293 5221 396 42
*/
</code></pre>
<blockquote>
<p>P4823</p>
</blockquote>
<p>首先有个贪心的性质：</p>
<p>对于每个小矮人，一定是逃生能力弱，即$a+b$较小的人先逃比能力强的人先逃的不会更差。</p>
<p>因为能力弱的人如果不先逃，以后就可能逃不出去了。</p>
<p>不会出现能力强的先逃后弱的能逃，而弱的先逃强的就逃不了的情况。</p>
<p>只要弱的逃了强的逃不了，那强的逃了弱的也跑不了。因为后一个逃的脚底下高度是一定的。</p>
<p>有了这个性质后就可以用背包解决每个矮人是否要逃出去。因为可能它$a$特别大，不逃对人梯的贡献更大。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int N=2200;
struct node{
    int a,b;
}q[N];
bool cmp(node a,node b){
    return a.a+a.b&lt;b.a+b.b;
}
int n,h;
int dp[N];
int main(){
    memset(dp,-0x3f,sizeof dp);
    dp[0]=0;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i)scanf(&quot;%d%d&quot;,&amp;q[i].a,&amp;q[i].b),dp[0]+=q[i].a;
    scanf(&quot;%d&quot;,&amp;h);
    sort(q+1,q+n+1,cmp);
    for(int i=1;i&lt;=n;++i){
        for(int j=i;j&gt;=1;--j){
            if(dp[j-1]+q[i].b&gt;=h)dp[j]=max(dp[j],dp[j-1]-q[i].a);
        }
    }
    for(int i=n;i&gt;=0;--i){
        if(dp[i]&gt;=0){
            printf(&quot;%d&quot;,i);
            return 0;   
        }
    }

    return 0;
}
</code></pre>
<ul>
<li>结论：当背包的转移收到顺序影响，又不能确定物品拿取的具体顺序，可以寻找贪心的性质,排序后做背包。<blockquote>
<p>P3961</p>
</blockquote>
</li>
</ul>
<p>可以用斜率存储所有点的信息，注意处理$x=0$即斜率不存在的情况。</p>
<p>之后，对于每一组金子，可以将第$i$个的时间价值和前$i-1$个并再一起，表示连续取$i$个金子。</p>
<p>在做背包时，同一组只能选一个，所以注意顺序。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define int long long 
using namespace std;
const int N=320,M=5e4+10,K=200;
int f[M],top[N+N][N],nxt[N],head[N+N][N],l[N],r[N];
int n,T,cnt,tot;
struct query{
    int x,y,t,v;
    double k;
}q[N];
struct item{
    int t,v;
}c[N]; 
bool cmp(query a,query b){
    if(a.k==b.k)return a.y&lt;b.y;
    else return a.k&lt;b.k;
} 
void print1(){
    for(int i=1;i&lt;=tot;++i){
        for(int k=l[i];k&lt;=r[i];++k){
            cout&lt;&lt;c[k].t&lt;&lt;&quot; &quot;&lt;&lt;c[k].v&lt;&lt;endl;        
        }
    }
}

signed main(){
    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;T);
    for(int i=1;i&lt;=n;++i){
        scanf(&quot;%lld%lld%lld%lld&quot;,&amp;q[i].x,&amp;q[i].y,&amp;q[i].t,&amp;q[i].v);
        if(q[i].x!=0)q[i].k=q[i].y*1.0/(q[i].x*1.0);
        else q[i].k=N;
    }
    sort(q+1,q+n+1,cmp);
    tot=0;
    for(int i=1;i&lt;=n;++i){
        int x=q[i].x,y=q[i].y;
        if(q[i].k!=q[i-1].k || i==1){
            r[tot]=i-1;
            ++tot;
            l[tot]=i;
        }
        c[i].t+=q[i].t;
        c[i].v+=q[i].v;
        if(q[i].k==q[i-1].k &amp;&amp; i!=1){
            c[i].t+=c[i-1].t;
            c[i].v+=c[i-1].v;
        }
    }
    r[tot]=n;
    //print1();
    //memset(f,-0x3f,sizeof f);
    f[0]=0;
    for(int i=1;i&lt;=tot;++i){
        for(int j=T;j&gt;=c[l[i]].t;--j){
            for(int k=l[i];k&lt;=r[i];++k){
                if(j&gt;=c[k].t)f[j]=max(f[j],f[j-c[k].t]+c[k].v);
            }
        }
    }
    int maxn=0;
    for(int i=0;i&lt;=T;++i){
        maxn=max(maxn,f[i]);
    }
    printf(&quot;%lld&quot;,maxn);
    return 0;
}
/*
4 17
0 10 2 3
-2 3 1 1
-4 6 2 2
-6 8 15 9

3 10
1 1 13 1
2 2 2 2
1 3 4 7
*/

</code></pre>
<blockquote>
<p>P1156</p>
</blockquote>
<p>这题唯一的坑点就是同一时间会放多个垃圾。</p>
<p>这时要用链表/vector存储一下，并且同一时刻的垃圾是有先后顺序的，即高度可以累加。</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int N=4400,T=1000,K=220;
int f[N][K];
int D,G,tot;
int cnt[N],tim[N];
struct node {
    int h,f;
} c[N][K];
int main() {
    //freopen(&quot;P1156_2.in&quot;,&quot;r&quot;,stdin);
    scanf(&quot;%d%d&quot;,&amp;D,&amp;G);
    int sum=10;
    for(int i=1,tmp; i&lt;=G; ++i) {
        scanf(&quot;%d&quot;,&amp;tmp);
        ++cnt[tmp];
        scanf(&quot;%d%d&quot;,&amp;c[tmp][cnt[tmp]].f,&amp;c[tmp][cnt[tmp]].h);
        sum+=c[tmp][cnt[tmp]].f;
    }
    memset(f,-1,sizeof f);
    f[0][0]=10;
    for(int i=1; i&lt;=sum; ++i) {
        for(int j=0; j&lt;=cnt[i]; ++j) {
            tim[++tot]=i;
            for(int h=D; h&gt;=0; --h) {
                int t1=tim[tot]-tim[tot-1];
                if(c[i][j].h) {
                    if(h&gt;=c[i][j].h &amp;&amp; f[tot-1][h-c[i][j].h]-t1&gt;=0)f[tot][h]=max(f[tot][h],f[tot-1][h-c[i][j].h]-t1);
                    if(f[tot-1][h]-t1&gt;=0)f[tot][h]=max(f[tot][h],f[tot-1][h]-t1+c[i][j].f);
                }
                if(f[tot-1][h]-t1&gt;=0)f[tot][h]=max(f[tot][h],f[tot-1][h]-t1);
            }
        }

    }
    int maxn=-1;
    for(int i=0; i&lt;=tot; ++i) {
        for(int h=0; h&lt;=D; ++h) {
            //cout&lt;&lt;f[i][h]&lt;&lt;&quot; &quot;;
            if(f[i][h]&gt;=0)maxn=max(maxn,tim[i]);
        }
        //cout&lt;&lt;endl;
        if(f[i][D]&gt;=0) {
            printf(&quot;%d\n&quot;,tim[i]);
            return 0;
        }
    }
    printf(&quot;%d\n&quot;,maxn);
    /*for(int i=0;i&lt;=tot;++i){
        cout&lt;&lt;tim[i]&lt;&lt;&quot; &quot;;
    }*/
    return 0;
}
/*
100 4
5 4 9
9 3 2
12 6 10
13 1 1
*/
</code></pre>
<blockquote>
<p>P5662</p>
</blockquote>
<p>一个很重要的想法：每天卖的东西当天还能买回来。这让我们能够简化状态。</p>
<p>此时如果我们向持有某物品$n$天，我们就第$1$天买，第$2$天卖，再第$2$天买，第$3$天卖，以此类推。</p>
<p>这样我们就不需要记录每天物品的个数，只需要记录转天的钱数即可。</p>
<p>设$f[k]$表示第$i$天，第$j$个物品时还剩$k$元，明天能获得的最大的钱数。</p>
<p>那么有:</p>
<p>$$
f[k-c[i][j]]=max(f[k-c[i][j]],f[k]+c[i+1][j]-c[i][j])
$$</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#define int long long 
using namespace std;
const int N=110,M=10010,T=110;
int n,m,t,ans;
int c[T][N];
int f[M];
signed main(){
    scanf(&quot;%lld%lld%lld&quot;,&amp;t,&amp;n,&amp;m);
    for(int i=1;i&lt;=t;++i){
        for(int j=1;j&lt;=n;++j){
            scanf(&quot;%lld&quot;,&amp;c[i][j]);
        }
    } 
    f[m]=0;
    ans=m;
    for(int i=1;i&lt;=t;++i){
        memset(f,-1,sizeof f);
        f[ans]=ans;
        for(int j=1;j&lt;=n;++j){
            for(int k=ans;k&gt;=c[i][j];--k){
                if(f[k]==-1)continue;
                f[k-c[i][j]]=max(f[k-c[i][j]],f[k]+c[i+1][j]-c[i][j]);
            }
        }
        for(int i=0;i&lt;=ans;++i)ans=max(ans,f[i]);
    }
    printf(&quot;%lld&quot;,ans);
    return 0;
}
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
